/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.ptsl = (function() {

    /**
     * Namespace ptsl.
     * @exports ptsl
     * @namespace
     */
    var ptsl = {};

    ptsl.PTSL = (function() {

        /**
         * Constructs a new PTSL service.
         * @memberof ptsl
         * @classdesc Service for handling different types of Pro Tools commands using PTSL Client.
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function PTSL(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (PTSL.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PTSL;

        /**
         * Creates new PTSL service using the specified rpc implementation.
         * @function create
         * @memberof ptsl.PTSL
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {PTSL} RPC service. Useful where requests and/or responses are streamed.
         */
        PTSL.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link ptsl.PTSL#sendGrpcRequest}.
         * @memberof ptsl.PTSL
         * @typedef SendGrpcRequestCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ptsl.Response} [response] Response
         */

        /**
         * * Send generic gRPC request and receive generic response.
         * * Returns only the final response of the command.
         * @function sendGrpcRequest
         * @memberof ptsl.PTSL
         * @instance
         * @param {ptsl.IRequest} request Request message or plain object
         * @param {ptsl.PTSL.SendGrpcRequestCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PTSL.prototype.sendGrpcRequest = function sendGrpcRequest(request, callback) {
            return this.rpcCall(sendGrpcRequest, $root.ptsl.Request, $root.ptsl.Response, request, callback);
        }, "name", { value: "SendGrpcRequest" });

        /**
         * * Send generic gRPC request and receive generic response.
         * * Returns only the final response of the command.
         * @function sendGrpcRequest
         * @memberof ptsl.PTSL
         * @instance
         * @param {ptsl.IRequest} request Request message or plain object
         * @returns {Promise<ptsl.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link ptsl.PTSL#sendGrpcStreamingRequest}.
         * @memberof ptsl.PTSL
         * @typedef SendGrpcStreamingRequestCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {ptsl.Response} [response] Response
         */

        /**
         * * Send generic gRPC request and receive generic streaming responses.
         * * Returns all responses of the command, including intermediate responses.
         * @function sendGrpcStreamingRequest
         * @memberof ptsl.PTSL
         * @instance
         * @param {ptsl.IRequest} request Request message or plain object
         * @param {ptsl.PTSL.SendGrpcStreamingRequestCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PTSL.prototype.sendGrpcStreamingRequest = function sendGrpcStreamingRequest(request, callback) {
            return this.rpcCall(sendGrpcStreamingRequest, $root.ptsl.Request, $root.ptsl.Response, request, callback);
        }, "name", { value: "SendGrpcStreamingRequest" });

        /**
         * * Send generic gRPC request and receive generic streaming responses.
         * * Returns all responses of the command, including intermediate responses.
         * @function sendGrpcStreamingRequest
         * @memberof ptsl.PTSL
         * @instance
         * @param {ptsl.IRequest} request Request message or plain object
         * @returns {Promise<ptsl.Response>} Promise
         * @variation 2
         */

        return PTSL;
    })();

    /**
     * Pro Tools command type.
     * @name ptsl.CommandId
     * @enum {number}
     * @property {number} CreateSession=0 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_CreateSession=0 * Creates a new Pro Tools session.
     * *
     * * @request_body_type CreateSessionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"session_name": "session_name",
     * * 	"session_location": "/Users/username/Documents/sessions/",
     * * 	"file_type": "FT_WAVE",
     * * 	"sample_rate": "SR_44100",
     * * 	"bit_depth": "Bit16",
     * * 	"input_output_settings": "IO_Last",
     * * 	"is_interleaved": true,
     * * 	"is_cloud_project": false,
     * * 	"create_from_template": true,
     * * 	"template_group": "Getting Started",
     * * 	"template_name": "Beats"
     * * }
     * * @end_example
     * *
     * * @category_session_file
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} OpenSession=1 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_OpenSession=1 * Opens a Pro Tools session.
     * *
     * * @request_body_type OpenSessionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"session_path": "/Path/to/session_name.ptx",
     * *	// since Pro Tools 2025.06
     * *	// empty 'behavior_options' field will suppress all dialogs during OpenSession command
     * *  "behavior_options": {}
     * * }
     * * @end_example
     * *
     * * @category_session_file
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} Import=2 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Import=2 * Imports existing Pro Tools session.
     * *
     * * @request_body_type ImportRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"file_list": [
     * * 		"/path/to/file.wav"
     * * 	],
     * * 	"destination": "MD_NewTrack",
     * * 	"location": "ML_Spot",
     * * 	"location_data": {
     * * 		"location_type": "Start",
     * * 		"location": {
     * * 			"location": "12345678",
     * * 			"time_type": "TLType_Samples"
     * * 		}
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_session_file
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetTrackList=3 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetTrackList=3 * Gets list of tracks from session.
     * 
     * * @request_body_type GetTrackListRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_filter_list": [{"filter": "Selected", "is_inverted": true}],
     * * 	"is_filter_list_additive": true,
     * * 	"pagination_request": {
     * * 		"limit": 0,
     * * 		"offset": 0
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type GetTrackListResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"track_list": [{
     * * 		"name": "Audio 1",
     * * 		"type": "TT_Audio",
     * * 		"format": "TF_Mono",
     * * 		"color": "#ff13355f",
     * * 		"id": "{00000000-2a000000-d072e1e1-aa4193d5}",
     * * 		"id_compressed": "dvK0gQ4EfY0aaaacOaaaaa",
     * * 		"index": 2,
     * * 		"parent_folder_id": "{00000000-2a000000-2b75e1e1-b81bc33c}",
     * * 		"parent_folder_name": "Folder 1",
     * * 		"timebase": "TTB_Samples",
     * * 		"track_attributes": {
     * * 			"contains_automation": false,
     * * 			"contains_clips": false,
     * * 			"is_frozen": false,
     * * 			"is_hidden": "None",
     * * 			"is_inactive": "None",
     * * 			"is_input_monitoring_on": "None",
     * * 			"is_locked": false,
     * * 			"is_muted": false,
     * * 			"is_online": false,
     * * 			"is_open": false,
     * * 			"is_record_enabled": false,
     * * 			"is_record_enabled_safe": false,
     * * 			"is_selected": "SetImplicitly",
     * * 			"is_smart_dsp_on": false,
     * * 			"is_smart_dsp_on_safe": false,
     * * 			"is_soloed": false,
     * * 			"is_soloed_safe": false
     * * 		}
     * * 	}],
     * * 	"pagination_response": {
     * * 		"limit": 0,
     * * 		"offset": 0,
     * * 		"total": 1
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SelectAllClipsOnTrack=4 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SelectAllClipsOnTrack=4 * Selects all clips on the selected track.
     * *
     * * @request_body_type SelectAllClipsOnTrackRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_name": "track name"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} ExtendSelectionToTargetTracks=5 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ExtendSelectionToTargetTracks=5 * Extends selection to target tracks.
     * *
     * * @request_body_type ExtendSelectionToTargetTracksRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"tracks_to_extend_to": ["track1", "track2"]
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} TrimToSelection=6 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_TrimToSelection=6 * Trims clips to selection.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} CreateFadesBasedOnPreset=7 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_CreateFadesBasedOnPreset=7 * Creates fades on clips from specified preset.
     * *
     * * @request_body_type CreateFadesBasedOnPresetRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"fade_preset_name": "fade preset name",
     * * 	"auto_adjust_bounds": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} RenameTargetTrack=8 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RenameTargetTrack=8 * Renames selected track.
     * *
     * * @request_body_type RenameTargetTrackRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"new_name": "Audio 1 - Renamed",
     * * 	"current_name": "Audio 1"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} ConsolidateClip=9 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ConsolidateClip=9 * Consolidates selected clips.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} ExportClipsAsFiles=10 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ExportClipsAsFiles=10 * Exports selected clips as files.
     * *
     * * @request_body_type ExportClipsAsFilesRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"file_path": "/Path/to/existing/folder/",
     * * 	"format": "EF_Mono",
     * * 	"file_type": "WAV",
     * * 	"bit_depth": "Bit16",
     * * 	"duplicate_names": "AutoRenaming",
     * * 	"enforce_avid_compatibility": true,
     * * 	"sample_rate_custom": 4000
     * * }
     * * @end_example
     * *
     * * @category_export
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} ExportSelectedTracksAsAAFOMF=11 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ExportSelectedTracksAsAAFOMF=11 * Exports selected clips as AAF/OMF.
     * *
     * * @request_body_json_example
     * * {
     * * 	"file_type": "AAF_WAV",
     * * 	"bit_depth": "AAF_Bit16",
     * * 	"copy_option": "CopyFromSourceMedia",
     * * 	"enforce_media_composer_compatibility": false,
     * * 	"quantize_edits_to_frame_boundaries": false,
     * * 	"export_stereo_as_multichannel": true,
     * * 	"container_file_name": "container_file_name",
     * * 	"container_file_location": "/Users/username/Documents/container_file_location/",
     * * 	"asset_file_location": "/Users/username/Documents/asset_file_location/",
     * * 	"comments": "comments",
     * * 	"sequence_name": "sequence_name"
     * * }
     * * @end_example
     * *
     * * @category_export
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetTaskStatus=12 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetTaskStatus=12 * Gets task execution status.
     * *
     * * Only returns the status of the task that is currently in progress.
     * * So it should be called asynchronously in parallel to the requested PTSL Command.
     * *
     * * @request_body_type GetTaskStatusRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"task_id": "af797e04-d0fb-459c-bd2b-6e1c6f999ec6"
     * * }
     * * @end_example
     * *
     * * @response_body_type GetTaskStatusResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"task_id": "af797e04-d0fb-459c-bd2b-6e1c6f999ec6",
     * * 	"status": "Completed",
     * * 	"progress": 100
     * * }
     * * @end_example
     * *
     * * @category_general
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} HostReadyCheck=13 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_HostReadyCheck=13 * Checks to see if the Pro Tools application is fully loaded and ready to execute PTSL commands.
     * *
     * * @response_body_type HostReadyCheckResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"is_host_ready": true
     * * }
     * * @end_example
     * *
     * * @category_general
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} RefreshTargetAudioFiles=14 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RefreshTargetAudioFiles=14 * Forces rescan the file list or forces recalculate waveforms for the specific files.
     * *
     * * @request_body_type RefreshTargetAudioFilesRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"file_list": ["/Path/to/Audio_1.wav", "/Path/to/Audio_2.wav"]
     * * }
     * * @end_example
     * *
     * * @response_body_type RefreshTargetAudioFilesResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"success_count": 1,
     * * 	"failure_count": 1,
     * * 	"failure_list": ["/Path/to/Audio_1.wav"]
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} RefreshAllModifiedAudioFiles=15 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RefreshAllModifiedAudioFiles=15 * Refreshes modified files in the session.
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetFileLocation=16 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetFileLocation=16 * Gets an optionally filtered list of the media files referenced by the session.
     * *
     * * @request_body_type GetFileLocationRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"file_filters": ["NotOnTimeline_Files", "Video_Files"],
     * * 	"pagination_request": {
     * * 		"limit": 0,
     * * 		"offset": 0
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type GetFileLocationResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"file_locations": [
     * * 		{
     * * 			"file_id": "a3b9c9df-26a7-46c2-aa86-41799f92feb9",
     * * 			"info": {
     * * 				"is_online": true
     * * 			},
     * * 			"path": "/path/to/Audio.wav"
     * * 		},
     * * 		{
     * * 			"file_id": "18c9e2d5-c1d9-4086-a657-716fcdb40e14",
     * * 			"info": {
     * * 				"is_online": true
     * * 			},
     * * 			"path": "/path/to/Video.mp4"
     * * 		}
     * * 	],
     * * 	"pagination_response": {
     * * 		"limit": 0,
     * * 		"offset": 0,
     * * 		"total": 2
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} CloseSession=17 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_CloseSession=17 * Closes a Pro Tools session.
     * *
     * * @request_body_type CloseSessionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"save_on_close": true
     * * }
     * * @end_example
     * *
     * * @category_session_file
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SaveSession=18 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SaveSession=18 * Saves a Pro Tools session.
     * *
     * * @category_session_file
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SaveSessionAs=19 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SaveSessionAs=19 * Saves Pro Tools session as a new session.
     * *
     * * @request_body_type SaveSessionAsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"session_name": "Test",
     * * 	"session_location": "/Path/to/existing/folder"
     * * }
     * * @end_example
     * *
     * * @category_session_file
     * * @category_export
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} Cut=20 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Cut=20 * Cuts data on track.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} Copy=21 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Copy=21 * Copies data on track.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} Paste=22 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Paste=22 * Pastes data on track.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} Clear=23 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Clear=23 * Clears data on track.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} CutSpecial=24 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_CutSpecial=24 * Cuts data on track by filtering data type.
     * *
     * * @request_body_type CutSpecialRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"automation_data_option": "All_Automation"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} CopySpecial=25 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_CopySpecial=25 * Copies data on track by filtering data type.
     * *
     * * @request_body_type CopySpecialRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"automation_data_option": "All_Automation"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} ClearSpecial=26 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ClearSpecial=26 * Clears data on track by filtering data type.
     * *
     * * @request_body_type ClearSpecialRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"automation_data_option": "All_Automation"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} PasteSpecial=27 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_PasteSpecial=27 * Pastes data on track by filtering data type.
     * *
     * * @request_body_type PasteSpecialRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"paste_special_option": "MergeMidi"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} ExportMix=28 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ExportMix=28 * @brief Renders all or part of the session to one or more files.
     * *
     * * @details Export Mix (Bounce Mix) can export an entire mix, including sub-mixes, to multiple file
     * * formats without having to create extra dedicated audio tracks in the session for bus recording.
     * * Different options and settings are available depending on the selected FileType. The options are
     * * organized in sections including Audio, Video, Location, and Dolby Atmos. Here's a breakdown of how the
     * * sections are used for each FileType:
     * *
     * * - WAV
     * *    -# has no Video section
     * *    -# has a unique field called DeliveryFormat (only shown if Interleaved is selected as the file format and there are multiple mix sources)
     * *
     * * - AIF
     * *    -# has no Video section
     * *
     * * - MP3
     * *    -# has no Video section
     * *    -# does not allow multiple mix sources
     * *    -# does not allow mix sources greater than 0
     * *    -# does not allow specifying Bit Depth value (always a 16Bit)
     * *    -# Sample Rate is limited to 48k and 44.1k
     * *    -# Import after Bounce is not available
     * *
     * * - MXF OPAtom
     * *    -# has no Video section
     * *    -# File format is multi-mono
     * *    -# Bit Depth is only 16Bit and 24Bit
     * *    -# Sample Rate is limited to 48k and 44.1k
     * *    -# Pad to frame boundary is hard-coded to ON
     * *
     * * - WAV (Dolby Atmos ADM BWF)
     * *    -# has no Audio section
     * *    -# has no Video section
     * *    -# has Dolby Atmos section (unique to this format)
     * *    -# has FFOA (bool) default to False
     * *    -# if FFOA is true then there's an option to enter TimeCode value
     * *        -# TimeCode value will match the session frame rate
     * *        -# Frame rate will always be 23.976 and 30 non-drop (if Frame rate is 60 -> it will still be 30)
     * *    -# has Embed Program-level Metadata
     * *
     * * @request_body_type ExportMixRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"preset_path": "/Users/username/Documents/Pro Tools/Pro Tools Presets/Bounce/bounce_preset_1.ptpreset",
     * * 	"file_name": "file_name",
     * * 	"file_type": "EMFType_MP3",
     * * 	"location_info": {
     * * 		"file_destination": "EM_FD_Directory",
     * * 		"directory": "/Users/username/export_folder/",
     * * 		"import_after_bounce": "TB_False"
     * * 	},
     * * 	"audio_info": {
     * * 		"export_format": "EF_Interleaved",
     * * 		"bit_depth": "Bit16",
     * * 		"sample_rate": "SR_44100",
     * * 		"pad_to_frame_boundary": "TB_False",
     * * 		"delivery_format": "EM_DF_FilePerMixSource"
     * * 	},
     * * 	"video_info": {
     * * 		"include_video": "TB_False"
     * * 	},
     * * 	"offline_bounce": "TB_True",
     * * 	"mix_source_list": [{
     * * 		"source_type": "Bus",
     * * 		"name": "Bus 1"
     * * 	},
     * * 	{
     * * 		"source_type": "Bus",
     * * 		"name": "Bus 1-2"
     * * 	}],
     * * 	"start_time": {
     * * 		"location": "00:00:10:00",
     * * 		"time_type": "TLType_TimeCode"
     * * 	},
     * * 	"end_time": {
     * * 		"location": "00:00:12:00",
     * * 		"time_type": "TLType_TimeCode"
     * * 	},
     * * 	// since Pro Tools 2025.06
     * * 	// use empty "audio_enconding_options" to suppress any encoding options dialog
     * * 	// during ExportMix command and apply defaults
     * * 	"audio_encoding_options": {
     * * 		"encoding_options_mp3": {
     * * 			"bit_rate": "MP3EOCBRate_320kbps",
     * * 			"quality": "MP3EOQuality_Highest"
     * * 		}
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_export
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} Spot=29 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Spot=29 * Places clips at exact locations.
     * *
     * * @request_body_type SpotRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"location_data": {
     * * 		"location_type": "SLType_Start",
     * * 		"location": {
     * * 		"time_type": "TLType_TimeCode",
     * * 			"location": "00:00:09:21.02"
     * * 		}
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} ExportSessionInfoAsText=30 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ExportSessionInfoAsText=30 * Provides session data as text.
     * *
     * * @request_body_type ExportSessionInfoAsTextRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"include_file_list": true,
     * * 	"include_clip_list": true,
     * * 	"include_markers": true,
     * * 	"include_plugin_list": true,
     * * 	"include_track_edls": true,
     * * 	"show_sub_frames": true,
     * * 	"include_user_timestamps": true,
     * * 	"track_list_type": "AllTracks",
     * * 	"fade_handling_type": "ShowCrossfades",
     * * 	"location_type": "TLType_Samples",
     * * 	"text_as_file_format": "UTF8",
     * * 	"output_type": "ESI_File",
     * * 	"output_path": "/path/to/session_info.txt"
     * * }
     * * @end_example
     * *
     * * @response_body_type ExportSessionInfoAsTextResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"session_info": ""
     * * }
     * * @end_example
     * *
     * * @category_session_file
     * * @category_export
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetDynamicProperties=31 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetDynamicProperties=31 * Gets dynamic properties from the host application.
     * *
     * * @note Use dynamic properties to query the application about its support for features such as codecs
     * * that are not directly bound to a particular version of the API or host application.
     * *
     * * TODO Add json examples for request and response after the command will be supported.
     * *
     * * @sa DynamicPropertyType
     * *
     * * @category_general
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetPlaybackMode=32 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetPlaybackMode=32 * Sets playback mode.
     * *
     * * @request_body_type SetPlaybackModeRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"playback_mode": "PM_Normal"
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetRecordMode=33 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetRecordMode=33 * Sets record mode.
     * *
     * * @request_body_type SetRecordModeRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"record_mode": "RM_Normal",
     * * 	"record_arm_transport": true
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionAudioFormat=34 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionAudioFormat=34 * Gets current session audio files format.
     * *
     * * @response_body_type GetSessionAudioFormatResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "SAF_WAVE",
     * * 	"possible_settings": ["SAF_WAVE", "SAF_AIFF"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionSampleRate=35 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionSampleRate=35 * Gets current session sample rate.
     * *
     * * @response_body_type GetSessionSampleRateResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"sample_rate": "SR_48000"
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionBitDepth=36 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionBitDepth=36 * Gets current session bit depth.
     * *
     * * @response_body_type GetSessionBitDepthResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "Bit16",
     * * 	"possible_settings": ["Bit16", "Bit24", "Bit32Float"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionInterleavedState=37 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionInterleavedState=37 * Gets current session interleaved state.
     * *
     * * @response_body_type GetSessionInterleavedStateResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": true,
     * * 	"possible_settings": [true, false]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionTimeCodeRate=38 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionTimeCodeRate=38 * Gets current session time code rate.
     * *
     * * @response_body_type GetSessionTimeCodeRateResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "STCR_Fps23976",
     * * 	"possible_settings": ["STCR_Fps23976", "STCR_Fps24", "STCR_Fps25", "STCR_Fps2997", "STCR_Fps2997Drop", "STCR_Fps30", "STCR_Fps30Drop", "STCR_Fps47952", "STCR_Fps48", "STCR_Fps50", "STCR_Fps5994", "STCR_Fps5994Drop", "STCR_Fps60", "STCR_Fps60Drop", "STCR_Fps100", "STCR_Fps11988", "STCR_Fps11988Drop", "STCR_Fps120", "STCR_Fps120Drop"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionFeetFramesRate=39 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionFeetFramesRate=39 * Gets current session feet+frames rate.
     * *
     * * @response_body_type GetSessionFeetFramesRateResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "SFFR_Fps23976",
     * * 	"possible_settings": ["SFFR_Fps23976", "SFFR_Fps24", "SFFR_Fps25"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionAudioRatePullSettings=40 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionAudioRatePullSettings=40 * Gets current session audio rate pull up/down.
     * *
     * * @response_body_type GetSessionAudioRatePullSettingsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "SRP_None",
     * * 	"possible_settings": ["SRP_None", "SRP_Up01", "SRP_Down01", "SRP_Up4", "SRP_Up4Up01", "SRP_Up4Down01", "SRP_Down4", "SRP_Down4Up01", "SRP_Down4Down01"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionVideoRatePullSettings=41 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionVideoRatePullSettings=41 * Gets current session video rate pull up/down.
     * *
     * * @response_body_type GetSessionVideoRatePullSettingsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "SRP_None",
     * * 	"possible_settings": ["SRP_None", "SRP_Up01", "SRP_Down01"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionName=42 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionName=42 * Gets current session name.
     * *
     * * @response_body_type GetSessionNameResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"session_name": "Test1"
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionPath=43 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionPath=43 * Gets current session path.
     * *
     * * @response_body_type GetSessionPathResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"session_path": {
     * * 		"info": {
     * * 			"is_online": false
     * * 		},
     * * 		"path": "D:/Test/Test.ptx"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionStartTime=44 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionStartTime=44 * Gets current session start time.
     * *
     * * @response_body_type GetSessionStartTimeResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"session_start_time": "00:00:00:00.00"
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetSessionLength=45 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionLength=45 * Gets current session length.
     * *
     * * @response_body_type GetSessionLengthResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"session_length": "24:00:00:00"
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionAudioFormat=46 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionAudioFormat=46 * Sets current session audio files format.
     * *
     * * @request_body_type SetSessionAudioFormatRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"audio_format": "SAF_WAVE"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionBitDepth=47 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionBitDepth=47 * Sets current session bit depth.
     * *
     * * @request_body_type SetSessionBitDepthRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"bit_depth": "Bit16"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionInterleavedState=48 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionInterleavedState=48 * Sets current session interleaved state.
     * *
     * * @request_body_type SetSessionInterleavedStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"interleaved_state": true
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionTimeCodeRate=49 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionTimeCodeRate=49 * Sets current session time code rate.
     * *
     * * @request_body_type SetSessionTimeCodeRateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"time_code_rate": "STCR_Fps23976"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionFeetFramesRate=50 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionFeetFramesRate=50 * Sets current session feet+frames rate.
     * *
     * * @request_body_type SetSessionFeetFramesRateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"feet_frames_rate": "SFFR_Fps23976"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionAudioRatePullSettings=51 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionAudioRatePullSettings=51 * Sets current session audio rate pull up/down.
     * *
     * * @request_body_type SetSessionAudioRatePullSettingsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"audio_rate_pull": "SRP_Up01"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionVideoRatePullSettings=52 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionVideoRatePullSettings=52 * Sets current session video rate pull up/down.
     * *
     * * @request_body_type SetSessionVideoRatePullSettingsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"video_rate_pull": "SRP_Up01"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionStartTime=53 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionStartTime=53 * Sets current session start time.
     * *
     * * @request_body_type SetSessionStartTimeRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"location": {
     * * 		"time_type": "TLType_TimeCode",
     * * 		"location": "00:00:10:00"
     * * 	},
     * * 	"maintain_relative_position": false
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} SetSessionLength=54 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSessionLength=54 * Sets current session length.
     * *
     * * @request_body_type SetSessionLengthRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"session_length": "06:00:00:00"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetPTSLVersion=55 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetPTSLVersion=55 * Gets current version of PTSL Host, Client, and API commands.
     * *
     * * @response_body_type GetPTSLVersionResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"version": 2025,
     * * 	"version_minor": 3,
     * * 	"version_revision": 0
     * * }
     * * @end_example
     * *
     * * @category_general
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetPlaybackMode=56 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetPlaybackMode=56 * Gets current playback mode.
     * *
     * * @response_body_type GetPlaybackModeResponseBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"current_settings": ["PM_Normal"],
     * * 	"possible_settings": ["PM_Normal", "PM_Loop", "PM_DynamicTransport"]
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetRecordMode=57 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetRecordMode=57 * Gets current record mode.
     * *
     * * @response_body_type GetRecordModeResponseBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"current_setting": "RM_Normal",
     * * 	"possible_settings": ["RM_Normal", "RM_Loop", "RM_Destructive", "RM_QuickPunch", "RM_TrackPunch", "RM_DestructivePunch"]
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetTransportArmed=58 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetTransportArmed=58 * Gets transport armed.
     * *
     * * @response_body_type GetTransportArmedResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"is_transport_armed": true
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} GetTransportState=59 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetTransportState=59 * Gets current transport state.
     * *
     * * @response_body_type GetTransportStateResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "TS_TransportPlaying",
     * * 	"possible_settings": ["TS_TransportPlaying", "TS_TransportStopped", "TS_TransportRecording", "TS_TransportPlayingHalfSpeed", "TS_TransportRecordingHalfSpeed", "TS_TransportFastForward", "TS_TransportRewind", "TS_TransportScrub", "TS_TransportShuttle", "TS_TransportPrimed", "TS_TransportIsCueing", "TS_TransportIsCued", "TS_TransportIsCuedForPreview", "TS_TransportIsStopping", "TS_TransportIsPreviewing"]
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2022.12
     * *
     * * @_ingroup ptsl_version_2022_12
     * @property {number} ClearMemoryLocation=61 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ClearMemoryLocation=61 * Removes memory locations corresponding to the numbers provided in the list.
     * * @note Memory location enumeration should start with 1 (using 0 or negative numbers may result in undefined behavior).
     * *
     * * @request_body_type ClearMemoryLocationRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"location_list": [1, 2]
     * * }
     * * @end_example
     * *
     * * @response_body_type ClearMemoryLocationResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"success_count": 1,
     * * 	"failure_count": 1,
     * * 	"failure_list": [2]
     * * }
     * * @end_example
     * 
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.03.
     * *
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} RenameSelectedClip=62 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RenameSelectedClip=62 * Renames a clip that was selected in the Pro Tools.
     * *
     * * @request_body_type RenameSelectedClipRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"clip_location": "CL_ClipsList",
     * * 	"new_name": "NewName",
     * * 	"rename_file": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.03.
     * *
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} RenameTargetClip=63 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RenameTargetClip=63 * Renames a clip that was selected in the Pro Tools.
     * *
     * * @request_body_type RenameTargetClipRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"clip_name": "CurrentName",
     * * 	"new_name": "NewName",
     * * 	"rename_file": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.03.
     * *
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} TogglePlayState=64 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_TogglePlayState=64 * Toggles current play state (behaves the same as the button press).
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2023.03
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} ToggleRecordEnable=65 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ToggleRecordEnable=65 * Toggles current record enable (behaves the same as the button press).
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2023.03
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} PlayHalfSpeed=66 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_PlayHalfSpeed=66 * Plays with half speed.
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2023.03
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} RecordHalfSpeed=67 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RecordHalfSpeed=67 * Records with half speed.
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2023.03
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} EditMemoryLocation=68 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_EditMemoryLocation=68 * Edits memory location.
     * *
     * *@request_body_type EditMemoryLocationRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"number": 1,
     * * 	"name": "Location 1",
     * * 	"start_time": "00:00:00",
     * * 	"end_time": "00:00:00",
     * * 	"time_properties": "TP_Marker",
     * * 	"reference": "MLR_Absolute",
     * * 	"general_properties": {
     * * 		"zoom_settings": false,
     * * 		"pre_post_roll_times": false,
     * * 		"track_visibility": false,
     * * 		"track_heights": false,
     * * 		"group_enables": false,
     * * 		"window_configuration": true,
     * * 		"window_configuration_index": 1,
     * * 		"venue_snapshot_index": 1
     * * 	},
     * * 	"comments": "comments",
     * * 	"color_index": 1,
     * * 	"location": "MLC_Track",
     * * 	"track_name": "Audio 1"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.03
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} GetMemoryLocations=69 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetMemoryLocations=69 * Gets memory locations.
     * *
     * * @request_body_type GetMemoryLocationsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"pagination_request": {
     * * 		"limit": 0,
     * * 		"offset": 0
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type GetMemoryLocationsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"memory_locations": [{
     * * 		"name": "Location 1",
     * * 		"number": 1,
     * * 		"location": "MarkerLocation_NamedRuler",
     * * 		"name": "Location 1",
     * * 		"reference": "MLR_Absolute",
     * * 		"start_time": "5",
     * * 		"end_time": "5",
     * * 		"time_properties": "TP_Marker",
     * * 		"color_index": 7,
     * * 		"comments": "",
     * * 		"general_properties": {
     * * 			"group_enables": false,
     * * 			"pre_post_roll_times": false,
     * * 			"track_heights": false,
     * * 			"track_visibility": false,
     * * 			"window_configuration": false,
     * * 			"window_configuration_index": 0,
     * * 			"window_configuration_name": "(none)",
     * * 			"zoom_settings": false
     * * 		}
     * * 	}],
     * * 	"pagination_response": {
     * * 		"limit": 0,
     * * 		"offset": 0,
     * * 		"total": 1
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.03
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} RegisterConnection=70 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RegisterConnection=70 * Submits registration information to create a new connection.
     * *
     * * @request_body_type RegisterConnectionRequestBody
     * * @response_body_type RegisterConnectionResponseBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"company_name": "MyCompany",
     * * 	"application_name": "MyApp"
     * * }
     * * @end_example
     * *
     * * @response_body_json_example
     * * {
     * * 	"session_id":"bb004310-c92f-48ed-8c0b-ee301024fdce"
     * * }
     * * @end_example
     * *
     * * @note This API provides PTSL Session ID; please don't confuse it with Pro Tools sessions.
     * *
     * * @category_general
     * * @category_all
     * *
     * * @since Pro Tools 2023.03
     * *
     * * @_ingroup ptsl_version_2023_03
     * @property {number} CreateMemoryLocation=71 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_CreateMemoryLocation=71 * Creates memory location.
     * *
     * * @request_body_type CreateMemoryLocationRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"number": 1,
     * * 	"name": "name",
     * * 	"start_time": "0",
     * * 	"end_time": "123",
     * * 	"time_properties": "TP_Selection",
     * * 	"reference": "MLR_FollowTrackTimebase",
     * * 	"general_properties": {
     * * 		"zoom_settings": false,
     * * 		"pre_post_roll_times": false,
     * * 		"track_visibility": false,
     * * 		"track_heights": false,
     * * 		"group_enables": false,
     * * 		"window_configuration": true,
     * * 		"window_configuration_index": 1,
     * * 		"venue_snapshot_index": 1
     * * 	},
     * * 	"comments": "comments",
     * * 	"color_index": 1,
     * * 	"location": "MLC_Track",
     * * 	"track_name": "Audio 1"
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.06
     * *
     * * @_ingroup ptsl_version_2023_06
     * @property {number} CreateNewTracks=72 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_CreateNewTracks=72 * Creates new tracks.
     * *
     * * @request_body_type CreateNewTracksRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"number_of_tracks": 1,
     * * 	"track_name": "track_name",
     * * 	"track_format": "TF_Mono",
     * * 	"track_type": "TT_Audio",
     * * 	"track_timebase": "TTB_Samples",
     * * 	"pagination_request": {
     * * 		"limit": 0,
     * * 		"offset": 0
     * * 	},
     * * 	"insertion_point_position": "TIPoint_After",
     * * 	"insertion_point_track_name": "Audio 1"
     * * }
     * * @end_example
     * *
     * * @response_body_type CreateNewTracksResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *  "created_track_ids": ["{00000000-2a000000-146b14e4-a5cd69d9}"],
     * * 	"created_track_names": ["track_name"],
     * * 	"number_of_tracks": 1,
     * * 	"pagination_response": {
     * * 		"limit": 0,
     * * 		"offset": 0,
     * * 		"total": 1
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} SelectTracksByName=73 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SelectTracksByName=73 * Selects tracks by specified names without using wildcards.
     * *
     * * @request_body_type SelectTracksByNameRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1"],
     * * 	"selection_mode": "SM_Replace",
     * * 	"pagination_request": {
     * * 		"limit": 0,
     * * 		"offset": 0
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type SelectTracksByNameResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"track_list": [{
     * * 		"name": "Audio 1",
     * * 		"type": "TT_Audio",
     * * 		"format": "TF_Mono",
     * * 		"color": "#ff13355f",
     * * 		"id": "{00000000-2a000000-d072e1e1-aa4193d5}",
     * * 		"id_compressed": "dvK0gQ4EfY0aaaacOaaaaa",
     * * 		"index": 2,
     * * 		"parent_folder_id": "{00000000-2a000000-2b75e1e1-b81bc33c}",
     * * 		"parent_folder_name": "Folder 1",
     * * 		"timebase": "TTB_Samples",
     * * 		"track_attributes": {
     * * 			"contains_automation": false,
     * * 			"contains_clips": false,
     * * 			"is_frozen": false,
     * * 			"is_hidden": "None",
     * * 			"is_inactive": "None",
     * * 			"is_input_monitoring_on": "None",
     * * 			"is_locked": false,
     * * 			"is_muted": false,
     * * 			"is_online": false,
     * * 			"is_open": false,
     * * 			"is_record_enabled": false,
     * * 			"is_record_enabled_safe": false,
     * * 			"is_selected": "SetImplicitly",
     * * 			"is_smart_dsp_on": false,
     * * 			"is_smart_dsp_on_safe": false,
     * * 			"is_soloed": false,
     * * 			"is_soloed_safe": false
     * * 		}
     * * 	}],
     * * 	"pagination_response": {
     * * 		"limit": 0,
     * * 		"offset": 0,
     * * 		"total": 1
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} GetEditMode=74 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetEditMode=74 * Gets edit mode.
     * *
     * * @response_body_type GetEditModeResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "EMO_Shuffle",
     * * 	"possible_settings": ["EMO_Shuffle", "EMO_Slip", "EMO_Spot", "EMO_GridAbsolute", "EMO_GridRelative", "EMO_ShuffleSnapToGridAbsolute", "EMO_SlipSnapToGridAbsolute", "EMO_SpotSnapToGridAbsolute", "EMO_ShuffleSnapToGridRelative", "EMO_SlipSnapToGridRelative", "EMO_SpotSnapToGridRelative"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} SetEditMode=75 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetEditMode=75 * Sets edit mode.
     * *
     * * @request_body_type SetEditModeRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"edit_mode": "EMO_Shuffle"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} GetEditTool=76 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetEditTool=76 * Gets current edit tool.
     * *
     * * @response_body_type GetEditToolResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "ET_ZoomNormal",
     * * 	"possible_settings": ["ET_ZoomNormal", "ET_ZoomSingle", "ET_TrimStandard", "ET_TrimTce", "ET_TrimScrub", "ET_TrimLoop", "ET_Selector", "ET_GrabberTime", "ET_GrabberSeparation", "ET_GrabberObject", "ET_SmartTool", "ET_Scrubber", "ET_PencilFreeHand", "ET_PencilLine", "ET_PencilTriangle", "ET_PencilSquare", "ET_PencilRandom", "ET_PencilParabolic", "ET_PencilSCurve"]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} SetEditTool=77 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetEditTool=77 * Sets edit tool.
     * *
     * * @request_body_type SetEditToolRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"edit_tool": "ET_ZoomNormal"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} RecallZoomPreset=78 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RecallZoomPreset=78 * Recalls zoom preset.
     * *
     * * @request_body_type RecallZoomPresetRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"zoom_preset": 1
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} GetEditModeOptions=79 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetEditModeOptions=79 * Gets current edit mode options.
     * *
     * * @response_body_type GetEditModeOptionsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"edit_mode_options":{
     * * 		"tab_to_transients": true,
     * * 		"link_timeline_and_edit_selection": true,
     * * 		"link_track_and_edit_selection": true,
     * * 		"insertion_follows_playback": true,
     * * 		"automation_follows_edit": true,
     * * 		"markers_follow_edit": true,
     * * 		"layered_editing": true
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} SetEditModeOptions=80 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetEditModeOptions=80 * Sets edit mode options.
     * *
     * * @request_body_type SetEditModeOptionsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"edit_mode_options": {
     * * 		"tab_to_transients": true,
     * * 		"link_timeline_and_edit_selection": true,
     * * 		"link_track_and_edit_selection": true,
     * * 		"insertion_follows_playback": true,
     * * 		"automation_follows_edit": true,
     * * 		"markers_follow_edit": true,
     * * 		"mirrored_midi_editing": true,
     * * 		"layered_editing": true
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} SetTimelineSelection=81 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTimelineSelection=81 * Sets timeline selection.
     * * @request_body_type SetTimelineSelectionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"play_start_marker_time": "25",
     * * 	"in_time": "20",
     * * 	"out_time": "30",
     * * 	"pre_roll_start_time": "15",
     * * 	"post_roll_stop_time": "35",
     * * 	"pre_roll_enabled": "TB_True",
     * * 	"post_roll_enabled": "TB_True"
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} GetTimelineSelection=82 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetTimelineSelection=82 * Gets timeline selection.
     * *
     * * @request_body_type GetTimelineSelectionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"location_type": "TLType_Samples"
     * * }
     * * @end_example
     * *
     * * @response_body_type GetTimelineSelectionResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"in_time": "998424",
     * * 	"out_time": "1098424",
     * * 	"play_start_marker_time": "998424",
     * * 	"post_roll_enabled": false,
     * * 	"post_roll_stop_time": "1098424",
     * * 	"pre_roll_enabled": false,
     * * 	"pre_roll_start_time": "998424"
     * * }
     * * @end_example
     * *
     * * @category_transport
     * * @category_all
     * *
     * * @since Pro Tools 2023.09
     * *
     * * @_ingroup ptsl_version_2023_09
     * @property {number} ImportVideo=83 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ImportVideo=83 * Imports Video file(s) into the session.
     * *
     * *@request_body_type ImportVideoRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"video_file_list": ["/path/to/video_1.mp4", "/path/to/video_2.mp4"],
     * * 	"destination": "MD_NewTrack",
     * * 	"location": "ML_Spot",
     * * 	"spot_location_data": {
     * * 		"location_type": "End",
     * * 		"location": {
     * * 			"location": "1234567",
     * * 			"time_type": "TLType_Samples"
     * * 		}
     * * 	},
     * * 	"gaps_between_clips": 5,
     * * 	"import_audio_from_file": true,
     * * 	"audio_destination_path": "/path/to/folder/",
     * * 	"remove_existing_video_tracks": false,
     * * 	"remove_existing_video_clips": false,
     * * 	"clear_destination_video_track_playlist": false
     * * }
     * * @end_example
     * *
     * * @response_body_type ImportVideoResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"failure_list": [{
     * * 		"failure_message": "File was not found",
     * * 		"file_path": "/Path/to/non_existing_file.mp4"
     * * 	}]
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SelectMemoryLocation=84 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SelectMemoryLocation=84 * Selects the memory location specified.
     * *
     * * @request_body_type SelectMemoryLocationRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"number": 1
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackMuteState=85 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackMuteState=85 * Sets the `mute` state of the specified tracks (except Video and MasterFader types of tracks).
     * *
     * * @request_body_type SetTrackMuteStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackSoloState=86 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackSoloState=86 * Sets the `solo` state of the specified tracks (except Video and MasterFader types of tracks).
     * *
     * * @request_body_type SetTrackSoloStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackSoloSafeState=87 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackSoloSafeState=87 * Sets the `solo safe` state of the specified tracks (except Video and MasterFader types of tracks).
     * *
     * * @request_body_type SetTrackSoloSafeStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackRecordEnableState=88 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackRecordEnableState=88 * Sets the `record enable` state of the specified tracks (Audio, Instrument, Midi and VCA types of tracks only).
     * *
     * * @request_body_type SetTrackRecordEnableStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackRecordSafeEnableState=89 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackRecordSafeEnableState=89 * Sets the `record safe enable` state of the specified tracks (Audio, Instrument, Midi and VCA types of tracks only).
     * *
     * * @request_body_type SetTrackRecordSafeEnableStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackInputMonitorState=90 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackInputMonitorState=90 * Sets the `input monitor` state of Audio, Instrument and VCA track types.
     * *
     * * @request_body_type SetTrackInputMonitorStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackSmartDspState=91 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackSmartDspState=91 * Sets the `smart DSP` state of the specified tracks (except Video, Midi, VCA and Basic Folder types of tracks).
     * *
     * * @request_body_type SetTrackSmartDspStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackHiddenState=92 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackHiddenState=92 * Sets the `hidden` state of the specified tracks.
     * *
     * * @request_body_type SetTrackHiddenStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackInactiveState=93 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackInactiveState=93 * Set the `inactive` state of the specified tracks (except Video tracks).
     * *
     * * @request_body_type SetTrackInactiveStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackFrozenState=94 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackFrozenState=94 * Sets the `frozen` state of the specified tracks (Audio, Instrument, AuxInput and Routing Folder types of tracks only).
     * *
     * * @request_body_type SetTrackFrozenStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackOnlineState=95 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackOnlineState=95 * Sets the `online` state of the specified tracks (Video tracks only).
     * *
     * * @request_body_type SetTrackOnlineStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_name": "track1",
     * *  "enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} SetTrackOpenState=96 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackOpenState=96 * Sets the `open` state of the specified tracks (Folder tracks only).
     * *
     * * @request_body_type SetTrackOpenStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2023.12
     * *
     * * @_ingroup ptsl_version_2023_12
     * @property {number} GetSessionIDs=97 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionIDs=97 * Provides originId, instanceId and parentId of the current opened session:
     * * - originId is the main ID of the session (or project), and it remains the same in all variations of the session through Save As, Save Copy In, etc.
     * * - instanceId is unique for each session variation. In a new/original session file, the instanceId is equal to originId. When variants are introduced via Save As, Save Copy In, and several others, instanceId is set to a new unique ID.
     * * - parentId is set to the instanceId of the source session for sessions based off of a previous session. For new/original sessions, the parentId is set to zeros. That means parentId is equal to originId for first-generation variants, and is different for second and later generation variations.
     * *
     * * @response_body_type GetSessionIDsResponseBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"origin_id": "{00000000-2a000000-086ed1e0-94ef763d}",
     * * 	"instance_id": "{00000000-2a000000-086ed1e0-94ef763d}",
     * * 	"parent_id": "{00000000-00000000-00000000-00000000}"
     * * }
     * * @end_example
     * *
     * * @category_session_file
     * * @category_all
     * *
     * * @since Pro Tools 2024.03
     * *
     * * @_ingroup ptsl_version_2024_03
     * @property {number} GetMemoryLocationsManageMode=98 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetMemoryLocationsManageMode=98 * Returns the Memory Locations Manage Mode state (see menu Window -> Memory Locations in the UI).
     * *
     * * @response_body_type GetMemoryLocationsManageModeResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} SetMemoryLocationsManageMode=99 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetMemoryLocationsManageMode=99 * Sets the Memory Locations Manage Mode (see menu Window -> Memory Locations in the UI).
     * *
     * * @request_body_type SetMemoryLocationsManageModeRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} SetMainCounterFormat=100 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetMainCounterFormat=100 * Sets the time format of the Main Counter.
     * *
     * * @request_body_type SetMainCounterFormatRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"location_type": "TLType_MinSecs"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} SetSubCounterFormat=101 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetSubCounterFormat=101 * Sets the time format of the Sub Counter.
     * *
     * * @request_body_type SetSubCounterFormatRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"location_type": "TLType_MinSecs"
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} GetMainCounterFormat=102 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetMainCounterFormat=102 * Gets the time format of the Main Counter.
     * *
     * * @response_body_type GetMainCounterFormatResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "MinSecs",
     * * 	"current_type": "TLType_MinSecs",
     * * 	"possible_settings": [ "BarsBeats", "MinSecs", "TimeCode", "FeetFrames", "Samples" ],
     * * 	"possible_types": [ "TLType_BarsBeats", "TLType_MinSecs", "TLType_TimeCode", "TLType_FeetFrames", "TLType_Samples" ]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} GetSubCounterFormat=103 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSubCounterFormat=103 * Returns the time format of the Sub Counter.
     * *
     * * @response_body_type GetSubCounterFormatResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"current_setting": "BarsBeats",
     * * 	"current_type": "TLType_BarsBeats",
     * * 	"possible_settings": [ "BarsBeats", "MinSecs", "TimeCode", "FeetFrames", "Samples" ],
     * * 	"possible_types": [ "TLType_BarsBeats", "TLType_MinSecs", "TLType_TimeCode", "TLType_FeetFrames", "TLType_Samples" ]
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} Undo=104 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Undo=104 * Undoes the last N operations. Successfully undone operations are returned in the response.
     * *
     * * @request_body_type UndoRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"levels": 1
     * * }
     * * @end_example
     * *
     * * @response_body_type UndoResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"operations": [{
     * * 		"details": "00:00:00:00 to 00:00:00:01",
     * * 		"operation": "Change Session Start",
     * * 		"time": "2024-08-26T12:43:18+0300"
     * * 	}]
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} Redo=105 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_Redo=105 * Redoes the last N operations. Successfully redone operations are returned in the response.
     * *
     * * @request_body_type RedoRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"levels": 1
     * * }
     * * @end_example
     * *
     * * @response_body_type RedoResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"operations": [{
     * * 		"details": "00:00:00:00 to 00:00:00:01",
     * * 		"operation": "Change Session Start",
     * * 		"time": "2024-08-26T12:43:18+0300"
     * * 	}]
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} UndoAll=106 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_UndoAll=106 * Undoes all operations listed in Undo History.
     * *
     * * @response_body_type UndoAllResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"operations": [{
     * * 		"details": "00:00:00:00 to 00:00:00:01",
     * * 		"operation": "Change Session Start",
     * * 		"time": "2024-08-26T12:43:18+0300"
     * * 	}]
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} RedoAll=107 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RedoAll=107 * Redoes all operations listed in Undo History.
     * *
     * * @response_body_type RedoAllResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"operations": [{
     * * 		"details": "00:00:00:00 to 00:00:00:01",
     * * 		"operation": "Change Session Start",
     * * 		"time": "2024-08-26T12:43:18+0300"
     * * 	}]
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} ClearUndoQueue=108 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_ClearUndoQueue=108 * Clears the undo queue.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} SetTrackDSPModeSafeState=109 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_SetTrackDSPModeSafeState=109 * Sets the DSP Mode Safe state for the specified tracks.
     * *
     * * @request_body_type SetTrackDSPModeSafeStateRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"track_names": ["track1", "track2"],
     * * 	"enabled": true
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} GetSessionSystemDelayInfo=110 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GetSessionSystemDelayInfo=110 * Provides the System Delay value and the Delay Compensation state of the current session.
     * *
     * * @response_body_type GetSessionSystemDelayInfoResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"samples": 12345,
     * * 	"delay_compensation_enabled": true
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} GroupClips=111 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_GroupClips=111 * Creates a new clip group based on the Edit selection made across tracks.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} UngroupClips=112 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_UngroupClips=112 * Reveals all underlying clips and any nested clip groups within a selected clip group, making them independent and editable.
     * * @note Only the front-most top-level clip group will be ungrouped; any underlying clip groups will be preserved.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} UngroupAllClips=113 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_UngroupAllClips=113 * Reveals all clips within a selected clip group and any of its nested clip groups, making them independent and editable.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} RegroupClips=114 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RegroupClips=114 * Reassembles a previously ungrouped clip group, including any nested clip groups, restoring its original structure.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} RepeatSelection=115 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_RepeatSelection=115 * Lets you specify the number of times the selected material is duplicated.
     * *
     * * @request_body_type RepeatSelectionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"num_repeats": 1
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} DuplicateSelection=116 * @deprecated since Pro Tools 2025.06, use the version with the CId_ prefix
     * @property {number} CId_DuplicateSelection=116 * Copies a selection and places it immediately after the end of the selection.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since Pro Tools 2024.06
     * *
     * * @_ingroup ptsl_version_2024_06
     * @property {number} ClearAllMemoryLocations=117 * @deprecated since Pro Tools 2025.06
     * @property {number} CId_ClearAllMemoryLocations=117 * Clears all the memory locations in the session.
     * *
     * * @response_body_type ClearAllMemoryLocationsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"success_count": 1,
     * * 	"failure_count": 0,
     * * 	"failure_list": []
     * * }
     * * @end_example
     * *
     * * @since Pro Tools 2024.10
     * *
     * * @_ingroup ptsl_version_2024_10
     * @property {number} CId_GetTimeAsType=118 * Converts given TimelineLocation between units
     * *
     * * @request_body_type GetTimeAsTypeRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *  "location": {
     * * 		"location": "100|20|200",
     * * 		"time_type": "TLType_BarsBeats"
     * * 	},
     * *	"time_type": "TLType_Seconds"
     * * }
     * * @end_example
     * *
     * * @response_body_type GetTimeAsTypeResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"converted_location": {
     * * 		"time_type": "TLType_Seconds",
     * * 		"location": "207.60"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_time_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_SubtractLocations=119 * Returns the TimeLength between two timeline locations, applying any conversions necessary.
     * *
     * * @request_body_type SubtractLocationsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"first_location": {
     * * 		"location": "34:04.833",
     * * 		"time_type": "TLType_MinSecs"
     * * 	},
     * * 	"second_location": {
     * * 		"location": "00:34:04:20.00",
     * * 		"time_type": "TLType_TimeCode"
     * * 	},
     * * 	"desired_time_type": "BTType_Samples"
     * * }
     * * @end_example
     * *
     * * @response_body_type SubtractLocationsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"length": {
     * * 		"length": 1584,
     * * 		"time_type": "BTType_Samples"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_time_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_AddLengthToLocation=120 * Adds length to a timeline location, regardless of units.
     * *
     * * @request_body_type AddLengthToLocationRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"location": {
     * * 		"location": "1023 | 2 | 640",
     * * 		"time_type": "TLType_BarsBeats"
     * * 	},
     * * 	"length": {
     * * 		"length": 5,
     * * 		"time_type": "BTType_Frames"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type AddLengthToLocationResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"result_location": {
     * * 		"time_type": "TLType_BarsBeats",
     * * 		"location": "1023| 3 | 072"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_time_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_SubtractPositions=121 * Returns the TimeLength between two timeline positions.
     * *
     * * @request_body_type SubtractPositionsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"first_position": {
     * * 		"position": 333,
     * * 		"time_type": "BTType_Samples"
     * * 	},
     * * 	"second_position": {
     * * 		"position": 222,
     * * 		"time_type": "BTType_Samples"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type SubtractPositionsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"length": {
     * * 		"length": 111,
     * * 		"time_type": "BTType_Samples"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_time_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_AddLengthToPosition=122 * Adds length to a timeline position.
     * *
     * * @request_body_type AddLengthToPositionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"position": {
     * * 		"position": 333,
     * * 		"time_type": "BTType_Samples"
     * * 	},
     * * 	"length": {
     * * 		"length": 222,
     * * 		"time_type": "BTType_Samples"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type AddLengthToPositionResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"result_position": {
     * *		"position": 555,
     * * 		"time_type": "BTType_Samples"
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_time_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_ImportAudioToClipList=123 * Imports a set of specified audio files to Clip List of the currently opened session.
     * *
     * * @request_body_type ImportAudioToClipListRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"file_list": [ "/path/to/source/folder/audio_file.wav" ],
     * * 	"destination_path": "/path/to/destination/folder/",
     * * 	"audio_operations": "AOperations_CopyAudio"
     * * }
     * * @end_example
     * *
     * * @response_body_type ImportAudioToClipListResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *   "failure_list": [],
     * *   "file_list": [
     * *     {
     * *       "destination_file_list": [
     * *         {
     * *           "clip_id_list": [
     * *             "9dbeaa63-83ae-4af0-82da-d758a1b9e357",
     * *             "69b3c578-e648-4177-b54f-d0d48e7fa70c"
     * *           ],
     * *           "file_id": "0aaa644b-04c4-4f21-941e-cf60e02414d1",
     * *           "file_path": "/path/to/destination/folder/audio_file.wav"
     * *         }
     * *       ],
     * *       "original_input_path": "/path/to/source/folder/audio_file.wav"
     * *     }
     * *   ]
     * * }
     * * @end_example
     * *
     * * @category_session_write
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_SpotClipsByID=124 * Spots a set of specified clips referencing by clip ID.
     * *
     * * @request_body_type SpotClipsByIDRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"src_clips": [
     * * 		"e3cd8341-5c77-4590-90e2-1e35c0d673d8",
     * * 		"495cb605-3a09-4099-99fb-ad2adc1eef80"
     * * 	],
     * * 	"dst_track_id": "{00000000-2a000000-22db75e3-61ea7379}",
     * * 	"clip_instance_attributes": {
     * * 		"color_index": 61
     * * 	},
     * * 	"dst_location_data": {
     * * 		"location_type": "SLType_SyncPoint",
     * * 		"location": {
     * * 			"time_type": "TLType_Samples",
     * * 			"location": "123456"
     * * 		}
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_GetClipList=125 * Returns a list of clips present in current session.
     * *
     * * @request_body_type GetClipListRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"pagination_request": {
     * * 		"limit": 0,
     * * 		"offset": 0
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type GetClipListResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *     "clip_list": [
     * *         {
     * *             "clip_full_name": "Audio 1_01",
     * *             "clip_id": "c76b0492-5d42-4670-8750-86e69092f7aa",
     * *             "clip_root_name": "Audio 1_01",
     * *             "clip_type": "CType_Audio",
     * *             "end_point": {
     * *                 "position": 1000000960000,
     * *                 "time_type": "BTType_Ticks"
     * *             },
     * *             "file_id": "261d2602-6475-478d-a81f-6baffb7600b5",
     * *             "original_timestamp_point": {
     * *                 "location": "216972",
     * *                 "time_type": "TLType_Samples"
     * *             },
     * *             "src_end_point": {
     * *                 "position": 120,
     * *                 "time_type": "BTType_Samples"
     * *             },
     * *             "src_start_point": {
     * *                 "position": 110,
     * *                 "time_type": "BTType_Samples"
     * *             },
     * *             "start_point": {
     * *                 "position": 1000000000000,
     * *                 "time_type": "BTType_Ticks"
     * *             },
     * *             "sync_point": {
     * *                 "position": 1000000480000,
     * *                 "time_type": "BTType_Ticks"
     * *             },
     * *             "transpose_cents": 50,
     * *             "transpose_semitones": -12,
     * *             "user_timestamp_point": {
     * *                 "location": "90177150",
     * *                 "time_type": "TLType_Samples"
     * *             }
     * *         }
     * *     ],
     * *     "pagination_response": {
     * *         "limit": 0,
     * *         "offset": 0,
     * *         "total": 11
     * *     }
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_GetMediaFileInfo=126 Returns media file information referencing by file ID.
     * *
     * * @request_body_type GetMediaFileInfoRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"file_id": "d2169a6d-f489-4ae1-b788-17e172040f11"
     * * }
     * * @end_example
     * *
     * * @response_body_type GetMediaFileInfoResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"audio_file_info": {
     * * 		"encoding": "Bit16",
     * * 		"file_id": "d2169a6d-f489-4ae1-b788-17e172040f11",
     * * 		"file_type": "FT_WAVE",
     * * 		"length": {
     * * 			"length": 1024,
     * * 			"time_type": "BTType_Samples"
     * * 		},
     * * 		"num_channels": 6,
     * * 		"original_timestamp": {
     * * 			"location": "512",
     * * 			"time_type": "TLType_Samples"
     * * 		},
     * * 		"protools_umid": "aaOeTBl62SQk",
     * * 		"sample_rate": "SR_44100",
     * * 		"smpte_uid": "060a2b340101010501010f1013-000000-b6e836ab12ed0080-40233c039e74-d0bc",
     * * 		"stem_format": "SFormat_5_1",
     * * 		"user_timestamp": {
     * * 			"location": "512",
     * * 			"time_type": "TLType_Samples"
     * * 		}
     * * 	}
     * * }
     * * @end_example
     * *
     * * @category_session_read
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_CreateAudioClips=127 * Creates audio clips based on audio files.
     * *
     * * @request_body_type CreateAudioClipsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *     "clip_list": [
     * *         {
     * *             "name": "NewClipName",
     * *             "channel_format": "SFormat_Stereo",
     * *             "original_timestamp": {
     * *                 "location": "123",
     * *                 "time_type": "TLType_Frames"
     * *             },
     * *             "user_timestamp": {
     * *                 "location": "1003926080000",
     * *                 "time_type": "TLType_Ticks"
     * *             },
     * *             "clip_info": [
     * *                 {
     * *                     "file_id": "261d2602-6475-478d-a81f-6baffb7600b5",
     * *                     "src_channel": {
     * *                         "index": 5
     * *                     },
     * *                     "dst_channel": {
     * *                         "name": "SChannel_Left"
     * *                     },
     * *                     "src_start_point": {
     * *                         "position": 10,
     * *                         "time_type": "BTType_Samples"
     * *                     },
     * *                     "src_sync_point": {
     * *                         "position": 15,
     * *                         "time_type": "BTType_Samples"
     * *                     },
     * *                     "src_end_point": {
     * *                         "position": 20,
     * *                         "time_type": "BTType_Samples"
     * *                     },
     * *                     "start_point": {
     * *                         "position": 0,
     * *                         "time_type": "BTType_Ticks"
     * *                     },
     * *                     "end_point": {
     * *                         "position": 960000,
     * *                         "time_type": "BTType_Ticks"
     * *                     },
     * *                     "transpose_semitones": -12,
     * *                     "transpose_cents": 50
     * *                 },
     * *                 {
     * *                     "file_id": "261d2602-6475-478d-a81f-6baffb7600b5",
     * *                     "src_channel": {
     * *                         "name": "SChannel_LeftSurround"
     * *                     },
     * *                     "dst_channel": {
     * *                         "index": 1
     * *                     },
     * *                     "src_start_point": {
     * *                         "position": 110,
     * *                         "time_type": "BTType_Samples"
     * *                     },
     * *                     "src_sync_point": {
     * *                         "position": 115,
     * *                         "time_type": "BTType_Samples"
     * *                     },
     * *                     "src_end_point": {
     * *                         "position": 120,
     * *                         "time_type": "BTType_Samples"
     * *                     },
     * *                     "start_point": {
     * *                         "position": 0,
     * *                         "time_type": "BTType_Ticks"
     * *                     },
     * *                     "end_point": {
     * *                         "position": 960000,
     * *                         "time_type": "BTType_Ticks"
     * *                     },
     * *                     "transpose_semitones": -12,
     * *                     "transpose_cents": 50
     * *                 }
     * *             ]
     * *         }
     * *     ]
     * * }
     * * @end_example
     * *
     * * @response_body_type CreateAudioClipsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *	"clip_list": [
     * *		{
     * *			"clip_ids": [
     * *				"6aad8c03-3535-4e2b-b425-6aaa7e99d1e3",
     * *				"81b775a6-c431-4a3f-aee5-520aa0303fc2"
     * *			]
     * *		}
     * *	]
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_GetExportMixSourceList=128 * Gets the list of ExportMix sources.
     * *
     * * @request_body_type GetExportMixSourceListRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *   "type": "EMSType_Output"
     * * }
     * *
     * * @response_body_type GetExportMixSourceListResponseBody
     * *
     * * @response_body_json_example
     * * {
     * * 	"source_list": ["Outpu1", "Outpu2"]
     * * }
     * * @end_example
     * *
     * * @since Pro Tools 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_CreateBatchJob=129 * Creates a batch job.
     * *
     * * This command is work-in-progress and is not yet available for use.
     * *
     * * @request_body_type CreateBatchJobRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"job": {
     * * 		"name": "My complex operation",
     * * 		"description": "Does something complex in a few steps",
     * * 		"timeout": 5000,
     * * 		"is_cancelable": true,
     * * 		"cancel_on_failure": true
     * * 	}
     * * }
     * * @end_example
     * *
     * * @response_body_type CreateBatchJobResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *   "id": "d207e4f4-7a5a-4fe7-8edd-172dd002ff1b"
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_GetMonitorOutputPath=130 * Gets monitor output path from I/O Setup.
     * *
     * * @response_body_type GetMonitorOutputPathResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *   "monitor_path": "Stereo Speakers"
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_GetEditSelection=131 * Returns edit selection in the desired time units.
     * *
     * * @request_body_type GetEditSelectionRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *   "location_type": "TLType_TimeCode"
     * * }
     * * @end_example
     * *
     * * @response_body_type GetEditSelectionResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *   "in_time": "00:01:00:00"
     * *   "out_time": "00:01:10:00"
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_SubscribeToEvents=132 * Subscribes to the specified PTSL events.
     * *
     * * The method runs immediately, bypassing the command queue.
     * *
     * * @request_body_type SubscribeToEventsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *   "events": [
     * *     {
     * *       "event_id": "EId_SessionOpened",
     * *       "event_data_json": "{}"
     * *     }
     * *   ]
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_GetBatchJobStatus=133 * Gets batch job status.
     * *
     * * This command is work-in-progress and is not yet available for use.
     * *
     * * @request_body_type GetBatchJobStatusRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"id": "d207e4f4-7a5a-4fe7-8edd-172dd002ff1b"
     * * }
     * * @end_example
     * *
     * * @response_body_type GetBatchJobStatusResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *   "job_info": {
     * * 		"job_data": {
     * * 			"name": "My complex operation",
     * * 			"description": "Does something complex in a few steps",
     * * 			"timeout": 5000,
     * * 			"is_cancelable": true,
     * * 			"cancel_on_failure": true
     * * 			}
     * * 		"id": "d207e4f4-7a5a-4fe7-8edd-172dd002ff1b",
     * * 		"progress": 0,
     * * 		"status": BatchJobStatus_Completed
     * * 		}
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_BounceTrack=134 * Renders to file a single track using current selection or in/out points
     * *
     * * @request_body_type BounceTrackRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *	"file_name": "PTSL_BounceTrack",
     * *	"file_type": "EMFType_MP3",
     * *	"location_info": {
     * *		"file_destination": "EM_FD_SessionFolder",
     * *	},
     * *	"audio_info": {
     * *	},
     * *	"in_location": {
     * *		"location": "400000",
     * *		"time_type": "TLType_Samples",
     * *	},
     * *	"out_location": {
     * *		"location": "600000",
     * *		"time_type": "TLType_Samples",
     * *	},
     * *	"src_track_id": "{00000000-2a000000-ff6014e4-4869d955}",
     * *	"audio_encoding_options":{
     * *	},
     * *	"offline_bounce": "TB_True",
     * * }
     * * @end_example
     * *
     * * @note The following parameters are not yet supported: automation_options, audio_info,
     * *
     * * @response_body_json_example
     * * {
     * *   "file_paths": [
     * *		"/path/to/source/folder/audio_file1.wav",
     * *		"/path/to/source/folder/audio_file2.wav"
     * *   ]
     * * }
     * * @end_example
     * *
     * * @category_export
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_PollEvents=135 * Streams real-time events from Pro Tools to the client.
     * *
     * * This RPC runs indefinitely without a typical end condition. It does not accept input arguments,
     * * relying on other methods for event system configuration. Each InProgress
     * * message with the @ref ptsl::PollEventsResponseBody::event "event" is considered a new event.
     * *
     * * Only one active connection is allowed per PTSL session. If a new call is made
     * * within the same session, the polling is transferred to the new connection,
     * * terminating the previous one if active.
     * *
     * * The method runs immediately, bypassing the command queue.
     * *
     * * The method is not affected by the timeout mechanism.
     * *
     * * The method does not suppress Pro Tools UI alerts.
     * *
     * * @response_body_type PollEventsResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *     "event": {
     * *         "event_id": "EId_SessionOpened",
     * *         "event_data_json": ""
     * *     }
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_UnsubscribeFromEvents=136 * Unsubscribes from the specified PTSL events.
     * *
     * * The method runs immediately, bypassing the command queue.
     * *
     * * @request_body_type UnsubscribeFromEventsRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *   "events": [
     * *     {
     * *       "event_id": "EId_SessionOpened",
     * *       "event_data_json": "{}"
     * *     }
     * *   ]
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_CompleteBatchJob=137 * Complete batch job.
     * *
     * * This command is work-in-progress and is not yet available for use.
     * *
     * * @request_body_type CompleteBatchJobRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"id": "d207e4f4-7a5a-4fe7-8edd-172dd002ff1b"
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_CancelBatchJob=138 * Cancel batch job.
     * *
     * * This command is work-in-progress and is not yet available for use.
     * *
     * * @request_body_type CanceBatchJobRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * 	"id": "d207e4f4-7a5a-4fe7-8edd-172dd002ff1b"
     * * }
     * * @end_example
     * *
     * * @category_utility
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_BeginScrub=139 * Begins scrubbing for the CuePro Application.
     * *
     * * @request_body_type BeginScrubRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_EndScrub=140 * Ends scrubbing for the CuePro Application.
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_ContinueScrub=141 * Specifies the velocity of scrub movement from the CuePro Application.
     * *
     * * @request_body_type ContinueScrubRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_EnableCueProVideoPlugIn=142 * Lets the CuePro ADR application tell PT to instantiate its AVX plugin on the video track.
     * *
     * * @request_body_type EnableCueProVideoPlugInRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_UpdateVideo=143 * Updates the video frame played to the video output.
     * *
     * * @request_body_type UpdateVideoRequestBody
     * *
     * * @request_body_json_example
     * * {
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_EnableAPI=144 * Enables a private API set.
     * *
     * * @request_body_type EnableAPIRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *   "client_key_string": "0dMmDtSIIivEHX0QNU0rTpZ4lbhr7zI9MxMl6e ...."
     * * }
     * * @end_example
     * *
     * * @response_body_type EnableAPIResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *   "success" : 1
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     * @property {number} CId_ExchangePublicKeys=145 * Exchanges public encryption keys between client and ProTools.
     * *
     * * @request_body_type ExchangePublicKeysRequestBody
     * *
     * * @request_body_json_example
     * * {
     * *   "client_key_string": "0dMmDtSIIivEHX0QNU0rTpZ4lbhr7zI9MxMl6e ...."
     * * }
     * * @end_example
     * *
     * * @response_body_type ExchangePublicKeysResponseBody
     * *
     * * @response_body_json_example
     * * {
     * *   "pt_key_string": "0dMmDtSIIivEHX0QNU0rTpZ4lbhr7zI9MxMl6e ...."
     * * }
     * * @end_example
     * *
     * * @category_editing
     * * @category_all
     * *
     * * @since 2025.06
     * *
     * * @_ingroup ptsl_version_2025_06
     */
    ptsl.CommandId = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CreateSession"] = 0;
        values["CId_CreateSession"] = 0;
        values[valuesById[1] = "OpenSession"] = 1;
        values["CId_OpenSession"] = 1;
        values[valuesById[2] = "Import"] = 2;
        values["CId_Import"] = 2;
        values[valuesById[3] = "GetTrackList"] = 3;
        values["CId_GetTrackList"] = 3;
        values[valuesById[4] = "SelectAllClipsOnTrack"] = 4;
        values["CId_SelectAllClipsOnTrack"] = 4;
        values[valuesById[5] = "ExtendSelectionToTargetTracks"] = 5;
        values["CId_ExtendSelectionToTargetTracks"] = 5;
        values[valuesById[6] = "TrimToSelection"] = 6;
        values["CId_TrimToSelection"] = 6;
        values[valuesById[7] = "CreateFadesBasedOnPreset"] = 7;
        values["CId_CreateFadesBasedOnPreset"] = 7;
        values[valuesById[8] = "RenameTargetTrack"] = 8;
        values["CId_RenameTargetTrack"] = 8;
        values[valuesById[9] = "ConsolidateClip"] = 9;
        values["CId_ConsolidateClip"] = 9;
        values[valuesById[10] = "ExportClipsAsFiles"] = 10;
        values["CId_ExportClipsAsFiles"] = 10;
        values[valuesById[11] = "ExportSelectedTracksAsAAFOMF"] = 11;
        values["CId_ExportSelectedTracksAsAAFOMF"] = 11;
        values[valuesById[12] = "GetTaskStatus"] = 12;
        values["CId_GetTaskStatus"] = 12;
        values[valuesById[13] = "HostReadyCheck"] = 13;
        values["CId_HostReadyCheck"] = 13;
        values[valuesById[14] = "RefreshTargetAudioFiles"] = 14;
        values["CId_RefreshTargetAudioFiles"] = 14;
        values[valuesById[15] = "RefreshAllModifiedAudioFiles"] = 15;
        values["CId_RefreshAllModifiedAudioFiles"] = 15;
        values[valuesById[16] = "GetFileLocation"] = 16;
        values["CId_GetFileLocation"] = 16;
        values[valuesById[17] = "CloseSession"] = 17;
        values["CId_CloseSession"] = 17;
        values[valuesById[18] = "SaveSession"] = 18;
        values["CId_SaveSession"] = 18;
        values[valuesById[19] = "SaveSessionAs"] = 19;
        values["CId_SaveSessionAs"] = 19;
        values[valuesById[20] = "Cut"] = 20;
        values["CId_Cut"] = 20;
        values[valuesById[21] = "Copy"] = 21;
        values["CId_Copy"] = 21;
        values[valuesById[22] = "Paste"] = 22;
        values["CId_Paste"] = 22;
        values[valuesById[23] = "Clear"] = 23;
        values["CId_Clear"] = 23;
        values[valuesById[24] = "CutSpecial"] = 24;
        values["CId_CutSpecial"] = 24;
        values[valuesById[25] = "CopySpecial"] = 25;
        values["CId_CopySpecial"] = 25;
        values[valuesById[26] = "ClearSpecial"] = 26;
        values["CId_ClearSpecial"] = 26;
        values[valuesById[27] = "PasteSpecial"] = 27;
        values["CId_PasteSpecial"] = 27;
        values[valuesById[28] = "ExportMix"] = 28;
        values["CId_ExportMix"] = 28;
        values[valuesById[29] = "Spot"] = 29;
        values["CId_Spot"] = 29;
        values[valuesById[30] = "ExportSessionInfoAsText"] = 30;
        values["CId_ExportSessionInfoAsText"] = 30;
        values[valuesById[31] = "GetDynamicProperties"] = 31;
        values["CId_GetDynamicProperties"] = 31;
        values[valuesById[32] = "SetPlaybackMode"] = 32;
        values["CId_SetPlaybackMode"] = 32;
        values[valuesById[33] = "SetRecordMode"] = 33;
        values["CId_SetRecordMode"] = 33;
        values[valuesById[34] = "GetSessionAudioFormat"] = 34;
        values["CId_GetSessionAudioFormat"] = 34;
        values[valuesById[35] = "GetSessionSampleRate"] = 35;
        values["CId_GetSessionSampleRate"] = 35;
        values[valuesById[36] = "GetSessionBitDepth"] = 36;
        values["CId_GetSessionBitDepth"] = 36;
        values[valuesById[37] = "GetSessionInterleavedState"] = 37;
        values["CId_GetSessionInterleavedState"] = 37;
        values[valuesById[38] = "GetSessionTimeCodeRate"] = 38;
        values["CId_GetSessionTimeCodeRate"] = 38;
        values[valuesById[39] = "GetSessionFeetFramesRate"] = 39;
        values["CId_GetSessionFeetFramesRate"] = 39;
        values[valuesById[40] = "GetSessionAudioRatePullSettings"] = 40;
        values["CId_GetSessionAudioRatePullSettings"] = 40;
        values[valuesById[41] = "GetSessionVideoRatePullSettings"] = 41;
        values["CId_GetSessionVideoRatePullSettings"] = 41;
        values[valuesById[42] = "GetSessionName"] = 42;
        values["CId_GetSessionName"] = 42;
        values[valuesById[43] = "GetSessionPath"] = 43;
        values["CId_GetSessionPath"] = 43;
        values[valuesById[44] = "GetSessionStartTime"] = 44;
        values["CId_GetSessionStartTime"] = 44;
        values[valuesById[45] = "GetSessionLength"] = 45;
        values["CId_GetSessionLength"] = 45;
        values[valuesById[46] = "SetSessionAudioFormat"] = 46;
        values["CId_SetSessionAudioFormat"] = 46;
        values[valuesById[47] = "SetSessionBitDepth"] = 47;
        values["CId_SetSessionBitDepth"] = 47;
        values[valuesById[48] = "SetSessionInterleavedState"] = 48;
        values["CId_SetSessionInterleavedState"] = 48;
        values[valuesById[49] = "SetSessionTimeCodeRate"] = 49;
        values["CId_SetSessionTimeCodeRate"] = 49;
        values[valuesById[50] = "SetSessionFeetFramesRate"] = 50;
        values["CId_SetSessionFeetFramesRate"] = 50;
        values[valuesById[51] = "SetSessionAudioRatePullSettings"] = 51;
        values["CId_SetSessionAudioRatePullSettings"] = 51;
        values[valuesById[52] = "SetSessionVideoRatePullSettings"] = 52;
        values["CId_SetSessionVideoRatePullSettings"] = 52;
        values[valuesById[53] = "SetSessionStartTime"] = 53;
        values["CId_SetSessionStartTime"] = 53;
        values[valuesById[54] = "SetSessionLength"] = 54;
        values["CId_SetSessionLength"] = 54;
        values[valuesById[55] = "GetPTSLVersion"] = 55;
        values["CId_GetPTSLVersion"] = 55;
        values[valuesById[56] = "GetPlaybackMode"] = 56;
        values["CId_GetPlaybackMode"] = 56;
        values[valuesById[57] = "GetRecordMode"] = 57;
        values["CId_GetRecordMode"] = 57;
        values[valuesById[58] = "GetTransportArmed"] = 58;
        values["CId_GetTransportArmed"] = 58;
        values[valuesById[59] = "GetTransportState"] = 59;
        values["CId_GetTransportState"] = 59;
        values[valuesById[61] = "ClearMemoryLocation"] = 61;
        values["CId_ClearMemoryLocation"] = 61;
        values[valuesById[62] = "RenameSelectedClip"] = 62;
        values["CId_RenameSelectedClip"] = 62;
        values[valuesById[63] = "RenameTargetClip"] = 63;
        values["CId_RenameTargetClip"] = 63;
        values[valuesById[64] = "TogglePlayState"] = 64;
        values["CId_TogglePlayState"] = 64;
        values[valuesById[65] = "ToggleRecordEnable"] = 65;
        values["CId_ToggleRecordEnable"] = 65;
        values[valuesById[66] = "PlayHalfSpeed"] = 66;
        values["CId_PlayHalfSpeed"] = 66;
        values[valuesById[67] = "RecordHalfSpeed"] = 67;
        values["CId_RecordHalfSpeed"] = 67;
        values[valuesById[68] = "EditMemoryLocation"] = 68;
        values["CId_EditMemoryLocation"] = 68;
        values[valuesById[69] = "GetMemoryLocations"] = 69;
        values["CId_GetMemoryLocations"] = 69;
        values[valuesById[70] = "RegisterConnection"] = 70;
        values["CId_RegisterConnection"] = 70;
        values[valuesById[71] = "CreateMemoryLocation"] = 71;
        values["CId_CreateMemoryLocation"] = 71;
        values[valuesById[72] = "CreateNewTracks"] = 72;
        values["CId_CreateNewTracks"] = 72;
        values[valuesById[73] = "SelectTracksByName"] = 73;
        values["CId_SelectTracksByName"] = 73;
        values[valuesById[74] = "GetEditMode"] = 74;
        values["CId_GetEditMode"] = 74;
        values[valuesById[75] = "SetEditMode"] = 75;
        values["CId_SetEditMode"] = 75;
        values[valuesById[76] = "GetEditTool"] = 76;
        values["CId_GetEditTool"] = 76;
        values[valuesById[77] = "SetEditTool"] = 77;
        values["CId_SetEditTool"] = 77;
        values[valuesById[78] = "RecallZoomPreset"] = 78;
        values["CId_RecallZoomPreset"] = 78;
        values[valuesById[79] = "GetEditModeOptions"] = 79;
        values["CId_GetEditModeOptions"] = 79;
        values[valuesById[80] = "SetEditModeOptions"] = 80;
        values["CId_SetEditModeOptions"] = 80;
        values[valuesById[81] = "SetTimelineSelection"] = 81;
        values["CId_SetTimelineSelection"] = 81;
        values[valuesById[82] = "GetTimelineSelection"] = 82;
        values["CId_GetTimelineSelection"] = 82;
        values[valuesById[83] = "ImportVideo"] = 83;
        values["CId_ImportVideo"] = 83;
        values[valuesById[84] = "SelectMemoryLocation"] = 84;
        values["CId_SelectMemoryLocation"] = 84;
        values[valuesById[85] = "SetTrackMuteState"] = 85;
        values["CId_SetTrackMuteState"] = 85;
        values[valuesById[86] = "SetTrackSoloState"] = 86;
        values["CId_SetTrackSoloState"] = 86;
        values[valuesById[87] = "SetTrackSoloSafeState"] = 87;
        values["CId_SetTrackSoloSafeState"] = 87;
        values[valuesById[88] = "SetTrackRecordEnableState"] = 88;
        values["CId_SetTrackRecordEnableState"] = 88;
        values[valuesById[89] = "SetTrackRecordSafeEnableState"] = 89;
        values["CId_SetTrackRecordSafeEnableState"] = 89;
        values[valuesById[90] = "SetTrackInputMonitorState"] = 90;
        values["CId_SetTrackInputMonitorState"] = 90;
        values[valuesById[91] = "SetTrackSmartDspState"] = 91;
        values["CId_SetTrackSmartDspState"] = 91;
        values[valuesById[92] = "SetTrackHiddenState"] = 92;
        values["CId_SetTrackHiddenState"] = 92;
        values[valuesById[93] = "SetTrackInactiveState"] = 93;
        values["CId_SetTrackInactiveState"] = 93;
        values[valuesById[94] = "SetTrackFrozenState"] = 94;
        values["CId_SetTrackFrozenState"] = 94;
        values[valuesById[95] = "SetTrackOnlineState"] = 95;
        values["CId_SetTrackOnlineState"] = 95;
        values[valuesById[96] = "SetTrackOpenState"] = 96;
        values["CId_SetTrackOpenState"] = 96;
        values[valuesById[97] = "GetSessionIDs"] = 97;
        values["CId_GetSessionIDs"] = 97;
        values[valuesById[98] = "GetMemoryLocationsManageMode"] = 98;
        values["CId_GetMemoryLocationsManageMode"] = 98;
        values[valuesById[99] = "SetMemoryLocationsManageMode"] = 99;
        values["CId_SetMemoryLocationsManageMode"] = 99;
        values[valuesById[100] = "SetMainCounterFormat"] = 100;
        values["CId_SetMainCounterFormat"] = 100;
        values[valuesById[101] = "SetSubCounterFormat"] = 101;
        values["CId_SetSubCounterFormat"] = 101;
        values[valuesById[102] = "GetMainCounterFormat"] = 102;
        values["CId_GetMainCounterFormat"] = 102;
        values[valuesById[103] = "GetSubCounterFormat"] = 103;
        values["CId_GetSubCounterFormat"] = 103;
        values[valuesById[104] = "Undo"] = 104;
        values["CId_Undo"] = 104;
        values[valuesById[105] = "Redo"] = 105;
        values["CId_Redo"] = 105;
        values[valuesById[106] = "UndoAll"] = 106;
        values["CId_UndoAll"] = 106;
        values[valuesById[107] = "RedoAll"] = 107;
        values["CId_RedoAll"] = 107;
        values[valuesById[108] = "ClearUndoQueue"] = 108;
        values["CId_ClearUndoQueue"] = 108;
        values[valuesById[109] = "SetTrackDSPModeSafeState"] = 109;
        values["CId_SetTrackDSPModeSafeState"] = 109;
        values[valuesById[110] = "GetSessionSystemDelayInfo"] = 110;
        values["CId_GetSessionSystemDelayInfo"] = 110;
        values[valuesById[111] = "GroupClips"] = 111;
        values["CId_GroupClips"] = 111;
        values[valuesById[112] = "UngroupClips"] = 112;
        values["CId_UngroupClips"] = 112;
        values[valuesById[113] = "UngroupAllClips"] = 113;
        values["CId_UngroupAllClips"] = 113;
        values[valuesById[114] = "RegroupClips"] = 114;
        values["CId_RegroupClips"] = 114;
        values[valuesById[115] = "RepeatSelection"] = 115;
        values["CId_RepeatSelection"] = 115;
        values[valuesById[116] = "DuplicateSelection"] = 116;
        values["CId_DuplicateSelection"] = 116;
        values[valuesById[117] = "ClearAllMemoryLocations"] = 117;
        values["CId_ClearAllMemoryLocations"] = 117;
        values[valuesById[118] = "CId_GetTimeAsType"] = 118;
        values[valuesById[119] = "CId_SubtractLocations"] = 119;
        values[valuesById[120] = "CId_AddLengthToLocation"] = 120;
        values[valuesById[121] = "CId_SubtractPositions"] = 121;
        values[valuesById[122] = "CId_AddLengthToPosition"] = 122;
        values[valuesById[123] = "CId_ImportAudioToClipList"] = 123;
        values[valuesById[124] = "CId_SpotClipsByID"] = 124;
        values[valuesById[125] = "CId_GetClipList"] = 125;
        values[valuesById[126] = "CId_GetMediaFileInfo"] = 126;
        values[valuesById[127] = "CId_CreateAudioClips"] = 127;
        values[valuesById[128] = "CId_GetExportMixSourceList"] = 128;
        values[valuesById[129] = "CId_CreateBatchJob"] = 129;
        values[valuesById[130] = "CId_GetMonitorOutputPath"] = 130;
        values[valuesById[131] = "CId_GetEditSelection"] = 131;
        values[valuesById[132] = "CId_SubscribeToEvents"] = 132;
        values[valuesById[133] = "CId_GetBatchJobStatus"] = 133;
        values[valuesById[134] = "CId_BounceTrack"] = 134;
        values[valuesById[135] = "CId_PollEvents"] = 135;
        values[valuesById[136] = "CId_UnsubscribeFromEvents"] = 136;
        values[valuesById[137] = "CId_CompleteBatchJob"] = 137;
        values[valuesById[138] = "CId_CancelBatchJob"] = 138;
        values[valuesById[139] = "CId_BeginScrub"] = 139;
        values[valuesById[140] = "CId_EndScrub"] = 140;
        values[valuesById[141] = "CId_ContinueScrub"] = 141;
        values[valuesById[142] = "CId_EnableCueProVideoPlugIn"] = 142;
        values[valuesById[143] = "CId_UpdateVideo"] = 143;
        values[valuesById[144] = "CId_EnableAPI"] = 144;
        values[valuesById[145] = "CId_ExchangePublicKeys"] = 145;
        return values;
    })();

    /**
     * IDs of the PTSL events.
     * 
     * @since Pro Tools 2025.06
     * @name ptsl.EventId
     * @enum {number}
     * @property {number} EId_Unknown=0 * Tech-only value.
     * @property {number} EId_SessionOpened=1 * The event is triggered when an existing session is opened.
     * *
     * * @category_events
     * * @category_all
     * *
     * * @since 2025.06
     * @property {number} EId_SessionCreated=2 * The event is triggered when a new session is created.
     * *
     * * @category_events
     * * @category_all
     * *
     * * @since 2025.06
     * @property {number} EId_SessionClosed=3 * The event is triggered when a session is closed.
     * *
     * * @category_events
     * * @category_all
     * *
     * * @since 2025.06
     */
    ptsl.EventId = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EId_Unknown"] = 0;
        values[valuesById[1] = "EId_SessionOpened"] = 1;
        values[valuesById[2] = "EId_SessionCreated"] = 2;
        values[valuesById[3] = "EId_SessionClosed"] = 3;
        return values;
    })();

    /**
     * Status of execution of the Pro Tools task.
     * @name ptsl.TaskStatus
     * @enum {number}
     * @property {number} Queued=0 Queued value
     * @property {number} TStatus_Queued=0 TStatus_Queued value
     * @property {number} Pending=1 Pending value
     * @property {number} TStatus_Pending=1 TStatus_Pending value
     * @property {number} InProgress=2 InProgress value
     * @property {number} TStatus_InProgress=2 TStatus_InProgress value
     * @property {number} Completed=3 Completed value
     * @property {number} TStatus_Completed=3 TStatus_Completed value
     * @property {number} Failed=4 Failed value
     * @property {number} TStatus_Failed=4 TStatus_Failed value
     * @property {number} WaitingForUserInput=5 WaitingForUserInput value
     * @property {number} TStatus_WaitingForUserInput=5 TStatus_WaitingForUserInput value
     * @property {number} CompletedWithBadResponse=6 CompletedWithBadResponse value
     * @property {number} TStatus_CompletedWithBadResponse=6 TStatus_CompletedWithBadResponse value
     * @property {number} FailedWithBadErrorResponse=7 FailedWithBadErrorResponse value
     * @property {number} TStatus_FailedWithBadErrorResponse=7 TStatus_FailedWithBadErrorResponse value
     */
    ptsl.TaskStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Queued"] = 0;
        values["TStatus_Queued"] = 0;
        values[valuesById[1] = "Pending"] = 1;
        values["TStatus_Pending"] = 1;
        values[valuesById[2] = "InProgress"] = 2;
        values["TStatus_InProgress"] = 2;
        values[valuesById[3] = "Completed"] = 3;
        values["TStatus_Completed"] = 3;
        values[valuesById[4] = "Failed"] = 4;
        values["TStatus_Failed"] = 4;
        values[valuesById[5] = "WaitingForUserInput"] = 5;
        values["TStatus_WaitingForUserInput"] = 5;
        values[valuesById[6] = "CompletedWithBadResponse"] = 6;
        values["TStatus_CompletedWithBadResponse"] = 6;
        values[valuesById[7] = "FailedWithBadErrorResponse"] = 7;
        values["TStatus_FailedWithBadErrorResponse"] = 7;
        return values;
    })();

    /**
     * Type of the error message which can be returned to user.
     * It can be OS error or Pro Tools error.
     * @name ptsl.CommandErrorType
     * @enum {number}
     * @property {number} OS_WritePermissions=0 OS_WritePermissions value
     * @property {number} CEType_OS_WritePermissions=0 CEType_OS_WritePermissions value
     * @property {number} OS_ErrorCode=1 OS_ErrorCode value
     * @property {number} CEType_OS_ErrorCode=1 CEType_OS_ErrorCode value
     * @property {number} OS_NoLocationFound=2 OS_NoLocationFound value
     * @property {number} CEType_OS_NoLocationFound=2 CEType_OS_NoLocationFound value
     * @property {number} OS_NoSessionFound=3 OS_NoSessionFound value
     * @property {number} CEType_OS_NoSessionFound=3 CEType_OS_NoSessionFound value
     * @property {number} OS_FilePathLocation=4 OS_FilePathLocation value
     * @property {number} OS_ReadError=5 OS_ReadError value
     * @property {number} CEType_OS_ReadError=5 CEType_OS_ReadError value
     * @property {number} OS_DiskSpace=6 OS_DiskSpace value
     * @property {number} CEType_OS_DiskSpace=6 CEType_OS_DiskSpace value
     * @property {number} OS_DuplicateName=7 OS_DuplicateName value
     * @property {number} CEType_OS_DuplicateName=7 CEType_OS_DuplicateName value
     * @property {number} OS_IllegalCharacters=8 OS_IllegalCharacters value
     * @property {number} CEType_OS_IllegalCharacters=8 CEType_OS_IllegalCharacters value
     * @property {number} OS_CharactersLimit=9 OS_CharactersLimit value
     * @property {number} CEType_OS_CharactersLimit=9 CEType_OS_CharactersLimit value
     * @property {number} OS_ProToolsIsNotAvailable=10 OS_ProToolsIsNotAvailable value
     * @property {number} CEType_OS_ProToolsIsNotAvailable=10 CEType_OS_ProToolsIsNotAvailable value
     * @property {number} OS_NoFilePathFound=11 OS_NoFilePathFound value
     * @property {number} CEType_OS_NoFilePathFound=11 CEType_OS_NoFilePathFound value
     * @property {number} PT_UnknownError=100 PT_UnknownError value
     * @property {number} CEType_PT_UnknownError=100 CEType_PT_UnknownError value
     * @property {number} PT_NoTemplateGroup=101 PT_NoTemplateGroup value
     * @property {number} CEType_PT_NoTemplateGroup=101 CEType_PT_NoTemplateGroup value
     * @property {number} PT_NoTemplate=102 PT_NoTemplate value
     * @property {number} CEType_PT_NoTemplate=102 CEType_PT_NoTemplate value
     * @property {number} PT_SampleRateMismatch=103 PT_SampleRateMismatch value
     * @property {number} CEType_PT_SampleRateMismatch=103 CEType_PT_SampleRateMismatch value
     * @property {number} PT_NoVideoTrackFound=104 PT_NoVideoTrackFound value
     * @property {number} CEType_PT_NoVideoTrackFound=104 CEType_PT_NoVideoTrackFound value
     * @property {number} PT_NoTracksFound=105 PT_NoTracksFound value
     * @property {number} CEType_PT_NoTracksFound=105 CEType_PT_NoTracksFound value
     * @property {number} PT_NoOpenedSession=106 PT_NoOpenedSession value
     * @property {number} CEType_PT_NoOpenedSession=106 CEType_PT_NoOpenedSession value
     * @property {number} PT_NoTrackFound=107 PT_NoTrackFound value
     * @property {number} CEType_PT_NoTrackFound=107 CEType_PT_NoTrackFound value
     * @property {number} PT_NoClipsFound=108 PT_NoClipsFound value
     * @property {number} CEType_PT_NoClipsFound=108 CEType_PT_NoClipsFound value
     * @property {number} PT_NoSelection=109 PT_NoSelection value
     * @property {number} CEType_PT_NoSelection=109 CEType_PT_NoSelection value
     * @property {number} PT_RecordDrive=110 PT_RecordDrive value
     * @property {number} CEType_PT_RecordDrive=110 CEType_PT_RecordDrive value
     * @property {number} PT_NoPresetFound=111 PT_NoPresetFound value
     * @property {number} CEType_PT_NoPresetFound=111 CEType_PT_NoPresetFound value
     * @property {number} PT_FileTypeMXF=112 PT_FileTypeMXF value
     * @property {number} CEType_PT_FileTypeMXF=112 CEType_PT_FileTypeMXF value
     * @property {number} PT_CopyOptionCopy=113 PT_CopyOptionCopy value
     * @property {number} CEType_PT_CopyOptionCopy=113 CEType_PT_CopyOptionCopy value
     * @property {number} PT_CopyOptionLink=114 PT_CopyOptionLink value
     * @property {number} CEType_PT_CopyOptionLink=114 CEType_PT_CopyOptionLink value
     * @property {number} PT_QuantizeEdits=115 PT_QuantizeEdits value
     * @property {number} CEType_PT_QuantizeEdits=115 CEType_PT_QuantizeEdits value
     * @property {number} PT_ExportAsMultichannel=116 PT_ExportAsMultichannel value
     * @property {number} CEType_PT_ExportAsMultichannel=116 CEType_PT_ExportAsMultichannel value
     * @property {number} PT_IllegalCharactersComments=117 PT_IllegalCharactersComments value
     * @property {number} CEType_PT_IllegalCharactersComments=117 CEType_PT_IllegalCharactersComments value
     * @property {number} PT_IllegalCharactersSequenceName=118 PT_IllegalCharactersSequenceName value
     * @property {number} CEType_PT_IllegalCharactersSequenceName=118 CEType_PT_IllegalCharactersSequenceName value
     * @property {number} PT_MaxCharactersComments=119 PT_MaxCharactersComments value
     * @property {number} CEType_PT_MaxCharactersComments=119 CEType_PT_MaxCharactersComments value
     * @property {number} PT_MaxCharactersSequenceName=120 PT_MaxCharactersSequenceName value
     * @property {number} CEType_PT_MaxCharactersSequenceName=120 CEType_PT_MaxCharactersSequenceName value
     * @property {number} PT_NoSequenceName=121 PT_NoSequenceName value
     * @property {number} CEType_PT_NoSequenceName=121 CEType_PT_NoSequenceName value
     * @property {number} PT_InvalidTask=122 PT_InvalidTask value
     * @property {number} CEType_PT_InvalidTask=122 CEType_PT_InvalidTask value
     * @property {number} PT_FileNotFound=123 PT_FileNotFound value
     * @property {number} CEType_PT_FileNotFound=123 CEType_PT_FileNotFound value
     * @property {number} PT_InvalidSelection=124 PT_InvalidSelection value
     * @property {number} CEType_PT_InvalidSelection=124 CEType_PT_InvalidSelection value
     * @property {number} PT_ReadOnlySession=125 PT_ReadOnlySession value
     * @property {number} CEType_PT_ReadOnlySession=125 CEType_PT_ReadOnlySession value
     * @property {number} PT_InvalidParameter=126 PT_InvalidParameter value
     * @property {number} CEType_PT_InvalidParameter=126 CEType_PT_InvalidParameter value
     * @property {number} PT_Forbidden=127 PT_Forbidden value
     * @property {number} CEType_PT_Forbidden=127 CEType_PT_Forbidden value
     * @property {number} PT_NoTimelineFound=128 PT_NoTimelineFound value
     * @property {number} CEType_PT_NoTimelineFound=128 CEType_PT_NoTimelineFound value
     * @property {number} PT_ArgumentOutOfRange=129 PT_ArgumentOutOfRange value
     * @property {number} CEType_PT_ArgumentOutOfRange=129 CEType_PT_ArgumentOutOfRange value
     * @property {number} PT_ForbiddenTrackType=130 PT_ForbiddenTrackType value
     * @property {number} CEType_PT_ForbiddenTrackType=130 CEType_PT_ForbiddenTrackType value
     * @property {number} PT_NoVideoEngineFound=131 PT_NoVideoEngineFound value
     * @property {number} CEType_PT_NoVideoEngineFound=131 CEType_PT_NoVideoEngineFound value
     * @property {number} PT_NoDspHardwareFound=132 PT_NoDspHardwareFound value
     * @property {number} CEType_PT_NoDspHardwareFound=132 CEType_PT_NoDspHardwareFound value
     * @property {number} PT_UnsupportedCommand=133 PT_UnsupportedCommand value
     * @property {number} CEType_PT_UnsupportedCommand=133 CEType_PT_UnsupportedCommand value
     * @property {number} PT_HostNotReady=134 PT_HostNotReady value
     * @property {number} CEType_PT_HostNotReady=134 CEType_PT_HostNotReady value
     * @property {number} PT_CannotBeDone=135 PT_CannotBeDone value
     * @property {number} CEType_PT_CannotBeDone=135 CEType_PT_CannotBeDone value
     * @property {number} PT_ResponseLengthExceeded=136 PT_ResponseLengthExceeded value
     * @property {number} CEType_PT_ResponseLengthExceeded=136 CEType_PT_ResponseLengthExceeded value
     * @property {number} PT_CommandTimeout=137 PT_CommandTimeout value
     * @property {number} CEType_PT_CommandTimeout=137 CEType_PT_CommandTimeout value
     * @property {number} PT_HostIsBusy=138 PT_HostIsBusy value
     * @property {number} CEType_PT_HostIsBusy=138 CEType_PT_HostIsBusy value
     * @property {number} CEType_PT_DeprecatedParameter=139 * The parameter is deprecated and should not be used.
     * * @since Pro Tools 2025.06
     * @property {number} CEType_PT_DeprecatedParameterValue=140 * The parameter value is deprecated and should not be used.
     * * @since Pro Tools 2025.06
     * @property {number} PT_Info=200 PT_Info value
     * @property {number} CEType_PT_Info=200 CEType_PT_Info value
     * @property {number} SDK_VersionMismatch=401 SDK_VersionMismatch value
     * @property {number} CEType_SDK_VersionMismatch=401 CEType_SDK_VersionMismatch value
     * @property {number} SDK_NotImplemented=402 SDK_NotImplemented value
     * @property {number} CEType_SDK_NotImplemented=402 CEType_SDK_NotImplemented value
     * @property {number} SDK_SessionIdParseError=403 SDK_SessionIdParseError value
     * @property {number} CEType_SDK_SessionIdParseError=403 CEType_SDK_SessionIdParseError value
     * @property {number} SDK_GrpcGeneric=501 SDK_GrpcGeneric value
     * @property {number} CEType_SDK_GrpcGeneric=501 CEType_SDK_GrpcGeneric value
     */
    ptsl.CommandErrorType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OS_WritePermissions"] = 0;
        values["CEType_OS_WritePermissions"] = 0;
        values[valuesById[1] = "OS_ErrorCode"] = 1;
        values["CEType_OS_ErrorCode"] = 1;
        values[valuesById[2] = "OS_NoLocationFound"] = 2;
        values["CEType_OS_NoLocationFound"] = 2;
        values[valuesById[3] = "OS_NoSessionFound"] = 3;
        values["CEType_OS_NoSessionFound"] = 3;
        values[valuesById[4] = "OS_FilePathLocation"] = 4;
        values[valuesById[5] = "OS_ReadError"] = 5;
        values["CEType_OS_ReadError"] = 5;
        values[valuesById[6] = "OS_DiskSpace"] = 6;
        values["CEType_OS_DiskSpace"] = 6;
        values[valuesById[7] = "OS_DuplicateName"] = 7;
        values["CEType_OS_DuplicateName"] = 7;
        values[valuesById[8] = "OS_IllegalCharacters"] = 8;
        values["CEType_OS_IllegalCharacters"] = 8;
        values[valuesById[9] = "OS_CharactersLimit"] = 9;
        values["CEType_OS_CharactersLimit"] = 9;
        values[valuesById[10] = "OS_ProToolsIsNotAvailable"] = 10;
        values["CEType_OS_ProToolsIsNotAvailable"] = 10;
        values[valuesById[11] = "OS_NoFilePathFound"] = 11;
        values["CEType_OS_NoFilePathFound"] = 11;
        values[valuesById[100] = "PT_UnknownError"] = 100;
        values["CEType_PT_UnknownError"] = 100;
        values[valuesById[101] = "PT_NoTemplateGroup"] = 101;
        values["CEType_PT_NoTemplateGroup"] = 101;
        values[valuesById[102] = "PT_NoTemplate"] = 102;
        values["CEType_PT_NoTemplate"] = 102;
        values[valuesById[103] = "PT_SampleRateMismatch"] = 103;
        values["CEType_PT_SampleRateMismatch"] = 103;
        values[valuesById[104] = "PT_NoVideoTrackFound"] = 104;
        values["CEType_PT_NoVideoTrackFound"] = 104;
        values[valuesById[105] = "PT_NoTracksFound"] = 105;
        values["CEType_PT_NoTracksFound"] = 105;
        values[valuesById[106] = "PT_NoOpenedSession"] = 106;
        values["CEType_PT_NoOpenedSession"] = 106;
        values[valuesById[107] = "PT_NoTrackFound"] = 107;
        values["CEType_PT_NoTrackFound"] = 107;
        values[valuesById[108] = "PT_NoClipsFound"] = 108;
        values["CEType_PT_NoClipsFound"] = 108;
        values[valuesById[109] = "PT_NoSelection"] = 109;
        values["CEType_PT_NoSelection"] = 109;
        values[valuesById[110] = "PT_RecordDrive"] = 110;
        values["CEType_PT_RecordDrive"] = 110;
        values[valuesById[111] = "PT_NoPresetFound"] = 111;
        values["CEType_PT_NoPresetFound"] = 111;
        values[valuesById[112] = "PT_FileTypeMXF"] = 112;
        values["CEType_PT_FileTypeMXF"] = 112;
        values[valuesById[113] = "PT_CopyOptionCopy"] = 113;
        values["CEType_PT_CopyOptionCopy"] = 113;
        values[valuesById[114] = "PT_CopyOptionLink"] = 114;
        values["CEType_PT_CopyOptionLink"] = 114;
        values[valuesById[115] = "PT_QuantizeEdits"] = 115;
        values["CEType_PT_QuantizeEdits"] = 115;
        values[valuesById[116] = "PT_ExportAsMultichannel"] = 116;
        values["CEType_PT_ExportAsMultichannel"] = 116;
        values[valuesById[117] = "PT_IllegalCharactersComments"] = 117;
        values["CEType_PT_IllegalCharactersComments"] = 117;
        values[valuesById[118] = "PT_IllegalCharactersSequenceName"] = 118;
        values["CEType_PT_IllegalCharactersSequenceName"] = 118;
        values[valuesById[119] = "PT_MaxCharactersComments"] = 119;
        values["CEType_PT_MaxCharactersComments"] = 119;
        values[valuesById[120] = "PT_MaxCharactersSequenceName"] = 120;
        values["CEType_PT_MaxCharactersSequenceName"] = 120;
        values[valuesById[121] = "PT_NoSequenceName"] = 121;
        values["CEType_PT_NoSequenceName"] = 121;
        values[valuesById[122] = "PT_InvalidTask"] = 122;
        values["CEType_PT_InvalidTask"] = 122;
        values[valuesById[123] = "PT_FileNotFound"] = 123;
        values["CEType_PT_FileNotFound"] = 123;
        values[valuesById[124] = "PT_InvalidSelection"] = 124;
        values["CEType_PT_InvalidSelection"] = 124;
        values[valuesById[125] = "PT_ReadOnlySession"] = 125;
        values["CEType_PT_ReadOnlySession"] = 125;
        values[valuesById[126] = "PT_InvalidParameter"] = 126;
        values["CEType_PT_InvalidParameter"] = 126;
        values[valuesById[127] = "PT_Forbidden"] = 127;
        values["CEType_PT_Forbidden"] = 127;
        values[valuesById[128] = "PT_NoTimelineFound"] = 128;
        values["CEType_PT_NoTimelineFound"] = 128;
        values[valuesById[129] = "PT_ArgumentOutOfRange"] = 129;
        values["CEType_PT_ArgumentOutOfRange"] = 129;
        values[valuesById[130] = "PT_ForbiddenTrackType"] = 130;
        values["CEType_PT_ForbiddenTrackType"] = 130;
        values[valuesById[131] = "PT_NoVideoEngineFound"] = 131;
        values["CEType_PT_NoVideoEngineFound"] = 131;
        values[valuesById[132] = "PT_NoDspHardwareFound"] = 132;
        values["CEType_PT_NoDspHardwareFound"] = 132;
        values[valuesById[133] = "PT_UnsupportedCommand"] = 133;
        values["CEType_PT_UnsupportedCommand"] = 133;
        values[valuesById[134] = "PT_HostNotReady"] = 134;
        values["CEType_PT_HostNotReady"] = 134;
        values[valuesById[135] = "PT_CannotBeDone"] = 135;
        values["CEType_PT_CannotBeDone"] = 135;
        values[valuesById[136] = "PT_ResponseLengthExceeded"] = 136;
        values["CEType_PT_ResponseLengthExceeded"] = 136;
        values[valuesById[137] = "PT_CommandTimeout"] = 137;
        values["CEType_PT_CommandTimeout"] = 137;
        values[valuesById[138] = "PT_HostIsBusy"] = 138;
        values["CEType_PT_HostIsBusy"] = 138;
        values[valuesById[139] = "CEType_PT_DeprecatedParameter"] = 139;
        values[valuesById[140] = "CEType_PT_DeprecatedParameterValue"] = 140;
        values[valuesById[200] = "PT_Info"] = 200;
        values["CEType_PT_Info"] = 200;
        values[valuesById[401] = "SDK_VersionMismatch"] = 401;
        values["CEType_SDK_VersionMismatch"] = 401;
        values[valuesById[402] = "SDK_NotImplemented"] = 402;
        values["CEType_SDK_NotImplemented"] = 402;
        values[valuesById[403] = "SDK_SessionIdParseError"] = 403;
        values["CEType_SDK_SessionIdParseError"] = 403;
        values[valuesById[501] = "SDK_GrpcGeneric"] = 501;
        values["CEType_SDK_GrpcGeneric"] = 501;
        return values;
    })();

    /**
     * Type of Pro Tools track.
     * @name ptsl.TrackType
     * @enum {number}
     * @property {number} Unknown=0 Unknown value
     * @property {number} TT_Unknown=0 TT_Unknown value
     * @property {number} TType_Unknown=0 TType_Unknown value
     * @property {number} Midi=1 Midi value
     * @property {number} TT_Midi=1 TT_Midi value
     * @property {number} TType_Midi=1 TType_Midi value
     * @property {number} AudioTrack=2 AudioTrack value
     * @property {number} TT_Audio=2 TT_Audio value
     * @property {number} TType_Audio=2 TType_Audio value
     * @property {number} Aux=3 Aux value
     * @property {number} TT_Aux=3 TT_Aux value
     * @property {number} TType_Aux=3 TType_Aux value
     * @property {number} VideoTrack=4 VideoTrack value
     * @property {number} TT_Video=4 TT_Video value
     * @property {number} TType_Video=4 TType_Video value
     * @property {number} Vca=5 Vca value
     * @property {number} TT_Vca=5 TT_Vca value
     * @property {number} TType_Vca=5 TType_Vca value
     * @property {number} Tempo=6 Tempo value
     * @property {number} TT_Tempo=6 TT_Tempo value
     * @property {number} TType_Tempo=6 TType_Tempo value
     * @property {number} Markers=7 Markers value
     * @property {number} TT_Markers=7 TT_Markers value
     * @property {number} TType_Markers=7 TType_Markers value
     * @property {number} Meter=8 Meter value
     * @property {number} TT_Meter=8 TT_Meter value
     * @property {number} TType_Meter=8 TType_Meter value
     * @property {number} KeySignature=9 KeySignature value
     * @property {number} TT_KeySignature=9 TT_KeySignature value
     * @property {number} TType_KeySignature=9 TType_KeySignature value
     * @property {number} ChordSymbols=10 ChordSymbols value
     * @property {number} TT_ChordSymbols=10 TT_ChordSymbols value
     * @property {number} TType_ChordSymbols=10 TType_ChordSymbols value
     * @property {number} Instrument=11 Instrument value
     * @property {number} TT_Instrument=11 TT_Instrument value
     * @property {number} TType_Instrument=11 TType_Instrument value
     * @property {number} Master=12 Master value
     * @property {number} TT_Master=12 TT_Master value
     * @property {number} TType_Master=12 TType_Master value
     * @property {number} Heat=13 Heat value
     * @property {number} TT_Heat=13 TT_Heat value
     * @property {number} TType_Heat=13 TType_Heat value
     * @property {number} BasicFolder=14 BasicFolder value
     * @property {number} TT_BasicFolder=14 TT_BasicFolder value
     * @property {number} TType_BasicFolder=14 TType_BasicFolder value
     * @property {number} RoutingFolder=15 RoutingFolder value
     * @property {number} TT_RoutingFolder=15 TT_RoutingFolder value
     * @property {number} TType_RoutingFolder=15 TType_RoutingFolder value
     * @property {number} CompLane=16 CompLane value
     * @property {number} TT_CompLane=16 TT_CompLane value
     * @property {number} TType_CompLane=16 TType_CompLane value
     */
    ptsl.TrackType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Unknown"] = 0;
        values["TT_Unknown"] = 0;
        values["TType_Unknown"] = 0;
        values[valuesById[1] = "Midi"] = 1;
        values["TT_Midi"] = 1;
        values["TType_Midi"] = 1;
        values[valuesById[2] = "AudioTrack"] = 2;
        values["TT_Audio"] = 2;
        values["TType_Audio"] = 2;
        values[valuesById[3] = "Aux"] = 3;
        values["TT_Aux"] = 3;
        values["TType_Aux"] = 3;
        values[valuesById[4] = "VideoTrack"] = 4;
        values["TT_Video"] = 4;
        values["TType_Video"] = 4;
        values[valuesById[5] = "Vca"] = 5;
        values["TT_Vca"] = 5;
        values["TType_Vca"] = 5;
        values[valuesById[6] = "Tempo"] = 6;
        values["TT_Tempo"] = 6;
        values["TType_Tempo"] = 6;
        values[valuesById[7] = "Markers"] = 7;
        values["TT_Markers"] = 7;
        values["TType_Markers"] = 7;
        values[valuesById[8] = "Meter"] = 8;
        values["TT_Meter"] = 8;
        values["TType_Meter"] = 8;
        values[valuesById[9] = "KeySignature"] = 9;
        values["TT_KeySignature"] = 9;
        values["TType_KeySignature"] = 9;
        values[valuesById[10] = "ChordSymbols"] = 10;
        values["TT_ChordSymbols"] = 10;
        values["TType_ChordSymbols"] = 10;
        values[valuesById[11] = "Instrument"] = 11;
        values["TT_Instrument"] = 11;
        values["TType_Instrument"] = 11;
        values[valuesById[12] = "Master"] = 12;
        values["TT_Master"] = 12;
        values["TType_Master"] = 12;
        values[valuesById[13] = "Heat"] = 13;
        values["TT_Heat"] = 13;
        values["TType_Heat"] = 13;
        values[valuesById[14] = "BasicFolder"] = 14;
        values["TT_BasicFolder"] = 14;
        values["TType_BasicFolder"] = 14;
        values[valuesById[15] = "RoutingFolder"] = 15;
        values["TT_RoutingFolder"] = 15;
        values["TType_RoutingFolder"] = 15;
        values[valuesById[16] = "CompLane"] = 16;
        values["TT_CompLane"] = 16;
        values["TType_CompLane"] = 16;
        return values;
    })();

    /**
     * Format of Pro Tools track.
     * @name ptsl.TrackFormat
     * @enum {number}
     * @property {number} TF_Unknown=0 * @deprecated TF_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_Unknown
     * @property {number} TFormat_Unknown=0 TFormat_Unknown value
     * @property {number} TF_Mono=1 * @deprecated TF_Mono is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_Mono
     * @property {number} TFormat_Mono=1 TFormat_Mono value
     * @property {number} TF_Stereo=2 * @deprecated TF_Stereo is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_Stereo
     * @property {number} TFormat_Stereo=2 TFormat_Stereo value
     * @property {number} TF_LCR=3 * @deprecated TF_LCR is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_LCR
     * @property {number} TFormat_LCR=3 TFormat_LCR value
     * @property {number} TF_LCRS=4 * @deprecated TF_LCRS is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_LCRS
     * @property {number} TFormat_LCRS=4 TFormat_LCRS value
     * @property {number} TF_Quad=5 * @deprecated TF_Quad is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_Quad
     * @property {number} TFormat_Quad=5 TFormat_Quad value
     * @property {number} TF_5_0=6 * @deprecated TF_5_0 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_5_0
     * @property {number} TFormat_5_0=6 TFormat_5_0 value
     * @property {number} TF_5_1=7 * @deprecated TF_5_1 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_5_1
     * @property {number} TFormat_5_1=7 TFormat_5_1 value
     * @property {number} TF_5_0_2=8 * @deprecated TF_5_0_2 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_5_0_2
     * @property {number} TFormat_5_0_2=8 TFormat_5_0_2 value
     * @property {number} TF_5_1_2=9 * @deprecated TF_5_1_2 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_5_1_2
     * @property {number} TFormat_5_1_2=9 TFormat_5_1_2 value
     * @property {number} TF_5_0_4=10 * @deprecated TF_5_0_4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_5_0_4
     * @property {number} TFormat_5_0_4=10 TFormat_5_0_4 value
     * @property {number} TF_5_1_4=11 * @deprecated TF_5_1_4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_5_1_4
     * @property {number} TFormat_5_1_4=11 TFormat_5_1_4 value
     * @property {number} TF_6_0=12 * @deprecated TF_6_0 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_6_0
     * @property {number} TFormat_6_0=12 TFormat_6_0 value
     * @property {number} TF_6_1=13 * @deprecated TF_6_1 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_6_1
     * @property {number} TFormat_6_1=13 TFormat_6_1 value
     * @property {number} TF_7_0=14 * @deprecated TF_7_0 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_0
     * @property {number} TFormat_7_0=14 TFormat_7_0 value
     * @property {number} TF_7_1=15 * @deprecated TF_7_1 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_1
     * @property {number} TFormat_7_1=15 TFormat_7_1 value
     * @property {number} TF_7_0_SDDS=16 * @deprecated TF_7_0_SDDS is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_0_SDDS
     * @property {number} TFormat_7_0_SDDS=16 TFormat_7_0_SDDS value
     * @property {number} TF_7_1_SDDS=17 * @deprecated TF_7_1_SDDS is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_1_SDDS
     * @property {number} TFormat_7_1_SDDS=17 TFormat_7_1_SDDS value
     * @property {number} TF_7_0_2=18 * @deprecated TF_7_0_2 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_0_2
     * @property {number} TFormat_7_0_2=18 TFormat_7_0_2 value
     * @property {number} TF_7_1_2=19 * @deprecated TF_7_1_2 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_1_2
     * @property {number} TFormat_7_1_2=19 TFormat_7_1_2 value
     * @property {number} TF_7_0_4=20 * @deprecated TF_7_0_4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_0_4
     * @property {number} TFormat_7_0_4=20 TFormat_7_0_4 value
     * @property {number} TF_7_1_4=21 * @deprecated TF_7_1_4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_1_4
     * @property {number} TFormat_7_1_4=21 TFormat_7_1_4 value
     * @property {number} TF_7_0_6=22 * @deprecated TF_7_0_6 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_0_6
     * @property {number} TFormat_7_0_6=22 TFormat_7_0_6 value
     * @property {number} TF_7_1_6=23 * @deprecated TF_7_1_6 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7_1_6
     * @property {number} TFormat_7_1_6=23 TFormat_7_1_6 value
     * @property {number} TF_9_0_4=24 * @deprecated TF_9_0_4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_9_0_4
     * @property {number} TFormat_9_0_4=24 TFormat_9_0_4 value
     * @property {number} TF_9_1_4=25 * @deprecated TF_9_1_4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_9_1_4
     * @property {number} TFormat_9_1_4=25 TFormat_9_1_4 value
     * @property {number} TF_9_0_6=26 * @deprecated TF_9_0_6 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_9_0_6
     * @property {number} TFormat_9_0_6=26 TFormat_9_0_6 value
     * @property {number} TF_9_1_6=27 * @deprecated TF_9_1_6 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_9_1_6
     * @property {number} TFormat_9_1_6=27 TFormat_9_1_6 value
     * @property {number} TF_1stOrderAmbisonics=28 * @deprecated TF_1stOrderAmbisonics is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_1stOrderAmbisonics
     * @property {number} TFormat_1stOrderAmbisonics=28 TFormat_1stOrderAmbisonics value
     * @property {number} TF_2ndOrderAmbisonics=29 * @deprecated TF_2ndOrderAmbisonics is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_2ndOrderAmbisonics
     * @property {number} TFormat_2ndOrderAmbisonics=29 TFormat_2ndOrderAmbisonics value
     * @property {number} TF_3rdOrderAmbisonics=30 * @deprecated TF_3rdOrderAmbisonics is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_3rdOrderAmbisonics
     * @property {number} TFormat_3rdOrderAmbisonics=30 TFormat_3rdOrderAmbisonics value
     * @property {number} TF_4thOrderAmbisonics=31 * @deprecated TF_4thOrderAmbisonics is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_4thOrderAmbisonics
     * @property {number} TFormat_4thOrderAmbisonics=31 TFormat_4thOrderAmbisonics value
     * @property {number} TF_5thOrderAmbisonics=32 * @deprecated TF_5thOrderAmbisonics is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_5thOrderAmbisonics
     * @property {number} TFormat_5thOrderAmbisonics=32 TFormat_5thOrderAmbisonics value
     * @property {number} TF_6thOrderAmbisonics=33 * @deprecated TF_6thOrderAmbisonics is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_6thOrderAmbisonics
     * @property {number} TFormat_6thOrderAmbisonics=33 TFormat_6thOrderAmbisonics value
     * @property {number} TF_7thOrderAmbisonics=34 * @deprecated TF_7thOrderAmbisonics is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_7thOrderAmbisonics
     * @property {number} TFormat_7thOrderAmbisonics=34 TFormat_7thOrderAmbisonics value
     * @property {number} TF_None=35 * @deprecated TF_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_None
     * @property {number} TFormat_None=35 TFormat_None value
     * @property {number} TF_2_1=36 * @deprecated TF_2_1 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_2_1
     * @property {number} TFormat_2_1=36 TFormat_2_1 value
     * @property {number} TF_Overhead=37 * @deprecated TF_Overhead is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TFormat_Overhead
     * @property {number} TFormat_Overhead=37 TFormat_Overhead value
     */
    ptsl.TrackFormat = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TF_Unknown"] = 0;
        values["TFormat_Unknown"] = 0;
        values[valuesById[1] = "TF_Mono"] = 1;
        values["TFormat_Mono"] = 1;
        values[valuesById[2] = "TF_Stereo"] = 2;
        values["TFormat_Stereo"] = 2;
        values[valuesById[3] = "TF_LCR"] = 3;
        values["TFormat_LCR"] = 3;
        values[valuesById[4] = "TF_LCRS"] = 4;
        values["TFormat_LCRS"] = 4;
        values[valuesById[5] = "TF_Quad"] = 5;
        values["TFormat_Quad"] = 5;
        values[valuesById[6] = "TF_5_0"] = 6;
        values["TFormat_5_0"] = 6;
        values[valuesById[7] = "TF_5_1"] = 7;
        values["TFormat_5_1"] = 7;
        values[valuesById[8] = "TF_5_0_2"] = 8;
        values["TFormat_5_0_2"] = 8;
        values[valuesById[9] = "TF_5_1_2"] = 9;
        values["TFormat_5_1_2"] = 9;
        values[valuesById[10] = "TF_5_0_4"] = 10;
        values["TFormat_5_0_4"] = 10;
        values[valuesById[11] = "TF_5_1_4"] = 11;
        values["TFormat_5_1_4"] = 11;
        values[valuesById[12] = "TF_6_0"] = 12;
        values["TFormat_6_0"] = 12;
        values[valuesById[13] = "TF_6_1"] = 13;
        values["TFormat_6_1"] = 13;
        values[valuesById[14] = "TF_7_0"] = 14;
        values["TFormat_7_0"] = 14;
        values[valuesById[15] = "TF_7_1"] = 15;
        values["TFormat_7_1"] = 15;
        values[valuesById[16] = "TF_7_0_SDDS"] = 16;
        values["TFormat_7_0_SDDS"] = 16;
        values[valuesById[17] = "TF_7_1_SDDS"] = 17;
        values["TFormat_7_1_SDDS"] = 17;
        values[valuesById[18] = "TF_7_0_2"] = 18;
        values["TFormat_7_0_2"] = 18;
        values[valuesById[19] = "TF_7_1_2"] = 19;
        values["TFormat_7_1_2"] = 19;
        values[valuesById[20] = "TF_7_0_4"] = 20;
        values["TFormat_7_0_4"] = 20;
        values[valuesById[21] = "TF_7_1_4"] = 21;
        values["TFormat_7_1_4"] = 21;
        values[valuesById[22] = "TF_7_0_6"] = 22;
        values["TFormat_7_0_6"] = 22;
        values[valuesById[23] = "TF_7_1_6"] = 23;
        values["TFormat_7_1_6"] = 23;
        values[valuesById[24] = "TF_9_0_4"] = 24;
        values["TFormat_9_0_4"] = 24;
        values[valuesById[25] = "TF_9_1_4"] = 25;
        values["TFormat_9_1_4"] = 25;
        values[valuesById[26] = "TF_9_0_6"] = 26;
        values["TFormat_9_0_6"] = 26;
        values[valuesById[27] = "TF_9_1_6"] = 27;
        values["TFormat_9_1_6"] = 27;
        values[valuesById[28] = "TF_1stOrderAmbisonics"] = 28;
        values["TFormat_1stOrderAmbisonics"] = 28;
        values[valuesById[29] = "TF_2ndOrderAmbisonics"] = 29;
        values["TFormat_2ndOrderAmbisonics"] = 29;
        values[valuesById[30] = "TF_3rdOrderAmbisonics"] = 30;
        values["TFormat_3rdOrderAmbisonics"] = 30;
        values[valuesById[31] = "TF_4thOrderAmbisonics"] = 31;
        values["TFormat_4thOrderAmbisonics"] = 31;
        values[valuesById[32] = "TF_5thOrderAmbisonics"] = 32;
        values["TFormat_5thOrderAmbisonics"] = 32;
        values[valuesById[33] = "TF_6thOrderAmbisonics"] = 33;
        values["TFormat_6thOrderAmbisonics"] = 33;
        values[valuesById[34] = "TF_7thOrderAmbisonics"] = 34;
        values["TFormat_7thOrderAmbisonics"] = 34;
        values[valuesById[35] = "TF_None"] = 35;
        values["TFormat_None"] = 35;
        values[valuesById[36] = "TF_2_1"] = 36;
        values["TFormat_2_1"] = 36;
        values[valuesById[37] = "TF_Overhead"] = 37;
        values["TFormat_Overhead"] = 37;
        return values;
    })();

    /**
     * Timebase of Pro Tools track.
     * @name ptsl.TrackTimebase
     * @enum {number}
     * @property {number} TTB_Unknown=0 * @deprecated TTB_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TTimebase_Unknown
     * @property {number} TTimebase_Unknown=0 TTimebase_Unknown value
     * @property {number} TTB_Samples=1 * @deprecated TTB_Samples is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TTimebase_Samples
     * @property {number} TTimebase_Samples=1 TTimebase_Samples value
     * @property {number} TTB_Ticks=2 * @deprecated TTB_Ticks is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TTimebase_Ticks
     * @property {number} TTimebase_Ticks=2 TTimebase_Ticks value
     * @property {number} TTB_None=3 * @deprecated TTB_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref TTimebase_None
     * @property {number} TTimebase_None=3 TTimebase_None value
     */
    ptsl.TrackTimebase = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TTB_Unknown"] = 0;
        values["TTimebase_Unknown"] = 0;
        values[valuesById[1] = "TTB_Samples"] = 1;
        values["TTimebase_Samples"] = 1;
        values[valuesById[2] = "TTB_Ticks"] = 2;
        values["TTimebase_Ticks"] = 2;
        values[valuesById[3] = "TTB_None"] = 3;
        values["TTimebase_None"] = 3;
        return values;
    })();

    ptsl.EmptyMessage = (function() {

        /**
         * Properties of an EmptyMessage.
         * @memberof ptsl
         * @interface IEmptyMessage
         */

        /**
         * Constructs a new EmptyMessage.
         * @memberof ptsl
         * @classdesc Stub empty message for initializing default request.
         * @implements IEmptyMessage
         * @constructor
         * @param {ptsl.IEmptyMessage=} [properties] Properties to set
         */
        function EmptyMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new EmptyMessage instance using the specified properties.
         * @function create
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {ptsl.IEmptyMessage=} [properties] Properties to set
         * @returns {ptsl.EmptyMessage} EmptyMessage instance
         */
        EmptyMessage.create = function create(properties) {
            return new EmptyMessage(properties);
        };

        /**
         * Encodes the specified EmptyMessage message. Does not implicitly {@link ptsl.EmptyMessage.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {ptsl.IEmptyMessage} message EmptyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmptyMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified EmptyMessage message, length delimited. Does not implicitly {@link ptsl.EmptyMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {ptsl.IEmptyMessage} message EmptyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmptyMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmptyMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EmptyMessage} EmptyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmptyMessage.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EmptyMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmptyMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EmptyMessage} EmptyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmptyMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmptyMessage message.
         * @function verify
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmptyMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an EmptyMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EmptyMessage} EmptyMessage
         */
        EmptyMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EmptyMessage)
                return object;
            return new $root.ptsl.EmptyMessage();
        };

        /**
         * Creates a plain object from an EmptyMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {ptsl.EmptyMessage} message EmptyMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmptyMessage.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this EmptyMessage to JSON.
         * @function toJSON
         * @memberof ptsl.EmptyMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmptyMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EmptyMessage
         * @function getTypeUrl
         * @memberof ptsl.EmptyMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EmptyMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EmptyMessage";
        };

        return EmptyMessage;
    })();

    ptsl.CommandError = (function() {

        /**
         * Properties of a CommandError.
         * @memberof ptsl
         * @interface ICommandError
         * @property {ptsl.CommandErrorType|null} [commandErrorType] CommandError commandErrorType
         * @property {string|null} [commandErrorMessage] CommandError commandErrorMessage
         * @property {boolean|null} [isWarning] CommandError isWarning
         */

        /**
         * Constructs a new CommandError.
         * @memberof ptsl
         * @classdesc Structure that describes common data of the error message.
         * @implements ICommandError
         * @constructor
         * @param {ptsl.ICommandError=} [properties] Properties to set
         */
        function CommandError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommandError commandErrorType.
         * @member {ptsl.CommandErrorType} commandErrorType
         * @memberof ptsl.CommandError
         * @instance
         */
        CommandError.prototype.commandErrorType = 0;

        /**
         * CommandError commandErrorMessage.
         * @member {string} commandErrorMessage
         * @memberof ptsl.CommandError
         * @instance
         */
        CommandError.prototype.commandErrorMessage = "";

        /**
         * CommandError isWarning.
         * @member {boolean} isWarning
         * @memberof ptsl.CommandError
         * @instance
         */
        CommandError.prototype.isWarning = false;

        /**
         * Creates a new CommandError instance using the specified properties.
         * @function create
         * @memberof ptsl.CommandError
         * @static
         * @param {ptsl.ICommandError=} [properties] Properties to set
         * @returns {ptsl.CommandError} CommandError instance
         */
        CommandError.create = function create(properties) {
            return new CommandError(properties);
        };

        /**
         * Encodes the specified CommandError message. Does not implicitly {@link ptsl.CommandError.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CommandError
         * @static
         * @param {ptsl.ICommandError} message CommandError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.commandErrorType != null && Object.hasOwnProperty.call(message, "commandErrorType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.commandErrorType);
            if (message.commandErrorMessage != null && Object.hasOwnProperty.call(message, "commandErrorMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.commandErrorMessage);
            if (message.isWarning != null && Object.hasOwnProperty.call(message, "isWarning"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWarning);
            return writer;
        };

        /**
         * Encodes the specified CommandError message, length delimited. Does not implicitly {@link ptsl.CommandError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CommandError
         * @static
         * @param {ptsl.ICommandError} message CommandError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommandError message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CommandError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CommandError} CommandError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandError.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CommandError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.commandErrorType = reader.int32();
                        break;
                    }
                case 2: {
                        message.commandErrorMessage = reader.string();
                        break;
                    }
                case 3: {
                        message.isWarning = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommandError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CommandError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CommandError} CommandError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommandError message.
         * @function verify
         * @memberof ptsl.CommandError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommandError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.commandErrorType != null && message.hasOwnProperty("commandErrorType"))
                switch (message.commandErrorType) {
                default:
                    return "commandErrorType: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 100:
                case 100:
                case 101:
                case 101:
                case 102:
                case 102:
                case 103:
                case 103:
                case 104:
                case 104:
                case 105:
                case 105:
                case 106:
                case 106:
                case 107:
                case 107:
                case 108:
                case 108:
                case 109:
                case 109:
                case 110:
                case 110:
                case 111:
                case 111:
                case 112:
                case 112:
                case 113:
                case 113:
                case 114:
                case 114:
                case 115:
                case 115:
                case 116:
                case 116:
                case 117:
                case 117:
                case 118:
                case 118:
                case 119:
                case 119:
                case 120:
                case 120:
                case 121:
                case 121:
                case 122:
                case 122:
                case 123:
                case 123:
                case 124:
                case 124:
                case 125:
                case 125:
                case 126:
                case 126:
                case 127:
                case 127:
                case 128:
                case 128:
                case 129:
                case 129:
                case 130:
                case 130:
                case 131:
                case 131:
                case 132:
                case 132:
                case 133:
                case 133:
                case 134:
                case 134:
                case 135:
                case 135:
                case 136:
                case 136:
                case 137:
                case 137:
                case 138:
                case 138:
                case 139:
                case 140:
                case 200:
                case 200:
                case 401:
                case 401:
                case 402:
                case 402:
                case 403:
                case 403:
                case 501:
                case 501:
                    break;
                }
            if (message.commandErrorMessage != null && message.hasOwnProperty("commandErrorMessage"))
                if (!$util.isString(message.commandErrorMessage))
                    return "commandErrorMessage: string expected";
            if (message.isWarning != null && message.hasOwnProperty("isWarning"))
                if (typeof message.isWarning !== "boolean")
                    return "isWarning: boolean expected";
            return null;
        };

        /**
         * Creates a CommandError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CommandError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CommandError} CommandError
         */
        CommandError.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CommandError)
                return object;
            var message = new $root.ptsl.CommandError();
            switch (object.commandErrorType) {
            default:
                if (typeof object.commandErrorType === "number") {
                    message.commandErrorType = object.commandErrorType;
                    break;
                }
                break;
            case "OS_WritePermissions":
            case 0:
                message.commandErrorType = 0;
                break;
            case "CEType_OS_WritePermissions":
            case 0:
                message.commandErrorType = 0;
                break;
            case "OS_ErrorCode":
            case 1:
                message.commandErrorType = 1;
                break;
            case "CEType_OS_ErrorCode":
            case 1:
                message.commandErrorType = 1;
                break;
            case "OS_NoLocationFound":
            case 2:
                message.commandErrorType = 2;
                break;
            case "CEType_OS_NoLocationFound":
            case 2:
                message.commandErrorType = 2;
                break;
            case "OS_NoSessionFound":
            case 3:
                message.commandErrorType = 3;
                break;
            case "CEType_OS_NoSessionFound":
            case 3:
                message.commandErrorType = 3;
                break;
            case "OS_FilePathLocation":
            case 4:
                message.commandErrorType = 4;
                break;
            case "OS_ReadError":
            case 5:
                message.commandErrorType = 5;
                break;
            case "CEType_OS_ReadError":
            case 5:
                message.commandErrorType = 5;
                break;
            case "OS_DiskSpace":
            case 6:
                message.commandErrorType = 6;
                break;
            case "CEType_OS_DiskSpace":
            case 6:
                message.commandErrorType = 6;
                break;
            case "OS_DuplicateName":
            case 7:
                message.commandErrorType = 7;
                break;
            case "CEType_OS_DuplicateName":
            case 7:
                message.commandErrorType = 7;
                break;
            case "OS_IllegalCharacters":
            case 8:
                message.commandErrorType = 8;
                break;
            case "CEType_OS_IllegalCharacters":
            case 8:
                message.commandErrorType = 8;
                break;
            case "OS_CharactersLimit":
            case 9:
                message.commandErrorType = 9;
                break;
            case "CEType_OS_CharactersLimit":
            case 9:
                message.commandErrorType = 9;
                break;
            case "OS_ProToolsIsNotAvailable":
            case 10:
                message.commandErrorType = 10;
                break;
            case "CEType_OS_ProToolsIsNotAvailable":
            case 10:
                message.commandErrorType = 10;
                break;
            case "OS_NoFilePathFound":
            case 11:
                message.commandErrorType = 11;
                break;
            case "CEType_OS_NoFilePathFound":
            case 11:
                message.commandErrorType = 11;
                break;
            case "PT_UnknownError":
            case 100:
                message.commandErrorType = 100;
                break;
            case "CEType_PT_UnknownError":
            case 100:
                message.commandErrorType = 100;
                break;
            case "PT_NoTemplateGroup":
            case 101:
                message.commandErrorType = 101;
                break;
            case "CEType_PT_NoTemplateGroup":
            case 101:
                message.commandErrorType = 101;
                break;
            case "PT_NoTemplate":
            case 102:
                message.commandErrorType = 102;
                break;
            case "CEType_PT_NoTemplate":
            case 102:
                message.commandErrorType = 102;
                break;
            case "PT_SampleRateMismatch":
            case 103:
                message.commandErrorType = 103;
                break;
            case "CEType_PT_SampleRateMismatch":
            case 103:
                message.commandErrorType = 103;
                break;
            case "PT_NoVideoTrackFound":
            case 104:
                message.commandErrorType = 104;
                break;
            case "CEType_PT_NoVideoTrackFound":
            case 104:
                message.commandErrorType = 104;
                break;
            case "PT_NoTracksFound":
            case 105:
                message.commandErrorType = 105;
                break;
            case "CEType_PT_NoTracksFound":
            case 105:
                message.commandErrorType = 105;
                break;
            case "PT_NoOpenedSession":
            case 106:
                message.commandErrorType = 106;
                break;
            case "CEType_PT_NoOpenedSession":
            case 106:
                message.commandErrorType = 106;
                break;
            case "PT_NoTrackFound":
            case 107:
                message.commandErrorType = 107;
                break;
            case "CEType_PT_NoTrackFound":
            case 107:
                message.commandErrorType = 107;
                break;
            case "PT_NoClipsFound":
            case 108:
                message.commandErrorType = 108;
                break;
            case "CEType_PT_NoClipsFound":
            case 108:
                message.commandErrorType = 108;
                break;
            case "PT_NoSelection":
            case 109:
                message.commandErrorType = 109;
                break;
            case "CEType_PT_NoSelection":
            case 109:
                message.commandErrorType = 109;
                break;
            case "PT_RecordDrive":
            case 110:
                message.commandErrorType = 110;
                break;
            case "CEType_PT_RecordDrive":
            case 110:
                message.commandErrorType = 110;
                break;
            case "PT_NoPresetFound":
            case 111:
                message.commandErrorType = 111;
                break;
            case "CEType_PT_NoPresetFound":
            case 111:
                message.commandErrorType = 111;
                break;
            case "PT_FileTypeMXF":
            case 112:
                message.commandErrorType = 112;
                break;
            case "CEType_PT_FileTypeMXF":
            case 112:
                message.commandErrorType = 112;
                break;
            case "PT_CopyOptionCopy":
            case 113:
                message.commandErrorType = 113;
                break;
            case "CEType_PT_CopyOptionCopy":
            case 113:
                message.commandErrorType = 113;
                break;
            case "PT_CopyOptionLink":
            case 114:
                message.commandErrorType = 114;
                break;
            case "CEType_PT_CopyOptionLink":
            case 114:
                message.commandErrorType = 114;
                break;
            case "PT_QuantizeEdits":
            case 115:
                message.commandErrorType = 115;
                break;
            case "CEType_PT_QuantizeEdits":
            case 115:
                message.commandErrorType = 115;
                break;
            case "PT_ExportAsMultichannel":
            case 116:
                message.commandErrorType = 116;
                break;
            case "CEType_PT_ExportAsMultichannel":
            case 116:
                message.commandErrorType = 116;
                break;
            case "PT_IllegalCharactersComments":
            case 117:
                message.commandErrorType = 117;
                break;
            case "CEType_PT_IllegalCharactersComments":
            case 117:
                message.commandErrorType = 117;
                break;
            case "PT_IllegalCharactersSequenceName":
            case 118:
                message.commandErrorType = 118;
                break;
            case "CEType_PT_IllegalCharactersSequenceName":
            case 118:
                message.commandErrorType = 118;
                break;
            case "PT_MaxCharactersComments":
            case 119:
                message.commandErrorType = 119;
                break;
            case "CEType_PT_MaxCharactersComments":
            case 119:
                message.commandErrorType = 119;
                break;
            case "PT_MaxCharactersSequenceName":
            case 120:
                message.commandErrorType = 120;
                break;
            case "CEType_PT_MaxCharactersSequenceName":
            case 120:
                message.commandErrorType = 120;
                break;
            case "PT_NoSequenceName":
            case 121:
                message.commandErrorType = 121;
                break;
            case "CEType_PT_NoSequenceName":
            case 121:
                message.commandErrorType = 121;
                break;
            case "PT_InvalidTask":
            case 122:
                message.commandErrorType = 122;
                break;
            case "CEType_PT_InvalidTask":
            case 122:
                message.commandErrorType = 122;
                break;
            case "PT_FileNotFound":
            case 123:
                message.commandErrorType = 123;
                break;
            case "CEType_PT_FileNotFound":
            case 123:
                message.commandErrorType = 123;
                break;
            case "PT_InvalidSelection":
            case 124:
                message.commandErrorType = 124;
                break;
            case "CEType_PT_InvalidSelection":
            case 124:
                message.commandErrorType = 124;
                break;
            case "PT_ReadOnlySession":
            case 125:
                message.commandErrorType = 125;
                break;
            case "CEType_PT_ReadOnlySession":
            case 125:
                message.commandErrorType = 125;
                break;
            case "PT_InvalidParameter":
            case 126:
                message.commandErrorType = 126;
                break;
            case "CEType_PT_InvalidParameter":
            case 126:
                message.commandErrorType = 126;
                break;
            case "PT_Forbidden":
            case 127:
                message.commandErrorType = 127;
                break;
            case "CEType_PT_Forbidden":
            case 127:
                message.commandErrorType = 127;
                break;
            case "PT_NoTimelineFound":
            case 128:
                message.commandErrorType = 128;
                break;
            case "CEType_PT_NoTimelineFound":
            case 128:
                message.commandErrorType = 128;
                break;
            case "PT_ArgumentOutOfRange":
            case 129:
                message.commandErrorType = 129;
                break;
            case "CEType_PT_ArgumentOutOfRange":
            case 129:
                message.commandErrorType = 129;
                break;
            case "PT_ForbiddenTrackType":
            case 130:
                message.commandErrorType = 130;
                break;
            case "CEType_PT_ForbiddenTrackType":
            case 130:
                message.commandErrorType = 130;
                break;
            case "PT_NoVideoEngineFound":
            case 131:
                message.commandErrorType = 131;
                break;
            case "CEType_PT_NoVideoEngineFound":
            case 131:
                message.commandErrorType = 131;
                break;
            case "PT_NoDspHardwareFound":
            case 132:
                message.commandErrorType = 132;
                break;
            case "CEType_PT_NoDspHardwareFound":
            case 132:
                message.commandErrorType = 132;
                break;
            case "PT_UnsupportedCommand":
            case 133:
                message.commandErrorType = 133;
                break;
            case "CEType_PT_UnsupportedCommand":
            case 133:
                message.commandErrorType = 133;
                break;
            case "PT_HostNotReady":
            case 134:
                message.commandErrorType = 134;
                break;
            case "CEType_PT_HostNotReady":
            case 134:
                message.commandErrorType = 134;
                break;
            case "PT_CannotBeDone":
            case 135:
                message.commandErrorType = 135;
                break;
            case "CEType_PT_CannotBeDone":
            case 135:
                message.commandErrorType = 135;
                break;
            case "PT_ResponseLengthExceeded":
            case 136:
                message.commandErrorType = 136;
                break;
            case "CEType_PT_ResponseLengthExceeded":
            case 136:
                message.commandErrorType = 136;
                break;
            case "PT_CommandTimeout":
            case 137:
                message.commandErrorType = 137;
                break;
            case "CEType_PT_CommandTimeout":
            case 137:
                message.commandErrorType = 137;
                break;
            case "PT_HostIsBusy":
            case 138:
                message.commandErrorType = 138;
                break;
            case "CEType_PT_HostIsBusy":
            case 138:
                message.commandErrorType = 138;
                break;
            case "CEType_PT_DeprecatedParameter":
            case 139:
                message.commandErrorType = 139;
                break;
            case "CEType_PT_DeprecatedParameterValue":
            case 140:
                message.commandErrorType = 140;
                break;
            case "PT_Info":
            case 200:
                message.commandErrorType = 200;
                break;
            case "CEType_PT_Info":
            case 200:
                message.commandErrorType = 200;
                break;
            case "SDK_VersionMismatch":
            case 401:
                message.commandErrorType = 401;
                break;
            case "CEType_SDK_VersionMismatch":
            case 401:
                message.commandErrorType = 401;
                break;
            case "SDK_NotImplemented":
            case 402:
                message.commandErrorType = 402;
                break;
            case "CEType_SDK_NotImplemented":
            case 402:
                message.commandErrorType = 402;
                break;
            case "SDK_SessionIdParseError":
            case 403:
                message.commandErrorType = 403;
                break;
            case "CEType_SDK_SessionIdParseError":
            case 403:
                message.commandErrorType = 403;
                break;
            case "SDK_GrpcGeneric":
            case 501:
                message.commandErrorType = 501;
                break;
            case "CEType_SDK_GrpcGeneric":
            case 501:
                message.commandErrorType = 501;
                break;
            }
            if (object.commandErrorMessage != null)
                message.commandErrorMessage = String(object.commandErrorMessage);
            if (object.isWarning != null)
                message.isWarning = Boolean(object.isWarning);
            return message;
        };

        /**
         * Creates a plain object from a CommandError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CommandError
         * @static
         * @param {ptsl.CommandError} message CommandError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommandError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.commandErrorType = options.enums === String ? "OS_WritePermissions" : 0;
                object.commandErrorMessage = "";
                object.isWarning = false;
            }
            if (message.commandErrorType != null && message.hasOwnProperty("commandErrorType"))
                object.commandErrorType = options.enums === String ? $root.ptsl.CommandErrorType[message.commandErrorType] === undefined ? message.commandErrorType : $root.ptsl.CommandErrorType[message.commandErrorType] : message.commandErrorType;
            if (message.commandErrorMessage != null && message.hasOwnProperty("commandErrorMessage"))
                object.commandErrorMessage = message.commandErrorMessage;
            if (message.isWarning != null && message.hasOwnProperty("isWarning"))
                object.isWarning = message.isWarning;
            return object;
        };

        /**
         * Converts this CommandError to JSON.
         * @function toJSON
         * @memberof ptsl.CommandError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommandError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CommandError
         * @function getTypeUrl
         * @memberof ptsl.CommandError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CommandError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CommandError";
        };

        return CommandError;
    })();

    ptsl.ResponseError = (function() {

        /**
         * Properties of a ResponseError.
         * @memberof ptsl
         * @interface IResponseError
         * @property {Array.<ptsl.ICommandError>|null} [errors] ResponseError errors
         */

        /**
         * Constructs a new ResponseError.
         * @memberof ptsl
         * @classdesc Structure that describes error response during command execution.
         * @implements IResponseError
         * @constructor
         * @param {ptsl.IResponseError=} [properties] Properties to set
         */
        function ResponseError(properties) {
            this.errors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseError errors.
         * @member {Array.<ptsl.ICommandError>} errors
         * @memberof ptsl.ResponseError
         * @instance
         */
        ResponseError.prototype.errors = $util.emptyArray;

        /**
         * Creates a new ResponseError instance using the specified properties.
         * @function create
         * @memberof ptsl.ResponseError
         * @static
         * @param {ptsl.IResponseError=} [properties] Properties to set
         * @returns {ptsl.ResponseError} ResponseError instance
         */
        ResponseError.create = function create(properties) {
            return new ResponseError(properties);
        };

        /**
         * Encodes the specified ResponseError message. Does not implicitly {@link ptsl.ResponseError.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ResponseError
         * @static
         * @param {ptsl.IResponseError} message ResponseError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errors != null && message.errors.length)
                for (var i = 0; i < message.errors.length; ++i)
                    $root.ptsl.CommandError.encode(message.errors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResponseError message, length delimited. Does not implicitly {@link ptsl.ResponseError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ResponseError
         * @static
         * @param {ptsl.IResponseError} message ResponseError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseError message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ResponseError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ResponseError} ResponseError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseError.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ResponseError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.errors && message.errors.length))
                            message.errors = [];
                        message.errors.push($root.ptsl.CommandError.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResponseError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ResponseError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ResponseError} ResponseError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseError message.
         * @function verify
         * @memberof ptsl.ResponseError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errors != null && message.hasOwnProperty("errors")) {
                if (!Array.isArray(message.errors))
                    return "errors: array expected";
                for (var i = 0; i < message.errors.length; ++i) {
                    var error = $root.ptsl.CommandError.verify(message.errors[i]);
                    if (error)
                        return "errors." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResponseError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ResponseError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ResponseError} ResponseError
         */
        ResponseError.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ResponseError)
                return object;
            var message = new $root.ptsl.ResponseError();
            if (object.errors) {
                if (!Array.isArray(object.errors))
                    throw TypeError(".ptsl.ResponseError.errors: array expected");
                message.errors = [];
                for (var i = 0; i < object.errors.length; ++i) {
                    if (typeof object.errors[i] !== "object")
                        throw TypeError(".ptsl.ResponseError.errors: object expected");
                    message.errors[i] = $root.ptsl.CommandError.fromObject(object.errors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResponseError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ResponseError
         * @static
         * @param {ptsl.ResponseError} message ResponseError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.errors = [];
            if (message.errors && message.errors.length) {
                object.errors = [];
                for (var j = 0; j < message.errors.length; ++j)
                    object.errors[j] = $root.ptsl.CommandError.toObject(message.errors[j], options);
            }
            return object;
        };

        /**
         * Converts this ResponseError to JSON.
         * @function toJSON
         * @memberof ptsl.ResponseError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ResponseError
         * @function getTypeUrl
         * @memberof ptsl.ResponseError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ResponseError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ResponseError";
        };

        return ResponseError;
    })();

    ptsl.RequestHeader = (function() {

        /**
         * Properties of a RequestHeader.
         * @memberof ptsl
         * @interface IRequestHeader
         * @property {string|null} [taskId] RequestHeader taskId
         * @property {ptsl.CommandId|null} [command] RequestHeader command
         * @property {number|null} [version] RequestHeader version
         * @property {string|null} [sessionId] RequestHeader sessionId
         * @property {number|null} [versionMinor] RequestHeader versionMinor
         * @property {number|null} [versionRevision] Revision version of PTSL Client API
         * @since Pro Tools 2025.06
         * @property {string|null} [versionedRequestHeaderJson] JSON string with @ref VersionedRequestHeader data
         * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new RequestHeader.
         * @memberof ptsl
         * @classdesc Structure that describes common data of Pro Tools request message.
         * @implements IRequestHeader
         * @constructor
         * @param {ptsl.IRequestHeader=} [properties] Properties to set
         */
        function RequestHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestHeader taskId.
         * @member {string} taskId
         * @memberof ptsl.RequestHeader
         * @instance
         */
        RequestHeader.prototype.taskId = "";

        /**
         * RequestHeader command.
         * @member {ptsl.CommandId} command
         * @memberof ptsl.RequestHeader
         * @instance
         */
        RequestHeader.prototype.command = 0;

        /**
         * RequestHeader version.
         * @member {number} version
         * @memberof ptsl.RequestHeader
         * @instance
         */
        RequestHeader.prototype.version = 0;

        /**
         * RequestHeader sessionId.
         * @member {string} sessionId
         * @memberof ptsl.RequestHeader
         * @instance
         */
        RequestHeader.prototype.sessionId = "";

        /**
         * RequestHeader versionMinor.
         * @member {number} versionMinor
         * @memberof ptsl.RequestHeader
         * @instance
         */
        RequestHeader.prototype.versionMinor = 0;

        /**
         * Revision version of PTSL Client API
         * @since Pro Tools 2025.06
         * @member {number} versionRevision
         * @memberof ptsl.RequestHeader
         * @instance
         */
        RequestHeader.prototype.versionRevision = 0;

        /**
         * JSON string with @ref VersionedRequestHeader data
         * @since Pro Tools 2025.06
         * @member {string} versionedRequestHeaderJson
         * @memberof ptsl.RequestHeader
         * @instance
         */
        RequestHeader.prototype.versionedRequestHeaderJson = "";

        /**
         * Creates a new RequestHeader instance using the specified properties.
         * @function create
         * @memberof ptsl.RequestHeader
         * @static
         * @param {ptsl.IRequestHeader=} [properties] Properties to set
         * @returns {ptsl.RequestHeader} RequestHeader instance
         */
        RequestHeader.create = function create(properties) {
            return new RequestHeader(properties);
        };

        /**
         * Encodes the specified RequestHeader message. Does not implicitly {@link ptsl.RequestHeader.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RequestHeader
         * @static
         * @param {ptsl.IRequestHeader} message RequestHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskId);
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.command);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
            if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sessionId);
            if (message.versionMinor != null && Object.hasOwnProperty.call(message, "versionMinor"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.versionMinor);
            if (message.versionRevision != null && Object.hasOwnProperty.call(message, "versionRevision"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.versionRevision);
            if (message.versionedRequestHeaderJson != null && Object.hasOwnProperty.call(message, "versionedRequestHeaderJson"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.versionedRequestHeaderJson);
            return writer;
        };

        /**
         * Encodes the specified RequestHeader message, length delimited. Does not implicitly {@link ptsl.RequestHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RequestHeader
         * @static
         * @param {ptsl.IRequestHeader} message RequestHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestHeader message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RequestHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RequestHeader} RequestHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestHeader.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RequestHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.taskId = reader.string();
                        break;
                    }
                case 2: {
                        message.command = reader.int32();
                        break;
                    }
                case 3: {
                        message.version = reader.int32();
                        break;
                    }
                case 4: {
                        message.sessionId = reader.string();
                        break;
                    }
                case 5: {
                        message.versionMinor = reader.int32();
                        break;
                    }
                case 6: {
                        message.versionRevision = reader.int32();
                        break;
                    }
                case 7: {
                        message.versionedRequestHeaderJson = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RequestHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RequestHeader} RequestHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestHeader message.
         * @function verify
         * @memberof ptsl.RequestHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isString(message.taskId))
                    return "taskId: string expected";
            if (message.command != null && message.hasOwnProperty("command"))
                switch (message.command) {
                default:
                    return "command: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                case 20:
                case 20:
                case 21:
                case 21:
                case 22:
                case 22:
                case 23:
                case 23:
                case 24:
                case 24:
                case 25:
                case 25:
                case 26:
                case 26:
                case 27:
                case 27:
                case 28:
                case 28:
                case 29:
                case 29:
                case 30:
                case 30:
                case 31:
                case 31:
                case 32:
                case 32:
                case 33:
                case 33:
                case 34:
                case 34:
                case 35:
                case 35:
                case 36:
                case 36:
                case 37:
                case 37:
                case 38:
                case 38:
                case 39:
                case 39:
                case 40:
                case 40:
                case 41:
                case 41:
                case 42:
                case 42:
                case 43:
                case 43:
                case 44:
                case 44:
                case 45:
                case 45:
                case 46:
                case 46:
                case 47:
                case 47:
                case 48:
                case 48:
                case 49:
                case 49:
                case 50:
                case 50:
                case 51:
                case 51:
                case 52:
                case 52:
                case 53:
                case 53:
                case 54:
                case 54:
                case 55:
                case 55:
                case 56:
                case 56:
                case 57:
                case 57:
                case 58:
                case 58:
                case 59:
                case 59:
                case 61:
                case 61:
                case 62:
                case 62:
                case 63:
                case 63:
                case 64:
                case 64:
                case 65:
                case 65:
                case 66:
                case 66:
                case 67:
                case 67:
                case 68:
                case 68:
                case 69:
                case 69:
                case 70:
                case 70:
                case 71:
                case 71:
                case 72:
                case 72:
                case 73:
                case 73:
                case 74:
                case 74:
                case 75:
                case 75:
                case 76:
                case 76:
                case 77:
                case 77:
                case 78:
                case 78:
                case 79:
                case 79:
                case 80:
                case 80:
                case 81:
                case 81:
                case 82:
                case 82:
                case 83:
                case 83:
                case 84:
                case 84:
                case 85:
                case 85:
                case 86:
                case 86:
                case 87:
                case 87:
                case 88:
                case 88:
                case 89:
                case 89:
                case 90:
                case 90:
                case 91:
                case 91:
                case 92:
                case 92:
                case 93:
                case 93:
                case 94:
                case 94:
                case 95:
                case 95:
                case 96:
                case 96:
                case 97:
                case 97:
                case 98:
                case 98:
                case 99:
                case 99:
                case 100:
                case 100:
                case 101:
                case 101:
                case 102:
                case 102:
                case 103:
                case 103:
                case 104:
                case 104:
                case 105:
                case 105:
                case 106:
                case 106:
                case 107:
                case 107:
                case 108:
                case 108:
                case 109:
                case 109:
                case 110:
                case 110:
                case 111:
                case 111:
                case 112:
                case 112:
                case 113:
                case 113:
                case 114:
                case 114:
                case 115:
                case 115:
                case 116:
                case 116:
                case 117:
                case 117:
                case 118:
                case 119:
                case 120:
                case 121:
                case 122:
                case 123:
                case 124:
                case 125:
                case 126:
                case 127:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                    break;
                }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                if (!$util.isString(message.sessionId))
                    return "sessionId: string expected";
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                if (!$util.isInteger(message.versionMinor))
                    return "versionMinor: integer expected";
            if (message.versionRevision != null && message.hasOwnProperty("versionRevision"))
                if (!$util.isInteger(message.versionRevision))
                    return "versionRevision: integer expected";
            if (message.versionedRequestHeaderJson != null && message.hasOwnProperty("versionedRequestHeaderJson"))
                if (!$util.isString(message.versionedRequestHeaderJson))
                    return "versionedRequestHeaderJson: string expected";
            return null;
        };

        /**
         * Creates a RequestHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RequestHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RequestHeader} RequestHeader
         */
        RequestHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RequestHeader)
                return object;
            var message = new $root.ptsl.RequestHeader();
            if (object.taskId != null)
                message.taskId = String(object.taskId);
            switch (object.command) {
            default:
                if (typeof object.command === "number") {
                    message.command = object.command;
                    break;
                }
                break;
            case "CreateSession":
            case 0:
                message.command = 0;
                break;
            case "CId_CreateSession":
            case 0:
                message.command = 0;
                break;
            case "OpenSession":
            case 1:
                message.command = 1;
                break;
            case "CId_OpenSession":
            case 1:
                message.command = 1;
                break;
            case "Import":
            case 2:
                message.command = 2;
                break;
            case "CId_Import":
            case 2:
                message.command = 2;
                break;
            case "GetTrackList":
            case 3:
                message.command = 3;
                break;
            case "CId_GetTrackList":
            case 3:
                message.command = 3;
                break;
            case "SelectAllClipsOnTrack":
            case 4:
                message.command = 4;
                break;
            case "CId_SelectAllClipsOnTrack":
            case 4:
                message.command = 4;
                break;
            case "ExtendSelectionToTargetTracks":
            case 5:
                message.command = 5;
                break;
            case "CId_ExtendSelectionToTargetTracks":
            case 5:
                message.command = 5;
                break;
            case "TrimToSelection":
            case 6:
                message.command = 6;
                break;
            case "CId_TrimToSelection":
            case 6:
                message.command = 6;
                break;
            case "CreateFadesBasedOnPreset":
            case 7:
                message.command = 7;
                break;
            case "CId_CreateFadesBasedOnPreset":
            case 7:
                message.command = 7;
                break;
            case "RenameTargetTrack":
            case 8:
                message.command = 8;
                break;
            case "CId_RenameTargetTrack":
            case 8:
                message.command = 8;
                break;
            case "ConsolidateClip":
            case 9:
                message.command = 9;
                break;
            case "CId_ConsolidateClip":
            case 9:
                message.command = 9;
                break;
            case "ExportClipsAsFiles":
            case 10:
                message.command = 10;
                break;
            case "CId_ExportClipsAsFiles":
            case 10:
                message.command = 10;
                break;
            case "ExportSelectedTracksAsAAFOMF":
            case 11:
                message.command = 11;
                break;
            case "CId_ExportSelectedTracksAsAAFOMF":
            case 11:
                message.command = 11;
                break;
            case "GetTaskStatus":
            case 12:
                message.command = 12;
                break;
            case "CId_GetTaskStatus":
            case 12:
                message.command = 12;
                break;
            case "HostReadyCheck":
            case 13:
                message.command = 13;
                break;
            case "CId_HostReadyCheck":
            case 13:
                message.command = 13;
                break;
            case "RefreshTargetAudioFiles":
            case 14:
                message.command = 14;
                break;
            case "CId_RefreshTargetAudioFiles":
            case 14:
                message.command = 14;
                break;
            case "RefreshAllModifiedAudioFiles":
            case 15:
                message.command = 15;
                break;
            case "CId_RefreshAllModifiedAudioFiles":
            case 15:
                message.command = 15;
                break;
            case "GetFileLocation":
            case 16:
                message.command = 16;
                break;
            case "CId_GetFileLocation":
            case 16:
                message.command = 16;
                break;
            case "CloseSession":
            case 17:
                message.command = 17;
                break;
            case "CId_CloseSession":
            case 17:
                message.command = 17;
                break;
            case "SaveSession":
            case 18:
                message.command = 18;
                break;
            case "CId_SaveSession":
            case 18:
                message.command = 18;
                break;
            case "SaveSessionAs":
            case 19:
                message.command = 19;
                break;
            case "CId_SaveSessionAs":
            case 19:
                message.command = 19;
                break;
            case "Cut":
            case 20:
                message.command = 20;
                break;
            case "CId_Cut":
            case 20:
                message.command = 20;
                break;
            case "Copy":
            case 21:
                message.command = 21;
                break;
            case "CId_Copy":
            case 21:
                message.command = 21;
                break;
            case "Paste":
            case 22:
                message.command = 22;
                break;
            case "CId_Paste":
            case 22:
                message.command = 22;
                break;
            case "Clear":
            case 23:
                message.command = 23;
                break;
            case "CId_Clear":
            case 23:
                message.command = 23;
                break;
            case "CutSpecial":
            case 24:
                message.command = 24;
                break;
            case "CId_CutSpecial":
            case 24:
                message.command = 24;
                break;
            case "CopySpecial":
            case 25:
                message.command = 25;
                break;
            case "CId_CopySpecial":
            case 25:
                message.command = 25;
                break;
            case "ClearSpecial":
            case 26:
                message.command = 26;
                break;
            case "CId_ClearSpecial":
            case 26:
                message.command = 26;
                break;
            case "PasteSpecial":
            case 27:
                message.command = 27;
                break;
            case "CId_PasteSpecial":
            case 27:
                message.command = 27;
                break;
            case "ExportMix":
            case 28:
                message.command = 28;
                break;
            case "CId_ExportMix":
            case 28:
                message.command = 28;
                break;
            case "Spot":
            case 29:
                message.command = 29;
                break;
            case "CId_Spot":
            case 29:
                message.command = 29;
                break;
            case "ExportSessionInfoAsText":
            case 30:
                message.command = 30;
                break;
            case "CId_ExportSessionInfoAsText":
            case 30:
                message.command = 30;
                break;
            case "GetDynamicProperties":
            case 31:
                message.command = 31;
                break;
            case "CId_GetDynamicProperties":
            case 31:
                message.command = 31;
                break;
            case "SetPlaybackMode":
            case 32:
                message.command = 32;
                break;
            case "CId_SetPlaybackMode":
            case 32:
                message.command = 32;
                break;
            case "SetRecordMode":
            case 33:
                message.command = 33;
                break;
            case "CId_SetRecordMode":
            case 33:
                message.command = 33;
                break;
            case "GetSessionAudioFormat":
            case 34:
                message.command = 34;
                break;
            case "CId_GetSessionAudioFormat":
            case 34:
                message.command = 34;
                break;
            case "GetSessionSampleRate":
            case 35:
                message.command = 35;
                break;
            case "CId_GetSessionSampleRate":
            case 35:
                message.command = 35;
                break;
            case "GetSessionBitDepth":
            case 36:
                message.command = 36;
                break;
            case "CId_GetSessionBitDepth":
            case 36:
                message.command = 36;
                break;
            case "GetSessionInterleavedState":
            case 37:
                message.command = 37;
                break;
            case "CId_GetSessionInterleavedState":
            case 37:
                message.command = 37;
                break;
            case "GetSessionTimeCodeRate":
            case 38:
                message.command = 38;
                break;
            case "CId_GetSessionTimeCodeRate":
            case 38:
                message.command = 38;
                break;
            case "GetSessionFeetFramesRate":
            case 39:
                message.command = 39;
                break;
            case "CId_GetSessionFeetFramesRate":
            case 39:
                message.command = 39;
                break;
            case "GetSessionAudioRatePullSettings":
            case 40:
                message.command = 40;
                break;
            case "CId_GetSessionAudioRatePullSettings":
            case 40:
                message.command = 40;
                break;
            case "GetSessionVideoRatePullSettings":
            case 41:
                message.command = 41;
                break;
            case "CId_GetSessionVideoRatePullSettings":
            case 41:
                message.command = 41;
                break;
            case "GetSessionName":
            case 42:
                message.command = 42;
                break;
            case "CId_GetSessionName":
            case 42:
                message.command = 42;
                break;
            case "GetSessionPath":
            case 43:
                message.command = 43;
                break;
            case "CId_GetSessionPath":
            case 43:
                message.command = 43;
                break;
            case "GetSessionStartTime":
            case 44:
                message.command = 44;
                break;
            case "CId_GetSessionStartTime":
            case 44:
                message.command = 44;
                break;
            case "GetSessionLength":
            case 45:
                message.command = 45;
                break;
            case "CId_GetSessionLength":
            case 45:
                message.command = 45;
                break;
            case "SetSessionAudioFormat":
            case 46:
                message.command = 46;
                break;
            case "CId_SetSessionAudioFormat":
            case 46:
                message.command = 46;
                break;
            case "SetSessionBitDepth":
            case 47:
                message.command = 47;
                break;
            case "CId_SetSessionBitDepth":
            case 47:
                message.command = 47;
                break;
            case "SetSessionInterleavedState":
            case 48:
                message.command = 48;
                break;
            case "CId_SetSessionInterleavedState":
            case 48:
                message.command = 48;
                break;
            case "SetSessionTimeCodeRate":
            case 49:
                message.command = 49;
                break;
            case "CId_SetSessionTimeCodeRate":
            case 49:
                message.command = 49;
                break;
            case "SetSessionFeetFramesRate":
            case 50:
                message.command = 50;
                break;
            case "CId_SetSessionFeetFramesRate":
            case 50:
                message.command = 50;
                break;
            case "SetSessionAudioRatePullSettings":
            case 51:
                message.command = 51;
                break;
            case "CId_SetSessionAudioRatePullSettings":
            case 51:
                message.command = 51;
                break;
            case "SetSessionVideoRatePullSettings":
            case 52:
                message.command = 52;
                break;
            case "CId_SetSessionVideoRatePullSettings":
            case 52:
                message.command = 52;
                break;
            case "SetSessionStartTime":
            case 53:
                message.command = 53;
                break;
            case "CId_SetSessionStartTime":
            case 53:
                message.command = 53;
                break;
            case "SetSessionLength":
            case 54:
                message.command = 54;
                break;
            case "CId_SetSessionLength":
            case 54:
                message.command = 54;
                break;
            case "GetPTSLVersion":
            case 55:
                message.command = 55;
                break;
            case "CId_GetPTSLVersion":
            case 55:
                message.command = 55;
                break;
            case "GetPlaybackMode":
            case 56:
                message.command = 56;
                break;
            case "CId_GetPlaybackMode":
            case 56:
                message.command = 56;
                break;
            case "GetRecordMode":
            case 57:
                message.command = 57;
                break;
            case "CId_GetRecordMode":
            case 57:
                message.command = 57;
                break;
            case "GetTransportArmed":
            case 58:
                message.command = 58;
                break;
            case "CId_GetTransportArmed":
            case 58:
                message.command = 58;
                break;
            case "GetTransportState":
            case 59:
                message.command = 59;
                break;
            case "CId_GetTransportState":
            case 59:
                message.command = 59;
                break;
            case "ClearMemoryLocation":
            case 61:
                message.command = 61;
                break;
            case "CId_ClearMemoryLocation":
            case 61:
                message.command = 61;
                break;
            case "RenameSelectedClip":
            case 62:
                message.command = 62;
                break;
            case "CId_RenameSelectedClip":
            case 62:
                message.command = 62;
                break;
            case "RenameTargetClip":
            case 63:
                message.command = 63;
                break;
            case "CId_RenameTargetClip":
            case 63:
                message.command = 63;
                break;
            case "TogglePlayState":
            case 64:
                message.command = 64;
                break;
            case "CId_TogglePlayState":
            case 64:
                message.command = 64;
                break;
            case "ToggleRecordEnable":
            case 65:
                message.command = 65;
                break;
            case "CId_ToggleRecordEnable":
            case 65:
                message.command = 65;
                break;
            case "PlayHalfSpeed":
            case 66:
                message.command = 66;
                break;
            case "CId_PlayHalfSpeed":
            case 66:
                message.command = 66;
                break;
            case "RecordHalfSpeed":
            case 67:
                message.command = 67;
                break;
            case "CId_RecordHalfSpeed":
            case 67:
                message.command = 67;
                break;
            case "EditMemoryLocation":
            case 68:
                message.command = 68;
                break;
            case "CId_EditMemoryLocation":
            case 68:
                message.command = 68;
                break;
            case "GetMemoryLocations":
            case 69:
                message.command = 69;
                break;
            case "CId_GetMemoryLocations":
            case 69:
                message.command = 69;
                break;
            case "RegisterConnection":
            case 70:
                message.command = 70;
                break;
            case "CId_RegisterConnection":
            case 70:
                message.command = 70;
                break;
            case "CreateMemoryLocation":
            case 71:
                message.command = 71;
                break;
            case "CId_CreateMemoryLocation":
            case 71:
                message.command = 71;
                break;
            case "CreateNewTracks":
            case 72:
                message.command = 72;
                break;
            case "CId_CreateNewTracks":
            case 72:
                message.command = 72;
                break;
            case "SelectTracksByName":
            case 73:
                message.command = 73;
                break;
            case "CId_SelectTracksByName":
            case 73:
                message.command = 73;
                break;
            case "GetEditMode":
            case 74:
                message.command = 74;
                break;
            case "CId_GetEditMode":
            case 74:
                message.command = 74;
                break;
            case "SetEditMode":
            case 75:
                message.command = 75;
                break;
            case "CId_SetEditMode":
            case 75:
                message.command = 75;
                break;
            case "GetEditTool":
            case 76:
                message.command = 76;
                break;
            case "CId_GetEditTool":
            case 76:
                message.command = 76;
                break;
            case "SetEditTool":
            case 77:
                message.command = 77;
                break;
            case "CId_SetEditTool":
            case 77:
                message.command = 77;
                break;
            case "RecallZoomPreset":
            case 78:
                message.command = 78;
                break;
            case "CId_RecallZoomPreset":
            case 78:
                message.command = 78;
                break;
            case "GetEditModeOptions":
            case 79:
                message.command = 79;
                break;
            case "CId_GetEditModeOptions":
            case 79:
                message.command = 79;
                break;
            case "SetEditModeOptions":
            case 80:
                message.command = 80;
                break;
            case "CId_SetEditModeOptions":
            case 80:
                message.command = 80;
                break;
            case "SetTimelineSelection":
            case 81:
                message.command = 81;
                break;
            case "CId_SetTimelineSelection":
            case 81:
                message.command = 81;
                break;
            case "GetTimelineSelection":
            case 82:
                message.command = 82;
                break;
            case "CId_GetTimelineSelection":
            case 82:
                message.command = 82;
                break;
            case "ImportVideo":
            case 83:
                message.command = 83;
                break;
            case "CId_ImportVideo":
            case 83:
                message.command = 83;
                break;
            case "SelectMemoryLocation":
            case 84:
                message.command = 84;
                break;
            case "CId_SelectMemoryLocation":
            case 84:
                message.command = 84;
                break;
            case "SetTrackMuteState":
            case 85:
                message.command = 85;
                break;
            case "CId_SetTrackMuteState":
            case 85:
                message.command = 85;
                break;
            case "SetTrackSoloState":
            case 86:
                message.command = 86;
                break;
            case "CId_SetTrackSoloState":
            case 86:
                message.command = 86;
                break;
            case "SetTrackSoloSafeState":
            case 87:
                message.command = 87;
                break;
            case "CId_SetTrackSoloSafeState":
            case 87:
                message.command = 87;
                break;
            case "SetTrackRecordEnableState":
            case 88:
                message.command = 88;
                break;
            case "CId_SetTrackRecordEnableState":
            case 88:
                message.command = 88;
                break;
            case "SetTrackRecordSafeEnableState":
            case 89:
                message.command = 89;
                break;
            case "CId_SetTrackRecordSafeEnableState":
            case 89:
                message.command = 89;
                break;
            case "SetTrackInputMonitorState":
            case 90:
                message.command = 90;
                break;
            case "CId_SetTrackInputMonitorState":
            case 90:
                message.command = 90;
                break;
            case "SetTrackSmartDspState":
            case 91:
                message.command = 91;
                break;
            case "CId_SetTrackSmartDspState":
            case 91:
                message.command = 91;
                break;
            case "SetTrackHiddenState":
            case 92:
                message.command = 92;
                break;
            case "CId_SetTrackHiddenState":
            case 92:
                message.command = 92;
                break;
            case "SetTrackInactiveState":
            case 93:
                message.command = 93;
                break;
            case "CId_SetTrackInactiveState":
            case 93:
                message.command = 93;
                break;
            case "SetTrackFrozenState":
            case 94:
                message.command = 94;
                break;
            case "CId_SetTrackFrozenState":
            case 94:
                message.command = 94;
                break;
            case "SetTrackOnlineState":
            case 95:
                message.command = 95;
                break;
            case "CId_SetTrackOnlineState":
            case 95:
                message.command = 95;
                break;
            case "SetTrackOpenState":
            case 96:
                message.command = 96;
                break;
            case "CId_SetTrackOpenState":
            case 96:
                message.command = 96;
                break;
            case "GetSessionIDs":
            case 97:
                message.command = 97;
                break;
            case "CId_GetSessionIDs":
            case 97:
                message.command = 97;
                break;
            case "GetMemoryLocationsManageMode":
            case 98:
                message.command = 98;
                break;
            case "CId_GetMemoryLocationsManageMode":
            case 98:
                message.command = 98;
                break;
            case "SetMemoryLocationsManageMode":
            case 99:
                message.command = 99;
                break;
            case "CId_SetMemoryLocationsManageMode":
            case 99:
                message.command = 99;
                break;
            case "SetMainCounterFormat":
            case 100:
                message.command = 100;
                break;
            case "CId_SetMainCounterFormat":
            case 100:
                message.command = 100;
                break;
            case "SetSubCounterFormat":
            case 101:
                message.command = 101;
                break;
            case "CId_SetSubCounterFormat":
            case 101:
                message.command = 101;
                break;
            case "GetMainCounterFormat":
            case 102:
                message.command = 102;
                break;
            case "CId_GetMainCounterFormat":
            case 102:
                message.command = 102;
                break;
            case "GetSubCounterFormat":
            case 103:
                message.command = 103;
                break;
            case "CId_GetSubCounterFormat":
            case 103:
                message.command = 103;
                break;
            case "Undo":
            case 104:
                message.command = 104;
                break;
            case "CId_Undo":
            case 104:
                message.command = 104;
                break;
            case "Redo":
            case 105:
                message.command = 105;
                break;
            case "CId_Redo":
            case 105:
                message.command = 105;
                break;
            case "UndoAll":
            case 106:
                message.command = 106;
                break;
            case "CId_UndoAll":
            case 106:
                message.command = 106;
                break;
            case "RedoAll":
            case 107:
                message.command = 107;
                break;
            case "CId_RedoAll":
            case 107:
                message.command = 107;
                break;
            case "ClearUndoQueue":
            case 108:
                message.command = 108;
                break;
            case "CId_ClearUndoQueue":
            case 108:
                message.command = 108;
                break;
            case "SetTrackDSPModeSafeState":
            case 109:
                message.command = 109;
                break;
            case "CId_SetTrackDSPModeSafeState":
            case 109:
                message.command = 109;
                break;
            case "GetSessionSystemDelayInfo":
            case 110:
                message.command = 110;
                break;
            case "CId_GetSessionSystemDelayInfo":
            case 110:
                message.command = 110;
                break;
            case "GroupClips":
            case 111:
                message.command = 111;
                break;
            case "CId_GroupClips":
            case 111:
                message.command = 111;
                break;
            case "UngroupClips":
            case 112:
                message.command = 112;
                break;
            case "CId_UngroupClips":
            case 112:
                message.command = 112;
                break;
            case "UngroupAllClips":
            case 113:
                message.command = 113;
                break;
            case "CId_UngroupAllClips":
            case 113:
                message.command = 113;
                break;
            case "RegroupClips":
            case 114:
                message.command = 114;
                break;
            case "CId_RegroupClips":
            case 114:
                message.command = 114;
                break;
            case "RepeatSelection":
            case 115:
                message.command = 115;
                break;
            case "CId_RepeatSelection":
            case 115:
                message.command = 115;
                break;
            case "DuplicateSelection":
            case 116:
                message.command = 116;
                break;
            case "CId_DuplicateSelection":
            case 116:
                message.command = 116;
                break;
            case "ClearAllMemoryLocations":
            case 117:
                message.command = 117;
                break;
            case "CId_ClearAllMemoryLocations":
            case 117:
                message.command = 117;
                break;
            case "CId_GetTimeAsType":
            case 118:
                message.command = 118;
                break;
            case "CId_SubtractLocations":
            case 119:
                message.command = 119;
                break;
            case "CId_AddLengthToLocation":
            case 120:
                message.command = 120;
                break;
            case "CId_SubtractPositions":
            case 121:
                message.command = 121;
                break;
            case "CId_AddLengthToPosition":
            case 122:
                message.command = 122;
                break;
            case "CId_ImportAudioToClipList":
            case 123:
                message.command = 123;
                break;
            case "CId_SpotClipsByID":
            case 124:
                message.command = 124;
                break;
            case "CId_GetClipList":
            case 125:
                message.command = 125;
                break;
            case "CId_GetMediaFileInfo":
            case 126:
                message.command = 126;
                break;
            case "CId_CreateAudioClips":
            case 127:
                message.command = 127;
                break;
            case "CId_GetExportMixSourceList":
            case 128:
                message.command = 128;
                break;
            case "CId_CreateBatchJob":
            case 129:
                message.command = 129;
                break;
            case "CId_GetMonitorOutputPath":
            case 130:
                message.command = 130;
                break;
            case "CId_GetEditSelection":
            case 131:
                message.command = 131;
                break;
            case "CId_SubscribeToEvents":
            case 132:
                message.command = 132;
                break;
            case "CId_GetBatchJobStatus":
            case 133:
                message.command = 133;
                break;
            case "CId_BounceTrack":
            case 134:
                message.command = 134;
                break;
            case "CId_PollEvents":
            case 135:
                message.command = 135;
                break;
            case "CId_UnsubscribeFromEvents":
            case 136:
                message.command = 136;
                break;
            case "CId_CompleteBatchJob":
            case 137:
                message.command = 137;
                break;
            case "CId_CancelBatchJob":
            case 138:
                message.command = 138;
                break;
            case "CId_BeginScrub":
            case 139:
                message.command = 139;
                break;
            case "CId_EndScrub":
            case 140:
                message.command = 140;
                break;
            case "CId_ContinueScrub":
            case 141:
                message.command = 141;
                break;
            case "CId_EnableCueProVideoPlugIn":
            case 142:
                message.command = 142;
                break;
            case "CId_UpdateVideo":
            case 143:
                message.command = 143;
                break;
            case "CId_EnableAPI":
            case 144:
                message.command = 144;
                break;
            case "CId_ExchangePublicKeys":
            case 145:
                message.command = 145;
                break;
            }
            if (object.version != null)
                message.version = object.version | 0;
            if (object.sessionId != null)
                message.sessionId = String(object.sessionId);
            if (object.versionMinor != null)
                message.versionMinor = object.versionMinor | 0;
            if (object.versionRevision != null)
                message.versionRevision = object.versionRevision | 0;
            if (object.versionedRequestHeaderJson != null)
                message.versionedRequestHeaderJson = String(object.versionedRequestHeaderJson);
            return message;
        };

        /**
         * Creates a plain object from a RequestHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RequestHeader
         * @static
         * @param {ptsl.RequestHeader} message RequestHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.taskId = "";
                object.command = options.enums === String ? "CreateSession" : 0;
                object.version = 0;
                object.sessionId = "";
                object.versionMinor = 0;
                object.versionRevision = 0;
                object.versionedRequestHeaderJson = "";
            }
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = message.taskId;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = options.enums === String ? $root.ptsl.CommandId[message.command] === undefined ? message.command : $root.ptsl.CommandId[message.command] : message.command;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                object.sessionId = message.sessionId;
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                object.versionMinor = message.versionMinor;
            if (message.versionRevision != null && message.hasOwnProperty("versionRevision"))
                object.versionRevision = message.versionRevision;
            if (message.versionedRequestHeaderJson != null && message.hasOwnProperty("versionedRequestHeaderJson"))
                object.versionedRequestHeaderJson = message.versionedRequestHeaderJson;
            return object;
        };

        /**
         * Converts this RequestHeader to JSON.
         * @function toJSON
         * @memberof ptsl.RequestHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RequestHeader
         * @function getTypeUrl
         * @memberof ptsl.RequestHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RequestHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RequestHeader";
        };

        return RequestHeader;
    })();

    ptsl.VersionedRequestHeader = (function() {

        /**
         * Properties of a VersionedRequestHeader.
         * @memberof ptsl
         * @interface IVersionedRequestHeader
         * @property {ptsl.IBatchJobRequestHeaderData|null} [batchJobHeader] * Header data containing detailed information
         * * in case of current request being a part of any running batch job
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new VersionedRequestHeader.
         * @memberof ptsl
         * @classdesc Structure that describes versioned request header.
         * @since Pro Tools 2025.06
         * @implements IVersionedRequestHeader
         * @constructor
         * @param {ptsl.IVersionedRequestHeader=} [properties] Properties to set
         */
        function VersionedRequestHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Header data containing detailed information
         * * in case of current request being a part of any running batch job
         * * @since Pro Tools 2025.06
         * @member {ptsl.IBatchJobRequestHeaderData|null|undefined} batchJobHeader
         * @memberof ptsl.VersionedRequestHeader
         * @instance
         */
        VersionedRequestHeader.prototype.batchJobHeader = null;

        /**
         * Creates a new VersionedRequestHeader instance using the specified properties.
         * @function create
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {ptsl.IVersionedRequestHeader=} [properties] Properties to set
         * @returns {ptsl.VersionedRequestHeader} VersionedRequestHeader instance
         */
        VersionedRequestHeader.create = function create(properties) {
            return new VersionedRequestHeader(properties);
        };

        /**
         * Encodes the specified VersionedRequestHeader message. Does not implicitly {@link ptsl.VersionedRequestHeader.verify|verify} messages.
         * @function encode
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {ptsl.IVersionedRequestHeader} message VersionedRequestHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedRequestHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.batchJobHeader != null && Object.hasOwnProperty.call(message, "batchJobHeader"))
                $root.ptsl.BatchJobRequestHeaderData.encode(message.batchJobHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VersionedRequestHeader message, length delimited. Does not implicitly {@link ptsl.VersionedRequestHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {ptsl.IVersionedRequestHeader} message VersionedRequestHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedRequestHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionedRequestHeader message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.VersionedRequestHeader} VersionedRequestHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedRequestHeader.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.VersionedRequestHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.batchJobHeader = $root.ptsl.BatchJobRequestHeaderData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VersionedRequestHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.VersionedRequestHeader} VersionedRequestHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedRequestHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionedRequestHeader message.
         * @function verify
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionedRequestHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.batchJobHeader != null && message.hasOwnProperty("batchJobHeader")) {
                var error = $root.ptsl.BatchJobRequestHeaderData.verify(message.batchJobHeader);
                if (error)
                    return "batchJobHeader." + error;
            }
            return null;
        };

        /**
         * Creates a VersionedRequestHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.VersionedRequestHeader} VersionedRequestHeader
         */
        VersionedRequestHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.VersionedRequestHeader)
                return object;
            var message = new $root.ptsl.VersionedRequestHeader();
            if (object.batchJobHeader != null) {
                if (typeof object.batchJobHeader !== "object")
                    throw TypeError(".ptsl.VersionedRequestHeader.batchJobHeader: object expected");
                message.batchJobHeader = $root.ptsl.BatchJobRequestHeaderData.fromObject(object.batchJobHeader);
            }
            return message;
        };

        /**
         * Creates a plain object from a VersionedRequestHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {ptsl.VersionedRequestHeader} message VersionedRequestHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionedRequestHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.batchJobHeader = null;
            if (message.batchJobHeader != null && message.hasOwnProperty("batchJobHeader"))
                object.batchJobHeader = $root.ptsl.BatchJobRequestHeaderData.toObject(message.batchJobHeader, options);
            return object;
        };

        /**
         * Converts this VersionedRequestHeader to JSON.
         * @function toJSON
         * @memberof ptsl.VersionedRequestHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionedRequestHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VersionedRequestHeader
         * @function getTypeUrl
         * @memberof ptsl.VersionedRequestHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VersionedRequestHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.VersionedRequestHeader";
        };

        return VersionedRequestHeader;
    })();

    ptsl.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof ptsl
         * @interface IRequest
         * @property {ptsl.IRequestHeader|null} [header] Request header
         * @property {string|null} [requestBodyJson] Request requestBodyJson
         */

        /**
         * Constructs a new Request.
         * @memberof ptsl
         * @classdesc Structure that describes Pro Tools request.
         * @implements IRequest
         * @constructor
         * @param {ptsl.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request header.
         * @member {ptsl.IRequestHeader|null|undefined} header
         * @memberof ptsl.Request
         * @instance
         */
        Request.prototype.header = null;

        /**
         * Request requestBodyJson.
         * @member {string} requestBodyJson
         * @memberof ptsl.Request
         * @instance
         */
        Request.prototype.requestBodyJson = "";

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof ptsl.Request
         * @static
         * @param {ptsl.IRequest=} [properties] Properties to set
         * @returns {ptsl.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link ptsl.Request.verify|verify} messages.
         * @function encode
         * @memberof ptsl.Request
         * @static
         * @param {ptsl.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                $root.ptsl.RequestHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.requestBodyJson != null && Object.hasOwnProperty.call(message, "requestBodyJson"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.requestBodyJson);
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link ptsl.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.Request
         * @static
         * @param {ptsl.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.header = $root.ptsl.RequestHeader.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.requestBodyJson = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof ptsl.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.header != null && message.hasOwnProperty("header")) {
                var error = $root.ptsl.RequestHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.requestBodyJson != null && message.hasOwnProperty("requestBodyJson"))
                if (!$util.isString(message.requestBodyJson))
                    return "requestBodyJson: string expected";
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.Request)
                return object;
            var message = new $root.ptsl.Request();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".ptsl.Request.header: object expected");
                message.header = $root.ptsl.RequestHeader.fromObject(object.header);
            }
            if (object.requestBodyJson != null)
                message.requestBodyJson = String(object.requestBodyJson);
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.Request
         * @static
         * @param {ptsl.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.requestBodyJson = "";
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.ptsl.RequestHeader.toObject(message.header, options);
            if (message.requestBodyJson != null && message.hasOwnProperty("requestBodyJson"))
                object.requestBodyJson = message.requestBodyJson;
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof ptsl.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Request
         * @function getTypeUrl
         * @memberof ptsl.Request
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.Request";
        };

        return Request;
    })();

    ptsl.ResponseHeader = (function() {

        /**
         * Properties of a ResponseHeader.
         * @memberof ptsl
         * @interface IResponseHeader
         * @property {string|null} [taskId] ResponseHeader taskId
         * @property {ptsl.CommandId|null} [command] ResponseHeader command
         * @property {ptsl.TaskStatus|null} [status] ResponseHeader status
         * @property {number|null} [progress] ResponseHeader progress
         * @property {number|null} [version] ResponseHeader version
         * @property {number|null} [versionMinor] Minor version of PTSL host API - the month (10)
         * @since Pro Tools 2025.06
         * @property {number|null} [versionRevision] Revision version of PTSL host API
         * @since Pro Tools 2025.06
         * @property {string|null} [versionedResponseHeaderJson] JSON string with versioned response header data
         * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new ResponseHeader.
         * @memberof ptsl
         * @classdesc Structure that describes common data of Pro Tools response message.
         * @implements IResponseHeader
         * @constructor
         * @param {ptsl.IResponseHeader=} [properties] Properties to set
         */
        function ResponseHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseHeader taskId.
         * @member {string} taskId
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.taskId = "";

        /**
         * ResponseHeader command.
         * @member {ptsl.CommandId} command
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.command = 0;

        /**
         * ResponseHeader status.
         * @member {ptsl.TaskStatus} status
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.status = 0;

        /**
         * ResponseHeader progress.
         * @member {number} progress
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.progress = 0;

        /**
         * ResponseHeader version.
         * @member {number} version
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.version = 0;

        /**
         * Minor version of PTSL host API - the month (10)
         * @since Pro Tools 2025.06
         * @member {number} versionMinor
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.versionMinor = 0;

        /**
         * Revision version of PTSL host API
         * @since Pro Tools 2025.06
         * @member {number} versionRevision
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.versionRevision = 0;

        /**
         * JSON string with versioned response header data
         * @since Pro Tools 2025.06
         * @member {string} versionedResponseHeaderJson
         * @memberof ptsl.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.versionedResponseHeaderJson = "";

        /**
         * Creates a new ResponseHeader instance using the specified properties.
         * @function create
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {ptsl.IResponseHeader=} [properties] Properties to set
         * @returns {ptsl.ResponseHeader} ResponseHeader instance
         */
        ResponseHeader.create = function create(properties) {
            return new ResponseHeader(properties);
        };

        /**
         * Encodes the specified ResponseHeader message. Does not implicitly {@link ptsl.ResponseHeader.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {ptsl.IResponseHeader} message ResponseHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskId);
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.command);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.progress);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.version);
            if (message.versionMinor != null && Object.hasOwnProperty.call(message, "versionMinor"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.versionMinor);
            if (message.versionRevision != null && Object.hasOwnProperty.call(message, "versionRevision"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.versionRevision);
            if (message.versionedResponseHeaderJson != null && Object.hasOwnProperty.call(message, "versionedResponseHeaderJson"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.versionedResponseHeaderJson);
            return writer;
        };

        /**
         * Encodes the specified ResponseHeader message, length delimited. Does not implicitly {@link ptsl.ResponseHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {ptsl.IResponseHeader} message ResponseHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseHeader message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ResponseHeader} ResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseHeader.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ResponseHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.taskId = reader.string();
                        break;
                    }
                case 2: {
                        message.command = reader.int32();
                        break;
                    }
                case 3: {
                        message.status = reader.int32();
                        break;
                    }
                case 4: {
                        message.progress = reader.int32();
                        break;
                    }
                case 5: {
                        message.version = reader.int32();
                        break;
                    }
                case 6: {
                        message.versionMinor = reader.int32();
                        break;
                    }
                case 7: {
                        message.versionRevision = reader.int32();
                        break;
                    }
                case 8: {
                        message.versionedResponseHeaderJson = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResponseHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ResponseHeader} ResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseHeader message.
         * @function verify
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isString(message.taskId))
                    return "taskId: string expected";
            if (message.command != null && message.hasOwnProperty("command"))
                switch (message.command) {
                default:
                    return "command: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                case 20:
                case 20:
                case 21:
                case 21:
                case 22:
                case 22:
                case 23:
                case 23:
                case 24:
                case 24:
                case 25:
                case 25:
                case 26:
                case 26:
                case 27:
                case 27:
                case 28:
                case 28:
                case 29:
                case 29:
                case 30:
                case 30:
                case 31:
                case 31:
                case 32:
                case 32:
                case 33:
                case 33:
                case 34:
                case 34:
                case 35:
                case 35:
                case 36:
                case 36:
                case 37:
                case 37:
                case 38:
                case 38:
                case 39:
                case 39:
                case 40:
                case 40:
                case 41:
                case 41:
                case 42:
                case 42:
                case 43:
                case 43:
                case 44:
                case 44:
                case 45:
                case 45:
                case 46:
                case 46:
                case 47:
                case 47:
                case 48:
                case 48:
                case 49:
                case 49:
                case 50:
                case 50:
                case 51:
                case 51:
                case 52:
                case 52:
                case 53:
                case 53:
                case 54:
                case 54:
                case 55:
                case 55:
                case 56:
                case 56:
                case 57:
                case 57:
                case 58:
                case 58:
                case 59:
                case 59:
                case 61:
                case 61:
                case 62:
                case 62:
                case 63:
                case 63:
                case 64:
                case 64:
                case 65:
                case 65:
                case 66:
                case 66:
                case 67:
                case 67:
                case 68:
                case 68:
                case 69:
                case 69:
                case 70:
                case 70:
                case 71:
                case 71:
                case 72:
                case 72:
                case 73:
                case 73:
                case 74:
                case 74:
                case 75:
                case 75:
                case 76:
                case 76:
                case 77:
                case 77:
                case 78:
                case 78:
                case 79:
                case 79:
                case 80:
                case 80:
                case 81:
                case 81:
                case 82:
                case 82:
                case 83:
                case 83:
                case 84:
                case 84:
                case 85:
                case 85:
                case 86:
                case 86:
                case 87:
                case 87:
                case 88:
                case 88:
                case 89:
                case 89:
                case 90:
                case 90:
                case 91:
                case 91:
                case 92:
                case 92:
                case 93:
                case 93:
                case 94:
                case 94:
                case 95:
                case 95:
                case 96:
                case 96:
                case 97:
                case 97:
                case 98:
                case 98:
                case 99:
                case 99:
                case 100:
                case 100:
                case 101:
                case 101:
                case 102:
                case 102:
                case 103:
                case 103:
                case 104:
                case 104:
                case 105:
                case 105:
                case 106:
                case 106:
                case 107:
                case 107:
                case 108:
                case 108:
                case 109:
                case 109:
                case 110:
                case 110:
                case 111:
                case 111:
                case 112:
                case 112:
                case 113:
                case 113:
                case 114:
                case 114:
                case 115:
                case 115:
                case 116:
                case 116:
                case 117:
                case 117:
                case 118:
                case 119:
                case 120:
                case 121:
                case 122:
                case 123:
                case 124:
                case 125:
                case 126:
                case 127:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                    break;
                }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                    break;
                }
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                if (!$util.isInteger(message.versionMinor))
                    return "versionMinor: integer expected";
            if (message.versionRevision != null && message.hasOwnProperty("versionRevision"))
                if (!$util.isInteger(message.versionRevision))
                    return "versionRevision: integer expected";
            if (message.versionedResponseHeaderJson != null && message.hasOwnProperty("versionedResponseHeaderJson"))
                if (!$util.isString(message.versionedResponseHeaderJson))
                    return "versionedResponseHeaderJson: string expected";
            return null;
        };

        /**
         * Creates a ResponseHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ResponseHeader} ResponseHeader
         */
        ResponseHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ResponseHeader)
                return object;
            var message = new $root.ptsl.ResponseHeader();
            if (object.taskId != null)
                message.taskId = String(object.taskId);
            switch (object.command) {
            default:
                if (typeof object.command === "number") {
                    message.command = object.command;
                    break;
                }
                break;
            case "CreateSession":
            case 0:
                message.command = 0;
                break;
            case "CId_CreateSession":
            case 0:
                message.command = 0;
                break;
            case "OpenSession":
            case 1:
                message.command = 1;
                break;
            case "CId_OpenSession":
            case 1:
                message.command = 1;
                break;
            case "Import":
            case 2:
                message.command = 2;
                break;
            case "CId_Import":
            case 2:
                message.command = 2;
                break;
            case "GetTrackList":
            case 3:
                message.command = 3;
                break;
            case "CId_GetTrackList":
            case 3:
                message.command = 3;
                break;
            case "SelectAllClipsOnTrack":
            case 4:
                message.command = 4;
                break;
            case "CId_SelectAllClipsOnTrack":
            case 4:
                message.command = 4;
                break;
            case "ExtendSelectionToTargetTracks":
            case 5:
                message.command = 5;
                break;
            case "CId_ExtendSelectionToTargetTracks":
            case 5:
                message.command = 5;
                break;
            case "TrimToSelection":
            case 6:
                message.command = 6;
                break;
            case "CId_TrimToSelection":
            case 6:
                message.command = 6;
                break;
            case "CreateFadesBasedOnPreset":
            case 7:
                message.command = 7;
                break;
            case "CId_CreateFadesBasedOnPreset":
            case 7:
                message.command = 7;
                break;
            case "RenameTargetTrack":
            case 8:
                message.command = 8;
                break;
            case "CId_RenameTargetTrack":
            case 8:
                message.command = 8;
                break;
            case "ConsolidateClip":
            case 9:
                message.command = 9;
                break;
            case "CId_ConsolidateClip":
            case 9:
                message.command = 9;
                break;
            case "ExportClipsAsFiles":
            case 10:
                message.command = 10;
                break;
            case "CId_ExportClipsAsFiles":
            case 10:
                message.command = 10;
                break;
            case "ExportSelectedTracksAsAAFOMF":
            case 11:
                message.command = 11;
                break;
            case "CId_ExportSelectedTracksAsAAFOMF":
            case 11:
                message.command = 11;
                break;
            case "GetTaskStatus":
            case 12:
                message.command = 12;
                break;
            case "CId_GetTaskStatus":
            case 12:
                message.command = 12;
                break;
            case "HostReadyCheck":
            case 13:
                message.command = 13;
                break;
            case "CId_HostReadyCheck":
            case 13:
                message.command = 13;
                break;
            case "RefreshTargetAudioFiles":
            case 14:
                message.command = 14;
                break;
            case "CId_RefreshTargetAudioFiles":
            case 14:
                message.command = 14;
                break;
            case "RefreshAllModifiedAudioFiles":
            case 15:
                message.command = 15;
                break;
            case "CId_RefreshAllModifiedAudioFiles":
            case 15:
                message.command = 15;
                break;
            case "GetFileLocation":
            case 16:
                message.command = 16;
                break;
            case "CId_GetFileLocation":
            case 16:
                message.command = 16;
                break;
            case "CloseSession":
            case 17:
                message.command = 17;
                break;
            case "CId_CloseSession":
            case 17:
                message.command = 17;
                break;
            case "SaveSession":
            case 18:
                message.command = 18;
                break;
            case "CId_SaveSession":
            case 18:
                message.command = 18;
                break;
            case "SaveSessionAs":
            case 19:
                message.command = 19;
                break;
            case "CId_SaveSessionAs":
            case 19:
                message.command = 19;
                break;
            case "Cut":
            case 20:
                message.command = 20;
                break;
            case "CId_Cut":
            case 20:
                message.command = 20;
                break;
            case "Copy":
            case 21:
                message.command = 21;
                break;
            case "CId_Copy":
            case 21:
                message.command = 21;
                break;
            case "Paste":
            case 22:
                message.command = 22;
                break;
            case "CId_Paste":
            case 22:
                message.command = 22;
                break;
            case "Clear":
            case 23:
                message.command = 23;
                break;
            case "CId_Clear":
            case 23:
                message.command = 23;
                break;
            case "CutSpecial":
            case 24:
                message.command = 24;
                break;
            case "CId_CutSpecial":
            case 24:
                message.command = 24;
                break;
            case "CopySpecial":
            case 25:
                message.command = 25;
                break;
            case "CId_CopySpecial":
            case 25:
                message.command = 25;
                break;
            case "ClearSpecial":
            case 26:
                message.command = 26;
                break;
            case "CId_ClearSpecial":
            case 26:
                message.command = 26;
                break;
            case "PasteSpecial":
            case 27:
                message.command = 27;
                break;
            case "CId_PasteSpecial":
            case 27:
                message.command = 27;
                break;
            case "ExportMix":
            case 28:
                message.command = 28;
                break;
            case "CId_ExportMix":
            case 28:
                message.command = 28;
                break;
            case "Spot":
            case 29:
                message.command = 29;
                break;
            case "CId_Spot":
            case 29:
                message.command = 29;
                break;
            case "ExportSessionInfoAsText":
            case 30:
                message.command = 30;
                break;
            case "CId_ExportSessionInfoAsText":
            case 30:
                message.command = 30;
                break;
            case "GetDynamicProperties":
            case 31:
                message.command = 31;
                break;
            case "CId_GetDynamicProperties":
            case 31:
                message.command = 31;
                break;
            case "SetPlaybackMode":
            case 32:
                message.command = 32;
                break;
            case "CId_SetPlaybackMode":
            case 32:
                message.command = 32;
                break;
            case "SetRecordMode":
            case 33:
                message.command = 33;
                break;
            case "CId_SetRecordMode":
            case 33:
                message.command = 33;
                break;
            case "GetSessionAudioFormat":
            case 34:
                message.command = 34;
                break;
            case "CId_GetSessionAudioFormat":
            case 34:
                message.command = 34;
                break;
            case "GetSessionSampleRate":
            case 35:
                message.command = 35;
                break;
            case "CId_GetSessionSampleRate":
            case 35:
                message.command = 35;
                break;
            case "GetSessionBitDepth":
            case 36:
                message.command = 36;
                break;
            case "CId_GetSessionBitDepth":
            case 36:
                message.command = 36;
                break;
            case "GetSessionInterleavedState":
            case 37:
                message.command = 37;
                break;
            case "CId_GetSessionInterleavedState":
            case 37:
                message.command = 37;
                break;
            case "GetSessionTimeCodeRate":
            case 38:
                message.command = 38;
                break;
            case "CId_GetSessionTimeCodeRate":
            case 38:
                message.command = 38;
                break;
            case "GetSessionFeetFramesRate":
            case 39:
                message.command = 39;
                break;
            case "CId_GetSessionFeetFramesRate":
            case 39:
                message.command = 39;
                break;
            case "GetSessionAudioRatePullSettings":
            case 40:
                message.command = 40;
                break;
            case "CId_GetSessionAudioRatePullSettings":
            case 40:
                message.command = 40;
                break;
            case "GetSessionVideoRatePullSettings":
            case 41:
                message.command = 41;
                break;
            case "CId_GetSessionVideoRatePullSettings":
            case 41:
                message.command = 41;
                break;
            case "GetSessionName":
            case 42:
                message.command = 42;
                break;
            case "CId_GetSessionName":
            case 42:
                message.command = 42;
                break;
            case "GetSessionPath":
            case 43:
                message.command = 43;
                break;
            case "CId_GetSessionPath":
            case 43:
                message.command = 43;
                break;
            case "GetSessionStartTime":
            case 44:
                message.command = 44;
                break;
            case "CId_GetSessionStartTime":
            case 44:
                message.command = 44;
                break;
            case "GetSessionLength":
            case 45:
                message.command = 45;
                break;
            case "CId_GetSessionLength":
            case 45:
                message.command = 45;
                break;
            case "SetSessionAudioFormat":
            case 46:
                message.command = 46;
                break;
            case "CId_SetSessionAudioFormat":
            case 46:
                message.command = 46;
                break;
            case "SetSessionBitDepth":
            case 47:
                message.command = 47;
                break;
            case "CId_SetSessionBitDepth":
            case 47:
                message.command = 47;
                break;
            case "SetSessionInterleavedState":
            case 48:
                message.command = 48;
                break;
            case "CId_SetSessionInterleavedState":
            case 48:
                message.command = 48;
                break;
            case "SetSessionTimeCodeRate":
            case 49:
                message.command = 49;
                break;
            case "CId_SetSessionTimeCodeRate":
            case 49:
                message.command = 49;
                break;
            case "SetSessionFeetFramesRate":
            case 50:
                message.command = 50;
                break;
            case "CId_SetSessionFeetFramesRate":
            case 50:
                message.command = 50;
                break;
            case "SetSessionAudioRatePullSettings":
            case 51:
                message.command = 51;
                break;
            case "CId_SetSessionAudioRatePullSettings":
            case 51:
                message.command = 51;
                break;
            case "SetSessionVideoRatePullSettings":
            case 52:
                message.command = 52;
                break;
            case "CId_SetSessionVideoRatePullSettings":
            case 52:
                message.command = 52;
                break;
            case "SetSessionStartTime":
            case 53:
                message.command = 53;
                break;
            case "CId_SetSessionStartTime":
            case 53:
                message.command = 53;
                break;
            case "SetSessionLength":
            case 54:
                message.command = 54;
                break;
            case "CId_SetSessionLength":
            case 54:
                message.command = 54;
                break;
            case "GetPTSLVersion":
            case 55:
                message.command = 55;
                break;
            case "CId_GetPTSLVersion":
            case 55:
                message.command = 55;
                break;
            case "GetPlaybackMode":
            case 56:
                message.command = 56;
                break;
            case "CId_GetPlaybackMode":
            case 56:
                message.command = 56;
                break;
            case "GetRecordMode":
            case 57:
                message.command = 57;
                break;
            case "CId_GetRecordMode":
            case 57:
                message.command = 57;
                break;
            case "GetTransportArmed":
            case 58:
                message.command = 58;
                break;
            case "CId_GetTransportArmed":
            case 58:
                message.command = 58;
                break;
            case "GetTransportState":
            case 59:
                message.command = 59;
                break;
            case "CId_GetTransportState":
            case 59:
                message.command = 59;
                break;
            case "ClearMemoryLocation":
            case 61:
                message.command = 61;
                break;
            case "CId_ClearMemoryLocation":
            case 61:
                message.command = 61;
                break;
            case "RenameSelectedClip":
            case 62:
                message.command = 62;
                break;
            case "CId_RenameSelectedClip":
            case 62:
                message.command = 62;
                break;
            case "RenameTargetClip":
            case 63:
                message.command = 63;
                break;
            case "CId_RenameTargetClip":
            case 63:
                message.command = 63;
                break;
            case "TogglePlayState":
            case 64:
                message.command = 64;
                break;
            case "CId_TogglePlayState":
            case 64:
                message.command = 64;
                break;
            case "ToggleRecordEnable":
            case 65:
                message.command = 65;
                break;
            case "CId_ToggleRecordEnable":
            case 65:
                message.command = 65;
                break;
            case "PlayHalfSpeed":
            case 66:
                message.command = 66;
                break;
            case "CId_PlayHalfSpeed":
            case 66:
                message.command = 66;
                break;
            case "RecordHalfSpeed":
            case 67:
                message.command = 67;
                break;
            case "CId_RecordHalfSpeed":
            case 67:
                message.command = 67;
                break;
            case "EditMemoryLocation":
            case 68:
                message.command = 68;
                break;
            case "CId_EditMemoryLocation":
            case 68:
                message.command = 68;
                break;
            case "GetMemoryLocations":
            case 69:
                message.command = 69;
                break;
            case "CId_GetMemoryLocations":
            case 69:
                message.command = 69;
                break;
            case "RegisterConnection":
            case 70:
                message.command = 70;
                break;
            case "CId_RegisterConnection":
            case 70:
                message.command = 70;
                break;
            case "CreateMemoryLocation":
            case 71:
                message.command = 71;
                break;
            case "CId_CreateMemoryLocation":
            case 71:
                message.command = 71;
                break;
            case "CreateNewTracks":
            case 72:
                message.command = 72;
                break;
            case "CId_CreateNewTracks":
            case 72:
                message.command = 72;
                break;
            case "SelectTracksByName":
            case 73:
                message.command = 73;
                break;
            case "CId_SelectTracksByName":
            case 73:
                message.command = 73;
                break;
            case "GetEditMode":
            case 74:
                message.command = 74;
                break;
            case "CId_GetEditMode":
            case 74:
                message.command = 74;
                break;
            case "SetEditMode":
            case 75:
                message.command = 75;
                break;
            case "CId_SetEditMode":
            case 75:
                message.command = 75;
                break;
            case "GetEditTool":
            case 76:
                message.command = 76;
                break;
            case "CId_GetEditTool":
            case 76:
                message.command = 76;
                break;
            case "SetEditTool":
            case 77:
                message.command = 77;
                break;
            case "CId_SetEditTool":
            case 77:
                message.command = 77;
                break;
            case "RecallZoomPreset":
            case 78:
                message.command = 78;
                break;
            case "CId_RecallZoomPreset":
            case 78:
                message.command = 78;
                break;
            case "GetEditModeOptions":
            case 79:
                message.command = 79;
                break;
            case "CId_GetEditModeOptions":
            case 79:
                message.command = 79;
                break;
            case "SetEditModeOptions":
            case 80:
                message.command = 80;
                break;
            case "CId_SetEditModeOptions":
            case 80:
                message.command = 80;
                break;
            case "SetTimelineSelection":
            case 81:
                message.command = 81;
                break;
            case "CId_SetTimelineSelection":
            case 81:
                message.command = 81;
                break;
            case "GetTimelineSelection":
            case 82:
                message.command = 82;
                break;
            case "CId_GetTimelineSelection":
            case 82:
                message.command = 82;
                break;
            case "ImportVideo":
            case 83:
                message.command = 83;
                break;
            case "CId_ImportVideo":
            case 83:
                message.command = 83;
                break;
            case "SelectMemoryLocation":
            case 84:
                message.command = 84;
                break;
            case "CId_SelectMemoryLocation":
            case 84:
                message.command = 84;
                break;
            case "SetTrackMuteState":
            case 85:
                message.command = 85;
                break;
            case "CId_SetTrackMuteState":
            case 85:
                message.command = 85;
                break;
            case "SetTrackSoloState":
            case 86:
                message.command = 86;
                break;
            case "CId_SetTrackSoloState":
            case 86:
                message.command = 86;
                break;
            case "SetTrackSoloSafeState":
            case 87:
                message.command = 87;
                break;
            case "CId_SetTrackSoloSafeState":
            case 87:
                message.command = 87;
                break;
            case "SetTrackRecordEnableState":
            case 88:
                message.command = 88;
                break;
            case "CId_SetTrackRecordEnableState":
            case 88:
                message.command = 88;
                break;
            case "SetTrackRecordSafeEnableState":
            case 89:
                message.command = 89;
                break;
            case "CId_SetTrackRecordSafeEnableState":
            case 89:
                message.command = 89;
                break;
            case "SetTrackInputMonitorState":
            case 90:
                message.command = 90;
                break;
            case "CId_SetTrackInputMonitorState":
            case 90:
                message.command = 90;
                break;
            case "SetTrackSmartDspState":
            case 91:
                message.command = 91;
                break;
            case "CId_SetTrackSmartDspState":
            case 91:
                message.command = 91;
                break;
            case "SetTrackHiddenState":
            case 92:
                message.command = 92;
                break;
            case "CId_SetTrackHiddenState":
            case 92:
                message.command = 92;
                break;
            case "SetTrackInactiveState":
            case 93:
                message.command = 93;
                break;
            case "CId_SetTrackInactiveState":
            case 93:
                message.command = 93;
                break;
            case "SetTrackFrozenState":
            case 94:
                message.command = 94;
                break;
            case "CId_SetTrackFrozenState":
            case 94:
                message.command = 94;
                break;
            case "SetTrackOnlineState":
            case 95:
                message.command = 95;
                break;
            case "CId_SetTrackOnlineState":
            case 95:
                message.command = 95;
                break;
            case "SetTrackOpenState":
            case 96:
                message.command = 96;
                break;
            case "CId_SetTrackOpenState":
            case 96:
                message.command = 96;
                break;
            case "GetSessionIDs":
            case 97:
                message.command = 97;
                break;
            case "CId_GetSessionIDs":
            case 97:
                message.command = 97;
                break;
            case "GetMemoryLocationsManageMode":
            case 98:
                message.command = 98;
                break;
            case "CId_GetMemoryLocationsManageMode":
            case 98:
                message.command = 98;
                break;
            case "SetMemoryLocationsManageMode":
            case 99:
                message.command = 99;
                break;
            case "CId_SetMemoryLocationsManageMode":
            case 99:
                message.command = 99;
                break;
            case "SetMainCounterFormat":
            case 100:
                message.command = 100;
                break;
            case "CId_SetMainCounterFormat":
            case 100:
                message.command = 100;
                break;
            case "SetSubCounterFormat":
            case 101:
                message.command = 101;
                break;
            case "CId_SetSubCounterFormat":
            case 101:
                message.command = 101;
                break;
            case "GetMainCounterFormat":
            case 102:
                message.command = 102;
                break;
            case "CId_GetMainCounterFormat":
            case 102:
                message.command = 102;
                break;
            case "GetSubCounterFormat":
            case 103:
                message.command = 103;
                break;
            case "CId_GetSubCounterFormat":
            case 103:
                message.command = 103;
                break;
            case "Undo":
            case 104:
                message.command = 104;
                break;
            case "CId_Undo":
            case 104:
                message.command = 104;
                break;
            case "Redo":
            case 105:
                message.command = 105;
                break;
            case "CId_Redo":
            case 105:
                message.command = 105;
                break;
            case "UndoAll":
            case 106:
                message.command = 106;
                break;
            case "CId_UndoAll":
            case 106:
                message.command = 106;
                break;
            case "RedoAll":
            case 107:
                message.command = 107;
                break;
            case "CId_RedoAll":
            case 107:
                message.command = 107;
                break;
            case "ClearUndoQueue":
            case 108:
                message.command = 108;
                break;
            case "CId_ClearUndoQueue":
            case 108:
                message.command = 108;
                break;
            case "SetTrackDSPModeSafeState":
            case 109:
                message.command = 109;
                break;
            case "CId_SetTrackDSPModeSafeState":
            case 109:
                message.command = 109;
                break;
            case "GetSessionSystemDelayInfo":
            case 110:
                message.command = 110;
                break;
            case "CId_GetSessionSystemDelayInfo":
            case 110:
                message.command = 110;
                break;
            case "GroupClips":
            case 111:
                message.command = 111;
                break;
            case "CId_GroupClips":
            case 111:
                message.command = 111;
                break;
            case "UngroupClips":
            case 112:
                message.command = 112;
                break;
            case "CId_UngroupClips":
            case 112:
                message.command = 112;
                break;
            case "UngroupAllClips":
            case 113:
                message.command = 113;
                break;
            case "CId_UngroupAllClips":
            case 113:
                message.command = 113;
                break;
            case "RegroupClips":
            case 114:
                message.command = 114;
                break;
            case "CId_RegroupClips":
            case 114:
                message.command = 114;
                break;
            case "RepeatSelection":
            case 115:
                message.command = 115;
                break;
            case "CId_RepeatSelection":
            case 115:
                message.command = 115;
                break;
            case "DuplicateSelection":
            case 116:
                message.command = 116;
                break;
            case "CId_DuplicateSelection":
            case 116:
                message.command = 116;
                break;
            case "ClearAllMemoryLocations":
            case 117:
                message.command = 117;
                break;
            case "CId_ClearAllMemoryLocations":
            case 117:
                message.command = 117;
                break;
            case "CId_GetTimeAsType":
            case 118:
                message.command = 118;
                break;
            case "CId_SubtractLocations":
            case 119:
                message.command = 119;
                break;
            case "CId_AddLengthToLocation":
            case 120:
                message.command = 120;
                break;
            case "CId_SubtractPositions":
            case 121:
                message.command = 121;
                break;
            case "CId_AddLengthToPosition":
            case 122:
                message.command = 122;
                break;
            case "CId_ImportAudioToClipList":
            case 123:
                message.command = 123;
                break;
            case "CId_SpotClipsByID":
            case 124:
                message.command = 124;
                break;
            case "CId_GetClipList":
            case 125:
                message.command = 125;
                break;
            case "CId_GetMediaFileInfo":
            case 126:
                message.command = 126;
                break;
            case "CId_CreateAudioClips":
            case 127:
                message.command = 127;
                break;
            case "CId_GetExportMixSourceList":
            case 128:
                message.command = 128;
                break;
            case "CId_CreateBatchJob":
            case 129:
                message.command = 129;
                break;
            case "CId_GetMonitorOutputPath":
            case 130:
                message.command = 130;
                break;
            case "CId_GetEditSelection":
            case 131:
                message.command = 131;
                break;
            case "CId_SubscribeToEvents":
            case 132:
                message.command = 132;
                break;
            case "CId_GetBatchJobStatus":
            case 133:
                message.command = 133;
                break;
            case "CId_BounceTrack":
            case 134:
                message.command = 134;
                break;
            case "CId_PollEvents":
            case 135:
                message.command = 135;
                break;
            case "CId_UnsubscribeFromEvents":
            case 136:
                message.command = 136;
                break;
            case "CId_CompleteBatchJob":
            case 137:
                message.command = 137;
                break;
            case "CId_CancelBatchJob":
            case 138:
                message.command = 138;
                break;
            case "CId_BeginScrub":
            case 139:
                message.command = 139;
                break;
            case "CId_EndScrub":
            case 140:
                message.command = 140;
                break;
            case "CId_ContinueScrub":
            case 141:
                message.command = 141;
                break;
            case "CId_EnableCueProVideoPlugIn":
            case 142:
                message.command = 142;
                break;
            case "CId_UpdateVideo":
            case 143:
                message.command = 143;
                break;
            case "CId_EnableAPI":
            case 144:
                message.command = 144;
                break;
            case "CId_ExchangePublicKeys":
            case 145:
                message.command = 145;
                break;
            }
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "Queued":
            case 0:
                message.status = 0;
                break;
            case "TStatus_Queued":
            case 0:
                message.status = 0;
                break;
            case "Pending":
            case 1:
                message.status = 1;
                break;
            case "TStatus_Pending":
            case 1:
                message.status = 1;
                break;
            case "InProgress":
            case 2:
                message.status = 2;
                break;
            case "TStatus_InProgress":
            case 2:
                message.status = 2;
                break;
            case "Completed":
            case 3:
                message.status = 3;
                break;
            case "TStatus_Completed":
            case 3:
                message.status = 3;
                break;
            case "Failed":
            case 4:
                message.status = 4;
                break;
            case "TStatus_Failed":
            case 4:
                message.status = 4;
                break;
            case "WaitingForUserInput":
            case 5:
                message.status = 5;
                break;
            case "TStatus_WaitingForUserInput":
            case 5:
                message.status = 5;
                break;
            case "CompletedWithBadResponse":
            case 6:
                message.status = 6;
                break;
            case "TStatus_CompletedWithBadResponse":
            case 6:
                message.status = 6;
                break;
            case "FailedWithBadErrorResponse":
            case 7:
                message.status = 7;
                break;
            case "TStatus_FailedWithBadErrorResponse":
            case 7:
                message.status = 7;
                break;
            }
            if (object.progress != null)
                message.progress = object.progress | 0;
            if (object.version != null)
                message.version = object.version | 0;
            if (object.versionMinor != null)
                message.versionMinor = object.versionMinor | 0;
            if (object.versionRevision != null)
                message.versionRevision = object.versionRevision | 0;
            if (object.versionedResponseHeaderJson != null)
                message.versionedResponseHeaderJson = String(object.versionedResponseHeaderJson);
            return message;
        };

        /**
         * Creates a plain object from a ResponseHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {ptsl.ResponseHeader} message ResponseHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.taskId = "";
                object.command = options.enums === String ? "CreateSession" : 0;
                object.status = options.enums === String ? "Queued" : 0;
                object.progress = 0;
                object.version = 0;
                object.versionMinor = 0;
                object.versionRevision = 0;
                object.versionedResponseHeaderJson = "";
            }
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = message.taskId;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = options.enums === String ? $root.ptsl.CommandId[message.command] === undefined ? message.command : $root.ptsl.CommandId[message.command] : message.command;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.ptsl.TaskStatus[message.status] === undefined ? message.status : $root.ptsl.TaskStatus[message.status] : message.status;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                object.versionMinor = message.versionMinor;
            if (message.versionRevision != null && message.hasOwnProperty("versionRevision"))
                object.versionRevision = message.versionRevision;
            if (message.versionedResponseHeaderJson != null && message.hasOwnProperty("versionedResponseHeaderJson"))
                object.versionedResponseHeaderJson = message.versionedResponseHeaderJson;
            return object;
        };

        /**
         * Converts this ResponseHeader to JSON.
         * @function toJSON
         * @memberof ptsl.ResponseHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ResponseHeader
         * @function getTypeUrl
         * @memberof ptsl.ResponseHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ResponseHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ResponseHeader";
        };

        return ResponseHeader;
    })();

    ptsl.VersionedResponseHeader = (function() {

        /**
         * Properties of a VersionedResponseHeader.
         * @memberof ptsl
         * @interface IVersionedResponseHeader
         */

        /**
         * Constructs a new VersionedResponseHeader.
         * @memberof ptsl
         * @classdesc Structure that describes versioned response header.
         * @since Pro Tools 2025.06
         * @implements IVersionedResponseHeader
         * @constructor
         * @param {ptsl.IVersionedResponseHeader=} [properties] Properties to set
         */
        function VersionedResponseHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new VersionedResponseHeader instance using the specified properties.
         * @function create
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {ptsl.IVersionedResponseHeader=} [properties] Properties to set
         * @returns {ptsl.VersionedResponseHeader} VersionedResponseHeader instance
         */
        VersionedResponseHeader.create = function create(properties) {
            return new VersionedResponseHeader(properties);
        };

        /**
         * Encodes the specified VersionedResponseHeader message. Does not implicitly {@link ptsl.VersionedResponseHeader.verify|verify} messages.
         * @function encode
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {ptsl.IVersionedResponseHeader} message VersionedResponseHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedResponseHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified VersionedResponseHeader message, length delimited. Does not implicitly {@link ptsl.VersionedResponseHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {ptsl.IVersionedResponseHeader} message VersionedResponseHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedResponseHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionedResponseHeader message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.VersionedResponseHeader} VersionedResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedResponseHeader.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.VersionedResponseHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VersionedResponseHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.VersionedResponseHeader} VersionedResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedResponseHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionedResponseHeader message.
         * @function verify
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionedResponseHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a VersionedResponseHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.VersionedResponseHeader} VersionedResponseHeader
         */
        VersionedResponseHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.VersionedResponseHeader)
                return object;
            return new $root.ptsl.VersionedResponseHeader();
        };

        /**
         * Creates a plain object from a VersionedResponseHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {ptsl.VersionedResponseHeader} message VersionedResponseHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionedResponseHeader.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this VersionedResponseHeader to JSON.
         * @function toJSON
         * @memberof ptsl.VersionedResponseHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionedResponseHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VersionedResponseHeader
         * @function getTypeUrl
         * @memberof ptsl.VersionedResponseHeader
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VersionedResponseHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.VersionedResponseHeader";
        };

        return VersionedResponseHeader;
    })();

    ptsl.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof ptsl
         * @interface IResponse
         * @property {ptsl.IResponseHeader|null} [header] Response header
         * @property {string|null} [responseBodyJson] Response responseBodyJson
         * @property {string|null} [responseErrorJson] Response responseErrorJson
         */

        /**
         * Constructs a new Response.
         * @memberof ptsl
         * @classdesc Structure that describes Pro Tools response.
         * @implements IResponse
         * @constructor
         * @param {ptsl.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response header.
         * @member {ptsl.IResponseHeader|null|undefined} header
         * @memberof ptsl.Response
         * @instance
         */
        Response.prototype.header = null;

        /**
         * Response responseBodyJson.
         * @member {string} responseBodyJson
         * @memberof ptsl.Response
         * @instance
         */
        Response.prototype.responseBodyJson = "";

        /**
         * Response responseErrorJson.
         * @member {string} responseErrorJson
         * @memberof ptsl.Response
         * @instance
         */
        Response.prototype.responseErrorJson = "";

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof ptsl.Response
         * @static
         * @param {ptsl.IResponse=} [properties] Properties to set
         * @returns {ptsl.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link ptsl.Response.verify|verify} messages.
         * @function encode
         * @memberof ptsl.Response
         * @static
         * @param {ptsl.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                $root.ptsl.ResponseHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.responseBodyJson != null && Object.hasOwnProperty.call(message, "responseBodyJson"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.responseBodyJson);
            if (message.responseErrorJson != null && Object.hasOwnProperty.call(message, "responseErrorJson"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.responseErrorJson);
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link ptsl.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.Response
         * @static
         * @param {ptsl.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.header = $root.ptsl.ResponseHeader.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.responseBodyJson = reader.string();
                        break;
                    }
                case 3: {
                        message.responseErrorJson = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof ptsl.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.header != null && message.hasOwnProperty("header")) {
                var error = $root.ptsl.ResponseHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.responseBodyJson != null && message.hasOwnProperty("responseBodyJson"))
                if (!$util.isString(message.responseBodyJson))
                    return "responseBodyJson: string expected";
            if (message.responseErrorJson != null && message.hasOwnProperty("responseErrorJson"))
                if (!$util.isString(message.responseErrorJson))
                    return "responseErrorJson: string expected";
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.Response)
                return object;
            var message = new $root.ptsl.Response();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".ptsl.Response.header: object expected");
                message.header = $root.ptsl.ResponseHeader.fromObject(object.header);
            }
            if (object.responseBodyJson != null)
                message.responseBodyJson = String(object.responseBodyJson);
            if (object.responseErrorJson != null)
                message.responseErrorJson = String(object.responseErrorJson);
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.Response
         * @static
         * @param {ptsl.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.responseBodyJson = "";
                object.responseErrorJson = "";
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.ptsl.ResponseHeader.toObject(message.header, options);
            if (message.responseBodyJson != null && message.hasOwnProperty("responseBodyJson"))
                object.responseBodyJson = message.responseBodyJson;
            if (message.responseErrorJson != null && message.hasOwnProperty("responseErrorJson"))
                object.responseErrorJson = message.responseErrorJson;
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof ptsl.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Response
         * @function getTypeUrl
         * @memberof ptsl.Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.Response";
        };

        return Response;
    })();

    ptsl.EventRequestData = (function() {

        /**
         * Properties of an EventRequestData.
         * @memberof ptsl
         * @interface IEventRequestData
         * @property {ptsl.EventId|null} [eventId] * Event ID.
         * @property {string|null} [eventDataJson] * JSON string of filtering parameters.
         */

        /**
         * Constructs a new EventRequestData.
         * @memberof ptsl
         * @classdesc Structure that describes Pro Tools event request and its filtering parameters.
         * 
         * @since Pro Tools 2025.06
         * @implements IEventRequestData
         * @constructor
         * @param {ptsl.IEventRequestData=} [properties] Properties to set
         */
        function EventRequestData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Event ID.
         * @member {ptsl.EventId} eventId
         * @memberof ptsl.EventRequestData
         * @instance
         */
        EventRequestData.prototype.eventId = 0;

        /**
         * * JSON string of filtering parameters.
         * @member {string} eventDataJson
         * @memberof ptsl.EventRequestData
         * @instance
         */
        EventRequestData.prototype.eventDataJson = "";

        /**
         * Creates a new EventRequestData instance using the specified properties.
         * @function create
         * @memberof ptsl.EventRequestData
         * @static
         * @param {ptsl.IEventRequestData=} [properties] Properties to set
         * @returns {ptsl.EventRequestData} EventRequestData instance
         */
        EventRequestData.create = function create(properties) {
            return new EventRequestData(properties);
        };

        /**
         * Encodes the specified EventRequestData message. Does not implicitly {@link ptsl.EventRequestData.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EventRequestData
         * @static
         * @param {ptsl.IEventRequestData} message EventRequestData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRequestData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventId != null && Object.hasOwnProperty.call(message, "eventId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventId);
            if (message.eventDataJson != null && Object.hasOwnProperty.call(message, "eventDataJson"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.eventDataJson);
            return writer;
        };

        /**
         * Encodes the specified EventRequestData message, length delimited. Does not implicitly {@link ptsl.EventRequestData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EventRequestData
         * @static
         * @param {ptsl.IEventRequestData} message EventRequestData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventRequestData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventRequestData message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EventRequestData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EventRequestData} EventRequestData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRequestData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EventRequestData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.eventId = reader.int32();
                        break;
                    }
                case 2: {
                        message.eventDataJson = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventRequestData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EventRequestData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EventRequestData} EventRequestData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventRequestData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventRequestData message.
         * @function verify
         * @memberof ptsl.EventRequestData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventRequestData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                switch (message.eventId) {
                default:
                    return "eventId: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.eventDataJson != null && message.hasOwnProperty("eventDataJson"))
                if (!$util.isString(message.eventDataJson))
                    return "eventDataJson: string expected";
            return null;
        };

        /**
         * Creates an EventRequestData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EventRequestData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EventRequestData} EventRequestData
         */
        EventRequestData.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EventRequestData)
                return object;
            var message = new $root.ptsl.EventRequestData();
            switch (object.eventId) {
            default:
                if (typeof object.eventId === "number") {
                    message.eventId = object.eventId;
                    break;
                }
                break;
            case "EId_Unknown":
            case 0:
                message.eventId = 0;
                break;
            case "EId_SessionOpened":
            case 1:
                message.eventId = 1;
                break;
            case "EId_SessionCreated":
            case 2:
                message.eventId = 2;
                break;
            case "EId_SessionClosed":
            case 3:
                message.eventId = 3;
                break;
            }
            if (object.eventDataJson != null)
                message.eventDataJson = String(object.eventDataJson);
            return message;
        };

        /**
         * Creates a plain object from an EventRequestData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EventRequestData
         * @static
         * @param {ptsl.EventRequestData} message EventRequestData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventRequestData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eventId = options.enums === String ? "EId_Unknown" : 0;
                object.eventDataJson = "";
            }
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                object.eventId = options.enums === String ? $root.ptsl.EventId[message.eventId] === undefined ? message.eventId : $root.ptsl.EventId[message.eventId] : message.eventId;
            if (message.eventDataJson != null && message.hasOwnProperty("eventDataJson"))
                object.eventDataJson = message.eventDataJson;
            return object;
        };

        /**
         * Converts this EventRequestData to JSON.
         * @function toJSON
         * @memberof ptsl.EventRequestData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventRequestData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EventRequestData
         * @function getTypeUrl
         * @memberof ptsl.EventRequestData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EventRequestData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EventRequestData";
        };

        return EventRequestData;
    })();

    ptsl.EventResponseData = (function() {

        /**
         * Properties of an EventResponseData.
         * @memberof ptsl
         * @interface IEventResponseData
         * @property {ptsl.EventId|null} [eventId] * Event ID.
         * @property {string|null} [eventDataJson] * JSON string of event data.
         */

        /**
         * Constructs a new EventResponseData.
         * @memberof ptsl
         * @classdesc Structure that describes Pro Tools event response and its data.
         * 
         * @since Pro Tools 2025.06
         * @implements IEventResponseData
         * @constructor
         * @param {ptsl.IEventResponseData=} [properties] Properties to set
         */
        function EventResponseData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Event ID.
         * @member {ptsl.EventId} eventId
         * @memberof ptsl.EventResponseData
         * @instance
         */
        EventResponseData.prototype.eventId = 0;

        /**
         * * JSON string of event data.
         * @member {string} eventDataJson
         * @memberof ptsl.EventResponseData
         * @instance
         */
        EventResponseData.prototype.eventDataJson = "";

        /**
         * Creates a new EventResponseData instance using the specified properties.
         * @function create
         * @memberof ptsl.EventResponseData
         * @static
         * @param {ptsl.IEventResponseData=} [properties] Properties to set
         * @returns {ptsl.EventResponseData} EventResponseData instance
         */
        EventResponseData.create = function create(properties) {
            return new EventResponseData(properties);
        };

        /**
         * Encodes the specified EventResponseData message. Does not implicitly {@link ptsl.EventResponseData.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EventResponseData
         * @static
         * @param {ptsl.IEventResponseData} message EventResponseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventId != null && Object.hasOwnProperty.call(message, "eventId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventId);
            if (message.eventDataJson != null && Object.hasOwnProperty.call(message, "eventDataJson"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.eventDataJson);
            return writer;
        };

        /**
         * Encodes the specified EventResponseData message, length delimited. Does not implicitly {@link ptsl.EventResponseData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EventResponseData
         * @static
         * @param {ptsl.IEventResponseData} message EventResponseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventResponseData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventResponseData message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EventResponseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EventResponseData} EventResponseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventResponseData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EventResponseData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.eventId = reader.int32();
                        break;
                    }
                case 2: {
                        message.eventDataJson = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventResponseData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EventResponseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EventResponseData} EventResponseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventResponseData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventResponseData message.
         * @function verify
         * @memberof ptsl.EventResponseData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventResponseData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                switch (message.eventId) {
                default:
                    return "eventId: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.eventDataJson != null && message.hasOwnProperty("eventDataJson"))
                if (!$util.isString(message.eventDataJson))
                    return "eventDataJson: string expected";
            return null;
        };

        /**
         * Creates an EventResponseData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EventResponseData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EventResponseData} EventResponseData
         */
        EventResponseData.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EventResponseData)
                return object;
            var message = new $root.ptsl.EventResponseData();
            switch (object.eventId) {
            default:
                if (typeof object.eventId === "number") {
                    message.eventId = object.eventId;
                    break;
                }
                break;
            case "EId_Unknown":
            case 0:
                message.eventId = 0;
                break;
            case "EId_SessionOpened":
            case 1:
                message.eventId = 1;
                break;
            case "EId_SessionCreated":
            case 2:
                message.eventId = 2;
                break;
            case "EId_SessionClosed":
            case 3:
                message.eventId = 3;
                break;
            }
            if (object.eventDataJson != null)
                message.eventDataJson = String(object.eventDataJson);
            return message;
        };

        /**
         * Creates a plain object from an EventResponseData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EventResponseData
         * @static
         * @param {ptsl.EventResponseData} message EventResponseData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventResponseData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eventId = options.enums === String ? "EId_Unknown" : 0;
                object.eventDataJson = "";
            }
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                object.eventId = options.enums === String ? $root.ptsl.EventId[message.eventId] === undefined ? message.eventId : $root.ptsl.EventId[message.eventId] : message.eventId;
            if (message.eventDataJson != null && message.hasOwnProperty("eventDataJson"))
                object.eventDataJson = message.eventDataJson;
            return object;
        };

        /**
         * Converts this EventResponseData to JSON.
         * @function toJSON
         * @memberof ptsl.EventResponseData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventResponseData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EventResponseData
         * @function getTypeUrl
         * @memberof ptsl.EventResponseData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EventResponseData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EventResponseData";
        };

        return EventResponseData;
    })();

    ptsl.PaginationRequest = (function() {

        /**
         * Properties of a PaginationRequest.
         * @memberof ptsl
         * @interface IPaginationRequest
         * @property {number|null} [limit] PaginationRequest limit
         * @property {number|null} [offset] PaginationRequest offset
         */

        /**
         * Constructs a new PaginationRequest.
         * @memberof ptsl
         * @classdesc Structure that describes pagination request parameters for responses with large lists of data.
         * @implements IPaginationRequest
         * @constructor
         * @param {ptsl.IPaginationRequest=} [properties] Properties to set
         */
        function PaginationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaginationRequest limit.
         * @member {number} limit
         * @memberof ptsl.PaginationRequest
         * @instance
         */
        PaginationRequest.prototype.limit = 0;

        /**
         * PaginationRequest offset.
         * @member {number} offset
         * @memberof ptsl.PaginationRequest
         * @instance
         */
        PaginationRequest.prototype.offset = 0;

        /**
         * Creates a new PaginationRequest instance using the specified properties.
         * @function create
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {ptsl.IPaginationRequest=} [properties] Properties to set
         * @returns {ptsl.PaginationRequest} PaginationRequest instance
         */
        PaginationRequest.create = function create(properties) {
            return new PaginationRequest(properties);
        };

        /**
         * Encodes the specified PaginationRequest message. Does not implicitly {@link ptsl.PaginationRequest.verify|verify} messages.
         * @function encode
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {ptsl.IPaginationRequest} message PaginationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaginationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.offset);
            return writer;
        };

        /**
         * Encodes the specified PaginationRequest message, length delimited. Does not implicitly {@link ptsl.PaginationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {ptsl.IPaginationRequest} message PaginationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaginationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaginationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.PaginationRequest} PaginationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaginationRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.PaginationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.limit = reader.int32();
                        break;
                    }
                case 2: {
                        message.offset = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaginationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.PaginationRequest} PaginationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaginationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaginationRequest message.
         * @function verify
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaginationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            return null;
        };

        /**
         * Creates a PaginationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.PaginationRequest} PaginationRequest
         */
        PaginationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.PaginationRequest)
                return object;
            var message = new $root.ptsl.PaginationRequest();
            if (object.limit != null)
                message.limit = object.limit | 0;
            if (object.offset != null)
                message.offset = object.offset | 0;
            return message;
        };

        /**
         * Creates a plain object from a PaginationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {ptsl.PaginationRequest} message PaginationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaginationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.limit = 0;
                object.offset = 0;
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this PaginationRequest to JSON.
         * @function toJSON
         * @memberof ptsl.PaginationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaginationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PaginationRequest
         * @function getTypeUrl
         * @memberof ptsl.PaginationRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PaginationRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.PaginationRequest";
        };

        return PaginationRequest;
    })();

    ptsl.Pagination = (function() {

        /**
         * Properties of a Pagination.
         * @memberof ptsl
         * @interface IPagination
         * @property {number|null} [total] Pagination total
         * @property {number|null} [limit] Pagination limit
         * @property {number|null} [offset] Pagination offset
         */

        /**
         * Constructs a new Pagination.
         * @memberof ptsl
         * @classdesc @deprecated since Pro Tools 2023.09, use PaginationRequest
         * Structure that describes pagination request parameters for responses with large lists of data.
         * @implements IPagination
         * @constructor
         * @param {ptsl.IPagination=} [properties] Properties to set
         */
        function Pagination(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Pagination total.
         * @member {number} total
         * @memberof ptsl.Pagination
         * @instance
         */
        Pagination.prototype.total = 0;

        /**
         * Pagination limit.
         * @member {number} limit
         * @memberof ptsl.Pagination
         * @instance
         */
        Pagination.prototype.limit = 0;

        /**
         * Pagination offset.
         * @member {number} offset
         * @memberof ptsl.Pagination
         * @instance
         */
        Pagination.prototype.offset = 0;

        /**
         * Creates a new Pagination instance using the specified properties.
         * @function create
         * @memberof ptsl.Pagination
         * @static
         * @param {ptsl.IPagination=} [properties] Properties to set
         * @returns {ptsl.Pagination} Pagination instance
         */
        Pagination.create = function create(properties) {
            return new Pagination(properties);
        };

        /**
         * Encodes the specified Pagination message. Does not implicitly {@link ptsl.Pagination.verify|verify} messages.
         * @function encode
         * @memberof ptsl.Pagination
         * @static
         * @param {ptsl.IPagination} message Pagination message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pagination.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.total);
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.offset);
            return writer;
        };

        /**
         * Encodes the specified Pagination message, length delimited. Does not implicitly {@link ptsl.Pagination.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.Pagination
         * @static
         * @param {ptsl.IPagination} message Pagination message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pagination.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Pagination message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.Pagination
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.Pagination} Pagination
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pagination.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.Pagination();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.total = reader.int32();
                        break;
                    }
                case 2: {
                        message.limit = reader.int32();
                        break;
                    }
                case 3: {
                        message.offset = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Pagination message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.Pagination
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.Pagination} Pagination
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pagination.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Pagination message.
         * @function verify
         * @memberof ptsl.Pagination
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pagination.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isInteger(message.total))
                    return "total: integer expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            return null;
        };

        /**
         * Creates a Pagination message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.Pagination
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.Pagination} Pagination
         */
        Pagination.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.Pagination)
                return object;
            var message = new $root.ptsl.Pagination();
            if (object.total != null)
                message.total = object.total | 0;
            if (object.limit != null)
                message.limit = object.limit | 0;
            if (object.offset != null)
                message.offset = object.offset | 0;
            return message;
        };

        /**
         * Creates a plain object from a Pagination message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.Pagination
         * @static
         * @param {ptsl.Pagination} message Pagination
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pagination.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.total = 0;
                object.limit = 0;
                object.offset = 0;
            }
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = message.total;
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this Pagination to JSON.
         * @function toJSON
         * @memberof ptsl.Pagination
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pagination.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Pagination
         * @function getTypeUrl
         * @memberof ptsl.Pagination
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Pagination.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.Pagination";
        };

        return Pagination;
    })();

    ptsl.PaginationResponse = (function() {

        /**
         * Properties of a PaginationResponse.
         * @memberof ptsl
         * @interface IPaginationResponse
         * @property {number|null} [total] PaginationResponse total
         * @property {number|null} [limit] PaginationResponse limit
         * @property {number|null} [offset] PaginationResponse offset
         */

        /**
         * Constructs a new PaginationResponse.
         * @memberof ptsl
         * @classdesc Structure that describes pagination for large lists of data in responses.
         * @implements IPaginationResponse
         * @constructor
         * @param {ptsl.IPaginationResponse=} [properties] Properties to set
         */
        function PaginationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaginationResponse total.
         * @member {number} total
         * @memberof ptsl.PaginationResponse
         * @instance
         */
        PaginationResponse.prototype.total = 0;

        /**
         * PaginationResponse limit.
         * @member {number} limit
         * @memberof ptsl.PaginationResponse
         * @instance
         */
        PaginationResponse.prototype.limit = 0;

        /**
         * PaginationResponse offset.
         * @member {number} offset
         * @memberof ptsl.PaginationResponse
         * @instance
         */
        PaginationResponse.prototype.offset = 0;

        /**
         * Creates a new PaginationResponse instance using the specified properties.
         * @function create
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {ptsl.IPaginationResponse=} [properties] Properties to set
         * @returns {ptsl.PaginationResponse} PaginationResponse instance
         */
        PaginationResponse.create = function create(properties) {
            return new PaginationResponse(properties);
        };

        /**
         * Encodes the specified PaginationResponse message. Does not implicitly {@link ptsl.PaginationResponse.verify|verify} messages.
         * @function encode
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {ptsl.IPaginationResponse} message PaginationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaginationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.total);
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.offset);
            return writer;
        };

        /**
         * Encodes the specified PaginationResponse message, length delimited. Does not implicitly {@link ptsl.PaginationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {ptsl.IPaginationResponse} message PaginationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaginationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaginationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.PaginationResponse} PaginationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaginationResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.PaginationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.total = reader.int32();
                        break;
                    }
                case 2: {
                        message.limit = reader.int32();
                        break;
                    }
                case 3: {
                        message.offset = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaginationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.PaginationResponse} PaginationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaginationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaginationResponse message.
         * @function verify
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaginationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isInteger(message.total))
                    return "total: integer expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            return null;
        };

        /**
         * Creates a PaginationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.PaginationResponse} PaginationResponse
         */
        PaginationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.PaginationResponse)
                return object;
            var message = new $root.ptsl.PaginationResponse();
            if (object.total != null)
                message.total = object.total | 0;
            if (object.limit != null)
                message.limit = object.limit | 0;
            if (object.offset != null)
                message.offset = object.offset | 0;
            return message;
        };

        /**
         * Creates a plain object from a PaginationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {ptsl.PaginationResponse} message PaginationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaginationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.total = 0;
                object.limit = 0;
                object.offset = 0;
            }
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = message.total;
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this PaginationResponse to JSON.
         * @function toJSON
         * @memberof ptsl.PaginationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaginationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PaginationResponse
         * @function getTypeUrl
         * @memberof ptsl.PaginationResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PaginationResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.PaginationResponse";
        };

        return PaginationResponse;
    })();

    /**
     * Type of the state and the way a track attribute is set.
     * @name ptsl.TrackAttributeState
     * @enum {number}
     * @property {number} TAState_Unknown=0 TAState_Unknown value
     * @property {number} None=1 * @deprecated since Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackAttributeState::TAState_None
     * @property {number} TAState_None=1 TAState_None value
     * @property {number} SetExplicitly=2 * @deprecated since Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackAttributeState::TAState_SetExplicitly
     * @property {number} TAState_SetExplicitly=2 TAState_SetExplicitly value
     * @property {number} SetImplicitly=3 * @deprecated since Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackAttributeState::TAState_SetImplicitly
     * @property {number} TAState_SetImplicitly=3 TAState_SetImplicitly value
     * @property {number} SetExplicitlyAndImplicitly=4 * @deprecated since Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackAttributeState::TAState_SetExplicitlyAndImplicitly
     * @property {number} TAState_SetExplicitlyAndImplicitly=4 TAState_SetExplicitlyAndImplicitly value
     */
    ptsl.TrackAttributeState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TAState_Unknown"] = 0;
        values[valuesById[1] = "None"] = 1;
        values["TAState_None"] = 1;
        values[valuesById[2] = "SetExplicitly"] = 2;
        values["TAState_SetExplicitly"] = 2;
        values[valuesById[3] = "SetImplicitly"] = 3;
        values["TAState_SetImplicitly"] = 3;
        values[valuesById[4] = "SetExplicitlyAndImplicitly"] = 4;
        values["TAState_SetExplicitlyAndImplicitly"] = 4;
        return values;
    })();

    ptsl.TrackAttributes = (function() {

        /**
         * Properties of a TrackAttributes.
         * @memberof ptsl
         * @interface ITrackAttributes
         * @property {ptsl.TrackAttributeState|null} [isInactive] TrackAttributes isInactive
         * @property {ptsl.TrackAttributeState|null} [isHidden] TrackAttributes isHidden
         * @property {ptsl.TrackAttributeState|null} [isSelected] TrackAttributes isSelected
         * @property {boolean|null} [containsClips] TrackAttributes containsClips
         * @property {boolean|null} [containsAutomation] TrackAttributes containsAutomation
         * @property {boolean|null} [isSoloed] TrackAttributes isSoloed
         * @property {boolean|null} [isRecordEnabled] TrackAttributes isRecordEnabled
         * @property {ptsl.TrackAttributeState|null} [isInputMonitoringOn] TrackAttributes isInputMonitoringOn
         * @property {boolean|null} [isSmartDspOn] TrackAttributes isSmartDspOn
         * @property {boolean|null} [isLocked] TrackAttributes isLocked
         * @property {boolean|null} [isMuted] TrackAttributes isMuted
         * @property {boolean|null} [isFrozen] TrackAttributes isFrozen
         * @property {boolean|null} [isOpen] TrackAttributes isOpen
         * @property {boolean|null} [isOnline] TrackAttributes isOnline
         * @property {boolean|null} [isRecordEnabledSafe] TrackAttributes isRecordEnabledSafe
         * @property {boolean|null} [isSmartDspOnSafe] TrackAttributes isSmartDspOnSafe
         * @property {boolean|null} [isSoloedSafe] TrackAttributes isSoloedSafe
         * @property {ptsl.TrackAttributeState|null} [hasEditSelection] TrackAttributes hasEditSelection
         */

        /**
         * Constructs a new TrackAttributes.
         * @memberof ptsl
         * @classdesc Structure that describes Pro Tools track attributes.
         * @implements ITrackAttributes
         * @constructor
         * @param {ptsl.ITrackAttributes=} [properties] Properties to set
         */
        function TrackAttributes(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrackAttributes isInactive.
         * @member {ptsl.TrackAttributeState} isInactive
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isInactive = 0;

        /**
         * TrackAttributes isHidden.
         * @member {ptsl.TrackAttributeState} isHidden
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isHidden = 0;

        /**
         * TrackAttributes isSelected.
         * @member {ptsl.TrackAttributeState} isSelected
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isSelected = 0;

        /**
         * TrackAttributes containsClips.
         * @member {boolean} containsClips
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.containsClips = false;

        /**
         * TrackAttributes containsAutomation.
         * @member {boolean} containsAutomation
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.containsAutomation = false;

        /**
         * TrackAttributes isSoloed.
         * @member {boolean} isSoloed
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isSoloed = false;

        /**
         * TrackAttributes isRecordEnabled.
         * @member {boolean} isRecordEnabled
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isRecordEnabled = false;

        /**
         * TrackAttributes isInputMonitoringOn.
         * @member {ptsl.TrackAttributeState} isInputMonitoringOn
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isInputMonitoringOn = 0;

        /**
         * TrackAttributes isSmartDspOn.
         * @member {boolean} isSmartDspOn
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isSmartDspOn = false;

        /**
         * TrackAttributes isLocked.
         * @member {boolean} isLocked
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isLocked = false;

        /**
         * TrackAttributes isMuted.
         * @member {boolean} isMuted
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isMuted = false;

        /**
         * TrackAttributes isFrozen.
         * @member {boolean} isFrozen
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isFrozen = false;

        /**
         * TrackAttributes isOpen.
         * @member {boolean} isOpen
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isOpen = false;

        /**
         * TrackAttributes isOnline.
         * @member {boolean} isOnline
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isOnline = false;

        /**
         * TrackAttributes isRecordEnabledSafe.
         * @member {boolean} isRecordEnabledSafe
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isRecordEnabledSafe = false;

        /**
         * TrackAttributes isSmartDspOnSafe.
         * @member {boolean} isSmartDspOnSafe
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isSmartDspOnSafe = false;

        /**
         * TrackAttributes isSoloedSafe.
         * @member {boolean} isSoloedSafe
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.isSoloedSafe = false;

        /**
         * TrackAttributes hasEditSelection.
         * @member {ptsl.TrackAttributeState} hasEditSelection
         * @memberof ptsl.TrackAttributes
         * @instance
         */
        TrackAttributes.prototype.hasEditSelection = 0;

        /**
         * Creates a new TrackAttributes instance using the specified properties.
         * @function create
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {ptsl.ITrackAttributes=} [properties] Properties to set
         * @returns {ptsl.TrackAttributes} TrackAttributes instance
         */
        TrackAttributes.create = function create(properties) {
            return new TrackAttributes(properties);
        };

        /**
         * Encodes the specified TrackAttributes message. Does not implicitly {@link ptsl.TrackAttributes.verify|verify} messages.
         * @function encode
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {ptsl.ITrackAttributes} message TrackAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackAttributes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isInactive != null && Object.hasOwnProperty.call(message, "isInactive"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isInactive);
            if (message.isHidden != null && Object.hasOwnProperty.call(message, "isHidden"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isHidden);
            if (message.isSelected != null && Object.hasOwnProperty.call(message, "isSelected"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isSelected);
            if (message.containsClips != null && Object.hasOwnProperty.call(message, "containsClips"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.containsClips);
            if (message.containsAutomation != null && Object.hasOwnProperty.call(message, "containsAutomation"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.containsAutomation);
            if (message.isSoloed != null && Object.hasOwnProperty.call(message, "isSoloed"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isSoloed);
            if (message.isRecordEnabled != null && Object.hasOwnProperty.call(message, "isRecordEnabled"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isRecordEnabled);
            if (message.isInputMonitoringOn != null && Object.hasOwnProperty.call(message, "isInputMonitoringOn"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.isInputMonitoringOn);
            if (message.isSmartDspOn != null && Object.hasOwnProperty.call(message, "isSmartDspOn"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isSmartDspOn);
            if (message.isLocked != null && Object.hasOwnProperty.call(message, "isLocked"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isLocked);
            if (message.isMuted != null && Object.hasOwnProperty.call(message, "isMuted"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isMuted);
            if (message.isFrozen != null && Object.hasOwnProperty.call(message, "isFrozen"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.isFrozen);
            if (message.isOpen != null && Object.hasOwnProperty.call(message, "isOpen"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.isOpen);
            if (message.isOnline != null && Object.hasOwnProperty.call(message, "isOnline"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isOnline);
            if (message.isRecordEnabledSafe != null && Object.hasOwnProperty.call(message, "isRecordEnabledSafe"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.isRecordEnabledSafe);
            if (message.isSmartDspOnSafe != null && Object.hasOwnProperty.call(message, "isSmartDspOnSafe"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isSmartDspOnSafe);
            if (message.isSoloedSafe != null && Object.hasOwnProperty.call(message, "isSoloedSafe"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.isSoloedSafe);
            if (message.hasEditSelection != null && Object.hasOwnProperty.call(message, "hasEditSelection"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.hasEditSelection);
            return writer;
        };

        /**
         * Encodes the specified TrackAttributes message, length delimited. Does not implicitly {@link ptsl.TrackAttributes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {ptsl.ITrackAttributes} message TrackAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackAttributes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrackAttributes message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.TrackAttributes} TrackAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackAttributes.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.TrackAttributes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.isInactive = reader.int32();
                        break;
                    }
                case 2: {
                        message.isHidden = reader.int32();
                        break;
                    }
                case 3: {
                        message.isSelected = reader.int32();
                        break;
                    }
                case 4: {
                        message.containsClips = reader.bool();
                        break;
                    }
                case 5: {
                        message.containsAutomation = reader.bool();
                        break;
                    }
                case 6: {
                        message.isSoloed = reader.bool();
                        break;
                    }
                case 7: {
                        message.isRecordEnabled = reader.bool();
                        break;
                    }
                case 8: {
                        message.isInputMonitoringOn = reader.int32();
                        break;
                    }
                case 9: {
                        message.isSmartDspOn = reader.bool();
                        break;
                    }
                case 10: {
                        message.isLocked = reader.bool();
                        break;
                    }
                case 11: {
                        message.isMuted = reader.bool();
                        break;
                    }
                case 12: {
                        message.isFrozen = reader.bool();
                        break;
                    }
                case 13: {
                        message.isOpen = reader.bool();
                        break;
                    }
                case 14: {
                        message.isOnline = reader.bool();
                        break;
                    }
                case 15: {
                        message.isRecordEnabledSafe = reader.bool();
                        break;
                    }
                case 16: {
                        message.isSmartDspOnSafe = reader.bool();
                        break;
                    }
                case 17: {
                        message.isSoloedSafe = reader.bool();
                        break;
                    }
                case 18: {
                        message.hasEditSelection = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrackAttributes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.TrackAttributes} TrackAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackAttributes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrackAttributes message.
         * @function verify
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrackAttributes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isInactive != null && message.hasOwnProperty("isInactive"))
                switch (message.isInactive) {
                default:
                    return "isInactive: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.isHidden != null && message.hasOwnProperty("isHidden"))
                switch (message.isHidden) {
                default:
                    return "isHidden: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                switch (message.isSelected) {
                default:
                    return "isSelected: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.containsClips != null && message.hasOwnProperty("containsClips"))
                if (typeof message.containsClips !== "boolean")
                    return "containsClips: boolean expected";
            if (message.containsAutomation != null && message.hasOwnProperty("containsAutomation"))
                if (typeof message.containsAutomation !== "boolean")
                    return "containsAutomation: boolean expected";
            if (message.isSoloed != null && message.hasOwnProperty("isSoloed"))
                if (typeof message.isSoloed !== "boolean")
                    return "isSoloed: boolean expected";
            if (message.isRecordEnabled != null && message.hasOwnProperty("isRecordEnabled"))
                if (typeof message.isRecordEnabled !== "boolean")
                    return "isRecordEnabled: boolean expected";
            if (message.isInputMonitoringOn != null && message.hasOwnProperty("isInputMonitoringOn"))
                switch (message.isInputMonitoringOn) {
                default:
                    return "isInputMonitoringOn: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.isSmartDspOn != null && message.hasOwnProperty("isSmartDspOn"))
                if (typeof message.isSmartDspOn !== "boolean")
                    return "isSmartDspOn: boolean expected";
            if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                if (typeof message.isLocked !== "boolean")
                    return "isLocked: boolean expected";
            if (message.isMuted != null && message.hasOwnProperty("isMuted"))
                if (typeof message.isMuted !== "boolean")
                    return "isMuted: boolean expected";
            if (message.isFrozen != null && message.hasOwnProperty("isFrozen"))
                if (typeof message.isFrozen !== "boolean")
                    return "isFrozen: boolean expected";
            if (message.isOpen != null && message.hasOwnProperty("isOpen"))
                if (typeof message.isOpen !== "boolean")
                    return "isOpen: boolean expected";
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                if (typeof message.isOnline !== "boolean")
                    return "isOnline: boolean expected";
            if (message.isRecordEnabledSafe != null && message.hasOwnProperty("isRecordEnabledSafe"))
                if (typeof message.isRecordEnabledSafe !== "boolean")
                    return "isRecordEnabledSafe: boolean expected";
            if (message.isSmartDspOnSafe != null && message.hasOwnProperty("isSmartDspOnSafe"))
                if (typeof message.isSmartDspOnSafe !== "boolean")
                    return "isSmartDspOnSafe: boolean expected";
            if (message.isSoloedSafe != null && message.hasOwnProperty("isSoloedSafe"))
                if (typeof message.isSoloedSafe !== "boolean")
                    return "isSoloedSafe: boolean expected";
            if (message.hasEditSelection != null && message.hasOwnProperty("hasEditSelection"))
                switch (message.hasEditSelection) {
                default:
                    return "hasEditSelection: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a TrackAttributes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.TrackAttributes} TrackAttributes
         */
        TrackAttributes.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.TrackAttributes)
                return object;
            var message = new $root.ptsl.TrackAttributes();
            switch (object.isInactive) {
            default:
                if (typeof object.isInactive === "number") {
                    message.isInactive = object.isInactive;
                    break;
                }
                break;
            case "TAState_Unknown":
            case 0:
                message.isInactive = 0;
                break;
            case "None":
            case 1:
                message.isInactive = 1;
                break;
            case "TAState_None":
            case 1:
                message.isInactive = 1;
                break;
            case "SetExplicitly":
            case 2:
                message.isInactive = 2;
                break;
            case "TAState_SetExplicitly":
            case 2:
                message.isInactive = 2;
                break;
            case "SetImplicitly":
            case 3:
                message.isInactive = 3;
                break;
            case "TAState_SetImplicitly":
            case 3:
                message.isInactive = 3;
                break;
            case "SetExplicitlyAndImplicitly":
            case 4:
                message.isInactive = 4;
                break;
            case "TAState_SetExplicitlyAndImplicitly":
            case 4:
                message.isInactive = 4;
                break;
            }
            switch (object.isHidden) {
            default:
                if (typeof object.isHidden === "number") {
                    message.isHidden = object.isHidden;
                    break;
                }
                break;
            case "TAState_Unknown":
            case 0:
                message.isHidden = 0;
                break;
            case "None":
            case 1:
                message.isHidden = 1;
                break;
            case "TAState_None":
            case 1:
                message.isHidden = 1;
                break;
            case "SetExplicitly":
            case 2:
                message.isHidden = 2;
                break;
            case "TAState_SetExplicitly":
            case 2:
                message.isHidden = 2;
                break;
            case "SetImplicitly":
            case 3:
                message.isHidden = 3;
                break;
            case "TAState_SetImplicitly":
            case 3:
                message.isHidden = 3;
                break;
            case "SetExplicitlyAndImplicitly":
            case 4:
                message.isHidden = 4;
                break;
            case "TAState_SetExplicitlyAndImplicitly":
            case 4:
                message.isHidden = 4;
                break;
            }
            switch (object.isSelected) {
            default:
                if (typeof object.isSelected === "number") {
                    message.isSelected = object.isSelected;
                    break;
                }
                break;
            case "TAState_Unknown":
            case 0:
                message.isSelected = 0;
                break;
            case "None":
            case 1:
                message.isSelected = 1;
                break;
            case "TAState_None":
            case 1:
                message.isSelected = 1;
                break;
            case "SetExplicitly":
            case 2:
                message.isSelected = 2;
                break;
            case "TAState_SetExplicitly":
            case 2:
                message.isSelected = 2;
                break;
            case "SetImplicitly":
            case 3:
                message.isSelected = 3;
                break;
            case "TAState_SetImplicitly":
            case 3:
                message.isSelected = 3;
                break;
            case "SetExplicitlyAndImplicitly":
            case 4:
                message.isSelected = 4;
                break;
            case "TAState_SetExplicitlyAndImplicitly":
            case 4:
                message.isSelected = 4;
                break;
            }
            if (object.containsClips != null)
                message.containsClips = Boolean(object.containsClips);
            if (object.containsAutomation != null)
                message.containsAutomation = Boolean(object.containsAutomation);
            if (object.isSoloed != null)
                message.isSoloed = Boolean(object.isSoloed);
            if (object.isRecordEnabled != null)
                message.isRecordEnabled = Boolean(object.isRecordEnabled);
            switch (object.isInputMonitoringOn) {
            default:
                if (typeof object.isInputMonitoringOn === "number") {
                    message.isInputMonitoringOn = object.isInputMonitoringOn;
                    break;
                }
                break;
            case "TAState_Unknown":
            case 0:
                message.isInputMonitoringOn = 0;
                break;
            case "None":
            case 1:
                message.isInputMonitoringOn = 1;
                break;
            case "TAState_None":
            case 1:
                message.isInputMonitoringOn = 1;
                break;
            case "SetExplicitly":
            case 2:
                message.isInputMonitoringOn = 2;
                break;
            case "TAState_SetExplicitly":
            case 2:
                message.isInputMonitoringOn = 2;
                break;
            case "SetImplicitly":
            case 3:
                message.isInputMonitoringOn = 3;
                break;
            case "TAState_SetImplicitly":
            case 3:
                message.isInputMonitoringOn = 3;
                break;
            case "SetExplicitlyAndImplicitly":
            case 4:
                message.isInputMonitoringOn = 4;
                break;
            case "TAState_SetExplicitlyAndImplicitly":
            case 4:
                message.isInputMonitoringOn = 4;
                break;
            }
            if (object.isSmartDspOn != null)
                message.isSmartDspOn = Boolean(object.isSmartDspOn);
            if (object.isLocked != null)
                message.isLocked = Boolean(object.isLocked);
            if (object.isMuted != null)
                message.isMuted = Boolean(object.isMuted);
            if (object.isFrozen != null)
                message.isFrozen = Boolean(object.isFrozen);
            if (object.isOpen != null)
                message.isOpen = Boolean(object.isOpen);
            if (object.isOnline != null)
                message.isOnline = Boolean(object.isOnline);
            if (object.isRecordEnabledSafe != null)
                message.isRecordEnabledSafe = Boolean(object.isRecordEnabledSafe);
            if (object.isSmartDspOnSafe != null)
                message.isSmartDspOnSafe = Boolean(object.isSmartDspOnSafe);
            if (object.isSoloedSafe != null)
                message.isSoloedSafe = Boolean(object.isSoloedSafe);
            switch (object.hasEditSelection) {
            default:
                if (typeof object.hasEditSelection === "number") {
                    message.hasEditSelection = object.hasEditSelection;
                    break;
                }
                break;
            case "TAState_Unknown":
            case 0:
                message.hasEditSelection = 0;
                break;
            case "None":
            case 1:
                message.hasEditSelection = 1;
                break;
            case "TAState_None":
            case 1:
                message.hasEditSelection = 1;
                break;
            case "SetExplicitly":
            case 2:
                message.hasEditSelection = 2;
                break;
            case "TAState_SetExplicitly":
            case 2:
                message.hasEditSelection = 2;
                break;
            case "SetImplicitly":
            case 3:
                message.hasEditSelection = 3;
                break;
            case "TAState_SetImplicitly":
            case 3:
                message.hasEditSelection = 3;
                break;
            case "SetExplicitlyAndImplicitly":
            case 4:
                message.hasEditSelection = 4;
                break;
            case "TAState_SetExplicitlyAndImplicitly":
            case 4:
                message.hasEditSelection = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TrackAttributes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {ptsl.TrackAttributes} message TrackAttributes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrackAttributes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.isInactive = options.enums === String ? "TAState_Unknown" : 0;
                object.isHidden = options.enums === String ? "TAState_Unknown" : 0;
                object.isSelected = options.enums === String ? "TAState_Unknown" : 0;
                object.containsClips = false;
                object.containsAutomation = false;
                object.isSoloed = false;
                object.isRecordEnabled = false;
                object.isInputMonitoringOn = options.enums === String ? "TAState_Unknown" : 0;
                object.isSmartDspOn = false;
                object.isLocked = false;
                object.isMuted = false;
                object.isFrozen = false;
                object.isOpen = false;
                object.isOnline = false;
                object.isRecordEnabledSafe = false;
                object.isSmartDspOnSafe = false;
                object.isSoloedSafe = false;
                object.hasEditSelection = options.enums === String ? "TAState_Unknown" : 0;
            }
            if (message.isInactive != null && message.hasOwnProperty("isInactive"))
                object.isInactive = options.enums === String ? $root.ptsl.TrackAttributeState[message.isInactive] === undefined ? message.isInactive : $root.ptsl.TrackAttributeState[message.isInactive] : message.isInactive;
            if (message.isHidden != null && message.hasOwnProperty("isHidden"))
                object.isHidden = options.enums === String ? $root.ptsl.TrackAttributeState[message.isHidden] === undefined ? message.isHidden : $root.ptsl.TrackAttributeState[message.isHidden] : message.isHidden;
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                object.isSelected = options.enums === String ? $root.ptsl.TrackAttributeState[message.isSelected] === undefined ? message.isSelected : $root.ptsl.TrackAttributeState[message.isSelected] : message.isSelected;
            if (message.containsClips != null && message.hasOwnProperty("containsClips"))
                object.containsClips = message.containsClips;
            if (message.containsAutomation != null && message.hasOwnProperty("containsAutomation"))
                object.containsAutomation = message.containsAutomation;
            if (message.isSoloed != null && message.hasOwnProperty("isSoloed"))
                object.isSoloed = message.isSoloed;
            if (message.isRecordEnabled != null && message.hasOwnProperty("isRecordEnabled"))
                object.isRecordEnabled = message.isRecordEnabled;
            if (message.isInputMonitoringOn != null && message.hasOwnProperty("isInputMonitoringOn"))
                object.isInputMonitoringOn = options.enums === String ? $root.ptsl.TrackAttributeState[message.isInputMonitoringOn] === undefined ? message.isInputMonitoringOn : $root.ptsl.TrackAttributeState[message.isInputMonitoringOn] : message.isInputMonitoringOn;
            if (message.isSmartDspOn != null && message.hasOwnProperty("isSmartDspOn"))
                object.isSmartDspOn = message.isSmartDspOn;
            if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                object.isLocked = message.isLocked;
            if (message.isMuted != null && message.hasOwnProperty("isMuted"))
                object.isMuted = message.isMuted;
            if (message.isFrozen != null && message.hasOwnProperty("isFrozen"))
                object.isFrozen = message.isFrozen;
            if (message.isOpen != null && message.hasOwnProperty("isOpen"))
                object.isOpen = message.isOpen;
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                object.isOnline = message.isOnline;
            if (message.isRecordEnabledSafe != null && message.hasOwnProperty("isRecordEnabledSafe"))
                object.isRecordEnabledSafe = message.isRecordEnabledSafe;
            if (message.isSmartDspOnSafe != null && message.hasOwnProperty("isSmartDspOnSafe"))
                object.isSmartDspOnSafe = message.isSmartDspOnSafe;
            if (message.isSoloedSafe != null && message.hasOwnProperty("isSoloedSafe"))
                object.isSoloedSafe = message.isSoloedSafe;
            if (message.hasEditSelection != null && message.hasOwnProperty("hasEditSelection"))
                object.hasEditSelection = options.enums === String ? $root.ptsl.TrackAttributeState[message.hasEditSelection] === undefined ? message.hasEditSelection : $root.ptsl.TrackAttributeState[message.hasEditSelection] : message.hasEditSelection;
            return object;
        };

        /**
         * Converts this TrackAttributes to JSON.
         * @function toJSON
         * @memberof ptsl.TrackAttributes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrackAttributes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrackAttributes
         * @function getTypeUrl
         * @memberof ptsl.TrackAttributes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrackAttributes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.TrackAttributes";
        };

        return TrackAttributes;
    })();

    ptsl.Track = (function() {

        /**
         * Properties of a Track.
         * @memberof ptsl
         * @interface ITrack
         * @property {string|null} [name] Track name
         * @property {ptsl.TrackType|null} [type] Track type
         * @property {string|null} [id] Track id
         * @property {number|null} [index] Track index
         * @property {string|null} [color] Track color
         * @property {ptsl.ITrackAttributes|null} [trackAttributes] Track trackAttributes
         * @property {string|null} [idCompressed] Track idCompressed
         * @property {ptsl.TrackFormat|null} [format] Track format
         * @property {ptsl.TrackTimebase|null} [timebase] Track timebase
         * @property {string|null} [parentFolderName] Track parentFolderName
         * @property {string|null} [parentFolderId] Track parentFolderId
         */

        /**
         * Constructs a new Track.
         * @memberof ptsl
         * @classdesc Structure that describes Pro Tools track.
         * @implements ITrack
         * @constructor
         * @param {ptsl.ITrack=} [properties] Properties to set
         */
        function Track(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Track name.
         * @member {string} name
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.name = "";

        /**
         * Track type.
         * @member {ptsl.TrackType} type
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.type = 0;

        /**
         * Track id.
         * @member {string} id
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.id = "";

        /**
         * Track index.
         * @member {number} index
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.index = 0;

        /**
         * Track color.
         * @member {string} color
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.color = "";

        /**
         * Track trackAttributes.
         * @member {ptsl.ITrackAttributes|null|undefined} trackAttributes
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.trackAttributes = null;

        /**
         * Track idCompressed.
         * @member {string} idCompressed
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.idCompressed = "";

        /**
         * Track format.
         * @member {ptsl.TrackFormat} format
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.format = 0;

        /**
         * Track timebase.
         * @member {ptsl.TrackTimebase} timebase
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.timebase = 0;

        /**
         * Track parentFolderName.
         * @member {string} parentFolderName
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.parentFolderName = "";

        /**
         * Track parentFolderId.
         * @member {string} parentFolderId
         * @memberof ptsl.Track
         * @instance
         */
        Track.prototype.parentFolderId = "";

        /**
         * Creates a new Track instance using the specified properties.
         * @function create
         * @memberof ptsl.Track
         * @static
         * @param {ptsl.ITrack=} [properties] Properties to set
         * @returns {ptsl.Track} Track instance
         */
        Track.create = function create(properties) {
            return new Track(properties);
        };

        /**
         * Encodes the specified Track message. Does not implicitly {@link ptsl.Track.verify|verify} messages.
         * @function encode
         * @memberof ptsl.Track
         * @static
         * @param {ptsl.ITrack} message Track message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Track.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.index);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);
            if (message.trackAttributes != null && Object.hasOwnProperty.call(message, "trackAttributes"))
                $root.ptsl.TrackAttributes.encode(message.trackAttributes, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.idCompressed != null && Object.hasOwnProperty.call(message, "idCompressed"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.idCompressed);
            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.format);
            if (message.timebase != null && Object.hasOwnProperty.call(message, "timebase"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.timebase);
            if (message.parentFolderName != null && Object.hasOwnProperty.call(message, "parentFolderName"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.parentFolderName);
            if (message.parentFolderId != null && Object.hasOwnProperty.call(message, "parentFolderId"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.parentFolderId);
            return writer;
        };

        /**
         * Encodes the specified Track message, length delimited. Does not implicitly {@link ptsl.Track.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.Track
         * @static
         * @param {ptsl.ITrack} message Track message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Track.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Track message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.Track
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.Track} Track
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Track.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.Track();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        message.id = reader.string();
                        break;
                    }
                case 4: {
                        message.index = reader.int32();
                        break;
                    }
                case 5: {
                        message.color = reader.string();
                        break;
                    }
                case 6: {
                        message.trackAttributes = $root.ptsl.TrackAttributes.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.idCompressed = reader.string();
                        break;
                    }
                case 8: {
                        message.format = reader.int32();
                        break;
                    }
                case 9: {
                        message.timebase = reader.int32();
                        break;
                    }
                case 10: {
                        message.parentFolderName = reader.string();
                        break;
                    }
                case 11: {
                        message.parentFolderId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Track message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.Track
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.Track} Track
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Track.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Track message.
         * @function verify
         * @memberof ptsl.Track
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Track.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 0:
                case 0:
                case 1:
                case 1:
                case 1:
                case 2:
                case 2:
                case 2:
                case 3:
                case 3:
                case 3:
                case 4:
                case 4:
                case 4:
                case 5:
                case 5:
                case 5:
                case 6:
                case 6:
                case 6:
                case 7:
                case 7:
                case 7:
                case 8:
                case 8:
                case 8:
                case 9:
                case 9:
                case 9:
                case 10:
                case 10:
                case 10:
                case 11:
                case 11:
                case 11:
                case 12:
                case 12:
                case 12:
                case 13:
                case 13:
                case 13:
                case 14:
                case 14:
                case 14:
                case 15:
                case 15:
                case 15:
                case 16:
                case 16:
                case 16:
                    break;
                }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            if (message.trackAttributes != null && message.hasOwnProperty("trackAttributes")) {
                var error = $root.ptsl.TrackAttributes.verify(message.trackAttributes);
                if (error)
                    return "trackAttributes." + error;
            }
            if (message.idCompressed != null && message.hasOwnProperty("idCompressed"))
                if (!$util.isString(message.idCompressed))
                    return "idCompressed: string expected";
            if (message.format != null && message.hasOwnProperty("format"))
                switch (message.format) {
                default:
                    return "format: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                case 20:
                case 20:
                case 21:
                case 21:
                case 22:
                case 22:
                case 23:
                case 23:
                case 24:
                case 24:
                case 25:
                case 25:
                case 26:
                case 26:
                case 27:
                case 27:
                case 28:
                case 28:
                case 29:
                case 29:
                case 30:
                case 30:
                case 31:
                case 31:
                case 32:
                case 32:
                case 33:
                case 33:
                case 34:
                case 34:
                case 35:
                case 35:
                case 36:
                case 36:
                case 37:
                case 37:
                    break;
                }
            if (message.timebase != null && message.hasOwnProperty("timebase"))
                switch (message.timebase) {
                default:
                    return "timebase: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.parentFolderName != null && message.hasOwnProperty("parentFolderName"))
                if (!$util.isString(message.parentFolderName))
                    return "parentFolderName: string expected";
            if (message.parentFolderId != null && message.hasOwnProperty("parentFolderId"))
                if (!$util.isString(message.parentFolderId))
                    return "parentFolderId: string expected";
            return null;
        };

        /**
         * Creates a Track message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.Track
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.Track} Track
         */
        Track.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.Track)
                return object;
            var message = new $root.ptsl.Track();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.type = 0;
                break;
            case "TT_Unknown":
            case 0:
                message.type = 0;
                break;
            case "TType_Unknown":
            case 0:
                message.type = 0;
                break;
            case "Midi":
            case 1:
                message.type = 1;
                break;
            case "TT_Midi":
            case 1:
                message.type = 1;
                break;
            case "TType_Midi":
            case 1:
                message.type = 1;
                break;
            case "AudioTrack":
            case 2:
                message.type = 2;
                break;
            case "TT_Audio":
            case 2:
                message.type = 2;
                break;
            case "TType_Audio":
            case 2:
                message.type = 2;
                break;
            case "Aux":
            case 3:
                message.type = 3;
                break;
            case "TT_Aux":
            case 3:
                message.type = 3;
                break;
            case "TType_Aux":
            case 3:
                message.type = 3;
                break;
            case "VideoTrack":
            case 4:
                message.type = 4;
                break;
            case "TT_Video":
            case 4:
                message.type = 4;
                break;
            case "TType_Video":
            case 4:
                message.type = 4;
                break;
            case "Vca":
            case 5:
                message.type = 5;
                break;
            case "TT_Vca":
            case 5:
                message.type = 5;
                break;
            case "TType_Vca":
            case 5:
                message.type = 5;
                break;
            case "Tempo":
            case 6:
                message.type = 6;
                break;
            case "TT_Tempo":
            case 6:
                message.type = 6;
                break;
            case "TType_Tempo":
            case 6:
                message.type = 6;
                break;
            case "Markers":
            case 7:
                message.type = 7;
                break;
            case "TT_Markers":
            case 7:
                message.type = 7;
                break;
            case "TType_Markers":
            case 7:
                message.type = 7;
                break;
            case "Meter":
            case 8:
                message.type = 8;
                break;
            case "TT_Meter":
            case 8:
                message.type = 8;
                break;
            case "TType_Meter":
            case 8:
                message.type = 8;
                break;
            case "KeySignature":
            case 9:
                message.type = 9;
                break;
            case "TT_KeySignature":
            case 9:
                message.type = 9;
                break;
            case "TType_KeySignature":
            case 9:
                message.type = 9;
                break;
            case "ChordSymbols":
            case 10:
                message.type = 10;
                break;
            case "TT_ChordSymbols":
            case 10:
                message.type = 10;
                break;
            case "TType_ChordSymbols":
            case 10:
                message.type = 10;
                break;
            case "Instrument":
            case 11:
                message.type = 11;
                break;
            case "TT_Instrument":
            case 11:
                message.type = 11;
                break;
            case "TType_Instrument":
            case 11:
                message.type = 11;
                break;
            case "Master":
            case 12:
                message.type = 12;
                break;
            case "TT_Master":
            case 12:
                message.type = 12;
                break;
            case "TType_Master":
            case 12:
                message.type = 12;
                break;
            case "Heat":
            case 13:
                message.type = 13;
                break;
            case "TT_Heat":
            case 13:
                message.type = 13;
                break;
            case "TType_Heat":
            case 13:
                message.type = 13;
                break;
            case "BasicFolder":
            case 14:
                message.type = 14;
                break;
            case "TT_BasicFolder":
            case 14:
                message.type = 14;
                break;
            case "TType_BasicFolder":
            case 14:
                message.type = 14;
                break;
            case "RoutingFolder":
            case 15:
                message.type = 15;
                break;
            case "TT_RoutingFolder":
            case 15:
                message.type = 15;
                break;
            case "TType_RoutingFolder":
            case 15:
                message.type = 15;
                break;
            case "CompLane":
            case 16:
                message.type = 16;
                break;
            case "TT_CompLane":
            case 16:
                message.type = 16;
                break;
            case "TType_CompLane":
            case 16:
                message.type = 16;
                break;
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.index != null)
                message.index = object.index | 0;
            if (object.color != null)
                message.color = String(object.color);
            if (object.trackAttributes != null) {
                if (typeof object.trackAttributes !== "object")
                    throw TypeError(".ptsl.Track.trackAttributes: object expected");
                message.trackAttributes = $root.ptsl.TrackAttributes.fromObject(object.trackAttributes);
            }
            if (object.idCompressed != null)
                message.idCompressed = String(object.idCompressed);
            switch (object.format) {
            default:
                if (typeof object.format === "number") {
                    message.format = object.format;
                    break;
                }
                break;
            case "TF_Unknown":
            case 0:
                message.format = 0;
                break;
            case "TFormat_Unknown":
            case 0:
                message.format = 0;
                break;
            case "TF_Mono":
            case 1:
                message.format = 1;
                break;
            case "TFormat_Mono":
            case 1:
                message.format = 1;
                break;
            case "TF_Stereo":
            case 2:
                message.format = 2;
                break;
            case "TFormat_Stereo":
            case 2:
                message.format = 2;
                break;
            case "TF_LCR":
            case 3:
                message.format = 3;
                break;
            case "TFormat_LCR":
            case 3:
                message.format = 3;
                break;
            case "TF_LCRS":
            case 4:
                message.format = 4;
                break;
            case "TFormat_LCRS":
            case 4:
                message.format = 4;
                break;
            case "TF_Quad":
            case 5:
                message.format = 5;
                break;
            case "TFormat_Quad":
            case 5:
                message.format = 5;
                break;
            case "TF_5_0":
            case 6:
                message.format = 6;
                break;
            case "TFormat_5_0":
            case 6:
                message.format = 6;
                break;
            case "TF_5_1":
            case 7:
                message.format = 7;
                break;
            case "TFormat_5_1":
            case 7:
                message.format = 7;
                break;
            case "TF_5_0_2":
            case 8:
                message.format = 8;
                break;
            case "TFormat_5_0_2":
            case 8:
                message.format = 8;
                break;
            case "TF_5_1_2":
            case 9:
                message.format = 9;
                break;
            case "TFormat_5_1_2":
            case 9:
                message.format = 9;
                break;
            case "TF_5_0_4":
            case 10:
                message.format = 10;
                break;
            case "TFormat_5_0_4":
            case 10:
                message.format = 10;
                break;
            case "TF_5_1_4":
            case 11:
                message.format = 11;
                break;
            case "TFormat_5_1_4":
            case 11:
                message.format = 11;
                break;
            case "TF_6_0":
            case 12:
                message.format = 12;
                break;
            case "TFormat_6_0":
            case 12:
                message.format = 12;
                break;
            case "TF_6_1":
            case 13:
                message.format = 13;
                break;
            case "TFormat_6_1":
            case 13:
                message.format = 13;
                break;
            case "TF_7_0":
            case 14:
                message.format = 14;
                break;
            case "TFormat_7_0":
            case 14:
                message.format = 14;
                break;
            case "TF_7_1":
            case 15:
                message.format = 15;
                break;
            case "TFormat_7_1":
            case 15:
                message.format = 15;
                break;
            case "TF_7_0_SDDS":
            case 16:
                message.format = 16;
                break;
            case "TFormat_7_0_SDDS":
            case 16:
                message.format = 16;
                break;
            case "TF_7_1_SDDS":
            case 17:
                message.format = 17;
                break;
            case "TFormat_7_1_SDDS":
            case 17:
                message.format = 17;
                break;
            case "TF_7_0_2":
            case 18:
                message.format = 18;
                break;
            case "TFormat_7_0_2":
            case 18:
                message.format = 18;
                break;
            case "TF_7_1_2":
            case 19:
                message.format = 19;
                break;
            case "TFormat_7_1_2":
            case 19:
                message.format = 19;
                break;
            case "TF_7_0_4":
            case 20:
                message.format = 20;
                break;
            case "TFormat_7_0_4":
            case 20:
                message.format = 20;
                break;
            case "TF_7_1_4":
            case 21:
                message.format = 21;
                break;
            case "TFormat_7_1_4":
            case 21:
                message.format = 21;
                break;
            case "TF_7_0_6":
            case 22:
                message.format = 22;
                break;
            case "TFormat_7_0_6":
            case 22:
                message.format = 22;
                break;
            case "TF_7_1_6":
            case 23:
                message.format = 23;
                break;
            case "TFormat_7_1_6":
            case 23:
                message.format = 23;
                break;
            case "TF_9_0_4":
            case 24:
                message.format = 24;
                break;
            case "TFormat_9_0_4":
            case 24:
                message.format = 24;
                break;
            case "TF_9_1_4":
            case 25:
                message.format = 25;
                break;
            case "TFormat_9_1_4":
            case 25:
                message.format = 25;
                break;
            case "TF_9_0_6":
            case 26:
                message.format = 26;
                break;
            case "TFormat_9_0_6":
            case 26:
                message.format = 26;
                break;
            case "TF_9_1_6":
            case 27:
                message.format = 27;
                break;
            case "TFormat_9_1_6":
            case 27:
                message.format = 27;
                break;
            case "TF_1stOrderAmbisonics":
            case 28:
                message.format = 28;
                break;
            case "TFormat_1stOrderAmbisonics":
            case 28:
                message.format = 28;
                break;
            case "TF_2ndOrderAmbisonics":
            case 29:
                message.format = 29;
                break;
            case "TFormat_2ndOrderAmbisonics":
            case 29:
                message.format = 29;
                break;
            case "TF_3rdOrderAmbisonics":
            case 30:
                message.format = 30;
                break;
            case "TFormat_3rdOrderAmbisonics":
            case 30:
                message.format = 30;
                break;
            case "TF_4thOrderAmbisonics":
            case 31:
                message.format = 31;
                break;
            case "TFormat_4thOrderAmbisonics":
            case 31:
                message.format = 31;
                break;
            case "TF_5thOrderAmbisonics":
            case 32:
                message.format = 32;
                break;
            case "TFormat_5thOrderAmbisonics":
            case 32:
                message.format = 32;
                break;
            case "TF_6thOrderAmbisonics":
            case 33:
                message.format = 33;
                break;
            case "TFormat_6thOrderAmbisonics":
            case 33:
                message.format = 33;
                break;
            case "TF_7thOrderAmbisonics":
            case 34:
                message.format = 34;
                break;
            case "TFormat_7thOrderAmbisonics":
            case 34:
                message.format = 34;
                break;
            case "TF_None":
            case 35:
                message.format = 35;
                break;
            case "TFormat_None":
            case 35:
                message.format = 35;
                break;
            case "TF_2_1":
            case 36:
                message.format = 36;
                break;
            case "TFormat_2_1":
            case 36:
                message.format = 36;
                break;
            case "TF_Overhead":
            case 37:
                message.format = 37;
                break;
            case "TFormat_Overhead":
            case 37:
                message.format = 37;
                break;
            }
            switch (object.timebase) {
            default:
                if (typeof object.timebase === "number") {
                    message.timebase = object.timebase;
                    break;
                }
                break;
            case "TTB_Unknown":
            case 0:
                message.timebase = 0;
                break;
            case "TTimebase_Unknown":
            case 0:
                message.timebase = 0;
                break;
            case "TTB_Samples":
            case 1:
                message.timebase = 1;
                break;
            case "TTimebase_Samples":
            case 1:
                message.timebase = 1;
                break;
            case "TTB_Ticks":
            case 2:
                message.timebase = 2;
                break;
            case "TTimebase_Ticks":
            case 2:
                message.timebase = 2;
                break;
            case "TTB_None":
            case 3:
                message.timebase = 3;
                break;
            case "TTimebase_None":
            case 3:
                message.timebase = 3;
                break;
            }
            if (object.parentFolderName != null)
                message.parentFolderName = String(object.parentFolderName);
            if (object.parentFolderId != null)
                message.parentFolderId = String(object.parentFolderId);
            return message;
        };

        /**
         * Creates a plain object from a Track message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.Track
         * @static
         * @param {ptsl.Track} message Track
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Track.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "Unknown" : 0;
                object.id = "";
                object.index = 0;
                object.color = "";
                object.trackAttributes = null;
                object.idCompressed = "";
                object.format = options.enums === String ? "TF_Unknown" : 0;
                object.timebase = options.enums === String ? "TTB_Unknown" : 0;
                object.parentFolderName = "";
                object.parentFolderId = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ptsl.TrackType[message.type] === undefined ? message.type : $root.ptsl.TrackType[message.type] : message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.trackAttributes != null && message.hasOwnProperty("trackAttributes"))
                object.trackAttributes = $root.ptsl.TrackAttributes.toObject(message.trackAttributes, options);
            if (message.idCompressed != null && message.hasOwnProperty("idCompressed"))
                object.idCompressed = message.idCompressed;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = options.enums === String ? $root.ptsl.TrackFormat[message.format] === undefined ? message.format : $root.ptsl.TrackFormat[message.format] : message.format;
            if (message.timebase != null && message.hasOwnProperty("timebase"))
                object.timebase = options.enums === String ? $root.ptsl.TrackTimebase[message.timebase] === undefined ? message.timebase : $root.ptsl.TrackTimebase[message.timebase] : message.timebase;
            if (message.parentFolderName != null && message.hasOwnProperty("parentFolderName"))
                object.parentFolderName = message.parentFolderName;
            if (message.parentFolderId != null && message.hasOwnProperty("parentFolderId"))
                object.parentFolderId = message.parentFolderId;
            return object;
        };

        /**
         * Converts this Track to JSON.
         * @function toJSON
         * @memberof ptsl.Track
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Track.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Track
         * @function getTypeUrl
         * @memberof ptsl.Track
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Track.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.Track";
        };

        return Track;
    })();

    ptsl.GetTaskStatusRequestBody = (function() {

        /**
         * Properties of a GetTaskStatusRequestBody.
         * @memberof ptsl
         * @interface IGetTaskStatusRequestBody
         * @property {string|null} [taskId] GetTaskStatusRequestBody taskId
         */

        /**
         * Constructs a new GetTaskStatusRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTaskStatus request data.
         * @implements IGetTaskStatusRequestBody
         * @constructor
         * @param {ptsl.IGetTaskStatusRequestBody=} [properties] Properties to set
         */
        function GetTaskStatusRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTaskStatusRequestBody taskId.
         * @member {string} taskId
         * @memberof ptsl.GetTaskStatusRequestBody
         * @instance
         */
        GetTaskStatusRequestBody.prototype.taskId = "";

        /**
         * Creates a new GetTaskStatusRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {ptsl.IGetTaskStatusRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetTaskStatusRequestBody} GetTaskStatusRequestBody instance
         */
        GetTaskStatusRequestBody.create = function create(properties) {
            return new GetTaskStatusRequestBody(properties);
        };

        /**
         * Encodes the specified GetTaskStatusRequestBody message. Does not implicitly {@link ptsl.GetTaskStatusRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {ptsl.IGetTaskStatusRequestBody} message GetTaskStatusRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTaskStatusRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskId);
            return writer;
        };

        /**
         * Encodes the specified GetTaskStatusRequestBody message, length delimited. Does not implicitly {@link ptsl.GetTaskStatusRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {ptsl.IGetTaskStatusRequestBody} message GetTaskStatusRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTaskStatusRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTaskStatusRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTaskStatusRequestBody} GetTaskStatusRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTaskStatusRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTaskStatusRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.taskId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTaskStatusRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTaskStatusRequestBody} GetTaskStatusRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTaskStatusRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTaskStatusRequestBody message.
         * @function verify
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTaskStatusRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isString(message.taskId))
                    return "taskId: string expected";
            return null;
        };

        /**
         * Creates a GetTaskStatusRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTaskStatusRequestBody} GetTaskStatusRequestBody
         */
        GetTaskStatusRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTaskStatusRequestBody)
                return object;
            var message = new $root.ptsl.GetTaskStatusRequestBody();
            if (object.taskId != null)
                message.taskId = String(object.taskId);
            return message;
        };

        /**
         * Creates a plain object from a GetTaskStatusRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {ptsl.GetTaskStatusRequestBody} message GetTaskStatusRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTaskStatusRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.taskId = "";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = message.taskId;
            return object;
        };

        /**
         * Converts this GetTaskStatusRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTaskStatusRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTaskStatusRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTaskStatusRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetTaskStatusRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTaskStatusRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTaskStatusRequestBody";
        };

        return GetTaskStatusRequestBody;
    })();

    ptsl.GetTaskStatusResponseBody = (function() {

        /**
         * Properties of a GetTaskStatusResponseBody.
         * @memberof ptsl
         * @interface IGetTaskStatusResponseBody
         * @property {string|null} [taskId] GetTaskStatusResponseBody taskId
         * @property {ptsl.TaskStatus|null} [status] GetTaskStatusResponseBody status
         * @property {number|null} [progress] GetTaskStatusResponseBody progress
         */

        /**
         * Constructs a new GetTaskStatusResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTaskStatus response data.
         * @implements IGetTaskStatusResponseBody
         * @constructor
         * @param {ptsl.IGetTaskStatusResponseBody=} [properties] Properties to set
         */
        function GetTaskStatusResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTaskStatusResponseBody taskId.
         * @member {string} taskId
         * @memberof ptsl.GetTaskStatusResponseBody
         * @instance
         */
        GetTaskStatusResponseBody.prototype.taskId = "";

        /**
         * GetTaskStatusResponseBody status.
         * @member {ptsl.TaskStatus} status
         * @memberof ptsl.GetTaskStatusResponseBody
         * @instance
         */
        GetTaskStatusResponseBody.prototype.status = 0;

        /**
         * GetTaskStatusResponseBody progress.
         * @member {number} progress
         * @memberof ptsl.GetTaskStatusResponseBody
         * @instance
         */
        GetTaskStatusResponseBody.prototype.progress = 0;

        /**
         * Creates a new GetTaskStatusResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {ptsl.IGetTaskStatusResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetTaskStatusResponseBody} GetTaskStatusResponseBody instance
         */
        GetTaskStatusResponseBody.create = function create(properties) {
            return new GetTaskStatusResponseBody(properties);
        };

        /**
         * Encodes the specified GetTaskStatusResponseBody message. Does not implicitly {@link ptsl.GetTaskStatusResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {ptsl.IGetTaskStatusResponseBody} message GetTaskStatusResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTaskStatusResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.taskId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.progress);
            return writer;
        };

        /**
         * Encodes the specified GetTaskStatusResponseBody message, length delimited. Does not implicitly {@link ptsl.GetTaskStatusResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {ptsl.IGetTaskStatusResponseBody} message GetTaskStatusResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTaskStatusResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTaskStatusResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTaskStatusResponseBody} GetTaskStatusResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTaskStatusResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTaskStatusResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.taskId = reader.string();
                        break;
                    }
                case 2: {
                        message.status = reader.int32();
                        break;
                    }
                case 3: {
                        message.progress = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTaskStatusResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTaskStatusResponseBody} GetTaskStatusResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTaskStatusResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTaskStatusResponseBody message.
         * @function verify
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTaskStatusResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isString(message.taskId))
                    return "taskId: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                    break;
                }
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            return null;
        };

        /**
         * Creates a GetTaskStatusResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTaskStatusResponseBody} GetTaskStatusResponseBody
         */
        GetTaskStatusResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTaskStatusResponseBody)
                return object;
            var message = new $root.ptsl.GetTaskStatusResponseBody();
            if (object.taskId != null)
                message.taskId = String(object.taskId);
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "Queued":
            case 0:
                message.status = 0;
                break;
            case "TStatus_Queued":
            case 0:
                message.status = 0;
                break;
            case "Pending":
            case 1:
                message.status = 1;
                break;
            case "TStatus_Pending":
            case 1:
                message.status = 1;
                break;
            case "InProgress":
            case 2:
                message.status = 2;
                break;
            case "TStatus_InProgress":
            case 2:
                message.status = 2;
                break;
            case "Completed":
            case 3:
                message.status = 3;
                break;
            case "TStatus_Completed":
            case 3:
                message.status = 3;
                break;
            case "Failed":
            case 4:
                message.status = 4;
                break;
            case "TStatus_Failed":
            case 4:
                message.status = 4;
                break;
            case "WaitingForUserInput":
            case 5:
                message.status = 5;
                break;
            case "TStatus_WaitingForUserInput":
            case 5:
                message.status = 5;
                break;
            case "CompletedWithBadResponse":
            case 6:
                message.status = 6;
                break;
            case "TStatus_CompletedWithBadResponse":
            case 6:
                message.status = 6;
                break;
            case "FailedWithBadErrorResponse":
            case 7:
                message.status = 7;
                break;
            case "TStatus_FailedWithBadErrorResponse":
            case 7:
                message.status = 7;
                break;
            }
            if (object.progress != null)
                message.progress = object.progress | 0;
            return message;
        };

        /**
         * Creates a plain object from a GetTaskStatusResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {ptsl.GetTaskStatusResponseBody} message GetTaskStatusResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTaskStatusResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.taskId = "";
                object.status = options.enums === String ? "Queued" : 0;
                object.progress = 0;
            }
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = message.taskId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.ptsl.TaskStatus[message.status] === undefined ? message.status : $root.ptsl.TaskStatus[message.status] : message.status;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            return object;
        };

        /**
         * Converts this GetTaskStatusResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTaskStatusResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTaskStatusResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTaskStatusResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetTaskStatusResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTaskStatusResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTaskStatusResponseBody";
        };

        return GetTaskStatusResponseBody;
    })();

    /**
     * Type of Pro Tools file.
     * @name ptsl.FileType
     * @enum {number}
     * @property {number} FType_Unknown=0 FType_Unknown value
     * @property {number} FT_WAVE=1 * @deprecated ptsl::FileType::WAVE is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileType::FType_WAVE
     * @property {number} FType_WAVE=1 FType_WAVE value
     * @property {number} FT_AIFF=2 * @deprecated ptsl::FileType::AIFF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileType::FType_AIFF
     * @property {number} FType_AIFF=2 FType_AIFF value
     * @property {number} FT_AAF=3 * @deprecated ptsl::FileType::AAF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileType::FType_AAF
     * @property {number} FType_AAF=3 FType_AAF value
     * @property {number} FT_OMF=4 * @deprecated ptsl::FileType::OMF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileType::FType_OMF
     * @property {number} FType_OMF=4 FType_OMF value
     * @property {number} FType_MXF=5 * @since Pro Tools 2025.06
     */
    ptsl.FileType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FType_Unknown"] = 0;
        values[valuesById[1] = "FT_WAVE"] = 1;
        values["FType_WAVE"] = 1;
        values[valuesById[2] = "FT_AIFF"] = 2;
        values["FType_AIFF"] = 2;
        values[valuesById[3] = "FT_AAF"] = 3;
        values["FType_AAF"] = 3;
        values[valuesById[4] = "FT_OMF"] = 4;
        values["FType_OMF"] = 4;
        values[valuesById[5] = "FType_MXF"] = 5;
        return values;
    })();

    /**
     * Type of Pro Tools input/output settings.
     * @name ptsl.IOSettings
     * @enum {number}
     * @property {number} IOSettings_Unknown=0 IOSettings_Unknown value
     * @property {number} IO_None=1 * @deprecated ptsl::IOSettings::IO_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::IOSettings::IOSettings_None
     * @property {number} IOSettings_None=1 IOSettings_None value
     * @property {number} IO_Last=2 * @deprecated ptsl::IOSettings::IO_Last is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::IOSettings::IOSettings_Last
     * @property {number} IOSettings_Last=2 IOSettings_Last value
     * @property {number} IO_StereoMix=3 * @deprecated ptsl::IOSettings::IO_StereoMix is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::IOSettings::IOSettings_StereoMix
     * @property {number} IOSettings_StereoMix=3 IOSettings_StereoMix value
     * @property {number} IO_51FilmMix=4 * @deprecated ptsl::IOSettings::IO_51FilmMix is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::IOSettings::IOSettings_51FilmMix
     * @property {number} IOSettings_51FilmMix=4 IOSettings_51FilmMix value
     * @property {number} IO_51SMPTEMix=5 * @deprecated ptsl::IOSettings::IO_51SMPTEMix is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::IOSettings::IOSettings_51SMPTEMix
     * @property {number} IOSettings_51SMPTEMix=5 IOSettings_51SMPTEMix value
     * @property {number} IO_51DTSMix=6 * @deprecated ptsl::IOSettings::IO_51DTSMix is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::IOSettings::IOSettings_51DTSMix
     * @property {number} IOSettings_51DTSMix=6 IOSettings_51DTSMix value
     * @property {number} IO_UserDefined=7 * @deprecated ptsl::IOSettings::IO_UserDefined is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::IOSettings::IOSettings_UserDefined
     * @property {number} IOSettings_UserDefined=7 IOSettings_UserDefined value
     */
    ptsl.IOSettings = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IOSettings_Unknown"] = 0;
        values[valuesById[1] = "IO_None"] = 1;
        values["IOSettings_None"] = 1;
        values[valuesById[2] = "IO_Last"] = 2;
        values["IOSettings_Last"] = 2;
        values[valuesById[3] = "IO_StereoMix"] = 3;
        values["IOSettings_StereoMix"] = 3;
        values[valuesById[4] = "IO_51FilmMix"] = 4;
        values["IOSettings_51FilmMix"] = 4;
        values[valuesById[5] = "IO_51SMPTEMix"] = 5;
        values["IOSettings_51SMPTEMix"] = 5;
        values[valuesById[6] = "IO_51DTSMix"] = 6;
        values["IOSettings_51DTSMix"] = 6;
        values[valuesById[7] = "IO_UserDefined"] = 7;
        values["IOSettings_UserDefined"] = 7;
        return values;
    })();

    ptsl.CreateSessionRequestBody = (function() {

        /**
         * Properties of a CreateSessionRequestBody.
         * @memberof ptsl
         * @interface ICreateSessionRequestBody
         * @property {string|null} [sessionName] CreateSessionRequestBody sessionName
         * @property {boolean|null} [createFromTemplate] CreateSessionRequestBody createFromTemplate
         * @property {string|null} [templateGroup] CreateSessionRequestBody templateGroup
         * @property {string|null} [templateName] CreateSessionRequestBody templateName
         * @property {ptsl.FileType|null} [fileType] CreateSessionRequestBody fileType
         * @property {ptsl.SampleRate|null} [sampleRate] CreateSessionRequestBody sampleRate
         * @property {ptsl.IOSettings|null} [inputOutputSettings] CreateSessionRequestBody inputOutputSettings
         * @property {boolean|null} [isInterleaved] CreateSessionRequestBody isInterleaved
         * @property {string|null} [sessionLocation] CreateSessionRequestBody sessionLocation
         * @property {boolean|null} [isCloudProject] CreateSessionRequestBody isCloudProject
         * @property {boolean|null} [createFromAaf] CreateSessionRequestBody createFromAaf
         * @property {string|null} [pathToAaf] CreateSessionRequestBody pathToAaf
         * @property {ptsl.BitDepth|null} [bitDepth] CreateSessionRequestBody bitDepth
         */

        /**
         * Constructs a new CreateSessionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateSession request data.
         * @implements ICreateSessionRequestBody
         * @constructor
         * @param {ptsl.ICreateSessionRequestBody=} [properties] Properties to set
         */
        function CreateSessionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateSessionRequestBody sessionName.
         * @member {string} sessionName
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.sessionName = "";

        /**
         * CreateSessionRequestBody createFromTemplate.
         * @member {boolean} createFromTemplate
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.createFromTemplate = false;

        /**
         * CreateSessionRequestBody templateGroup.
         * @member {string} templateGroup
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.templateGroup = "";

        /**
         * CreateSessionRequestBody templateName.
         * @member {string} templateName
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.templateName = "";

        /**
         * CreateSessionRequestBody fileType.
         * @member {ptsl.FileType} fileType
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.fileType = 0;

        /**
         * CreateSessionRequestBody sampleRate.
         * @member {ptsl.SampleRate} sampleRate
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.sampleRate = 0;

        /**
         * CreateSessionRequestBody inputOutputSettings.
         * @member {ptsl.IOSettings} inputOutputSettings
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.inputOutputSettings = 0;

        /**
         * CreateSessionRequestBody isInterleaved.
         * @member {boolean} isInterleaved
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.isInterleaved = false;

        /**
         * CreateSessionRequestBody sessionLocation.
         * @member {string} sessionLocation
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.sessionLocation = "";

        /**
         * CreateSessionRequestBody isCloudProject.
         * @member {boolean} isCloudProject
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.isCloudProject = false;

        /**
         * CreateSessionRequestBody createFromAaf.
         * @member {boolean} createFromAaf
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.createFromAaf = false;

        /**
         * CreateSessionRequestBody pathToAaf.
         * @member {string} pathToAaf
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.pathToAaf = "";

        /**
         * CreateSessionRequestBody bitDepth.
         * @member {ptsl.BitDepth} bitDepth
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         */
        CreateSessionRequestBody.prototype.bitDepth = 0;

        /**
         * Creates a new CreateSessionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {ptsl.ICreateSessionRequestBody=} [properties] Properties to set
         * @returns {ptsl.CreateSessionRequestBody} CreateSessionRequestBody instance
         */
        CreateSessionRequestBody.create = function create(properties) {
            return new CreateSessionRequestBody(properties);
        };

        /**
         * Encodes the specified CreateSessionRequestBody message. Does not implicitly {@link ptsl.CreateSessionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {ptsl.ICreateSessionRequestBody} message CreateSessionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSessionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionName != null && Object.hasOwnProperty.call(message, "sessionName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionName);
            if (message.createFromTemplate != null && Object.hasOwnProperty.call(message, "createFromTemplate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.createFromTemplate);
            if (message.templateGroup != null && Object.hasOwnProperty.call(message, "templateGroup"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.templateGroup);
            if (message.templateName != null && Object.hasOwnProperty.call(message, "templateName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.templateName);
            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.fileType);
            if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sampleRate);
            if (message.inputOutputSettings != null && Object.hasOwnProperty.call(message, "inputOutputSettings"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.inputOutputSettings);
            if (message.isInterleaved != null && Object.hasOwnProperty.call(message, "isInterleaved"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.isInterleaved);
            if (message.sessionLocation != null && Object.hasOwnProperty.call(message, "sessionLocation"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.sessionLocation);
            if (message.isCloudProject != null && Object.hasOwnProperty.call(message, "isCloudProject"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isCloudProject);
            if (message.createFromAaf != null && Object.hasOwnProperty.call(message, "createFromAaf"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.createFromAaf);
            if (message.pathToAaf != null && Object.hasOwnProperty.call(message, "pathToAaf"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.pathToAaf);
            if (message.bitDepth != null && Object.hasOwnProperty.call(message, "bitDepth"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.bitDepth);
            return writer;
        };

        /**
         * Encodes the specified CreateSessionRequestBody message, length delimited. Does not implicitly {@link ptsl.CreateSessionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {ptsl.ICreateSessionRequestBody} message CreateSessionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSessionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateSessionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateSessionRequestBody} CreateSessionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSessionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateSessionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionName = reader.string();
                        break;
                    }
                case 2: {
                        message.createFromTemplate = reader.bool();
                        break;
                    }
                case 3: {
                        message.templateGroup = reader.string();
                        break;
                    }
                case 4: {
                        message.templateName = reader.string();
                        break;
                    }
                case 5: {
                        message.fileType = reader.int32();
                        break;
                    }
                case 6: {
                        message.sampleRate = reader.int32();
                        break;
                    }
                case 7: {
                        message.inputOutputSettings = reader.int32();
                        break;
                    }
                case 8: {
                        message.isInterleaved = reader.bool();
                        break;
                    }
                case 9: {
                        message.sessionLocation = reader.string();
                        break;
                    }
                case 10: {
                        message.isCloudProject = reader.bool();
                        break;
                    }
                case 11: {
                        message.createFromAaf = reader.bool();
                        break;
                    }
                case 12: {
                        message.pathToAaf = reader.string();
                        break;
                    }
                case 13: {
                        message.bitDepth = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateSessionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateSessionRequestBody} CreateSessionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSessionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateSessionRequestBody message.
         * @function verify
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateSessionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionName != null && message.hasOwnProperty("sessionName"))
                if (!$util.isString(message.sessionName))
                    return "sessionName: string expected";
            if (message.createFromTemplate != null && message.hasOwnProperty("createFromTemplate"))
                if (typeof message.createFromTemplate !== "boolean")
                    return "createFromTemplate: boolean expected";
            if (message.templateGroup != null && message.hasOwnProperty("templateGroup"))
                if (!$util.isString(message.templateGroup))
                    return "templateGroup: string expected";
            if (message.templateName != null && message.hasOwnProperty("templateName"))
                if (!$util.isString(message.templateName))
                    return "templateName: string expected";
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                switch (message.fileType) {
                default:
                    return "fileType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                    break;
                }
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                switch (message.sampleRate) {
                default:
                    return "sampleRate: enum value expected";
                case 0:
                case 1:
                case 1:
                case 44100:
                case 44100:
                case 48000:
                case 48000:
                case 88200:
                case 88200:
                case 96000:
                case 96000:
                case 176400:
                case 176400:
                case 192000:
                case 192000:
                    break;
                }
            if (message.inputOutputSettings != null && message.hasOwnProperty("inputOutputSettings"))
                switch (message.inputOutputSettings) {
                default:
                    return "inputOutputSettings: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                    break;
                }
            if (message.isInterleaved != null && message.hasOwnProperty("isInterleaved"))
                if (typeof message.isInterleaved !== "boolean")
                    return "isInterleaved: boolean expected";
            if (message.sessionLocation != null && message.hasOwnProperty("sessionLocation"))
                if (!$util.isString(message.sessionLocation))
                    return "sessionLocation: string expected";
            if (message.isCloudProject != null && message.hasOwnProperty("isCloudProject"))
                if (typeof message.isCloudProject !== "boolean")
                    return "isCloudProject: boolean expected";
            if (message.createFromAaf != null && message.hasOwnProperty("createFromAaf"))
                if (typeof message.createFromAaf !== "boolean")
                    return "createFromAaf: boolean expected";
            if (message.pathToAaf != null && message.hasOwnProperty("pathToAaf"))
                if (!$util.isString(message.pathToAaf))
                    return "pathToAaf: string expected";
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                switch (message.bitDepth) {
                default:
                    return "bitDepth: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a CreateSessionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateSessionRequestBody} CreateSessionRequestBody
         */
        CreateSessionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateSessionRequestBody)
                return object;
            var message = new $root.ptsl.CreateSessionRequestBody();
            if (object.sessionName != null)
                message.sessionName = String(object.sessionName);
            if (object.createFromTemplate != null)
                message.createFromTemplate = Boolean(object.createFromTemplate);
            if (object.templateGroup != null)
                message.templateGroup = String(object.templateGroup);
            if (object.templateName != null)
                message.templateName = String(object.templateName);
            switch (object.fileType) {
            default:
                if (typeof object.fileType === "number") {
                    message.fileType = object.fileType;
                    break;
                }
                break;
            case "FType_Unknown":
            case 0:
                message.fileType = 0;
                break;
            case "FT_WAVE":
            case 1:
                message.fileType = 1;
                break;
            case "FType_WAVE":
            case 1:
                message.fileType = 1;
                break;
            case "FT_AIFF":
            case 2:
                message.fileType = 2;
                break;
            case "FType_AIFF":
            case 2:
                message.fileType = 2;
                break;
            case "FT_AAF":
            case 3:
                message.fileType = 3;
                break;
            case "FType_AAF":
            case 3:
                message.fileType = 3;
                break;
            case "FT_OMF":
            case 4:
                message.fileType = 4;
                break;
            case "FType_OMF":
            case 4:
                message.fileType = 4;
                break;
            case "FType_MXF":
            case 5:
                message.fileType = 5;
                break;
            }
            switch (object.sampleRate) {
            default:
                if (typeof object.sampleRate === "number") {
                    message.sampleRate = object.sampleRate;
                    break;
                }
                break;
            case "SRate_Unknown":
            case 0:
                message.sampleRate = 0;
                break;
            case "SR_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SRate_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SR_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SRate_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SR_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SRate_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SR_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SRate_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SR_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SRate_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SR_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SRate_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SR_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            case "SRate_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            }
            switch (object.inputOutputSettings) {
            default:
                if (typeof object.inputOutputSettings === "number") {
                    message.inputOutputSettings = object.inputOutputSettings;
                    break;
                }
                break;
            case "IOSettings_Unknown":
            case 0:
                message.inputOutputSettings = 0;
                break;
            case "IO_None":
            case 1:
                message.inputOutputSettings = 1;
                break;
            case "IOSettings_None":
            case 1:
                message.inputOutputSettings = 1;
                break;
            case "IO_Last":
            case 2:
                message.inputOutputSettings = 2;
                break;
            case "IOSettings_Last":
            case 2:
                message.inputOutputSettings = 2;
                break;
            case "IO_StereoMix":
            case 3:
                message.inputOutputSettings = 3;
                break;
            case "IOSettings_StereoMix":
            case 3:
                message.inputOutputSettings = 3;
                break;
            case "IO_51FilmMix":
            case 4:
                message.inputOutputSettings = 4;
                break;
            case "IOSettings_51FilmMix":
            case 4:
                message.inputOutputSettings = 4;
                break;
            case "IO_51SMPTEMix":
            case 5:
                message.inputOutputSettings = 5;
                break;
            case "IOSettings_51SMPTEMix":
            case 5:
                message.inputOutputSettings = 5;
                break;
            case "IO_51DTSMix":
            case 6:
                message.inputOutputSettings = 6;
                break;
            case "IOSettings_51DTSMix":
            case 6:
                message.inputOutputSettings = 6;
                break;
            case "IO_UserDefined":
            case 7:
                message.inputOutputSettings = 7;
                break;
            case "IOSettings_UserDefined":
            case 7:
                message.inputOutputSettings = 7;
                break;
            }
            if (object.isInterleaved != null)
                message.isInterleaved = Boolean(object.isInterleaved);
            if (object.sessionLocation != null)
                message.sessionLocation = String(object.sessionLocation);
            if (object.isCloudProject != null)
                message.isCloudProject = Boolean(object.isCloudProject);
            if (object.createFromAaf != null)
                message.createFromAaf = Boolean(object.createFromAaf);
            if (object.pathToAaf != null)
                message.pathToAaf = String(object.pathToAaf);
            switch (object.bitDepth) {
            default:
                if (typeof object.bitDepth === "number") {
                    message.bitDepth = object.bitDepth;
                    break;
                }
                break;
            case "BDepth_Unknown":
            case 0:
                message.bitDepth = 0;
                break;
            case "Bit_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "BDepth_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "Bit16":
            case 2:
                message.bitDepth = 2;
                break;
            case "BDepth_16":
            case 2:
                message.bitDepth = 2;
                break;
            case "Bit24":
            case 3:
                message.bitDepth = 3;
                break;
            case "BDepth_24":
            case 3:
                message.bitDepth = 3;
                break;
            case "Bit32Float":
            case 4:
                message.bitDepth = 4;
                break;
            case "BDepth_32Float":
            case 4:
                message.bitDepth = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateSessionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {ptsl.CreateSessionRequestBody} message CreateSessionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateSessionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sessionName = "";
                object.createFromTemplate = false;
                object.templateGroup = "";
                object.templateName = "";
                object.fileType = options.enums === String ? "FType_Unknown" : 0;
                object.sampleRate = options.enums === String ? "SRate_Unknown" : 0;
                object.inputOutputSettings = options.enums === String ? "IOSettings_Unknown" : 0;
                object.isInterleaved = false;
                object.sessionLocation = "";
                object.isCloudProject = false;
                object.createFromAaf = false;
                object.pathToAaf = "";
                object.bitDepth = options.enums === String ? "BDepth_Unknown" : 0;
            }
            if (message.sessionName != null && message.hasOwnProperty("sessionName"))
                object.sessionName = message.sessionName;
            if (message.createFromTemplate != null && message.hasOwnProperty("createFromTemplate"))
                object.createFromTemplate = message.createFromTemplate;
            if (message.templateGroup != null && message.hasOwnProperty("templateGroup"))
                object.templateGroup = message.templateGroup;
            if (message.templateName != null && message.hasOwnProperty("templateName"))
                object.templateName = message.templateName;
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.ptsl.FileType[message.fileType] === undefined ? message.fileType : $root.ptsl.FileType[message.fileType] : message.fileType;
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                object.sampleRate = options.enums === String ? $root.ptsl.SampleRate[message.sampleRate] === undefined ? message.sampleRate : $root.ptsl.SampleRate[message.sampleRate] : message.sampleRate;
            if (message.inputOutputSettings != null && message.hasOwnProperty("inputOutputSettings"))
                object.inputOutputSettings = options.enums === String ? $root.ptsl.IOSettings[message.inputOutputSettings] === undefined ? message.inputOutputSettings : $root.ptsl.IOSettings[message.inputOutputSettings] : message.inputOutputSettings;
            if (message.isInterleaved != null && message.hasOwnProperty("isInterleaved"))
                object.isInterleaved = message.isInterleaved;
            if (message.sessionLocation != null && message.hasOwnProperty("sessionLocation"))
                object.sessionLocation = message.sessionLocation;
            if (message.isCloudProject != null && message.hasOwnProperty("isCloudProject"))
                object.isCloudProject = message.isCloudProject;
            if (message.createFromAaf != null && message.hasOwnProperty("createFromAaf"))
                object.createFromAaf = message.createFromAaf;
            if (message.pathToAaf != null && message.hasOwnProperty("pathToAaf"))
                object.pathToAaf = message.pathToAaf;
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                object.bitDepth = options.enums === String ? $root.ptsl.BitDepth[message.bitDepth] === undefined ? message.bitDepth : $root.ptsl.BitDepth[message.bitDepth] : message.bitDepth;
            return object;
        };

        /**
         * Converts this CreateSessionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateSessionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateSessionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateSessionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CreateSessionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateSessionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateSessionRequestBody";
        };

        return CreateSessionRequestBody;
    })();

    ptsl.OpenSessionBehaviorOptions = (function() {

        /**
         * Properties of an OpenSessionBehaviorOptions.
         * @memberof ptsl
         * @interface IOpenSessionBehaviorOptions
         */

        /**
         * Constructs a new OpenSessionBehaviorOptions.
         * @memberof ptsl
         * @classdesc Structure that describes behavior aspects during OpenSession command.
         * There are no fields as of now but they may be added in the future updates
         * to provide more control of the OpenSession execution.
         * Pass empty message to OpenSession command request body to suppress all possible alerts and dialogs
         * that can pop up during Pro Tools session opening (Session Notes, Missing AAX Plugins, etc.).
         * @since Pro Tools 2025.06
         * @implements IOpenSessionBehaviorOptions
         * @constructor
         * @param {ptsl.IOpenSessionBehaviorOptions=} [properties] Properties to set
         */
        function OpenSessionBehaviorOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new OpenSessionBehaviorOptions instance using the specified properties.
         * @function create
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {ptsl.IOpenSessionBehaviorOptions=} [properties] Properties to set
         * @returns {ptsl.OpenSessionBehaviorOptions} OpenSessionBehaviorOptions instance
         */
        OpenSessionBehaviorOptions.create = function create(properties) {
            return new OpenSessionBehaviorOptions(properties);
        };

        /**
         * Encodes the specified OpenSessionBehaviorOptions message. Does not implicitly {@link ptsl.OpenSessionBehaviorOptions.verify|verify} messages.
         * @function encode
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {ptsl.IOpenSessionBehaviorOptions} message OpenSessionBehaviorOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenSessionBehaviorOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified OpenSessionBehaviorOptions message, length delimited. Does not implicitly {@link ptsl.OpenSessionBehaviorOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {ptsl.IOpenSessionBehaviorOptions} message OpenSessionBehaviorOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenSessionBehaviorOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenSessionBehaviorOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.OpenSessionBehaviorOptions} OpenSessionBehaviorOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenSessionBehaviorOptions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.OpenSessionBehaviorOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenSessionBehaviorOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.OpenSessionBehaviorOptions} OpenSessionBehaviorOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenSessionBehaviorOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenSessionBehaviorOptions message.
         * @function verify
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenSessionBehaviorOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an OpenSessionBehaviorOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.OpenSessionBehaviorOptions} OpenSessionBehaviorOptions
         */
        OpenSessionBehaviorOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.OpenSessionBehaviorOptions)
                return object;
            return new $root.ptsl.OpenSessionBehaviorOptions();
        };

        /**
         * Creates a plain object from an OpenSessionBehaviorOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {ptsl.OpenSessionBehaviorOptions} message OpenSessionBehaviorOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenSessionBehaviorOptions.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this OpenSessionBehaviorOptions to JSON.
         * @function toJSON
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenSessionBehaviorOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OpenSessionBehaviorOptions
         * @function getTypeUrl
         * @memberof ptsl.OpenSessionBehaviorOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OpenSessionBehaviorOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.OpenSessionBehaviorOptions";
        };

        return OpenSessionBehaviorOptions;
    })();

    ptsl.OpenSessionRequestBody = (function() {

        /**
         * Properties of an OpenSessionRequestBody.
         * @memberof ptsl
         * @interface IOpenSessionRequestBody
         * @property {string|null} [sessionPath] OpenSessionRequestBody sessionPath
         * @property {ptsl.IOpenSessionBehaviorOptions|null} [behaviorOptions] * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new OpenSessionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes OpenSession request data.
         * @implements IOpenSessionRequestBody
         * @constructor
         * @param {ptsl.IOpenSessionRequestBody=} [properties] Properties to set
         */
        function OpenSessionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenSessionRequestBody sessionPath.
         * @member {string} sessionPath
         * @memberof ptsl.OpenSessionRequestBody
         * @instance
         */
        OpenSessionRequestBody.prototype.sessionPath = "";

        /**
         * * @since Pro Tools 2025.06
         * @member {ptsl.IOpenSessionBehaviorOptions|null|undefined} behaviorOptions
         * @memberof ptsl.OpenSessionRequestBody
         * @instance
         */
        OpenSessionRequestBody.prototype.behaviorOptions = null;

        /**
         * Creates a new OpenSessionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {ptsl.IOpenSessionRequestBody=} [properties] Properties to set
         * @returns {ptsl.OpenSessionRequestBody} OpenSessionRequestBody instance
         */
        OpenSessionRequestBody.create = function create(properties) {
            return new OpenSessionRequestBody(properties);
        };

        /**
         * Encodes the specified OpenSessionRequestBody message. Does not implicitly {@link ptsl.OpenSessionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {ptsl.IOpenSessionRequestBody} message OpenSessionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenSessionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionPath != null && Object.hasOwnProperty.call(message, "sessionPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionPath);
            if (message.behaviorOptions != null && Object.hasOwnProperty.call(message, "behaviorOptions"))
                $root.ptsl.OpenSessionBehaviorOptions.encode(message.behaviorOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenSessionRequestBody message, length delimited. Does not implicitly {@link ptsl.OpenSessionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {ptsl.IOpenSessionRequestBody} message OpenSessionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenSessionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenSessionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.OpenSessionRequestBody} OpenSessionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenSessionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.OpenSessionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionPath = reader.string();
                        break;
                    }
                case 2: {
                        message.behaviorOptions = $root.ptsl.OpenSessionBehaviorOptions.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenSessionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.OpenSessionRequestBody} OpenSessionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenSessionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenSessionRequestBody message.
         * @function verify
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenSessionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionPath != null && message.hasOwnProperty("sessionPath"))
                if (!$util.isString(message.sessionPath))
                    return "sessionPath: string expected";
            if (message.behaviorOptions != null && message.hasOwnProperty("behaviorOptions")) {
                var error = $root.ptsl.OpenSessionBehaviorOptions.verify(message.behaviorOptions);
                if (error)
                    return "behaviorOptions." + error;
            }
            return null;
        };

        /**
         * Creates an OpenSessionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.OpenSessionRequestBody} OpenSessionRequestBody
         */
        OpenSessionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.OpenSessionRequestBody)
                return object;
            var message = new $root.ptsl.OpenSessionRequestBody();
            if (object.sessionPath != null)
                message.sessionPath = String(object.sessionPath);
            if (object.behaviorOptions != null) {
                if (typeof object.behaviorOptions !== "object")
                    throw TypeError(".ptsl.OpenSessionRequestBody.behaviorOptions: object expected");
                message.behaviorOptions = $root.ptsl.OpenSessionBehaviorOptions.fromObject(object.behaviorOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from an OpenSessionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {ptsl.OpenSessionRequestBody} message OpenSessionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenSessionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sessionPath = "";
                object.behaviorOptions = null;
            }
            if (message.sessionPath != null && message.hasOwnProperty("sessionPath"))
                object.sessionPath = message.sessionPath;
            if (message.behaviorOptions != null && message.hasOwnProperty("behaviorOptions"))
                object.behaviorOptions = $root.ptsl.OpenSessionBehaviorOptions.toObject(message.behaviorOptions, options);
            return object;
        };

        /**
         * Converts this OpenSessionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.OpenSessionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenSessionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OpenSessionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.OpenSessionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OpenSessionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.OpenSessionRequestBody";
        };

        return OpenSessionRequestBody;
    })();

    /**
     * Types of data which can be imported into Pro Tools.
     * @name ptsl.ImportType
     * @enum {number}
     * @property {number} IType_Unknown=0 IType_Unknown value
     * @property {number} Session=1 * @deprecated ptsl::ImportType::Session is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ImportType::IType_Session
     * @property {number} IType_Session=1 IType_Session value
     * @property {number} Audio=2 * @deprecated ptsl::ImportType::Audio is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ImportType::IType_Audio
     * @property {number} IType_Audio=2 IType_Audio value
     */
    ptsl.ImportType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IType_Unknown"] = 0;
        values[valuesById[1] = "Session"] = 1;
        values["IType_Session"] = 1;
        values[valuesById[2] = "Audio"] = 2;
        values["IType_Audio"] = 2;
        return values;
    })();

    /**
     * Audio import options.
     * @name ptsl.AudioMediaOptions
     * @enum {number}
     * @property {number} AMOptions_Unknown=0 AMOptions_Unknown value
     * @property {number} LinkToSourceAudio=1 * @deprecated ptsl::AudioMediaOptions::LinkToSource is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioMediaOptions::AMOptions_LinkToSource
     * @property {number} AMOptions_LinkToSourceAudio=1 AMOptions_LinkToSourceAudio value
     * @property {number} CopyFromSourceAudio=2 * @deprecated ptsl::AudioMediaOptions::CopyFromSource is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioMediaOptions::AMOptions_CopyFromSource
     * @property {number} AMOptions_CopyFromSourceAudio=2 AMOptions_CopyFromSourceAudio value
     * @property {number} ConsolidateFromSourceAudio=3 * @deprecated ptsl::AudioMediaOptions::ConsolidateFromSource is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioMediaOptions::AMOptions_ConsolidateFromSource
     * @property {number} AMOptions_ConsolidateFromSourceAudio=3 AMOptions_ConsolidateFromSourceAudio value
     * @property {number} ForceToTargetSessionFormat=4 * @deprecated ptsl::AudioMediaOptions::ForceToTargetSessionFormat is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioMediaOptions::AMOptions_ForceToTargetSessionFormat
     * @property {number} AMOptions_ForceToTargetSessionFormat=4 AMOptions_ForceToTargetSessionFormat value
     */
    ptsl.AudioMediaOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AMOptions_Unknown"] = 0;
        values[valuesById[1] = "LinkToSourceAudio"] = 1;
        values["AMOptions_LinkToSourceAudio"] = 1;
        values[valuesById[2] = "CopyFromSourceAudio"] = 2;
        values["AMOptions_CopyFromSourceAudio"] = 2;
        values[valuesById[3] = "ConsolidateFromSourceAudio"] = 3;
        values["AMOptions_ConsolidateFromSourceAudio"] = 3;
        values[valuesById[4] = "ForceToTargetSessionFormat"] = 4;
        values["AMOptions_ForceToTargetSessionFormat"] = 4;
        return values;
    })();

    /**
     * Video import options.
     * @name ptsl.VideoMediaOptions
     * @enum {number}
     * @property {number} VMOptions_Unknown=0 VMOptions_Unknown value
     * @property {number} LinkToSourceVideo=1 * @deprecated ptsl::VideoMediaOptions::LinkToSourceVideo is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::VideoMediaOptions::VMOptions_LinkToSourceVideo
     * @property {number} VMOptions_LinkToSourceVideo=1 VMOptions_LinkToSourceVideo value
     * @property {number} CopyFromSourceVideo=2 * @deprecated ptsl::VideoMediaOptions::CopyFromSourceVideo is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::VideoMediaOptions::VMOptions_CopyFromSourceVideo
     * @property {number} VMOptions_CopyFromSourceVideo=2 VMOptions_CopyFromSourceVideo value
     * @property {number} ImportAsOfflineSatelliteMedia=3 * @deprecated since Pro Tools 2025.06
     */
    ptsl.VideoMediaOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VMOptions_Unknown"] = 0;
        values[valuesById[1] = "LinkToSourceVideo"] = 1;
        values["VMOptions_LinkToSourceVideo"] = 1;
        values[valuesById[2] = "CopyFromSourceVideo"] = 2;
        values["VMOptions_CopyFromSourceVideo"] = 2;
        values[valuesById[3] = "ImportAsOfflineSatelliteMedia"] = 3;
        return values;
    })();

    /**
     * Options for matching tracks during import.
     * @name ptsl.MatchTrackOptions
     * @enum {number}
     * @property {number} MTOptions_Unknown=0 MTOptions_Unknown value
     * @property {number} MT_None=1 * @deprecated ptsl::MatchTrackOptions::MT_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MatchTrackOptions::MTOptions_None
     * @property {number} MTOptions_None=1 MTOptions_None value
     * @property {number} MT_MatchTracks=2 * @deprecated ptsl::MatchTrackOptions::MT_MatchTracks is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MatchTrackOptions::MTOptions_MatchTracks
     * @property {number} MTOptions_MatchTracks=2 MTOptions_MatchTracks value
     * @property {number} MT_ImportAsNewTrack=3 * @deprecated ptsl::MatchTrackOptions::MT_ImportAsNewTrack is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MatchTrackOptions::MTOptions_ImportAsNewTrack
     * @property {number} MTOptions_ImportAsNewTrack=3 MTOptions_ImportAsNewTrack value
     */
    ptsl.MatchTrackOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MTOptions_Unknown"] = 0;
        values[valuesById[1] = "MT_None"] = 1;
        values["MTOptions_None"] = 1;
        values[valuesById[2] = "MT_MatchTracks"] = 2;
        values["MTOptions_MatchTracks"] = 2;
        values[valuesById[3] = "MT_ImportAsNewTrack"] = 3;
        values["MTOptions_ImportAsNewTrack"] = 3;
        return values;
    })();

    /**
     * Options for time code mapping.
     * @name ptsl.TimeCodeMappingOptions
     * @enum {number}
     * @property {number} TCMOptions_Unknown=0 TCMOptions_Unknown value
     * @property {number} MaintainAbsoluteTimeCodeValues=1 * @deprecated ptsl::TimeCodeMappingOptions::MaintainAbsoluteTimeCodeValues is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimeCodeMappingOptions::TCMOptions_MaintainAbsoluteTimeCodeValues
     * @property {number} TCMOptions_MaintainAbsoluteTimeCodeValues=1 TCMOptions_MaintainAbsoluteTimeCodeValues value
     * @property {number} MaintainRelativeTimeCodeValues=2 * @deprecated ptsl::TimeCodeMappingOptions::MaintainRelativeTimeCodeValues is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimeCodeMappingOptions::TCMOptions_MaintainRelativeTimeCodeValues
     * @property {number} TCMOptions_MaintainRelativeTimeCodeValues=2 TCMOptions_MaintainRelativeTimeCodeValues value
     * @property {number} MapStartTimeCodeTo=3 * @deprecated ptsl::TimeCodeMappingOptions::MapStartTimeCodeTo is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimeCodeMappingOptions::TCMOptions_MapStartTimeCodeTo
     * @property {number} TCMOptions_MapStartTimeCodeTo=3 TCMOptions_MapStartTimeCodeTo value
     */
    ptsl.TimeCodeMappingOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TCMOptions_Unknown"] = 0;
        values[valuesById[1] = "MaintainAbsoluteTimeCodeValues"] = 1;
        values["TCMOptions_MaintainAbsoluteTimeCodeValues"] = 1;
        values[valuesById[2] = "MaintainRelativeTimeCodeValues"] = 2;
        values["TCMOptions_MaintainRelativeTimeCodeValues"] = 2;
        values[valuesById[3] = "MapStartTimeCodeTo"] = 3;
        values["TCMOptions_MapStartTimeCodeTo"] = 3;
        return values;
    })();

    /**
     * Options for track offsets.
     * @name ptsl.TrackOffsetOptions
     * @enum {number}
     * @property {number} TOOptions_Unknown=0 TOOptions_Unknown value
     * @property {number} BarsBeats=1 * @deprecated ptsl::TrackOffsetOptions::BarsBeats is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackOffsetOptions::TOOptions_BarsBeats
     * @property {number} TOOptions_BarsBeats=1 TOOptions_BarsBeats value
     * @property {number} MinSecs=2 * @deprecated ptsl::TrackOffsetOptions::MinSecs is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackOffsetOptions::TOOptions_MinSecs
     * @property {number} TOOptions_MinSecs=2 TOOptions_MinSecs value
     * @property {number} TimeCode=3 * @deprecated ptsl::TrackOffsetOptions::TimeCode is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackOffsetOptions::TOOptions_TimeCode
     * @property {number} TOOptions_TimeCode=3 TOOptions_TimeCode value
     * @property {number} FeetFrames=4 * @deprecated ptsl::TrackOffsetOptions::FeetFrames is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackOffsetOptions::TOOptions_FeetFrames
     * @property {number} TOOptions_FeetFrames=4 TOOptions_FeetFrames value
     * @property {number} Samples=5 * @deprecated ptsl::TrackOffsetOptions::Samples is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackOffsetOptions::TOOptions_Samples
     * @property {number} TOOptions_Samples=5 TOOptions_Samples value
     */
    ptsl.TrackOffsetOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TOOptions_Unknown"] = 0;
        values[valuesById[1] = "BarsBeats"] = 1;
        values["TOOptions_BarsBeats"] = 1;
        values[valuesById[2] = "MinSecs"] = 2;
        values["TOOptions_MinSecs"] = 2;
        values[valuesById[3] = "TimeCode"] = 3;
        values["TOOptions_TimeCode"] = 3;
        values[valuesById[4] = "FeetFrames"] = 4;
        values["TOOptions_FeetFrames"] = 4;
        values[valuesById[5] = "Samples"] = 5;
        values["TOOptions_Samples"] = 5;
        return values;
    })();

    /**
     * Types of conversion quality.
     * @name ptsl.ConversionQuality
     * @enum {number}
     * @property {number} CQuality_Unknown=0 CQuality_Unknown value
     * @property {number} Low=1 Low value
     * @property {number} CQuality_Low=1 CQuality_Low value
     * @property {number} Good=2 Good value
     * @property {number} CQuality_Good=2 CQuality_Good value
     * @property {number} Better=3 Better value
     * @property {number} CQuality_Better=3 CQuality_Better value
     * @property {number} Best=4 Best value
     * @property {number} CQuality_Best=4 CQuality_Best value
     * @property {number} TweakHead=5 TweakHead value
     * @property {number} CQuality_TweakHead=5 CQuality_TweakHead value
     */
    ptsl.ConversionQuality = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CQuality_Unknown"] = 0;
        values[valuesById[1] = "Low"] = 1;
        values["CQuality_Low"] = 1;
        values[valuesById[2] = "Good"] = 2;
        values["CQuality_Good"] = 2;
        values[valuesById[3] = "Better"] = 3;
        values["CQuality_Better"] = 3;
        values[valuesById[4] = "Best"] = 4;
        values["CQuality_Best"] = 4;
        values[valuesById[5] = "TweakHead"] = 5;
        values["CQuality_TweakHead"] = 5;
        return values;
    })();

    /**
     * Options for playlists import.
     * @name ptsl.MainPlaylistOptions
     * @enum {number}
     * @property {number} MPOptions_Unknown=0 MPOptions_Unknown value
     * @property {number} ImportReplaceExistingPlaylists=1 * @deprecated ptsl::MainPlaylistOptions::ImportReplaceExistingPlaylists is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MainPlaylistOptions::MPOptions_ImportReplaceExistingPlaylists
     * @property {number} MPOptions_ImportReplaceExistingPlaylists=1 MPOptions_ImportReplaceExistingPlaylists value
     * @property {number} ImportOverlayNewOnExistingPlaylists=2 * @deprecated ptsl::MainPlaylistOptions::ImportOverlayNewOnExistingPlaylists is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MainPlaylistOptions::MPOptions_ImportOverlayNewOnExistingPlaylists
     * @property {number} MPOptions_ImportOverlayNewOnExistingPlaylists=2 MPOptions_ImportOverlayNewOnExistingPlaylists value
     * @property {number} DoNotImport=3 * @deprecated ptsl::MainPlaylistOptions::DoNotImport is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MainPlaylistOptions::MPOptions_DoNotImport
     * @property {number} MPOptions_DoNotImport=3 MPOptions_DoNotImport value
     */
    ptsl.MainPlaylistOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MPOptions_Unknown"] = 0;
        values[valuesById[1] = "ImportReplaceExistingPlaylists"] = 1;
        values["MPOptions_ImportReplaceExistingPlaylists"] = 1;
        values[valuesById[2] = "ImportOverlayNewOnExistingPlaylists"] = 2;
        values["MPOptions_ImportOverlayNewOnExistingPlaylists"] = 2;
        values[valuesById[3] = "DoNotImport"] = 3;
        values["MPOptions_DoNotImport"] = 3;
        return values;
    })();

    /**
     * Audio import operations.
     * @name ptsl.AudioOperations
     * @enum {number}
     * @property {number} AOperations_Unknown=0 AOperations_Unknown value
     * @property {number} AddAudio=1 * @deprecated ptsl::AudioOperations::AddAudio is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioOperations::AOperations_AddAudio
     * @property {number} AOperations_AddAudio=1 AOperations_AddAudio value
     * @property {number} CopyAudio=2 * @deprecated ptsl::AudioOperations::CopyAudio is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioOperations::AOperations_CopyAudio
     * @property {number} AOperations_CopyAudio=2 AOperations_CopyAudio value
     * @property {number} ConvertAudio=3 * @deprecated ptsl::AudioOperations::ConvertAudio is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioOperations::AOperations_ConvertAudio
     * @property {number} AOperations_ConvertAudio=3 AOperations_ConvertAudio value
     * @property {number} Default=4 * @deprecated ptsl::AudioOperations::Default is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AudioOperations::AOperations_Default
     * @property {number} AOperations_Default=4 AOperations_Default value
     */
    ptsl.AudioOperations = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AOperations_Unknown"] = 0;
        values[valuesById[1] = "AddAudio"] = 1;
        values["AOperations_AddAudio"] = 1;
        values[valuesById[2] = "CopyAudio"] = 2;
        values["AOperations_CopyAudio"] = 2;
        values[valuesById[3] = "ConvertAudio"] = 3;
        values["AOperations_ConvertAudio"] = 3;
        values[valuesById[4] = "Default"] = 4;
        values["AOperations_Default"] = 4;
        return values;
    })();

    /**
     * Types of destination.
     * @name ptsl.MediaDestination
     * @enum {number}
     * @property {number} MDestination_Unknown=0 MDestination_Unknown value
     * @property {number} MD_None=1 * @deprecated ptsl::MediaDestination::MD_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaDestination::MDestination_None
     * @property {number} MDestination_None=1 MDestination_None value
     * @property {number} MD_MainVideoTrack=2 * @deprecated ptsl::MediaDestination::MD_MainVideoTrack is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaDestination::MDestination_MainVideoTrack
     * @property {number} MDestination_MainVideoTrack=2 MDestination_MainVideoTrack value
     * @property {number} MD_NewTrack=3 * @deprecated ptsl::MediaDestination::MD_NewTrack is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaDestination::MDestination_NewTrack
     * @property {number} MDestination_NewTrack=3 MDestination_NewTrack value
     * @property {number} MD_ClipList=4 * @deprecated ptsl::MediaDestination::MD_ClipList is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaDestination::MDestination_ClipList
     * @property {number} MDestination_ClipList=4 MDestination_ClipList value
     */
    ptsl.MediaDestination = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MDestination_Unknown"] = 0;
        values[valuesById[1] = "MD_None"] = 1;
        values["MDestination_None"] = 1;
        values[valuesById[2] = "MD_MainVideoTrack"] = 2;
        values["MDestination_MainVideoTrack"] = 2;
        values[valuesById[3] = "MD_NewTrack"] = 3;
        values["MDestination_NewTrack"] = 3;
        values[valuesById[4] = "MD_ClipList"] = 4;
        values["MDestination_ClipList"] = 4;
        return values;
    })();

    /**
     * Types of location in the session.
     * @name ptsl.MediaLocation
     * @enum {number}
     * @property {number} MLocation_Unknown=0 MLocation_Unknown value
     * @property {number} ML_None=1 * @deprecated ptsl::MediaLocation::ML_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaLocation::MLocation_None
     * @property {number} MLocation_None=1 MLocation_None value
     * @property {number} ML_SessionStart=2 * @deprecated ptsl::MediaLocation::ML_SessionStart is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaLocation::MLocation_SessionStart
     * @property {number} MLocation_SessionStart=2 MLocation_SessionStart value
     * @property {number} ML_SongStart=3 * @deprecated ptsl::MediaLocation::ML_SongStart is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaLocation::MLocation_SongStart
     * @property {number} MLocation_SongStart=3 MLocation_SongStart value
     * @property {number} ML_Selection=4 * @deprecated ptsl::MediaLocation::ML_Selection is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaLocation::MLocation_Selection
     * @property {number} MLocation_Selection=4 MLocation_Selection value
     * @property {number} ML_Spot=5 * @deprecated ptsl::MediaLocation::ML_Spot is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MediaLocation::MLocation_Spot
     * @property {number} MLocation_Spot=5 MLocation_Spot value
     */
    ptsl.MediaLocation = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MLocation_Unknown"] = 0;
        values[valuesById[1] = "ML_None"] = 1;
        values["MLocation_None"] = 1;
        values[valuesById[2] = "ML_SessionStart"] = 2;
        values["MLocation_SessionStart"] = 2;
        values[valuesById[3] = "ML_SongStart"] = 3;
        values["MLocation_SongStart"] = 3;
        values[valuesById[4] = "ML_Selection"] = 4;
        values["MLocation_Selection"] = 4;
        values[valuesById[5] = "ML_Spot"] = 5;
        values["MLocation_Spot"] = 5;
        return values;
    })();

    /**
     * Types of track list filters.
     * @name ptsl.TrackListFilter
     * @enum {number}
     * @property {number} TLFilter_Unknown=0 TLFilter_Unknown value
     * @property {number} All=1 * @deprecated ptsl::TrackListFilter::All is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_All
     * @property {number} TLFilter_All=1 TLFilter_All value
     * @property {number} Selected=2 * @deprecated ptsl::TrackListFilter::Selected is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Selected
     * @property {number} TLFilter_Selected=2 TLFilter_Selected value
     * @property {number} SelectedExplicitly=3 * @deprecated ptsl::TrackListFilter::SelectedExplicitly is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_SelectedExplicitly
     * @property {number} TLFilter_SelectedExplicitly=3 TLFilter_SelectedExplicitly value
     * @property {number} SelectedImplicitly=4 * @deprecated ptsl::TrackListFilter::SelectedImplicitly is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_SelectedImplicitly
     * @property {number} TLFilter_SelectedImplicitly=4 TLFilter_SelectedImplicitly value
     * @property {number} WithClipsOnMainPlaylist=5 * @deprecated ptsl::TrackListFilter::WithClipsOnMainPlaylist is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_WithClipsOnMainPlaylist
     * @property {number} TLFilter_WithClipsOnMainPlaylist=5 TLFilter_WithClipsOnMainPlaylist value
     * @property {number} WithAutomationOnMainPlaylist=6 * @deprecated ptsl::TrackListFilter::WithAutomationOnMainPlaylist is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_WithAutomationOnMainPlaylist
     * @property {number} TLFilter_WithAutomationOnMainPlaylist=6 TLFilter_WithAutomationOnMainPlaylist value
     * @property {number} Inactive=7 * @deprecated ptsl::TrackListFilter::Inactive is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Inactive
     * @property {number} TLFilter_Inactive=7 TLFilter_Inactive value
     * @property {number} InactiveExplicitly=8 * @deprecated ptsl::TrackListFilter::InactiveExplicitly is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_InactiveExplicitly
     * @property {number} TLFilter_InactiveExplicitly=8 TLFilter_InactiveExplicitly value
     * @property {number} InactiveImplicitly=9 * @deprecated ptsl::TrackListFilter::InactiveImplicitly is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_InactiveImplicitly
     * @property {number} TLFilter_InactiveImplicitly=9 TLFilter_InactiveImplicitly value
     * @property {number} Hidden=10 * @deprecated ptsl::TrackListFilter::Hidden is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Hidden
     * @property {number} TLFilter_Hidden=10 TLFilter_Hidden value
     * @property {number} HiddenExplicitly=11 * @deprecated ptsl::TrackListFilter::HiddenExplicitly is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_HiddenExplicitly
     * @property {number} TLFilter_HiddenExplicitly=11 TLFilter_HiddenExplicitly value
     * @property {number} HiddenImplicitly=12 * @deprecated ptsl::TrackListFilter::HiddenImplicitly is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_HiddenImplicitly
     * @property {number} TLFilter_HiddenImplicitly=12 TLFilter_HiddenImplicitly value
     * @property {number} Locked=13 * @deprecated ptsl::TrackListFilter::Locked is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Locked
     * @property {number} TLFilter_Locked=13 TLFilter_Locked value
     * @property {number} Muted=14 * @deprecated ptsl::TrackListFilter::Muted is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Muted
     * @property {number} TLFilter_Muted=14 TLFilter_Muted value
     * @property {number} Frozen=15 * @deprecated ptsl::TrackListFilter::Frozen is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Frozen
     * @property {number} TLFilter_Frozen=15 TLFilter_Frozen value
     * @property {number} Open=16 * @deprecated ptsl::TrackListFilter::Open is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Open
     * @property {number} TLFilter_Open=16 TLFilter_Open value
     * @property {number} Online=17 * @deprecated ptsl::TrackListFilter::Online is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListFilter::TLFilter_Online
     * @property {number} TLFilter_Online=17 TLFilter_Online value
     * @property {number} TLFilter_HasEditSelection=18 TLFilter_HasEditSelection value
     * @property {number} TLFilter_HasEditSelectionExplicitly=19 TLFilter_HasEditSelectionExplicitly value
     * @property {number} TLFilter_HasEditSelectionImplicitly=20 TLFilter_HasEditSelectionImplicitly value
     */
    ptsl.TrackListFilter = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TLFilter_Unknown"] = 0;
        values[valuesById[1] = "All"] = 1;
        values["TLFilter_All"] = 1;
        values[valuesById[2] = "Selected"] = 2;
        values["TLFilter_Selected"] = 2;
        values[valuesById[3] = "SelectedExplicitly"] = 3;
        values["TLFilter_SelectedExplicitly"] = 3;
        values[valuesById[4] = "SelectedImplicitly"] = 4;
        values["TLFilter_SelectedImplicitly"] = 4;
        values[valuesById[5] = "WithClipsOnMainPlaylist"] = 5;
        values["TLFilter_WithClipsOnMainPlaylist"] = 5;
        values[valuesById[6] = "WithAutomationOnMainPlaylist"] = 6;
        values["TLFilter_WithAutomationOnMainPlaylist"] = 6;
        values[valuesById[7] = "Inactive"] = 7;
        values["TLFilter_Inactive"] = 7;
        values[valuesById[8] = "InactiveExplicitly"] = 8;
        values["TLFilter_InactiveExplicitly"] = 8;
        values[valuesById[9] = "InactiveImplicitly"] = 9;
        values["TLFilter_InactiveImplicitly"] = 9;
        values[valuesById[10] = "Hidden"] = 10;
        values["TLFilter_Hidden"] = 10;
        values[valuesById[11] = "HiddenExplicitly"] = 11;
        values["TLFilter_HiddenExplicitly"] = 11;
        values[valuesById[12] = "HiddenImplicitly"] = 12;
        values["TLFilter_HiddenImplicitly"] = 12;
        values[valuesById[13] = "Locked"] = 13;
        values["TLFilter_Locked"] = 13;
        values[valuesById[14] = "Muted"] = 14;
        values["TLFilter_Muted"] = 14;
        values[valuesById[15] = "Frozen"] = 15;
        values["TLFilter_Frozen"] = 15;
        values[valuesById[16] = "Open"] = 16;
        values["TLFilter_Open"] = 16;
        values[valuesById[17] = "Online"] = 17;
        values["TLFilter_Online"] = 17;
        values[valuesById[18] = "TLFilter_HasEditSelection"] = 18;
        values[valuesById[19] = "TLFilter_HasEditSelectionExplicitly"] = 19;
        values[valuesById[20] = "TLFilter_HasEditSelectionImplicitly"] = 20;
        return values;
    })();

    ptsl.TrackDataToImport = (function() {

        /**
         * Properties of a TrackDataToImport.
         * @memberof ptsl
         * @interface ITrackDataToImport
         * @property {string|null} [trackDataPresetPath] TrackDataToImport trackDataPresetPath
         * @property {boolean|null} [clipGain] TrackDataToImport clipGain
         * @property {boolean|null} [clipsAndMedia] TrackDataToImport clipsAndMedia
         * @property {boolean|null} [volumeAutomation] TrackDataToImport volumeAutomation
         */

        /**
         * Constructs a new TrackDataToImport.
         * @memberof ptsl
         * @classdesc Structure that describes track data for import.
         * @implements ITrackDataToImport
         * @constructor
         * @param {ptsl.ITrackDataToImport=} [properties] Properties to set
         */
        function TrackDataToImport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrackDataToImport trackDataPresetPath.
         * @member {string} trackDataPresetPath
         * @memberof ptsl.TrackDataToImport
         * @instance
         */
        TrackDataToImport.prototype.trackDataPresetPath = "";

        /**
         * TrackDataToImport clipGain.
         * @member {boolean} clipGain
         * @memberof ptsl.TrackDataToImport
         * @instance
         */
        TrackDataToImport.prototype.clipGain = false;

        /**
         * TrackDataToImport clipsAndMedia.
         * @member {boolean} clipsAndMedia
         * @memberof ptsl.TrackDataToImport
         * @instance
         */
        TrackDataToImport.prototype.clipsAndMedia = false;

        /**
         * TrackDataToImport volumeAutomation.
         * @member {boolean} volumeAutomation
         * @memberof ptsl.TrackDataToImport
         * @instance
         */
        TrackDataToImport.prototype.volumeAutomation = false;

        /**
         * Creates a new TrackDataToImport instance using the specified properties.
         * @function create
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {ptsl.ITrackDataToImport=} [properties] Properties to set
         * @returns {ptsl.TrackDataToImport} TrackDataToImport instance
         */
        TrackDataToImport.create = function create(properties) {
            return new TrackDataToImport(properties);
        };

        /**
         * Encodes the specified TrackDataToImport message. Does not implicitly {@link ptsl.TrackDataToImport.verify|verify} messages.
         * @function encode
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {ptsl.ITrackDataToImport} message TrackDataToImport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackDataToImport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackDataPresetPath != null && Object.hasOwnProperty.call(message, "trackDataPresetPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackDataPresetPath);
            if (message.clipGain != null && Object.hasOwnProperty.call(message, "clipGain"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.clipGain);
            if (message.clipsAndMedia != null && Object.hasOwnProperty.call(message, "clipsAndMedia"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.clipsAndMedia);
            if (message.volumeAutomation != null && Object.hasOwnProperty.call(message, "volumeAutomation"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.volumeAutomation);
            return writer;
        };

        /**
         * Encodes the specified TrackDataToImport message, length delimited. Does not implicitly {@link ptsl.TrackDataToImport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {ptsl.ITrackDataToImport} message TrackDataToImport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackDataToImport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrackDataToImport message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.TrackDataToImport} TrackDataToImport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackDataToImport.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.TrackDataToImport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.trackDataPresetPath = reader.string();
                        break;
                    }
                case 2: {
                        message.clipGain = reader.bool();
                        break;
                    }
                case 3: {
                        message.clipsAndMedia = reader.bool();
                        break;
                    }
                case 4: {
                        message.volumeAutomation = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrackDataToImport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.TrackDataToImport} TrackDataToImport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackDataToImport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrackDataToImport message.
         * @function verify
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrackDataToImport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackDataPresetPath != null && message.hasOwnProperty("trackDataPresetPath"))
                if (!$util.isString(message.trackDataPresetPath))
                    return "trackDataPresetPath: string expected";
            if (message.clipGain != null && message.hasOwnProperty("clipGain"))
                if (typeof message.clipGain !== "boolean")
                    return "clipGain: boolean expected";
            if (message.clipsAndMedia != null && message.hasOwnProperty("clipsAndMedia"))
                if (typeof message.clipsAndMedia !== "boolean")
                    return "clipsAndMedia: boolean expected";
            if (message.volumeAutomation != null && message.hasOwnProperty("volumeAutomation"))
                if (typeof message.volumeAutomation !== "boolean")
                    return "volumeAutomation: boolean expected";
            return null;
        };

        /**
         * Creates a TrackDataToImport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.TrackDataToImport} TrackDataToImport
         */
        TrackDataToImport.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.TrackDataToImport)
                return object;
            var message = new $root.ptsl.TrackDataToImport();
            if (object.trackDataPresetPath != null)
                message.trackDataPresetPath = String(object.trackDataPresetPath);
            if (object.clipGain != null)
                message.clipGain = Boolean(object.clipGain);
            if (object.clipsAndMedia != null)
                message.clipsAndMedia = Boolean(object.clipsAndMedia);
            if (object.volumeAutomation != null)
                message.volumeAutomation = Boolean(object.volumeAutomation);
            return message;
        };

        /**
         * Creates a plain object from a TrackDataToImport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {ptsl.TrackDataToImport} message TrackDataToImport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrackDataToImport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trackDataPresetPath = "";
                object.clipGain = false;
                object.clipsAndMedia = false;
                object.volumeAutomation = false;
            }
            if (message.trackDataPresetPath != null && message.hasOwnProperty("trackDataPresetPath"))
                object.trackDataPresetPath = message.trackDataPresetPath;
            if (message.clipGain != null && message.hasOwnProperty("clipGain"))
                object.clipGain = message.clipGain;
            if (message.clipsAndMedia != null && message.hasOwnProperty("clipsAndMedia"))
                object.clipsAndMedia = message.clipsAndMedia;
            if (message.volumeAutomation != null && message.hasOwnProperty("volumeAutomation"))
                object.volumeAutomation = message.volumeAutomation;
            return object;
        };

        /**
         * Converts this TrackDataToImport to JSON.
         * @function toJSON
         * @memberof ptsl.TrackDataToImport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrackDataToImport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrackDataToImport
         * @function getTypeUrl
         * @memberof ptsl.TrackDataToImport
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrackDataToImport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.TrackDataToImport";
        };

        return TrackDataToImport;
    })();

    ptsl.SessionDataImport = (function() {

        /**
         * Properties of a SessionDataImport.
         * @memberof ptsl
         * @interface ISessionDataImport
         * @property {boolean|null} [tempoMeterMap] SessionDataImport tempoMeterMap
         * @property {boolean|null} [keySignatureChoedMap] SessionDataImport keySignatureChoedMap
         * @property {boolean|null} [markersMemoryLocations] SessionDataImport markersMemoryLocations
         * @property {boolean|null} [windowConfigurations] SessionDataImport windowConfigurations
         * @property {boolean|null} [micPreSettings] SessionDataImport micPreSettings
         * @property {boolean|null} [heatMasterSettings] SessionDataImport heatMasterSettings
         */

        /**
         * Constructs a new SessionDataImport.
         * @memberof ptsl
         * @classdesc Structure that describes other session data for import.
         * @implements ISessionDataImport
         * @constructor
         * @param {ptsl.ISessionDataImport=} [properties] Properties to set
         */
        function SessionDataImport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionDataImport tempoMeterMap.
         * @member {boolean} tempoMeterMap
         * @memberof ptsl.SessionDataImport
         * @instance
         */
        SessionDataImport.prototype.tempoMeterMap = false;

        /**
         * SessionDataImport keySignatureChoedMap.
         * @member {boolean} keySignatureChoedMap
         * @memberof ptsl.SessionDataImport
         * @instance
         */
        SessionDataImport.prototype.keySignatureChoedMap = false;

        /**
         * SessionDataImport markersMemoryLocations.
         * @member {boolean} markersMemoryLocations
         * @memberof ptsl.SessionDataImport
         * @instance
         */
        SessionDataImport.prototype.markersMemoryLocations = false;

        /**
         * SessionDataImport windowConfigurations.
         * @member {boolean} windowConfigurations
         * @memberof ptsl.SessionDataImport
         * @instance
         */
        SessionDataImport.prototype.windowConfigurations = false;

        /**
         * SessionDataImport micPreSettings.
         * @member {boolean} micPreSettings
         * @memberof ptsl.SessionDataImport
         * @instance
         */
        SessionDataImport.prototype.micPreSettings = false;

        /**
         * SessionDataImport heatMasterSettings.
         * @member {boolean} heatMasterSettings
         * @memberof ptsl.SessionDataImport
         * @instance
         */
        SessionDataImport.prototype.heatMasterSettings = false;

        /**
         * Creates a new SessionDataImport instance using the specified properties.
         * @function create
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {ptsl.ISessionDataImport=} [properties] Properties to set
         * @returns {ptsl.SessionDataImport} SessionDataImport instance
         */
        SessionDataImport.create = function create(properties) {
            return new SessionDataImport(properties);
        };

        /**
         * Encodes the specified SessionDataImport message. Does not implicitly {@link ptsl.SessionDataImport.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {ptsl.ISessionDataImport} message SessionDataImport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionDataImport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempoMeterMap != null && Object.hasOwnProperty.call(message, "tempoMeterMap"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.tempoMeterMap);
            if (message.keySignatureChoedMap != null && Object.hasOwnProperty.call(message, "keySignatureChoedMap"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.keySignatureChoedMap);
            if (message.markersMemoryLocations != null && Object.hasOwnProperty.call(message, "markersMemoryLocations"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.markersMemoryLocations);
            if (message.windowConfigurations != null && Object.hasOwnProperty.call(message, "windowConfigurations"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.windowConfigurations);
            if (message.micPreSettings != null && Object.hasOwnProperty.call(message, "micPreSettings"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.micPreSettings);
            if (message.heatMasterSettings != null && Object.hasOwnProperty.call(message, "heatMasterSettings"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.heatMasterSettings);
            return writer;
        };

        /**
         * Encodes the specified SessionDataImport message, length delimited. Does not implicitly {@link ptsl.SessionDataImport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {ptsl.ISessionDataImport} message SessionDataImport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionDataImport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionDataImport message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SessionDataImport} SessionDataImport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionDataImport.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SessionDataImport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.tempoMeterMap = reader.bool();
                        break;
                    }
                case 2: {
                        message.keySignatureChoedMap = reader.bool();
                        break;
                    }
                case 3: {
                        message.markersMemoryLocations = reader.bool();
                        break;
                    }
                case 4: {
                        message.windowConfigurations = reader.bool();
                        break;
                    }
                case 5: {
                        message.micPreSettings = reader.bool();
                        break;
                    }
                case 6: {
                        message.heatMasterSettings = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionDataImport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SessionDataImport} SessionDataImport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionDataImport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionDataImport message.
         * @function verify
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionDataImport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempoMeterMap != null && message.hasOwnProperty("tempoMeterMap"))
                if (typeof message.tempoMeterMap !== "boolean")
                    return "tempoMeterMap: boolean expected";
            if (message.keySignatureChoedMap != null && message.hasOwnProperty("keySignatureChoedMap"))
                if (typeof message.keySignatureChoedMap !== "boolean")
                    return "keySignatureChoedMap: boolean expected";
            if (message.markersMemoryLocations != null && message.hasOwnProperty("markersMemoryLocations"))
                if (typeof message.markersMemoryLocations !== "boolean")
                    return "markersMemoryLocations: boolean expected";
            if (message.windowConfigurations != null && message.hasOwnProperty("windowConfigurations"))
                if (typeof message.windowConfigurations !== "boolean")
                    return "windowConfigurations: boolean expected";
            if (message.micPreSettings != null && message.hasOwnProperty("micPreSettings"))
                if (typeof message.micPreSettings !== "boolean")
                    return "micPreSettings: boolean expected";
            if (message.heatMasterSettings != null && message.hasOwnProperty("heatMasterSettings"))
                if (typeof message.heatMasterSettings !== "boolean")
                    return "heatMasterSettings: boolean expected";
            return null;
        };

        /**
         * Creates a SessionDataImport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SessionDataImport} SessionDataImport
         */
        SessionDataImport.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SessionDataImport)
                return object;
            var message = new $root.ptsl.SessionDataImport();
            if (object.tempoMeterMap != null)
                message.tempoMeterMap = Boolean(object.tempoMeterMap);
            if (object.keySignatureChoedMap != null)
                message.keySignatureChoedMap = Boolean(object.keySignatureChoedMap);
            if (object.markersMemoryLocations != null)
                message.markersMemoryLocations = Boolean(object.markersMemoryLocations);
            if (object.windowConfigurations != null)
                message.windowConfigurations = Boolean(object.windowConfigurations);
            if (object.micPreSettings != null)
                message.micPreSettings = Boolean(object.micPreSettings);
            if (object.heatMasterSettings != null)
                message.heatMasterSettings = Boolean(object.heatMasterSettings);
            return message;
        };

        /**
         * Creates a plain object from a SessionDataImport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {ptsl.SessionDataImport} message SessionDataImport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionDataImport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempoMeterMap = false;
                object.keySignatureChoedMap = false;
                object.markersMemoryLocations = false;
                object.windowConfigurations = false;
                object.micPreSettings = false;
                object.heatMasterSettings = false;
            }
            if (message.tempoMeterMap != null && message.hasOwnProperty("tempoMeterMap"))
                object.tempoMeterMap = message.tempoMeterMap;
            if (message.keySignatureChoedMap != null && message.hasOwnProperty("keySignatureChoedMap"))
                object.keySignatureChoedMap = message.keySignatureChoedMap;
            if (message.markersMemoryLocations != null && message.hasOwnProperty("markersMemoryLocations"))
                object.markersMemoryLocations = message.markersMemoryLocations;
            if (message.windowConfigurations != null && message.hasOwnProperty("windowConfigurations"))
                object.windowConfigurations = message.windowConfigurations;
            if (message.micPreSettings != null && message.hasOwnProperty("micPreSettings"))
                object.micPreSettings = message.micPreSettings;
            if (message.heatMasterSettings != null && message.hasOwnProperty("heatMasterSettings"))
                object.heatMasterSettings = message.heatMasterSettings;
            return object;
        };

        /**
         * Converts this SessionDataImport to JSON.
         * @function toJSON
         * @memberof ptsl.SessionDataImport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionDataImport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SessionDataImport
         * @function getTypeUrl
         * @memberof ptsl.SessionDataImport
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SessionDataImport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SessionDataImport";
        };

        return SessionDataImport;
    })();

    ptsl.SessionData = (function() {

        /**
         * Properties of a SessionData.
         * @memberof ptsl
         * @interface ISessionData
         * @property {ptsl.AudioMediaOptions|null} [audioOptions] * media options
         * @property {number|null} [audioHandleSize] SessionData audioHandleSize
         * @property {ptsl.VideoMediaOptions|null} [videoOptions] SessionData videoOptions
         * @property {ptsl.MatchTrackOptions|null} [matchOptions] * tracks
         * @property {ptsl.MainPlaylistOptions|null} [playlistOptions] * main playlist options
         * @property {ptsl.ITrackDataToImport|null} [trackDataToImport] * track data to import
         * @property {ptsl.TimeCodeMappingOptions|null} [timecodeMappingUnits] * time code mapping options
         * @property {string|null} [timecodeMappingStartTime] SessionData timecodeMappingStartTime
         * @property {boolean|null} [adjustSessionStartTimeToMatchSource] SessionData adjustSessionStartTimeToMatchSource
         */

        /**
         * Constructs a new SessionData.
         * @memberof ptsl
         * @classdesc Structure that describes session for import.
         * @implements ISessionData
         * @constructor
         * @param {ptsl.ISessionData=} [properties] Properties to set
         */
        function SessionData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * media options
         * @member {ptsl.AudioMediaOptions} audioOptions
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.audioOptions = 0;

        /**
         * SessionData audioHandleSize.
         * @member {number} audioHandleSize
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.audioHandleSize = 0;

        /**
         * SessionData videoOptions.
         * @member {ptsl.VideoMediaOptions} videoOptions
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.videoOptions = 0;

        /**
         * * tracks
         * @member {ptsl.MatchTrackOptions} matchOptions
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.matchOptions = 0;

        /**
         * * main playlist options
         * @member {ptsl.MainPlaylistOptions} playlistOptions
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.playlistOptions = 0;

        /**
         * * track data to import
         * @member {ptsl.ITrackDataToImport|null|undefined} trackDataToImport
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.trackDataToImport = null;

        /**
         * * time code mapping options
         * @member {ptsl.TimeCodeMappingOptions} timecodeMappingUnits
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.timecodeMappingUnits = 0;

        /**
         * SessionData timecodeMappingStartTime.
         * @member {string} timecodeMappingStartTime
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.timecodeMappingStartTime = "";

        /**
         * SessionData adjustSessionStartTimeToMatchSource.
         * @member {boolean} adjustSessionStartTimeToMatchSource
         * @memberof ptsl.SessionData
         * @instance
         */
        SessionData.prototype.adjustSessionStartTimeToMatchSource = false;

        /**
         * Creates a new SessionData instance using the specified properties.
         * @function create
         * @memberof ptsl.SessionData
         * @static
         * @param {ptsl.ISessionData=} [properties] Properties to set
         * @returns {ptsl.SessionData} SessionData instance
         */
        SessionData.create = function create(properties) {
            return new SessionData(properties);
        };

        /**
         * Encodes the specified SessionData message. Does not implicitly {@link ptsl.SessionData.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SessionData
         * @static
         * @param {ptsl.ISessionData} message SessionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audioOptions != null && Object.hasOwnProperty.call(message, "audioOptions"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.audioOptions);
            if (message.audioHandleSize != null && Object.hasOwnProperty.call(message, "audioHandleSize"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.audioHandleSize);
            if (message.videoOptions != null && Object.hasOwnProperty.call(message, "videoOptions"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.videoOptions);
            if (message.matchOptions != null && Object.hasOwnProperty.call(message, "matchOptions"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.matchOptions);
            if (message.playlistOptions != null && Object.hasOwnProperty.call(message, "playlistOptions"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.playlistOptions);
            if (message.trackDataToImport != null && Object.hasOwnProperty.call(message, "trackDataToImport"))
                $root.ptsl.TrackDataToImport.encode(message.trackDataToImport, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.timecodeMappingUnits != null && Object.hasOwnProperty.call(message, "timecodeMappingUnits"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timecodeMappingUnits);
            if (message.timecodeMappingStartTime != null && Object.hasOwnProperty.call(message, "timecodeMappingStartTime"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.timecodeMappingStartTime);
            if (message.adjustSessionStartTimeToMatchSource != null && Object.hasOwnProperty.call(message, "adjustSessionStartTimeToMatchSource"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.adjustSessionStartTimeToMatchSource);
            return writer;
        };

        /**
         * Encodes the specified SessionData message, length delimited. Does not implicitly {@link ptsl.SessionData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SessionData
         * @static
         * @param {ptsl.ISessionData} message SessionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionData message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SessionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SessionData} SessionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SessionData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.audioOptions = reader.int32();
                        break;
                    }
                case 2: {
                        message.audioHandleSize = reader.int32();
                        break;
                    }
                case 3: {
                        message.videoOptions = reader.int32();
                        break;
                    }
                case 4: {
                        message.matchOptions = reader.int32();
                        break;
                    }
                case 5: {
                        message.playlistOptions = reader.int32();
                        break;
                    }
                case 6: {
                        message.trackDataToImport = $root.ptsl.TrackDataToImport.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.timecodeMappingUnits = reader.int32();
                        break;
                    }
                case 8: {
                        message.timecodeMappingStartTime = reader.string();
                        break;
                    }
                case 9: {
                        message.adjustSessionStartTimeToMatchSource = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SessionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SessionData} SessionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionData message.
         * @function verify
         * @memberof ptsl.SessionData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audioOptions != null && message.hasOwnProperty("audioOptions"))
                switch (message.audioOptions) {
                default:
                    return "audioOptions: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.audioHandleSize != null && message.hasOwnProperty("audioHandleSize"))
                if (!$util.isInteger(message.audioHandleSize))
                    return "audioHandleSize: integer expected";
            if (message.videoOptions != null && message.hasOwnProperty("videoOptions"))
                switch (message.videoOptions) {
                default:
                    return "videoOptions: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                    break;
                }
            if (message.matchOptions != null && message.hasOwnProperty("matchOptions"))
                switch (message.matchOptions) {
                default:
                    return "matchOptions: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.playlistOptions != null && message.hasOwnProperty("playlistOptions"))
                switch (message.playlistOptions) {
                default:
                    return "playlistOptions: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.trackDataToImport != null && message.hasOwnProperty("trackDataToImport")) {
                var error = $root.ptsl.TrackDataToImport.verify(message.trackDataToImport);
                if (error)
                    return "trackDataToImport." + error;
            }
            if (message.timecodeMappingUnits != null && message.hasOwnProperty("timecodeMappingUnits"))
                switch (message.timecodeMappingUnits) {
                default:
                    return "timecodeMappingUnits: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.timecodeMappingStartTime != null && message.hasOwnProperty("timecodeMappingStartTime"))
                if (!$util.isString(message.timecodeMappingStartTime))
                    return "timecodeMappingStartTime: string expected";
            if (message.adjustSessionStartTimeToMatchSource != null && message.hasOwnProperty("adjustSessionStartTimeToMatchSource"))
                if (typeof message.adjustSessionStartTimeToMatchSource !== "boolean")
                    return "adjustSessionStartTimeToMatchSource: boolean expected";
            return null;
        };

        /**
         * Creates a SessionData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SessionData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SessionData} SessionData
         */
        SessionData.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SessionData)
                return object;
            var message = new $root.ptsl.SessionData();
            switch (object.audioOptions) {
            default:
                if (typeof object.audioOptions === "number") {
                    message.audioOptions = object.audioOptions;
                    break;
                }
                break;
            case "AMOptions_Unknown":
            case 0:
                message.audioOptions = 0;
                break;
            case "LinkToSourceAudio":
            case 1:
                message.audioOptions = 1;
                break;
            case "AMOptions_LinkToSourceAudio":
            case 1:
                message.audioOptions = 1;
                break;
            case "CopyFromSourceAudio":
            case 2:
                message.audioOptions = 2;
                break;
            case "AMOptions_CopyFromSourceAudio":
            case 2:
                message.audioOptions = 2;
                break;
            case "ConsolidateFromSourceAudio":
            case 3:
                message.audioOptions = 3;
                break;
            case "AMOptions_ConsolidateFromSourceAudio":
            case 3:
                message.audioOptions = 3;
                break;
            case "ForceToTargetSessionFormat":
            case 4:
                message.audioOptions = 4;
                break;
            case "AMOptions_ForceToTargetSessionFormat":
            case 4:
                message.audioOptions = 4;
                break;
            }
            if (object.audioHandleSize != null)
                message.audioHandleSize = object.audioHandleSize | 0;
            switch (object.videoOptions) {
            default:
                if (typeof object.videoOptions === "number") {
                    message.videoOptions = object.videoOptions;
                    break;
                }
                break;
            case "VMOptions_Unknown":
            case 0:
                message.videoOptions = 0;
                break;
            case "LinkToSourceVideo":
            case 1:
                message.videoOptions = 1;
                break;
            case "VMOptions_LinkToSourceVideo":
            case 1:
                message.videoOptions = 1;
                break;
            case "CopyFromSourceVideo":
            case 2:
                message.videoOptions = 2;
                break;
            case "VMOptions_CopyFromSourceVideo":
            case 2:
                message.videoOptions = 2;
                break;
            case "ImportAsOfflineSatelliteMedia":
            case 3:
                message.videoOptions = 3;
                break;
            }
            switch (object.matchOptions) {
            default:
                if (typeof object.matchOptions === "number") {
                    message.matchOptions = object.matchOptions;
                    break;
                }
                break;
            case "MTOptions_Unknown":
            case 0:
                message.matchOptions = 0;
                break;
            case "MT_None":
            case 1:
                message.matchOptions = 1;
                break;
            case "MTOptions_None":
            case 1:
                message.matchOptions = 1;
                break;
            case "MT_MatchTracks":
            case 2:
                message.matchOptions = 2;
                break;
            case "MTOptions_MatchTracks":
            case 2:
                message.matchOptions = 2;
                break;
            case "MT_ImportAsNewTrack":
            case 3:
                message.matchOptions = 3;
                break;
            case "MTOptions_ImportAsNewTrack":
            case 3:
                message.matchOptions = 3;
                break;
            }
            switch (object.playlistOptions) {
            default:
                if (typeof object.playlistOptions === "number") {
                    message.playlistOptions = object.playlistOptions;
                    break;
                }
                break;
            case "MPOptions_Unknown":
            case 0:
                message.playlistOptions = 0;
                break;
            case "ImportReplaceExistingPlaylists":
            case 1:
                message.playlistOptions = 1;
                break;
            case "MPOptions_ImportReplaceExistingPlaylists":
            case 1:
                message.playlistOptions = 1;
                break;
            case "ImportOverlayNewOnExistingPlaylists":
            case 2:
                message.playlistOptions = 2;
                break;
            case "MPOptions_ImportOverlayNewOnExistingPlaylists":
            case 2:
                message.playlistOptions = 2;
                break;
            case "DoNotImport":
            case 3:
                message.playlistOptions = 3;
                break;
            case "MPOptions_DoNotImport":
            case 3:
                message.playlistOptions = 3;
                break;
            }
            if (object.trackDataToImport != null) {
                if (typeof object.trackDataToImport !== "object")
                    throw TypeError(".ptsl.SessionData.trackDataToImport: object expected");
                message.trackDataToImport = $root.ptsl.TrackDataToImport.fromObject(object.trackDataToImport);
            }
            switch (object.timecodeMappingUnits) {
            default:
                if (typeof object.timecodeMappingUnits === "number") {
                    message.timecodeMappingUnits = object.timecodeMappingUnits;
                    break;
                }
                break;
            case "TCMOptions_Unknown":
            case 0:
                message.timecodeMappingUnits = 0;
                break;
            case "MaintainAbsoluteTimeCodeValues":
            case 1:
                message.timecodeMappingUnits = 1;
                break;
            case "TCMOptions_MaintainAbsoluteTimeCodeValues":
            case 1:
                message.timecodeMappingUnits = 1;
                break;
            case "MaintainRelativeTimeCodeValues":
            case 2:
                message.timecodeMappingUnits = 2;
                break;
            case "TCMOptions_MaintainRelativeTimeCodeValues":
            case 2:
                message.timecodeMappingUnits = 2;
                break;
            case "MapStartTimeCodeTo":
            case 3:
                message.timecodeMappingUnits = 3;
                break;
            case "TCMOptions_MapStartTimeCodeTo":
            case 3:
                message.timecodeMappingUnits = 3;
                break;
            }
            if (object.timecodeMappingStartTime != null)
                message.timecodeMappingStartTime = String(object.timecodeMappingStartTime);
            if (object.adjustSessionStartTimeToMatchSource != null)
                message.adjustSessionStartTimeToMatchSource = Boolean(object.adjustSessionStartTimeToMatchSource);
            return message;
        };

        /**
         * Creates a plain object from a SessionData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SessionData
         * @static
         * @param {ptsl.SessionData} message SessionData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audioOptions = options.enums === String ? "AMOptions_Unknown" : 0;
                object.audioHandleSize = 0;
                object.videoOptions = options.enums === String ? "VMOptions_Unknown" : 0;
                object.matchOptions = options.enums === String ? "MTOptions_Unknown" : 0;
                object.playlistOptions = options.enums === String ? "MPOptions_Unknown" : 0;
                object.trackDataToImport = null;
                object.timecodeMappingUnits = options.enums === String ? "TCMOptions_Unknown" : 0;
                object.timecodeMappingStartTime = "";
                object.adjustSessionStartTimeToMatchSource = false;
            }
            if (message.audioOptions != null && message.hasOwnProperty("audioOptions"))
                object.audioOptions = options.enums === String ? $root.ptsl.AudioMediaOptions[message.audioOptions] === undefined ? message.audioOptions : $root.ptsl.AudioMediaOptions[message.audioOptions] : message.audioOptions;
            if (message.audioHandleSize != null && message.hasOwnProperty("audioHandleSize"))
                object.audioHandleSize = message.audioHandleSize;
            if (message.videoOptions != null && message.hasOwnProperty("videoOptions"))
                object.videoOptions = options.enums === String ? $root.ptsl.VideoMediaOptions[message.videoOptions] === undefined ? message.videoOptions : $root.ptsl.VideoMediaOptions[message.videoOptions] : message.videoOptions;
            if (message.matchOptions != null && message.hasOwnProperty("matchOptions"))
                object.matchOptions = options.enums === String ? $root.ptsl.MatchTrackOptions[message.matchOptions] === undefined ? message.matchOptions : $root.ptsl.MatchTrackOptions[message.matchOptions] : message.matchOptions;
            if (message.playlistOptions != null && message.hasOwnProperty("playlistOptions"))
                object.playlistOptions = options.enums === String ? $root.ptsl.MainPlaylistOptions[message.playlistOptions] === undefined ? message.playlistOptions : $root.ptsl.MainPlaylistOptions[message.playlistOptions] : message.playlistOptions;
            if (message.trackDataToImport != null && message.hasOwnProperty("trackDataToImport"))
                object.trackDataToImport = $root.ptsl.TrackDataToImport.toObject(message.trackDataToImport, options);
            if (message.timecodeMappingUnits != null && message.hasOwnProperty("timecodeMappingUnits"))
                object.timecodeMappingUnits = options.enums === String ? $root.ptsl.TimeCodeMappingOptions[message.timecodeMappingUnits] === undefined ? message.timecodeMappingUnits : $root.ptsl.TimeCodeMappingOptions[message.timecodeMappingUnits] : message.timecodeMappingUnits;
            if (message.timecodeMappingStartTime != null && message.hasOwnProperty("timecodeMappingStartTime"))
                object.timecodeMappingStartTime = message.timecodeMappingStartTime;
            if (message.adjustSessionStartTimeToMatchSource != null && message.hasOwnProperty("adjustSessionStartTimeToMatchSource"))
                object.adjustSessionStartTimeToMatchSource = message.adjustSessionStartTimeToMatchSource;
            return object;
        };

        /**
         * Converts this SessionData to JSON.
         * @function toJSON
         * @memberof ptsl.SessionData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SessionData
         * @function getTypeUrl
         * @memberof ptsl.SessionData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SessionData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SessionData";
        };

        return SessionData;
    })();

    /**
     * The types of location for Spot.
     * @name ptsl.SpotLocationType
     * @enum {number}
     * @property {number} SLType_Unknown=0 SLType_Unknown value
     * @property {number} Start=1 * @deprecated ptsl::SpotLocationType::Start is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SpotLocationType::SLType_Start
     * @property {number} SLType_Start=1 SLType_Start value
     * @property {number} SyncPoint=2 * @deprecated ptsl::SpotLocationType::SyncPoint is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SpotLocationType::SLType_SyncPoint
     * @property {number} SLType_SyncPoint=2 SLType_SyncPoint value
     * @property {number} End=3 * @deprecated ptsl::SpotLocationType::End is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SpotLocationType::SLType_End
     * @property {number} SLType_End=3 SLType_End value
     */
    ptsl.SpotLocationType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SLType_Unknown"] = 0;
        values[valuesById[1] = "Start"] = 1;
        values["SLType_Start"] = 1;
        values[valuesById[2] = "SyncPoint"] = 2;
        values["SLType_SyncPoint"] = 2;
        values[valuesById[3] = "End"] = 3;
        values["SLType_End"] = 3;
        return values;
    })();

    ptsl.SpotLocationData = (function() {

        /**
         * Properties of a SpotLocationData.
         * @memberof ptsl
         * @interface ISpotLocationData
         * @property {ptsl.SpotLocationType|null} [locationType] SpotLocationData locationType
         * @property {string|null} [locationValue] * @deprecated since Pro Tools 2025.06, use TimelineLocation::location::location instead
         * @property {ptsl.TrackOffsetOptions|null} [locationOptions] * @deprecated since Pro Tools 2025.06, use TimelineLocation::location::time_type instead
         * @property {ptsl.ITimelineLocation|null} [location] SpotLocationData location
         */

        /**
         * Constructs a new SpotLocationData.
         * @memberof ptsl
         * @classdesc Structure that describes location data.
         * @implements ISpotLocationData
         * @constructor
         * @param {ptsl.ISpotLocationData=} [properties] Properties to set
         */
        function SpotLocationData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpotLocationData locationType.
         * @member {ptsl.SpotLocationType} locationType
         * @memberof ptsl.SpotLocationData
         * @instance
         */
        SpotLocationData.prototype.locationType = 0;

        /**
         * * @deprecated since Pro Tools 2025.06, use TimelineLocation::location::location instead
         * @member {string} locationValue
         * @memberof ptsl.SpotLocationData
         * @instance
         */
        SpotLocationData.prototype.locationValue = "";

        /**
         * * @deprecated since Pro Tools 2025.06, use TimelineLocation::location::time_type instead
         * @member {ptsl.TrackOffsetOptions} locationOptions
         * @memberof ptsl.SpotLocationData
         * @instance
         */
        SpotLocationData.prototype.locationOptions = 0;

        /**
         * SpotLocationData location.
         * @member {ptsl.ITimelineLocation|null|undefined} location
         * @memberof ptsl.SpotLocationData
         * @instance
         */
        SpotLocationData.prototype.location = null;

        /**
         * Creates a new SpotLocationData instance using the specified properties.
         * @function create
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {ptsl.ISpotLocationData=} [properties] Properties to set
         * @returns {ptsl.SpotLocationData} SpotLocationData instance
         */
        SpotLocationData.create = function create(properties) {
            return new SpotLocationData(properties);
        };

        /**
         * Encodes the specified SpotLocationData message. Does not implicitly {@link ptsl.SpotLocationData.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {ptsl.ISpotLocationData} message SpotLocationData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpotLocationData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.locationType != null && Object.hasOwnProperty.call(message, "locationType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.locationType);
            if (message.locationValue != null && Object.hasOwnProperty.call(message, "locationValue"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.locationValue);
            if (message.locationOptions != null && Object.hasOwnProperty.call(message, "locationOptions"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.locationOptions);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                $root.ptsl.TimelineLocation.encode(message.location, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SpotLocationData message, length delimited. Does not implicitly {@link ptsl.SpotLocationData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {ptsl.ISpotLocationData} message SpotLocationData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpotLocationData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpotLocationData message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SpotLocationData} SpotLocationData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpotLocationData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SpotLocationData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.locationType = reader.int32();
                        break;
                    }
                case 2: {
                        message.locationValue = reader.string();
                        break;
                    }
                case 3: {
                        message.locationOptions = reader.int32();
                        break;
                    }
                case 4: {
                        message.location = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpotLocationData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SpotLocationData} SpotLocationData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpotLocationData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpotLocationData message.
         * @function verify
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpotLocationData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                switch (message.locationType) {
                default:
                    return "locationType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.locationValue != null && message.hasOwnProperty("locationValue"))
                if (!$util.isString(message.locationValue))
                    return "locationValue: string expected";
            if (message.locationOptions != null && message.hasOwnProperty("locationOptions"))
                switch (message.locationOptions) {
                default:
                    return "locationOptions: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.location != null && message.hasOwnProperty("location")) {
                var error = $root.ptsl.TimelineLocation.verify(message.location);
                if (error)
                    return "location." + error;
            }
            return null;
        };

        /**
         * Creates a SpotLocationData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SpotLocationData} SpotLocationData
         */
        SpotLocationData.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SpotLocationData)
                return object;
            var message = new $root.ptsl.SpotLocationData();
            switch (object.locationType) {
            default:
                if (typeof object.locationType === "number") {
                    message.locationType = object.locationType;
                    break;
                }
                break;
            case "SLType_Unknown":
            case 0:
                message.locationType = 0;
                break;
            case "Start":
            case 1:
                message.locationType = 1;
                break;
            case "SLType_Start":
            case 1:
                message.locationType = 1;
                break;
            case "SyncPoint":
            case 2:
                message.locationType = 2;
                break;
            case "SLType_SyncPoint":
            case 2:
                message.locationType = 2;
                break;
            case "End":
            case 3:
                message.locationType = 3;
                break;
            case "SLType_End":
            case 3:
                message.locationType = 3;
                break;
            }
            if (object.locationValue != null)
                message.locationValue = String(object.locationValue);
            switch (object.locationOptions) {
            default:
                if (typeof object.locationOptions === "number") {
                    message.locationOptions = object.locationOptions;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.locationOptions = 0;
                break;
            case "BarsBeats":
            case 1:
                message.locationOptions = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.locationOptions = 1;
                break;
            case "MinSecs":
            case 2:
                message.locationOptions = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.locationOptions = 2;
                break;
            case "TimeCode":
            case 3:
                message.locationOptions = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.locationOptions = 3;
                break;
            case "FeetFrames":
            case 4:
                message.locationOptions = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.locationOptions = 4;
                break;
            case "Samples":
            case 5:
                message.locationOptions = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.locationOptions = 5;
                break;
            }
            if (object.location != null) {
                if (typeof object.location !== "object")
                    throw TypeError(".ptsl.SpotLocationData.location: object expected");
                message.location = $root.ptsl.TimelineLocation.fromObject(object.location);
            }
            return message;
        };

        /**
         * Creates a plain object from a SpotLocationData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {ptsl.SpotLocationData} message SpotLocationData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpotLocationData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.locationType = options.enums === String ? "SLType_Unknown" : 0;
                object.locationValue = "";
                object.locationOptions = options.enums === String ? "TOOptions_Unknown" : 0;
                object.location = null;
            }
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                object.locationType = options.enums === String ? $root.ptsl.SpotLocationType[message.locationType] === undefined ? message.locationType : $root.ptsl.SpotLocationType[message.locationType] : message.locationType;
            if (message.locationValue != null && message.hasOwnProperty("locationValue"))
                object.locationValue = message.locationValue;
            if (message.locationOptions != null && message.hasOwnProperty("locationOptions"))
                object.locationOptions = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.locationOptions] === undefined ? message.locationOptions : $root.ptsl.TrackOffsetOptions[message.locationOptions] : message.locationOptions;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = $root.ptsl.TimelineLocation.toObject(message.location, options);
            return object;
        };

        /**
         * Converts this SpotLocationData to JSON.
         * @function toJSON
         * @memberof ptsl.SpotLocationData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpotLocationData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SpotLocationData
         * @function getTypeUrl
         * @memberof ptsl.SpotLocationData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SpotLocationData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SpotLocationData";
        };

        return SpotLocationData;
    })();

    ptsl.AudioData = (function() {

        /**
         * Properties of an AudioData.
         * @memberof ptsl
         * @interface IAudioData
         * @property {Array.<string>|null} [fileList] AudioData fileList
         * @property {ptsl.AudioOperations|null} [audioOperations] AudioData audioOperations
         * @property {string|null} [destinationPath] AudioData destinationPath
         * @property {ptsl.MediaDestination|null} [destination] * @deprecated since Pro Tools 2023.09, use audio_destination
         * @property {ptsl.MediaLocation|null} [location] * @deprecated since Pro Tools 2023.09, use audio_location
         * @property {ptsl.ISpotLocationData|null} [locationData] * @since Pro Tools 2023.06
         * @property {ptsl.MediaDestination|null} [audioDestination] * @since Pro Tools 2023.09
         * @property {ptsl.MediaLocation|null} [audioLocation] * @since Pro Tools 2023.09
         */

        /**
         * Constructs a new AudioData.
         * @memberof ptsl
         * @classdesc Structure that describes audio for import.
         * @implements IAudioData
         * @constructor
         * @param {ptsl.IAudioData=} [properties] Properties to set
         */
        function AudioData(properties) {
            this.fileList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AudioData fileList.
         * @member {Array.<string>} fileList
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.fileList = $util.emptyArray;

        /**
         * AudioData audioOperations.
         * @member {ptsl.AudioOperations} audioOperations
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.audioOperations = 0;

        /**
         * AudioData destinationPath.
         * @member {string} destinationPath
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.destinationPath = "";

        /**
         * * @deprecated since Pro Tools 2023.09, use audio_destination
         * @member {ptsl.MediaDestination} destination
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.destination = 0;

        /**
         * * @deprecated since Pro Tools 2023.09, use audio_location
         * @member {ptsl.MediaLocation} location
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.location = 0;

        /**
         * * @since Pro Tools 2023.06
         * @member {ptsl.ISpotLocationData|null|undefined} locationData
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.locationData = null;

        /**
         * * @since Pro Tools 2023.09
         * @member {ptsl.MediaDestination} audioDestination
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.audioDestination = 0;

        /**
         * * @since Pro Tools 2023.09
         * @member {ptsl.MediaLocation} audioLocation
         * @memberof ptsl.AudioData
         * @instance
         */
        AudioData.prototype.audioLocation = 0;

        /**
         * Creates a new AudioData instance using the specified properties.
         * @function create
         * @memberof ptsl.AudioData
         * @static
         * @param {ptsl.IAudioData=} [properties] Properties to set
         * @returns {ptsl.AudioData} AudioData instance
         */
        AudioData.create = function create(properties) {
            return new AudioData(properties);
        };

        /**
         * Encodes the specified AudioData message. Does not implicitly {@link ptsl.AudioData.verify|verify} messages.
         * @function encode
         * @memberof ptsl.AudioData
         * @static
         * @param {ptsl.IAudioData} message AudioData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileList != null && message.fileList.length)
                for (var i = 0; i < message.fileList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileList[i]);
            if (message.audioOperations != null && Object.hasOwnProperty.call(message, "audioOperations"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.audioOperations);
            if (message.destinationPath != null && Object.hasOwnProperty.call(message, "destinationPath"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.destinationPath);
            if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.destination);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.location);
            if (message.locationData != null && Object.hasOwnProperty.call(message, "locationData"))
                $root.ptsl.SpotLocationData.encode(message.locationData, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.audioDestination != null && Object.hasOwnProperty.call(message, "audioDestination"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.audioDestination);
            if (message.audioLocation != null && Object.hasOwnProperty.call(message, "audioLocation"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.audioLocation);
            return writer;
        };

        /**
         * Encodes the specified AudioData message, length delimited. Does not implicitly {@link ptsl.AudioData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.AudioData
         * @static
         * @param {ptsl.IAudioData} message AudioData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AudioData message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.AudioData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.AudioData} AudioData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.AudioData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.fileList && message.fileList.length))
                            message.fileList = [];
                        message.fileList.push(reader.string());
                        break;
                    }
                case 2: {
                        message.audioOperations = reader.int32();
                        break;
                    }
                case 3: {
                        message.destinationPath = reader.string();
                        break;
                    }
                case 4: {
                        message.destination = reader.int32();
                        break;
                    }
                case 5: {
                        message.location = reader.int32();
                        break;
                    }
                case 6: {
                        message.locationData = $root.ptsl.SpotLocationData.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.audioDestination = reader.int32();
                        break;
                    }
                case 8: {
                        message.audioLocation = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AudioData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.AudioData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.AudioData} AudioData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AudioData message.
         * @function verify
         * @memberof ptsl.AudioData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AudioData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileList != null && message.hasOwnProperty("fileList")) {
                if (!Array.isArray(message.fileList))
                    return "fileList: array expected";
                for (var i = 0; i < message.fileList.length; ++i)
                    if (!$util.isString(message.fileList[i]))
                        return "fileList: string[] expected";
            }
            if (message.audioOperations != null && message.hasOwnProperty("audioOperations"))
                switch (message.audioOperations) {
                default:
                    return "audioOperations: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                if (!$util.isString(message.destinationPath))
                    return "destinationPath: string expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                switch (message.destination) {
                default:
                    return "destination: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.location != null && message.hasOwnProperty("location"))
                switch (message.location) {
                default:
                    return "location: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.locationData != null && message.hasOwnProperty("locationData")) {
                var error = $root.ptsl.SpotLocationData.verify(message.locationData);
                if (error)
                    return "locationData." + error;
            }
            if (message.audioDestination != null && message.hasOwnProperty("audioDestination"))
                switch (message.audioDestination) {
                default:
                    return "audioDestination: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.audioLocation != null && message.hasOwnProperty("audioLocation"))
                switch (message.audioLocation) {
                default:
                    return "audioLocation: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates an AudioData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.AudioData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.AudioData} AudioData
         */
        AudioData.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.AudioData)
                return object;
            var message = new $root.ptsl.AudioData();
            if (object.fileList) {
                if (!Array.isArray(object.fileList))
                    throw TypeError(".ptsl.AudioData.fileList: array expected");
                message.fileList = [];
                for (var i = 0; i < object.fileList.length; ++i)
                    message.fileList[i] = String(object.fileList[i]);
            }
            switch (object.audioOperations) {
            default:
                if (typeof object.audioOperations === "number") {
                    message.audioOperations = object.audioOperations;
                    break;
                }
                break;
            case "AOperations_Unknown":
            case 0:
                message.audioOperations = 0;
                break;
            case "AddAudio":
            case 1:
                message.audioOperations = 1;
                break;
            case "AOperations_AddAudio":
            case 1:
                message.audioOperations = 1;
                break;
            case "CopyAudio":
            case 2:
                message.audioOperations = 2;
                break;
            case "AOperations_CopyAudio":
            case 2:
                message.audioOperations = 2;
                break;
            case "ConvertAudio":
            case 3:
                message.audioOperations = 3;
                break;
            case "AOperations_ConvertAudio":
            case 3:
                message.audioOperations = 3;
                break;
            case "Default":
            case 4:
                message.audioOperations = 4;
                break;
            case "AOperations_Default":
            case 4:
                message.audioOperations = 4;
                break;
            }
            if (object.destinationPath != null)
                message.destinationPath = String(object.destinationPath);
            switch (object.destination) {
            default:
                if (typeof object.destination === "number") {
                    message.destination = object.destination;
                    break;
                }
                break;
            case "MDestination_Unknown":
            case 0:
                message.destination = 0;
                break;
            case "MD_None":
            case 1:
                message.destination = 1;
                break;
            case "MDestination_None":
            case 1:
                message.destination = 1;
                break;
            case "MD_MainVideoTrack":
            case 2:
                message.destination = 2;
                break;
            case "MDestination_MainVideoTrack":
            case 2:
                message.destination = 2;
                break;
            case "MD_NewTrack":
            case 3:
                message.destination = 3;
                break;
            case "MDestination_NewTrack":
            case 3:
                message.destination = 3;
                break;
            case "MD_ClipList":
            case 4:
                message.destination = 4;
                break;
            case "MDestination_ClipList":
            case 4:
                message.destination = 4;
                break;
            }
            switch (object.location) {
            default:
                if (typeof object.location === "number") {
                    message.location = object.location;
                    break;
                }
                break;
            case "MLocation_Unknown":
            case 0:
                message.location = 0;
                break;
            case "ML_None":
            case 1:
                message.location = 1;
                break;
            case "MLocation_None":
            case 1:
                message.location = 1;
                break;
            case "ML_SessionStart":
            case 2:
                message.location = 2;
                break;
            case "MLocation_SessionStart":
            case 2:
                message.location = 2;
                break;
            case "ML_SongStart":
            case 3:
                message.location = 3;
                break;
            case "MLocation_SongStart":
            case 3:
                message.location = 3;
                break;
            case "ML_Selection":
            case 4:
                message.location = 4;
                break;
            case "MLocation_Selection":
            case 4:
                message.location = 4;
                break;
            case "ML_Spot":
            case 5:
                message.location = 5;
                break;
            case "MLocation_Spot":
            case 5:
                message.location = 5;
                break;
            }
            if (object.locationData != null) {
                if (typeof object.locationData !== "object")
                    throw TypeError(".ptsl.AudioData.locationData: object expected");
                message.locationData = $root.ptsl.SpotLocationData.fromObject(object.locationData);
            }
            switch (object.audioDestination) {
            default:
                if (typeof object.audioDestination === "number") {
                    message.audioDestination = object.audioDestination;
                    break;
                }
                break;
            case "MDestination_Unknown":
            case 0:
                message.audioDestination = 0;
                break;
            case "MD_None":
            case 1:
                message.audioDestination = 1;
                break;
            case "MDestination_None":
            case 1:
                message.audioDestination = 1;
                break;
            case "MD_MainVideoTrack":
            case 2:
                message.audioDestination = 2;
                break;
            case "MDestination_MainVideoTrack":
            case 2:
                message.audioDestination = 2;
                break;
            case "MD_NewTrack":
            case 3:
                message.audioDestination = 3;
                break;
            case "MDestination_NewTrack":
            case 3:
                message.audioDestination = 3;
                break;
            case "MD_ClipList":
            case 4:
                message.audioDestination = 4;
                break;
            case "MDestination_ClipList":
            case 4:
                message.audioDestination = 4;
                break;
            }
            switch (object.audioLocation) {
            default:
                if (typeof object.audioLocation === "number") {
                    message.audioLocation = object.audioLocation;
                    break;
                }
                break;
            case "MLocation_Unknown":
            case 0:
                message.audioLocation = 0;
                break;
            case "ML_None":
            case 1:
                message.audioLocation = 1;
                break;
            case "MLocation_None":
            case 1:
                message.audioLocation = 1;
                break;
            case "ML_SessionStart":
            case 2:
                message.audioLocation = 2;
                break;
            case "MLocation_SessionStart":
            case 2:
                message.audioLocation = 2;
                break;
            case "ML_SongStart":
            case 3:
                message.audioLocation = 3;
                break;
            case "MLocation_SongStart":
            case 3:
                message.audioLocation = 3;
                break;
            case "ML_Selection":
            case 4:
                message.audioLocation = 4;
                break;
            case "MLocation_Selection":
            case 4:
                message.audioLocation = 4;
                break;
            case "ML_Spot":
            case 5:
                message.audioLocation = 5;
                break;
            case "MLocation_Spot":
            case 5:
                message.audioLocation = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AudioData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.AudioData
         * @static
         * @param {ptsl.AudioData} message AudioData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AudioData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fileList = [];
            if (options.defaults) {
                object.audioOperations = options.enums === String ? "AOperations_Unknown" : 0;
                object.destinationPath = "";
                object.destination = options.enums === String ? "MDestination_Unknown" : 0;
                object.location = options.enums === String ? "MLocation_Unknown" : 0;
                object.locationData = null;
                object.audioDestination = options.enums === String ? "MDestination_Unknown" : 0;
                object.audioLocation = options.enums === String ? "MLocation_Unknown" : 0;
            }
            if (message.fileList && message.fileList.length) {
                object.fileList = [];
                for (var j = 0; j < message.fileList.length; ++j)
                    object.fileList[j] = message.fileList[j];
            }
            if (message.audioOperations != null && message.hasOwnProperty("audioOperations"))
                object.audioOperations = options.enums === String ? $root.ptsl.AudioOperations[message.audioOperations] === undefined ? message.audioOperations : $root.ptsl.AudioOperations[message.audioOperations] : message.audioOperations;
            if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                object.destinationPath = message.destinationPath;
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.enums === String ? $root.ptsl.MediaDestination[message.destination] === undefined ? message.destination : $root.ptsl.MediaDestination[message.destination] : message.destination;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = options.enums === String ? $root.ptsl.MediaLocation[message.location] === undefined ? message.location : $root.ptsl.MediaLocation[message.location] : message.location;
            if (message.locationData != null && message.hasOwnProperty("locationData"))
                object.locationData = $root.ptsl.SpotLocationData.toObject(message.locationData, options);
            if (message.audioDestination != null && message.hasOwnProperty("audioDestination"))
                object.audioDestination = options.enums === String ? $root.ptsl.MediaDestination[message.audioDestination] === undefined ? message.audioDestination : $root.ptsl.MediaDestination[message.audioDestination] : message.audioDestination;
            if (message.audioLocation != null && message.hasOwnProperty("audioLocation"))
                object.audioLocation = options.enums === String ? $root.ptsl.MediaLocation[message.audioLocation] === undefined ? message.audioLocation : $root.ptsl.MediaLocation[message.audioLocation] : message.audioLocation;
            return object;
        };

        /**
         * Converts this AudioData to JSON.
         * @function toJSON
         * @memberof ptsl.AudioData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AudioData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AudioData
         * @function getTypeUrl
         * @memberof ptsl.AudioData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AudioData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.AudioData";
        };

        return AudioData;
    })();

    ptsl.ImportRequestBody = (function() {

        /**
         * Properties of an ImportRequestBody.
         * @memberof ptsl
         * @interface IImportRequestBody
         * @property {string|null} [sessionPath] ImportRequestBody sessionPath
         * @property {ptsl.ImportType|null} [importType] ImportRequestBody importType
         * @property {ptsl.ISessionData|null} [sessionData] ImportRequestBody sessionData
         * @property {ptsl.IAudioData|null} [audioData] ImportRequestBody audioData
         */

        /**
         * Constructs a new ImportRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes Import request data.
         * @implements IImportRequestBody
         * @constructor
         * @param {ptsl.IImportRequestBody=} [properties] Properties to set
         */
        function ImportRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportRequestBody sessionPath.
         * @member {string} sessionPath
         * @memberof ptsl.ImportRequestBody
         * @instance
         */
        ImportRequestBody.prototype.sessionPath = "";

        /**
         * ImportRequestBody importType.
         * @member {ptsl.ImportType} importType
         * @memberof ptsl.ImportRequestBody
         * @instance
         */
        ImportRequestBody.prototype.importType = 0;

        /**
         * ImportRequestBody sessionData.
         * @member {ptsl.ISessionData|null|undefined} sessionData
         * @memberof ptsl.ImportRequestBody
         * @instance
         */
        ImportRequestBody.prototype.sessionData = null;

        /**
         * ImportRequestBody audioData.
         * @member {ptsl.IAudioData|null|undefined} audioData
         * @memberof ptsl.ImportRequestBody
         * @instance
         */
        ImportRequestBody.prototype.audioData = null;

        /**
         * Creates a new ImportRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {ptsl.IImportRequestBody=} [properties] Properties to set
         * @returns {ptsl.ImportRequestBody} ImportRequestBody instance
         */
        ImportRequestBody.create = function create(properties) {
            return new ImportRequestBody(properties);
        };

        /**
         * Encodes the specified ImportRequestBody message. Does not implicitly {@link ptsl.ImportRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {ptsl.IImportRequestBody} message ImportRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionPath != null && Object.hasOwnProperty.call(message, "sessionPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionPath);
            if (message.importType != null && Object.hasOwnProperty.call(message, "importType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.importType);
            if (message.sessionData != null && Object.hasOwnProperty.call(message, "sessionData"))
                $root.ptsl.SessionData.encode(message.sessionData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.audioData != null && Object.hasOwnProperty.call(message, "audioData"))
                $root.ptsl.AudioData.encode(message.audioData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportRequestBody message, length delimited. Does not implicitly {@link ptsl.ImportRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {ptsl.IImportRequestBody} message ImportRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportRequestBody} ImportRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionPath = reader.string();
                        break;
                    }
                case 2: {
                        message.importType = reader.int32();
                        break;
                    }
                case 3: {
                        message.sessionData = $root.ptsl.SessionData.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.audioData = $root.ptsl.AudioData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportRequestBody} ImportRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportRequestBody message.
         * @function verify
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionPath != null && message.hasOwnProperty("sessionPath"))
                if (!$util.isString(message.sessionPath))
                    return "sessionPath: string expected";
            if (message.importType != null && message.hasOwnProperty("importType"))
                switch (message.importType) {
                default:
                    return "importType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.sessionData != null && message.hasOwnProperty("sessionData")) {
                var error = $root.ptsl.SessionData.verify(message.sessionData);
                if (error)
                    return "sessionData." + error;
            }
            if (message.audioData != null && message.hasOwnProperty("audioData")) {
                var error = $root.ptsl.AudioData.verify(message.audioData);
                if (error)
                    return "audioData." + error;
            }
            return null;
        };

        /**
         * Creates an ImportRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportRequestBody} ImportRequestBody
         */
        ImportRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportRequestBody)
                return object;
            var message = new $root.ptsl.ImportRequestBody();
            if (object.sessionPath != null)
                message.sessionPath = String(object.sessionPath);
            switch (object.importType) {
            default:
                if (typeof object.importType === "number") {
                    message.importType = object.importType;
                    break;
                }
                break;
            case "IType_Unknown":
            case 0:
                message.importType = 0;
                break;
            case "Session":
            case 1:
                message.importType = 1;
                break;
            case "IType_Session":
            case 1:
                message.importType = 1;
                break;
            case "Audio":
            case 2:
                message.importType = 2;
                break;
            case "IType_Audio":
            case 2:
                message.importType = 2;
                break;
            }
            if (object.sessionData != null) {
                if (typeof object.sessionData !== "object")
                    throw TypeError(".ptsl.ImportRequestBody.sessionData: object expected");
                message.sessionData = $root.ptsl.SessionData.fromObject(object.sessionData);
            }
            if (object.audioData != null) {
                if (typeof object.audioData !== "object")
                    throw TypeError(".ptsl.ImportRequestBody.audioData: object expected");
                message.audioData = $root.ptsl.AudioData.fromObject(object.audioData);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {ptsl.ImportRequestBody} message ImportRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sessionPath = "";
                object.importType = options.enums === String ? "IType_Unknown" : 0;
                object.sessionData = null;
                object.audioData = null;
            }
            if (message.sessionPath != null && message.hasOwnProperty("sessionPath"))
                object.sessionPath = message.sessionPath;
            if (message.importType != null && message.hasOwnProperty("importType"))
                object.importType = options.enums === String ? $root.ptsl.ImportType[message.importType] === undefined ? message.importType : $root.ptsl.ImportType[message.importType] : message.importType;
            if (message.sessionData != null && message.hasOwnProperty("sessionData"))
                object.sessionData = $root.ptsl.SessionData.toObject(message.sessionData, options);
            if (message.audioData != null && message.hasOwnProperty("audioData"))
                object.audioData = $root.ptsl.AudioData.toObject(message.audioData, options);
            return object;
        };

        /**
         * Converts this ImportRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ImportRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ImportRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportRequestBody";
        };

        return ImportRequestBody;
    })();

    ptsl.ImportResponseBody = (function() {

        /**
         * Properties of an ImportResponseBody.
         * @memberof ptsl
         * @interface IImportResponseBody
         * @property {Array.<string>|null} [fileList] * @deprecated since Pro Tools 2023.09, use audio_data
         * @property {ptsl.AudioOperations|null} [audioOperations] * @deprecated since Pro Tools 2023.09, use audio_data
         * @property {string|null} [destinationPath] * @deprecated since Pro Tools 2023.09, use audio_data
         * @property {ptsl.IAudioData|null} [audioData] * @since Pro Tools 2023.09
         */

        /**
         * Constructs a new ImportResponseBody.
         * @memberof ptsl
         * @classdesc TODO Doesn't work
         * Structure that describes Import response data.
         * @implements IImportResponseBody
         * @constructor
         * @param {ptsl.IImportResponseBody=} [properties] Properties to set
         */
        function ImportResponseBody(properties) {
            this.fileList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2023.09, use audio_data
         * @member {Array.<string>} fileList
         * @memberof ptsl.ImportResponseBody
         * @instance
         */
        ImportResponseBody.prototype.fileList = $util.emptyArray;

        /**
         * * @deprecated since Pro Tools 2023.09, use audio_data
         * @member {ptsl.AudioOperations} audioOperations
         * @memberof ptsl.ImportResponseBody
         * @instance
         */
        ImportResponseBody.prototype.audioOperations = 0;

        /**
         * * @deprecated since Pro Tools 2023.09, use audio_data
         * @member {string} destinationPath
         * @memberof ptsl.ImportResponseBody
         * @instance
         */
        ImportResponseBody.prototype.destinationPath = "";

        /**
         * * @since Pro Tools 2023.09
         * @member {ptsl.IAudioData|null|undefined} audioData
         * @memberof ptsl.ImportResponseBody
         * @instance
         */
        ImportResponseBody.prototype.audioData = null;

        /**
         * Creates a new ImportResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {ptsl.IImportResponseBody=} [properties] Properties to set
         * @returns {ptsl.ImportResponseBody} ImportResponseBody instance
         */
        ImportResponseBody.create = function create(properties) {
            return new ImportResponseBody(properties);
        };

        /**
         * Encodes the specified ImportResponseBody message. Does not implicitly {@link ptsl.ImportResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {ptsl.IImportResponseBody} message ImportResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileList != null && message.fileList.length)
                for (var i = 0; i < message.fileList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileList[i]);
            if (message.audioOperations != null && Object.hasOwnProperty.call(message, "audioOperations"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.audioOperations);
            if (message.destinationPath != null && Object.hasOwnProperty.call(message, "destinationPath"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.destinationPath);
            if (message.audioData != null && Object.hasOwnProperty.call(message, "audioData"))
                $root.ptsl.AudioData.encode(message.audioData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportResponseBody message, length delimited. Does not implicitly {@link ptsl.ImportResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {ptsl.IImportResponseBody} message ImportResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportResponseBody} ImportResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.fileList && message.fileList.length))
                            message.fileList = [];
                        message.fileList.push(reader.string());
                        break;
                    }
                case 2: {
                        message.audioOperations = reader.int32();
                        break;
                    }
                case 3: {
                        message.destinationPath = reader.string();
                        break;
                    }
                case 4: {
                        message.audioData = $root.ptsl.AudioData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportResponseBody} ImportResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportResponseBody message.
         * @function verify
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileList != null && message.hasOwnProperty("fileList")) {
                if (!Array.isArray(message.fileList))
                    return "fileList: array expected";
                for (var i = 0; i < message.fileList.length; ++i)
                    if (!$util.isString(message.fileList[i]))
                        return "fileList: string[] expected";
            }
            if (message.audioOperations != null && message.hasOwnProperty("audioOperations"))
                switch (message.audioOperations) {
                default:
                    return "audioOperations: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                if (!$util.isString(message.destinationPath))
                    return "destinationPath: string expected";
            if (message.audioData != null && message.hasOwnProperty("audioData")) {
                var error = $root.ptsl.AudioData.verify(message.audioData);
                if (error)
                    return "audioData." + error;
            }
            return null;
        };

        /**
         * Creates an ImportResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportResponseBody} ImportResponseBody
         */
        ImportResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportResponseBody)
                return object;
            var message = new $root.ptsl.ImportResponseBody();
            if (object.fileList) {
                if (!Array.isArray(object.fileList))
                    throw TypeError(".ptsl.ImportResponseBody.fileList: array expected");
                message.fileList = [];
                for (var i = 0; i < object.fileList.length; ++i)
                    message.fileList[i] = String(object.fileList[i]);
            }
            switch (object.audioOperations) {
            default:
                if (typeof object.audioOperations === "number") {
                    message.audioOperations = object.audioOperations;
                    break;
                }
                break;
            case "AOperations_Unknown":
            case 0:
                message.audioOperations = 0;
                break;
            case "AddAudio":
            case 1:
                message.audioOperations = 1;
                break;
            case "AOperations_AddAudio":
            case 1:
                message.audioOperations = 1;
                break;
            case "CopyAudio":
            case 2:
                message.audioOperations = 2;
                break;
            case "AOperations_CopyAudio":
            case 2:
                message.audioOperations = 2;
                break;
            case "ConvertAudio":
            case 3:
                message.audioOperations = 3;
                break;
            case "AOperations_ConvertAudio":
            case 3:
                message.audioOperations = 3;
                break;
            case "Default":
            case 4:
                message.audioOperations = 4;
                break;
            case "AOperations_Default":
            case 4:
                message.audioOperations = 4;
                break;
            }
            if (object.destinationPath != null)
                message.destinationPath = String(object.destinationPath);
            if (object.audioData != null) {
                if (typeof object.audioData !== "object")
                    throw TypeError(".ptsl.ImportResponseBody.audioData: object expected");
                message.audioData = $root.ptsl.AudioData.fromObject(object.audioData);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {ptsl.ImportResponseBody} message ImportResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fileList = [];
            if (options.defaults) {
                object.audioOperations = options.enums === String ? "AOperations_Unknown" : 0;
                object.destinationPath = "";
                object.audioData = null;
            }
            if (message.fileList && message.fileList.length) {
                object.fileList = [];
                for (var j = 0; j < message.fileList.length; ++j)
                    object.fileList[j] = message.fileList[j];
            }
            if (message.audioOperations != null && message.hasOwnProperty("audioOperations"))
                object.audioOperations = options.enums === String ? $root.ptsl.AudioOperations[message.audioOperations] === undefined ? message.audioOperations : $root.ptsl.AudioOperations[message.audioOperations] : message.audioOperations;
            if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                object.destinationPath = message.destinationPath;
            if (message.audioData != null && message.hasOwnProperty("audioData"))
                object.audioData = $root.ptsl.AudioData.toObject(message.audioData, options);
            return object;
        };

        /**
         * Converts this ImportResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ImportResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ImportResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportResponseBody";
        };

        return ImportResponseBody;
    })();

    ptsl.TrackListInvertibleFilter = (function() {

        /**
         * Properties of a TrackListInvertibleFilter.
         * @memberof ptsl
         * @interface ITrackListInvertibleFilter
         * @property {ptsl.TrackListFilter|null} [filter] TrackListInvertibleFilter filter
         * @property {boolean|null} [isInverted] TrackListInvertibleFilter isInverted
         */

        /**
         * Constructs a new TrackListInvertibleFilter.
         * @memberof ptsl
         * @classdesc Structure that describes track list filter that can be inverted (e.g. active => inactive).
         * @implements ITrackListInvertibleFilter
         * @constructor
         * @param {ptsl.ITrackListInvertibleFilter=} [properties] Properties to set
         */
        function TrackListInvertibleFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrackListInvertibleFilter filter.
         * @member {ptsl.TrackListFilter} filter
         * @memberof ptsl.TrackListInvertibleFilter
         * @instance
         */
        TrackListInvertibleFilter.prototype.filter = 0;

        /**
         * TrackListInvertibleFilter isInverted.
         * @member {boolean} isInverted
         * @memberof ptsl.TrackListInvertibleFilter
         * @instance
         */
        TrackListInvertibleFilter.prototype.isInverted = false;

        /**
         * Creates a new TrackListInvertibleFilter instance using the specified properties.
         * @function create
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {ptsl.ITrackListInvertibleFilter=} [properties] Properties to set
         * @returns {ptsl.TrackListInvertibleFilter} TrackListInvertibleFilter instance
         */
        TrackListInvertibleFilter.create = function create(properties) {
            return new TrackListInvertibleFilter(properties);
        };

        /**
         * Encodes the specified TrackListInvertibleFilter message. Does not implicitly {@link ptsl.TrackListInvertibleFilter.verify|verify} messages.
         * @function encode
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {ptsl.ITrackListInvertibleFilter} message TrackListInvertibleFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackListInvertibleFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.filter);
            if (message.isInverted != null && Object.hasOwnProperty.call(message, "isInverted"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isInverted);
            return writer;
        };

        /**
         * Encodes the specified TrackListInvertibleFilter message, length delimited. Does not implicitly {@link ptsl.TrackListInvertibleFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {ptsl.ITrackListInvertibleFilter} message TrackListInvertibleFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackListInvertibleFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrackListInvertibleFilter message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.TrackListInvertibleFilter} TrackListInvertibleFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackListInvertibleFilter.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.TrackListInvertibleFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.filter = reader.int32();
                        break;
                    }
                case 2: {
                        message.isInverted = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrackListInvertibleFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.TrackListInvertibleFilter} TrackListInvertibleFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackListInvertibleFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrackListInvertibleFilter message.
         * @function verify
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrackListInvertibleFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filter != null && message.hasOwnProperty("filter"))
                switch (message.filter) {
                default:
                    return "filter: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.isInverted != null && message.hasOwnProperty("isInverted"))
                if (typeof message.isInverted !== "boolean")
                    return "isInverted: boolean expected";
            return null;
        };

        /**
         * Creates a TrackListInvertibleFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.TrackListInvertibleFilter} TrackListInvertibleFilter
         */
        TrackListInvertibleFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.TrackListInvertibleFilter)
                return object;
            var message = new $root.ptsl.TrackListInvertibleFilter();
            switch (object.filter) {
            default:
                if (typeof object.filter === "number") {
                    message.filter = object.filter;
                    break;
                }
                break;
            case "TLFilter_Unknown":
            case 0:
                message.filter = 0;
                break;
            case "All":
            case 1:
                message.filter = 1;
                break;
            case "TLFilter_All":
            case 1:
                message.filter = 1;
                break;
            case "Selected":
            case 2:
                message.filter = 2;
                break;
            case "TLFilter_Selected":
            case 2:
                message.filter = 2;
                break;
            case "SelectedExplicitly":
            case 3:
                message.filter = 3;
                break;
            case "TLFilter_SelectedExplicitly":
            case 3:
                message.filter = 3;
                break;
            case "SelectedImplicitly":
            case 4:
                message.filter = 4;
                break;
            case "TLFilter_SelectedImplicitly":
            case 4:
                message.filter = 4;
                break;
            case "WithClipsOnMainPlaylist":
            case 5:
                message.filter = 5;
                break;
            case "TLFilter_WithClipsOnMainPlaylist":
            case 5:
                message.filter = 5;
                break;
            case "WithAutomationOnMainPlaylist":
            case 6:
                message.filter = 6;
                break;
            case "TLFilter_WithAutomationOnMainPlaylist":
            case 6:
                message.filter = 6;
                break;
            case "Inactive":
            case 7:
                message.filter = 7;
                break;
            case "TLFilter_Inactive":
            case 7:
                message.filter = 7;
                break;
            case "InactiveExplicitly":
            case 8:
                message.filter = 8;
                break;
            case "TLFilter_InactiveExplicitly":
            case 8:
                message.filter = 8;
                break;
            case "InactiveImplicitly":
            case 9:
                message.filter = 9;
                break;
            case "TLFilter_InactiveImplicitly":
            case 9:
                message.filter = 9;
                break;
            case "Hidden":
            case 10:
                message.filter = 10;
                break;
            case "TLFilter_Hidden":
            case 10:
                message.filter = 10;
                break;
            case "HiddenExplicitly":
            case 11:
                message.filter = 11;
                break;
            case "TLFilter_HiddenExplicitly":
            case 11:
                message.filter = 11;
                break;
            case "HiddenImplicitly":
            case 12:
                message.filter = 12;
                break;
            case "TLFilter_HiddenImplicitly":
            case 12:
                message.filter = 12;
                break;
            case "Locked":
            case 13:
                message.filter = 13;
                break;
            case "TLFilter_Locked":
            case 13:
                message.filter = 13;
                break;
            case "Muted":
            case 14:
                message.filter = 14;
                break;
            case "TLFilter_Muted":
            case 14:
                message.filter = 14;
                break;
            case "Frozen":
            case 15:
                message.filter = 15;
                break;
            case "TLFilter_Frozen":
            case 15:
                message.filter = 15;
                break;
            case "Open":
            case 16:
                message.filter = 16;
                break;
            case "TLFilter_Open":
            case 16:
                message.filter = 16;
                break;
            case "Online":
            case 17:
                message.filter = 17;
                break;
            case "TLFilter_Online":
            case 17:
                message.filter = 17;
                break;
            case "TLFilter_HasEditSelection":
            case 18:
                message.filter = 18;
                break;
            case "TLFilter_HasEditSelectionExplicitly":
            case 19:
                message.filter = 19;
                break;
            case "TLFilter_HasEditSelectionImplicitly":
            case 20:
                message.filter = 20;
                break;
            }
            if (object.isInverted != null)
                message.isInverted = Boolean(object.isInverted);
            return message;
        };

        /**
         * Creates a plain object from a TrackListInvertibleFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {ptsl.TrackListInvertibleFilter} message TrackListInvertibleFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrackListInvertibleFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filter = options.enums === String ? "TLFilter_Unknown" : 0;
                object.isInverted = false;
            }
            if (message.filter != null && message.hasOwnProperty("filter"))
                object.filter = options.enums === String ? $root.ptsl.TrackListFilter[message.filter] === undefined ? message.filter : $root.ptsl.TrackListFilter[message.filter] : message.filter;
            if (message.isInverted != null && message.hasOwnProperty("isInverted"))
                object.isInverted = message.isInverted;
            return object;
        };

        /**
         * Converts this TrackListInvertibleFilter to JSON.
         * @function toJSON
         * @memberof ptsl.TrackListInvertibleFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrackListInvertibleFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrackListInvertibleFilter
         * @function getTypeUrl
         * @memberof ptsl.TrackListInvertibleFilter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrackListInvertibleFilter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.TrackListInvertibleFilter";
        };

        return TrackListInvertibleFilter;
    })();

    ptsl.GetTrackListRequestBody = (function() {

        /**
         * Properties of a GetTrackListRequestBody.
         * @memberof ptsl
         * @interface IGetTrackListRequestBody
         * @property {number|null} [pageLimit] * @deprecated since Pro Tools 2023.09, use pagination_request
         * @property {Array.<ptsl.ITrackListInvertibleFilter>|null} [trackFilterList] GetTrackListRequestBody trackFilterList
         * @property {boolean|null} [isFilterListAdditive] GetTrackListRequestBody isFilterListAdditive
         * @property {ptsl.IPaginationRequest|null} [paginationRequest] GetTrackListRequestBody paginationRequest
         */

        /**
         * Constructs a new GetTrackListRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTrackList request data.
         * @implements IGetTrackListRequestBody
         * @constructor
         * @param {ptsl.IGetTrackListRequestBody=} [properties] Properties to set
         */
        function GetTrackListRequestBody(properties) {
            this.trackFilterList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2023.09, use pagination_request
         * @member {number} pageLimit
         * @memberof ptsl.GetTrackListRequestBody
         * @instance
         */
        GetTrackListRequestBody.prototype.pageLimit = 0;

        /**
         * GetTrackListRequestBody trackFilterList.
         * @member {Array.<ptsl.ITrackListInvertibleFilter>} trackFilterList
         * @memberof ptsl.GetTrackListRequestBody
         * @instance
         */
        GetTrackListRequestBody.prototype.trackFilterList = $util.emptyArray;

        /**
         * GetTrackListRequestBody isFilterListAdditive.
         * @member {boolean} isFilterListAdditive
         * @memberof ptsl.GetTrackListRequestBody
         * @instance
         */
        GetTrackListRequestBody.prototype.isFilterListAdditive = false;

        /**
         * GetTrackListRequestBody paginationRequest.
         * @member {ptsl.IPaginationRequest|null|undefined} paginationRequest
         * @memberof ptsl.GetTrackListRequestBody
         * @instance
         */
        GetTrackListRequestBody.prototype.paginationRequest = null;

        /**
         * Creates a new GetTrackListRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {ptsl.IGetTrackListRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetTrackListRequestBody} GetTrackListRequestBody instance
         */
        GetTrackListRequestBody.create = function create(properties) {
            return new GetTrackListRequestBody(properties);
        };

        /**
         * Encodes the specified GetTrackListRequestBody message. Does not implicitly {@link ptsl.GetTrackListRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {ptsl.IGetTrackListRequestBody} message GetTrackListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTrackListRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pageLimit != null && Object.hasOwnProperty.call(message, "pageLimit"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pageLimit);
            if (message.trackFilterList != null && message.trackFilterList.length)
                for (var i = 0; i < message.trackFilterList.length; ++i)
                    $root.ptsl.TrackListInvertibleFilter.encode(message.trackFilterList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.isFilterListAdditive != null && Object.hasOwnProperty.call(message, "isFilterListAdditive"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isFilterListAdditive);
            if (message.paginationRequest != null && Object.hasOwnProperty.call(message, "paginationRequest"))
                $root.ptsl.PaginationRequest.encode(message.paginationRequest, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTrackListRequestBody message, length delimited. Does not implicitly {@link ptsl.GetTrackListRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {ptsl.IGetTrackListRequestBody} message GetTrackListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTrackListRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTrackListRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTrackListRequestBody} GetTrackListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTrackListRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTrackListRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.pageLimit = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.trackFilterList && message.trackFilterList.length))
                            message.trackFilterList = [];
                        message.trackFilterList.push($root.ptsl.TrackListInvertibleFilter.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.isFilterListAdditive = reader.bool();
                        break;
                    }
                case 4: {
                        message.paginationRequest = $root.ptsl.PaginationRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTrackListRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTrackListRequestBody} GetTrackListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTrackListRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTrackListRequestBody message.
         * @function verify
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTrackListRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pageLimit != null && message.hasOwnProperty("pageLimit"))
                if (!$util.isInteger(message.pageLimit))
                    return "pageLimit: integer expected";
            if (message.trackFilterList != null && message.hasOwnProperty("trackFilterList")) {
                if (!Array.isArray(message.trackFilterList))
                    return "trackFilterList: array expected";
                for (var i = 0; i < message.trackFilterList.length; ++i) {
                    var error = $root.ptsl.TrackListInvertibleFilter.verify(message.trackFilterList[i]);
                    if (error)
                        return "trackFilterList." + error;
                }
            }
            if (message.isFilterListAdditive != null && message.hasOwnProperty("isFilterListAdditive"))
                if (typeof message.isFilterListAdditive !== "boolean")
                    return "isFilterListAdditive: boolean expected";
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest")) {
                var error = $root.ptsl.PaginationRequest.verify(message.paginationRequest);
                if (error)
                    return "paginationRequest." + error;
            }
            return null;
        };

        /**
         * Creates a GetTrackListRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTrackListRequestBody} GetTrackListRequestBody
         */
        GetTrackListRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTrackListRequestBody)
                return object;
            var message = new $root.ptsl.GetTrackListRequestBody();
            if (object.pageLimit != null)
                message.pageLimit = object.pageLimit | 0;
            if (object.trackFilterList) {
                if (!Array.isArray(object.trackFilterList))
                    throw TypeError(".ptsl.GetTrackListRequestBody.trackFilterList: array expected");
                message.trackFilterList = [];
                for (var i = 0; i < object.trackFilterList.length; ++i) {
                    if (typeof object.trackFilterList[i] !== "object")
                        throw TypeError(".ptsl.GetTrackListRequestBody.trackFilterList: object expected");
                    message.trackFilterList[i] = $root.ptsl.TrackListInvertibleFilter.fromObject(object.trackFilterList[i]);
                }
            }
            if (object.isFilterListAdditive != null)
                message.isFilterListAdditive = Boolean(object.isFilterListAdditive);
            if (object.paginationRequest != null) {
                if (typeof object.paginationRequest !== "object")
                    throw TypeError(".ptsl.GetTrackListRequestBody.paginationRequest: object expected");
                message.paginationRequest = $root.ptsl.PaginationRequest.fromObject(object.paginationRequest);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTrackListRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {ptsl.GetTrackListRequestBody} message GetTrackListRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTrackListRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackFilterList = [];
            if (options.defaults) {
                object.pageLimit = 0;
                object.isFilterListAdditive = false;
                object.paginationRequest = null;
            }
            if (message.pageLimit != null && message.hasOwnProperty("pageLimit"))
                object.pageLimit = message.pageLimit;
            if (message.trackFilterList && message.trackFilterList.length) {
                object.trackFilterList = [];
                for (var j = 0; j < message.trackFilterList.length; ++j)
                    object.trackFilterList[j] = $root.ptsl.TrackListInvertibleFilter.toObject(message.trackFilterList[j], options);
            }
            if (message.isFilterListAdditive != null && message.hasOwnProperty("isFilterListAdditive"))
                object.isFilterListAdditive = message.isFilterListAdditive;
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest"))
                object.paginationRequest = $root.ptsl.PaginationRequest.toObject(message.paginationRequest, options);
            return object;
        };

        /**
         * Converts this GetTrackListRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTrackListRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTrackListRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTrackListRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetTrackListRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTrackListRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTrackListRequestBody";
        };

        return GetTrackListRequestBody;
    })();

    ptsl.GetTrackListResponseBody = (function() {

        /**
         * Properties of a GetTrackListResponseBody.
         * @memberof ptsl
         * @interface IGetTrackListResponseBody
         * @property {ptsl.IPagination|null} [stats] * @deprecated since Pro Tools 2023.09, use pagination_response
         * @property {Array.<ptsl.ITrack>|null} [trackList] GetTrackListResponseBody trackList
         * @property {ptsl.IPaginationResponse|null} [paginationResponse] * @since Pro Tools 2023.09
         */

        /**
         * Constructs a new GetTrackListResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTrackList response data.
         * @implements IGetTrackListResponseBody
         * @constructor
         * @param {ptsl.IGetTrackListResponseBody=} [properties] Properties to set
         */
        function GetTrackListResponseBody(properties) {
            this.trackList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2023.09, use pagination_response
         * @member {ptsl.IPagination|null|undefined} stats
         * @memberof ptsl.GetTrackListResponseBody
         * @instance
         */
        GetTrackListResponseBody.prototype.stats = null;

        /**
         * GetTrackListResponseBody trackList.
         * @member {Array.<ptsl.ITrack>} trackList
         * @memberof ptsl.GetTrackListResponseBody
         * @instance
         */
        GetTrackListResponseBody.prototype.trackList = $util.emptyArray;

        /**
         * * @since Pro Tools 2023.09
         * @member {ptsl.IPaginationResponse|null|undefined} paginationResponse
         * @memberof ptsl.GetTrackListResponseBody
         * @instance
         */
        GetTrackListResponseBody.prototype.paginationResponse = null;

        /**
         * Creates a new GetTrackListResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {ptsl.IGetTrackListResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetTrackListResponseBody} GetTrackListResponseBody instance
         */
        GetTrackListResponseBody.create = function create(properties) {
            return new GetTrackListResponseBody(properties);
        };

        /**
         * Encodes the specified GetTrackListResponseBody message. Does not implicitly {@link ptsl.GetTrackListResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {ptsl.IGetTrackListResponseBody} message GetTrackListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTrackListResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stats != null && Object.hasOwnProperty.call(message, "stats"))
                $root.ptsl.Pagination.encode(message.stats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trackList != null && message.trackList.length)
                for (var i = 0; i < message.trackList.length; ++i)
                    $root.ptsl.Track.encode(message.trackList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.paginationResponse != null && Object.hasOwnProperty.call(message, "paginationResponse"))
                $root.ptsl.PaginationResponse.encode(message.paginationResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTrackListResponseBody message, length delimited. Does not implicitly {@link ptsl.GetTrackListResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {ptsl.IGetTrackListResponseBody} message GetTrackListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTrackListResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTrackListResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTrackListResponseBody} GetTrackListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTrackListResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTrackListResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.stats = $root.ptsl.Pagination.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.trackList && message.trackList.length))
                            message.trackList = [];
                        message.trackList.push($root.ptsl.Track.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.paginationResponse = $root.ptsl.PaginationResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTrackListResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTrackListResponseBody} GetTrackListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTrackListResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTrackListResponseBody message.
         * @function verify
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTrackListResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stats != null && message.hasOwnProperty("stats")) {
                var error = $root.ptsl.Pagination.verify(message.stats);
                if (error)
                    return "stats." + error;
            }
            if (message.trackList != null && message.hasOwnProperty("trackList")) {
                if (!Array.isArray(message.trackList))
                    return "trackList: array expected";
                for (var i = 0; i < message.trackList.length; ++i) {
                    var error = $root.ptsl.Track.verify(message.trackList[i]);
                    if (error)
                        return "trackList." + error;
                }
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse")) {
                var error = $root.ptsl.PaginationResponse.verify(message.paginationResponse);
                if (error)
                    return "paginationResponse." + error;
            }
            return null;
        };

        /**
         * Creates a GetTrackListResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTrackListResponseBody} GetTrackListResponseBody
         */
        GetTrackListResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTrackListResponseBody)
                return object;
            var message = new $root.ptsl.GetTrackListResponseBody();
            if (object.stats != null) {
                if (typeof object.stats !== "object")
                    throw TypeError(".ptsl.GetTrackListResponseBody.stats: object expected");
                message.stats = $root.ptsl.Pagination.fromObject(object.stats);
            }
            if (object.trackList) {
                if (!Array.isArray(object.trackList))
                    throw TypeError(".ptsl.GetTrackListResponseBody.trackList: array expected");
                message.trackList = [];
                for (var i = 0; i < object.trackList.length; ++i) {
                    if (typeof object.trackList[i] !== "object")
                        throw TypeError(".ptsl.GetTrackListResponseBody.trackList: object expected");
                    message.trackList[i] = $root.ptsl.Track.fromObject(object.trackList[i]);
                }
            }
            if (object.paginationResponse != null) {
                if (typeof object.paginationResponse !== "object")
                    throw TypeError(".ptsl.GetTrackListResponseBody.paginationResponse: object expected");
                message.paginationResponse = $root.ptsl.PaginationResponse.fromObject(object.paginationResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTrackListResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {ptsl.GetTrackListResponseBody} message GetTrackListResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTrackListResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackList = [];
            if (options.defaults) {
                object.stats = null;
                object.paginationResponse = null;
            }
            if (message.stats != null && message.hasOwnProperty("stats"))
                object.stats = $root.ptsl.Pagination.toObject(message.stats, options);
            if (message.trackList && message.trackList.length) {
                object.trackList = [];
                for (var j = 0; j < message.trackList.length; ++j)
                    object.trackList[j] = $root.ptsl.Track.toObject(message.trackList[j], options);
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse"))
                object.paginationResponse = $root.ptsl.PaginationResponse.toObject(message.paginationResponse, options);
            return object;
        };

        /**
         * Converts this GetTrackListResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTrackListResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTrackListResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTrackListResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetTrackListResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTrackListResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTrackListResponseBody";
        };

        return GetTrackListResponseBody;
    })();

    ptsl.SelectAllClipsOnTrackRequestBody = (function() {

        /**
         * Properties of a SelectAllClipsOnTrackRequestBody.
         * @memberof ptsl
         * @interface ISelectAllClipsOnTrackRequestBody
         * @property {string|null} [trackName] SelectAllClipsOnTrackRequestBody trackName
         */

        /**
         * Constructs a new SelectAllClipsOnTrackRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SelectAllClipsOnTrack request data.
         * @implements ISelectAllClipsOnTrackRequestBody
         * @constructor
         * @param {ptsl.ISelectAllClipsOnTrackRequestBody=} [properties] Properties to set
         */
        function SelectAllClipsOnTrackRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SelectAllClipsOnTrackRequestBody trackName.
         * @member {string} trackName
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @instance
         */
        SelectAllClipsOnTrackRequestBody.prototype.trackName = "";

        /**
         * Creates a new SelectAllClipsOnTrackRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {ptsl.ISelectAllClipsOnTrackRequestBody=} [properties] Properties to set
         * @returns {ptsl.SelectAllClipsOnTrackRequestBody} SelectAllClipsOnTrackRequestBody instance
         */
        SelectAllClipsOnTrackRequestBody.create = function create(properties) {
            return new SelectAllClipsOnTrackRequestBody(properties);
        };

        /**
         * Encodes the specified SelectAllClipsOnTrackRequestBody message. Does not implicitly {@link ptsl.SelectAllClipsOnTrackRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {ptsl.ISelectAllClipsOnTrackRequestBody} message SelectAllClipsOnTrackRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectAllClipsOnTrackRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackName);
            return writer;
        };

        /**
         * Encodes the specified SelectAllClipsOnTrackRequestBody message, length delimited. Does not implicitly {@link ptsl.SelectAllClipsOnTrackRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {ptsl.ISelectAllClipsOnTrackRequestBody} message SelectAllClipsOnTrackRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectAllClipsOnTrackRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SelectAllClipsOnTrackRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SelectAllClipsOnTrackRequestBody} SelectAllClipsOnTrackRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectAllClipsOnTrackRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SelectAllClipsOnTrackRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.trackName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SelectAllClipsOnTrackRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SelectAllClipsOnTrackRequestBody} SelectAllClipsOnTrackRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectAllClipsOnTrackRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SelectAllClipsOnTrackRequestBody message.
         * @function verify
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SelectAllClipsOnTrackRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            return null;
        };

        /**
         * Creates a SelectAllClipsOnTrackRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SelectAllClipsOnTrackRequestBody} SelectAllClipsOnTrackRequestBody
         */
        SelectAllClipsOnTrackRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SelectAllClipsOnTrackRequestBody)
                return object;
            var message = new $root.ptsl.SelectAllClipsOnTrackRequestBody();
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            return message;
        };

        /**
         * Creates a plain object from a SelectAllClipsOnTrackRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {ptsl.SelectAllClipsOnTrackRequestBody} message SelectAllClipsOnTrackRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SelectAllClipsOnTrackRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.trackName = "";
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            return object;
        };

        /**
         * Converts this SelectAllClipsOnTrackRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SelectAllClipsOnTrackRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SelectAllClipsOnTrackRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SelectAllClipsOnTrackRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SelectAllClipsOnTrackRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SelectAllClipsOnTrackRequestBody";
        };

        return SelectAllClipsOnTrackRequestBody;
    })();

    ptsl.SelectAllClipsOnTrackResponseBody = (function() {

        /**
         * Properties of a SelectAllClipsOnTrackResponseBody.
         * @memberof ptsl
         * @interface ISelectAllClipsOnTrackResponseBody
         * @property {string|null} [trackName] SelectAllClipsOnTrackResponseBody trackName
         */

        /**
         * Constructs a new SelectAllClipsOnTrackResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes SelectAllClipsOnTrack response data.
         * @implements ISelectAllClipsOnTrackResponseBody
         * @constructor
         * @param {ptsl.ISelectAllClipsOnTrackResponseBody=} [properties] Properties to set
         */
        function SelectAllClipsOnTrackResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SelectAllClipsOnTrackResponseBody trackName.
         * @member {string} trackName
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @instance
         */
        SelectAllClipsOnTrackResponseBody.prototype.trackName = "";

        /**
         * Creates a new SelectAllClipsOnTrackResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {ptsl.ISelectAllClipsOnTrackResponseBody=} [properties] Properties to set
         * @returns {ptsl.SelectAllClipsOnTrackResponseBody} SelectAllClipsOnTrackResponseBody instance
         */
        SelectAllClipsOnTrackResponseBody.create = function create(properties) {
            return new SelectAllClipsOnTrackResponseBody(properties);
        };

        /**
         * Encodes the specified SelectAllClipsOnTrackResponseBody message. Does not implicitly {@link ptsl.SelectAllClipsOnTrackResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {ptsl.ISelectAllClipsOnTrackResponseBody} message SelectAllClipsOnTrackResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectAllClipsOnTrackResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackName);
            return writer;
        };

        /**
         * Encodes the specified SelectAllClipsOnTrackResponseBody message, length delimited. Does not implicitly {@link ptsl.SelectAllClipsOnTrackResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {ptsl.ISelectAllClipsOnTrackResponseBody} message SelectAllClipsOnTrackResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectAllClipsOnTrackResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SelectAllClipsOnTrackResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SelectAllClipsOnTrackResponseBody} SelectAllClipsOnTrackResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectAllClipsOnTrackResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SelectAllClipsOnTrackResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.trackName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SelectAllClipsOnTrackResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SelectAllClipsOnTrackResponseBody} SelectAllClipsOnTrackResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectAllClipsOnTrackResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SelectAllClipsOnTrackResponseBody message.
         * @function verify
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SelectAllClipsOnTrackResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            return null;
        };

        /**
         * Creates a SelectAllClipsOnTrackResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SelectAllClipsOnTrackResponseBody} SelectAllClipsOnTrackResponseBody
         */
        SelectAllClipsOnTrackResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SelectAllClipsOnTrackResponseBody)
                return object;
            var message = new $root.ptsl.SelectAllClipsOnTrackResponseBody();
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            return message;
        };

        /**
         * Creates a plain object from a SelectAllClipsOnTrackResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {ptsl.SelectAllClipsOnTrackResponseBody} message SelectAllClipsOnTrackResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SelectAllClipsOnTrackResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.trackName = "";
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            return object;
        };

        /**
         * Converts this SelectAllClipsOnTrackResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SelectAllClipsOnTrackResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SelectAllClipsOnTrackResponseBody
         * @function getTypeUrl
         * @memberof ptsl.SelectAllClipsOnTrackResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SelectAllClipsOnTrackResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SelectAllClipsOnTrackResponseBody";
        };

        return SelectAllClipsOnTrackResponseBody;
    })();

    ptsl.ExtendSelectionToTargetTracksRequestBody = (function() {

        /**
         * Properties of an ExtendSelectionToTargetTracksRequestBody.
         * @memberof ptsl
         * @interface IExtendSelectionToTargetTracksRequestBody
         * @property {Array.<string>|null} [tracksToExtendTo] ExtendSelectionToTargetTracksRequestBody tracksToExtendTo
         */

        /**
         * Constructs a new ExtendSelectionToTargetTracksRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExtendSelectionToTargetTracks request data.
         * @implements IExtendSelectionToTargetTracksRequestBody
         * @constructor
         * @param {ptsl.IExtendSelectionToTargetTracksRequestBody=} [properties] Properties to set
         */
        function ExtendSelectionToTargetTracksRequestBody(properties) {
            this.tracksToExtendTo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExtendSelectionToTargetTracksRequestBody tracksToExtendTo.
         * @member {Array.<string>} tracksToExtendTo
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @instance
         */
        ExtendSelectionToTargetTracksRequestBody.prototype.tracksToExtendTo = $util.emptyArray;

        /**
         * Creates a new ExtendSelectionToTargetTracksRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {ptsl.IExtendSelectionToTargetTracksRequestBody=} [properties] Properties to set
         * @returns {ptsl.ExtendSelectionToTargetTracksRequestBody} ExtendSelectionToTargetTracksRequestBody instance
         */
        ExtendSelectionToTargetTracksRequestBody.create = function create(properties) {
            return new ExtendSelectionToTargetTracksRequestBody(properties);
        };

        /**
         * Encodes the specified ExtendSelectionToTargetTracksRequestBody message. Does not implicitly {@link ptsl.ExtendSelectionToTargetTracksRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {ptsl.IExtendSelectionToTargetTracksRequestBody} message ExtendSelectionToTargetTracksRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtendSelectionToTargetTracksRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tracksToExtendTo != null && message.tracksToExtendTo.length)
                for (var i = 0; i < message.tracksToExtendTo.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tracksToExtendTo[i]);
            return writer;
        };

        /**
         * Encodes the specified ExtendSelectionToTargetTracksRequestBody message, length delimited. Does not implicitly {@link ptsl.ExtendSelectionToTargetTracksRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {ptsl.IExtendSelectionToTargetTracksRequestBody} message ExtendSelectionToTargetTracksRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtendSelectionToTargetTracksRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExtendSelectionToTargetTracksRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExtendSelectionToTargetTracksRequestBody} ExtendSelectionToTargetTracksRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtendSelectionToTargetTracksRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExtendSelectionToTargetTracksRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tracksToExtendTo && message.tracksToExtendTo.length))
                            message.tracksToExtendTo = [];
                        message.tracksToExtendTo.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExtendSelectionToTargetTracksRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExtendSelectionToTargetTracksRequestBody} ExtendSelectionToTargetTracksRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtendSelectionToTargetTracksRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExtendSelectionToTargetTracksRequestBody message.
         * @function verify
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExtendSelectionToTargetTracksRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tracksToExtendTo != null && message.hasOwnProperty("tracksToExtendTo")) {
                if (!Array.isArray(message.tracksToExtendTo))
                    return "tracksToExtendTo: array expected";
                for (var i = 0; i < message.tracksToExtendTo.length; ++i)
                    if (!$util.isString(message.tracksToExtendTo[i]))
                        return "tracksToExtendTo: string[] expected";
            }
            return null;
        };

        /**
         * Creates an ExtendSelectionToTargetTracksRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExtendSelectionToTargetTracksRequestBody} ExtendSelectionToTargetTracksRequestBody
         */
        ExtendSelectionToTargetTracksRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExtendSelectionToTargetTracksRequestBody)
                return object;
            var message = new $root.ptsl.ExtendSelectionToTargetTracksRequestBody();
            if (object.tracksToExtendTo) {
                if (!Array.isArray(object.tracksToExtendTo))
                    throw TypeError(".ptsl.ExtendSelectionToTargetTracksRequestBody.tracksToExtendTo: array expected");
                message.tracksToExtendTo = [];
                for (var i = 0; i < object.tracksToExtendTo.length; ++i)
                    message.tracksToExtendTo[i] = String(object.tracksToExtendTo[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExtendSelectionToTargetTracksRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {ptsl.ExtendSelectionToTargetTracksRequestBody} message ExtendSelectionToTargetTracksRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExtendSelectionToTargetTracksRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tracksToExtendTo = [];
            if (message.tracksToExtendTo && message.tracksToExtendTo.length) {
                object.tracksToExtendTo = [];
                for (var j = 0; j < message.tracksToExtendTo.length; ++j)
                    object.tracksToExtendTo[j] = message.tracksToExtendTo[j];
            }
            return object;
        };

        /**
         * Converts this ExtendSelectionToTargetTracksRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExtendSelectionToTargetTracksRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExtendSelectionToTargetTracksRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ExtendSelectionToTargetTracksRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExtendSelectionToTargetTracksRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExtendSelectionToTargetTracksRequestBody";
        };

        return ExtendSelectionToTargetTracksRequestBody;
    })();

    ptsl.ExtendSelectionToTargetTracksResponseBody = (function() {

        /**
         * Properties of an ExtendSelectionToTargetTracksResponseBody.
         * @memberof ptsl
         * @interface IExtendSelectionToTargetTracksResponseBody
         * @property {Array.<string>|null} [tracksToExtendTo] ExtendSelectionToTargetTracksResponseBody tracksToExtendTo
         */

        /**
         * Constructs a new ExtendSelectionToTargetTracksResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExtendSelectionToTargetTracks response data.
         * @implements IExtendSelectionToTargetTracksResponseBody
         * @constructor
         * @param {ptsl.IExtendSelectionToTargetTracksResponseBody=} [properties] Properties to set
         */
        function ExtendSelectionToTargetTracksResponseBody(properties) {
            this.tracksToExtendTo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExtendSelectionToTargetTracksResponseBody tracksToExtendTo.
         * @member {Array.<string>} tracksToExtendTo
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @instance
         */
        ExtendSelectionToTargetTracksResponseBody.prototype.tracksToExtendTo = $util.emptyArray;

        /**
         * Creates a new ExtendSelectionToTargetTracksResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {ptsl.IExtendSelectionToTargetTracksResponseBody=} [properties] Properties to set
         * @returns {ptsl.ExtendSelectionToTargetTracksResponseBody} ExtendSelectionToTargetTracksResponseBody instance
         */
        ExtendSelectionToTargetTracksResponseBody.create = function create(properties) {
            return new ExtendSelectionToTargetTracksResponseBody(properties);
        };

        /**
         * Encodes the specified ExtendSelectionToTargetTracksResponseBody message. Does not implicitly {@link ptsl.ExtendSelectionToTargetTracksResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {ptsl.IExtendSelectionToTargetTracksResponseBody} message ExtendSelectionToTargetTracksResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtendSelectionToTargetTracksResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tracksToExtendTo != null && message.tracksToExtendTo.length)
                for (var i = 0; i < message.tracksToExtendTo.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tracksToExtendTo[i]);
            return writer;
        };

        /**
         * Encodes the specified ExtendSelectionToTargetTracksResponseBody message, length delimited. Does not implicitly {@link ptsl.ExtendSelectionToTargetTracksResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {ptsl.IExtendSelectionToTargetTracksResponseBody} message ExtendSelectionToTargetTracksResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtendSelectionToTargetTracksResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExtendSelectionToTargetTracksResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExtendSelectionToTargetTracksResponseBody} ExtendSelectionToTargetTracksResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtendSelectionToTargetTracksResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExtendSelectionToTargetTracksResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tracksToExtendTo && message.tracksToExtendTo.length))
                            message.tracksToExtendTo = [];
                        message.tracksToExtendTo.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExtendSelectionToTargetTracksResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExtendSelectionToTargetTracksResponseBody} ExtendSelectionToTargetTracksResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtendSelectionToTargetTracksResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExtendSelectionToTargetTracksResponseBody message.
         * @function verify
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExtendSelectionToTargetTracksResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tracksToExtendTo != null && message.hasOwnProperty("tracksToExtendTo")) {
                if (!Array.isArray(message.tracksToExtendTo))
                    return "tracksToExtendTo: array expected";
                for (var i = 0; i < message.tracksToExtendTo.length; ++i)
                    if (!$util.isString(message.tracksToExtendTo[i]))
                        return "tracksToExtendTo: string[] expected";
            }
            return null;
        };

        /**
         * Creates an ExtendSelectionToTargetTracksResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExtendSelectionToTargetTracksResponseBody} ExtendSelectionToTargetTracksResponseBody
         */
        ExtendSelectionToTargetTracksResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExtendSelectionToTargetTracksResponseBody)
                return object;
            var message = new $root.ptsl.ExtendSelectionToTargetTracksResponseBody();
            if (object.tracksToExtendTo) {
                if (!Array.isArray(object.tracksToExtendTo))
                    throw TypeError(".ptsl.ExtendSelectionToTargetTracksResponseBody.tracksToExtendTo: array expected");
                message.tracksToExtendTo = [];
                for (var i = 0; i < object.tracksToExtendTo.length; ++i)
                    message.tracksToExtendTo[i] = String(object.tracksToExtendTo[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExtendSelectionToTargetTracksResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {ptsl.ExtendSelectionToTargetTracksResponseBody} message ExtendSelectionToTargetTracksResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExtendSelectionToTargetTracksResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tracksToExtendTo = [];
            if (message.tracksToExtendTo && message.tracksToExtendTo.length) {
                object.tracksToExtendTo = [];
                for (var j = 0; j < message.tracksToExtendTo.length; ++j)
                    object.tracksToExtendTo[j] = message.tracksToExtendTo[j];
            }
            return object;
        };

        /**
         * Converts this ExtendSelectionToTargetTracksResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExtendSelectionToTargetTracksResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExtendSelectionToTargetTracksResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ExtendSelectionToTargetTracksResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExtendSelectionToTargetTracksResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExtendSelectionToTargetTracksResponseBody";
        };

        return ExtendSelectionToTargetTracksResponseBody;
    })();

    ptsl.CreateFadesBasedOnPresetRequestBody = (function() {

        /**
         * Properties of a CreateFadesBasedOnPresetRequestBody.
         * @memberof ptsl
         * @interface ICreateFadesBasedOnPresetRequestBody
         * @property {string|null} [fadePresetName] CreateFadesBasedOnPresetRequestBody fadePresetName
         * @property {boolean|null} [autoAdjustBounds] CreateFadesBasedOnPresetRequestBody autoAdjustBounds
         */

        /**
         * Constructs a new CreateFadesBasedOnPresetRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateFadesBasedOnPreset request data.
         * @implements ICreateFadesBasedOnPresetRequestBody
         * @constructor
         * @param {ptsl.ICreateFadesBasedOnPresetRequestBody=} [properties] Properties to set
         */
        function CreateFadesBasedOnPresetRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateFadesBasedOnPresetRequestBody fadePresetName.
         * @member {string} fadePresetName
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @instance
         */
        CreateFadesBasedOnPresetRequestBody.prototype.fadePresetName = "";

        /**
         * CreateFadesBasedOnPresetRequestBody autoAdjustBounds.
         * @member {boolean} autoAdjustBounds
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @instance
         */
        CreateFadesBasedOnPresetRequestBody.prototype.autoAdjustBounds = false;

        /**
         * Creates a new CreateFadesBasedOnPresetRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {ptsl.ICreateFadesBasedOnPresetRequestBody=} [properties] Properties to set
         * @returns {ptsl.CreateFadesBasedOnPresetRequestBody} CreateFadesBasedOnPresetRequestBody instance
         */
        CreateFadesBasedOnPresetRequestBody.create = function create(properties) {
            return new CreateFadesBasedOnPresetRequestBody(properties);
        };

        /**
         * Encodes the specified CreateFadesBasedOnPresetRequestBody message. Does not implicitly {@link ptsl.CreateFadesBasedOnPresetRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {ptsl.ICreateFadesBasedOnPresetRequestBody} message CreateFadesBasedOnPresetRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFadesBasedOnPresetRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fadePresetName != null && Object.hasOwnProperty.call(message, "fadePresetName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fadePresetName);
            if (message.autoAdjustBounds != null && Object.hasOwnProperty.call(message, "autoAdjustBounds"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.autoAdjustBounds);
            return writer;
        };

        /**
         * Encodes the specified CreateFadesBasedOnPresetRequestBody message, length delimited. Does not implicitly {@link ptsl.CreateFadesBasedOnPresetRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {ptsl.ICreateFadesBasedOnPresetRequestBody} message CreateFadesBasedOnPresetRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFadesBasedOnPresetRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateFadesBasedOnPresetRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateFadesBasedOnPresetRequestBody} CreateFadesBasedOnPresetRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFadesBasedOnPresetRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateFadesBasedOnPresetRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fadePresetName = reader.string();
                        break;
                    }
                case 2: {
                        message.autoAdjustBounds = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateFadesBasedOnPresetRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateFadesBasedOnPresetRequestBody} CreateFadesBasedOnPresetRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFadesBasedOnPresetRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateFadesBasedOnPresetRequestBody message.
         * @function verify
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateFadesBasedOnPresetRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fadePresetName != null && message.hasOwnProperty("fadePresetName"))
                if (!$util.isString(message.fadePresetName))
                    return "fadePresetName: string expected";
            if (message.autoAdjustBounds != null && message.hasOwnProperty("autoAdjustBounds"))
                if (typeof message.autoAdjustBounds !== "boolean")
                    return "autoAdjustBounds: boolean expected";
            return null;
        };

        /**
         * Creates a CreateFadesBasedOnPresetRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateFadesBasedOnPresetRequestBody} CreateFadesBasedOnPresetRequestBody
         */
        CreateFadesBasedOnPresetRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateFadesBasedOnPresetRequestBody)
                return object;
            var message = new $root.ptsl.CreateFadesBasedOnPresetRequestBody();
            if (object.fadePresetName != null)
                message.fadePresetName = String(object.fadePresetName);
            if (object.autoAdjustBounds != null)
                message.autoAdjustBounds = Boolean(object.autoAdjustBounds);
            return message;
        };

        /**
         * Creates a plain object from a CreateFadesBasedOnPresetRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {ptsl.CreateFadesBasedOnPresetRequestBody} message CreateFadesBasedOnPresetRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateFadesBasedOnPresetRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fadePresetName = "";
                object.autoAdjustBounds = false;
            }
            if (message.fadePresetName != null && message.hasOwnProperty("fadePresetName"))
                object.fadePresetName = message.fadePresetName;
            if (message.autoAdjustBounds != null && message.hasOwnProperty("autoAdjustBounds"))
                object.autoAdjustBounds = message.autoAdjustBounds;
            return object;
        };

        /**
         * Converts this CreateFadesBasedOnPresetRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateFadesBasedOnPresetRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateFadesBasedOnPresetRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CreateFadesBasedOnPresetRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateFadesBasedOnPresetRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateFadesBasedOnPresetRequestBody";
        };

        return CreateFadesBasedOnPresetRequestBody;
    })();

    ptsl.CreateFadesBasedOnPresetResponseBody = (function() {

        /**
         * Properties of a CreateFadesBasedOnPresetResponseBody.
         * @memberof ptsl
         * @interface ICreateFadesBasedOnPresetResponseBody
         * @property {string|null} [fadePresetName] CreateFadesBasedOnPresetResponseBody fadePresetName
         */

        /**
         * Constructs a new CreateFadesBasedOnPresetResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateFadesBasedOnPreset response data.
         * @implements ICreateFadesBasedOnPresetResponseBody
         * @constructor
         * @param {ptsl.ICreateFadesBasedOnPresetResponseBody=} [properties] Properties to set
         */
        function CreateFadesBasedOnPresetResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateFadesBasedOnPresetResponseBody fadePresetName.
         * @member {string} fadePresetName
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @instance
         */
        CreateFadesBasedOnPresetResponseBody.prototype.fadePresetName = "";

        /**
         * Creates a new CreateFadesBasedOnPresetResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {ptsl.ICreateFadesBasedOnPresetResponseBody=} [properties] Properties to set
         * @returns {ptsl.CreateFadesBasedOnPresetResponseBody} CreateFadesBasedOnPresetResponseBody instance
         */
        CreateFadesBasedOnPresetResponseBody.create = function create(properties) {
            return new CreateFadesBasedOnPresetResponseBody(properties);
        };

        /**
         * Encodes the specified CreateFadesBasedOnPresetResponseBody message. Does not implicitly {@link ptsl.CreateFadesBasedOnPresetResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {ptsl.ICreateFadesBasedOnPresetResponseBody} message CreateFadesBasedOnPresetResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFadesBasedOnPresetResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fadePresetName != null && Object.hasOwnProperty.call(message, "fadePresetName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fadePresetName);
            return writer;
        };

        /**
         * Encodes the specified CreateFadesBasedOnPresetResponseBody message, length delimited. Does not implicitly {@link ptsl.CreateFadesBasedOnPresetResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {ptsl.ICreateFadesBasedOnPresetResponseBody} message CreateFadesBasedOnPresetResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFadesBasedOnPresetResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateFadesBasedOnPresetResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateFadesBasedOnPresetResponseBody} CreateFadesBasedOnPresetResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFadesBasedOnPresetResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateFadesBasedOnPresetResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fadePresetName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateFadesBasedOnPresetResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateFadesBasedOnPresetResponseBody} CreateFadesBasedOnPresetResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFadesBasedOnPresetResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateFadesBasedOnPresetResponseBody message.
         * @function verify
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateFadesBasedOnPresetResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fadePresetName != null && message.hasOwnProperty("fadePresetName"))
                if (!$util.isString(message.fadePresetName))
                    return "fadePresetName: string expected";
            return null;
        };

        /**
         * Creates a CreateFadesBasedOnPresetResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateFadesBasedOnPresetResponseBody} CreateFadesBasedOnPresetResponseBody
         */
        CreateFadesBasedOnPresetResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateFadesBasedOnPresetResponseBody)
                return object;
            var message = new $root.ptsl.CreateFadesBasedOnPresetResponseBody();
            if (object.fadePresetName != null)
                message.fadePresetName = String(object.fadePresetName);
            return message;
        };

        /**
         * Creates a plain object from a CreateFadesBasedOnPresetResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {ptsl.CreateFadesBasedOnPresetResponseBody} message CreateFadesBasedOnPresetResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateFadesBasedOnPresetResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fadePresetName = "";
            if (message.fadePresetName != null && message.hasOwnProperty("fadePresetName"))
                object.fadePresetName = message.fadePresetName;
            return object;
        };

        /**
         * Converts this CreateFadesBasedOnPresetResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateFadesBasedOnPresetResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateFadesBasedOnPresetResponseBody
         * @function getTypeUrl
         * @memberof ptsl.CreateFadesBasedOnPresetResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateFadesBasedOnPresetResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateFadesBasedOnPresetResponseBody";
        };

        return CreateFadesBasedOnPresetResponseBody;
    })();

    ptsl.RenameTargetTrackRequestBody = (function() {

        /**
         * Properties of a RenameTargetTrackRequestBody.
         * @memberof ptsl
         * @interface IRenameTargetTrackRequestBody
         * @property {string|null} [trackId] @deprecated
         * * track_id is deprecated starting in Pro Tools 2023.03
         * * Use RenameTargetTrackRequestBody::current_name instead
         * @property {string|null} [newName] RenameTargetTrackRequestBody newName
         * @property {string|null} [currentName] RenameTargetTrackRequestBody currentName
         */

        /**
         * Constructs a new RenameTargetTrackRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes RenameTargetTrack request data.
         * @implements IRenameTargetTrackRequestBody
         * @constructor
         * @param {ptsl.IRenameTargetTrackRequestBody=} [properties] Properties to set
         */
        function RenameTargetTrackRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * @deprecated
         * * track_id is deprecated starting in Pro Tools 2023.03
         * * Use RenameTargetTrackRequestBody::current_name instead
         * @member {string} trackId
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @instance
         */
        RenameTargetTrackRequestBody.prototype.trackId = "";

        /**
         * RenameTargetTrackRequestBody newName.
         * @member {string} newName
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @instance
         */
        RenameTargetTrackRequestBody.prototype.newName = "";

        /**
         * RenameTargetTrackRequestBody currentName.
         * @member {string} currentName
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @instance
         */
        RenameTargetTrackRequestBody.prototype.currentName = "";

        /**
         * Creates a new RenameTargetTrackRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {ptsl.IRenameTargetTrackRequestBody=} [properties] Properties to set
         * @returns {ptsl.RenameTargetTrackRequestBody} RenameTargetTrackRequestBody instance
         */
        RenameTargetTrackRequestBody.create = function create(properties) {
            return new RenameTargetTrackRequestBody(properties);
        };

        /**
         * Encodes the specified RenameTargetTrackRequestBody message. Does not implicitly {@link ptsl.RenameTargetTrackRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {ptsl.IRenameTargetTrackRequestBody} message RenameTargetTrackRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameTargetTrackRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackId != null && Object.hasOwnProperty.call(message, "trackId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackId);
            if (message.newName != null && Object.hasOwnProperty.call(message, "newName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.newName);
            if (message.currentName != null && Object.hasOwnProperty.call(message, "currentName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.currentName);
            return writer;
        };

        /**
         * Encodes the specified RenameTargetTrackRequestBody message, length delimited. Does not implicitly {@link ptsl.RenameTargetTrackRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {ptsl.IRenameTargetTrackRequestBody} message RenameTargetTrackRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameTargetTrackRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameTargetTrackRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RenameTargetTrackRequestBody} RenameTargetTrackRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameTargetTrackRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RenameTargetTrackRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.trackId = reader.string();
                        break;
                    }
                case 2: {
                        message.newName = reader.string();
                        break;
                    }
                case 3: {
                        message.currentName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RenameTargetTrackRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RenameTargetTrackRequestBody} RenameTargetTrackRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameTargetTrackRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameTargetTrackRequestBody message.
         * @function verify
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameTargetTrackRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackId != null && message.hasOwnProperty("trackId"))
                if (!$util.isString(message.trackId))
                    return "trackId: string expected";
            if (message.newName != null && message.hasOwnProperty("newName"))
                if (!$util.isString(message.newName))
                    return "newName: string expected";
            if (message.currentName != null && message.hasOwnProperty("currentName"))
                if (!$util.isString(message.currentName))
                    return "currentName: string expected";
            return null;
        };

        /**
         * Creates a RenameTargetTrackRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RenameTargetTrackRequestBody} RenameTargetTrackRequestBody
         */
        RenameTargetTrackRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RenameTargetTrackRequestBody)
                return object;
            var message = new $root.ptsl.RenameTargetTrackRequestBody();
            if (object.trackId != null)
                message.trackId = String(object.trackId);
            if (object.newName != null)
                message.newName = String(object.newName);
            if (object.currentName != null)
                message.currentName = String(object.currentName);
            return message;
        };

        /**
         * Creates a plain object from a RenameTargetTrackRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {ptsl.RenameTargetTrackRequestBody} message RenameTargetTrackRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameTargetTrackRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trackId = "";
                object.newName = "";
                object.currentName = "";
            }
            if (message.trackId != null && message.hasOwnProperty("trackId"))
                object.trackId = message.trackId;
            if (message.newName != null && message.hasOwnProperty("newName"))
                object.newName = message.newName;
            if (message.currentName != null && message.hasOwnProperty("currentName"))
                object.currentName = message.currentName;
            return object;
        };

        /**
         * Converts this RenameTargetTrackRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameTargetTrackRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RenameTargetTrackRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RenameTargetTrackRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RenameTargetTrackRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RenameTargetTrackRequestBody";
        };

        return RenameTargetTrackRequestBody;
    })();

    /**
     * Exported clips format.
     * @name ptsl.ExportFormat
     * @enum {number}
     * @property {number} EFormat_Unknown=0 EFormat_Unknown value
     * @property {number} EF_None=1 * @deprecated ptsl::ExportFormat::EF_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFormat::EFormat_None
     * @property {number} EFormat_None=1 EFormat_None value
     * @property {number} EF_Mono=2 * @deprecated ptsl::ExportFormat::EF_Mono is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFormat::EFormat_Mono
     * @property {number} EFormat_Mono=2 EFormat_Mono value
     * @property {number} EF_MultipleMono=3 * @deprecated ptsl::ExportFormat::EF_MultipleMono is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFormat::EFormat_MultipleMono
     * @property {number} EFormat_MultipleMono=3 EFormat_MultipleMono value
     * @property {number} EF_Interleaved=4 * @deprecated ptsl::ExportFormat::EF_Interleaved is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFormat::EFormat_Interleaved
     * @property {number} EFormat_Interleaved=4 EFormat_Interleaved value
     */
    ptsl.ExportFormat = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EFormat_Unknown"] = 0;
        values[valuesById[1] = "EF_None"] = 1;
        values["EFormat_None"] = 1;
        values[valuesById[2] = "EF_Mono"] = 2;
        values["EFormat_Mono"] = 2;
        values[valuesById[3] = "EF_MultipleMono"] = 3;
        values["EFormat_MultipleMono"] = 3;
        values[valuesById[4] = "EF_Interleaved"] = 4;
        values["EFormat_Interleaved"] = 4;
        return values;
    })();

    /**
     * The types of files which the clips will be exported to.
     * @name ptsl.ExportFileType
     * @enum {number}
     * @property {number} EFType_Unknown=0 EFType_Unknown value
     * @property {number} WAV=1 * @deprecated ptsl::ExportFileType::WAV is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFileType::EFType_WAV
     * @property {number} EFType_WAV=1 EFType_WAV value
     * @property {number} AIFF=2 * @deprecated ptsl::ExportFileType::AIFF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFileType::EFType_AIFF
     * @property {number} EFType_AIFF=2 EFType_AIFF value
     * @property {number} MXF=3 * @deprecated ptsl::ExportFileType::MXF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFileType::EFType_MXF
     * @property {number} EFType_MXF=3 EFType_MXF value
     * @property {number} MP3=4 * @deprecated ptsl::ExportFileType::MP3 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFileType::EFType_MP3
     * @property {number} EFType_MP3=4 EFType_MP3 value
     * @property {number} QuickTime=5 * @deprecated ptsl::ExportFileType::QuickTime is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportFileType::EFType_QuickTime
     * @property {number} EFType_QuickTime=5 EFType_QuickTime value
     */
    ptsl.ExportFileType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EFType_Unknown"] = 0;
        values[valuesById[1] = "WAV"] = 1;
        values["EFType_WAV"] = 1;
        values[valuesById[2] = "AIFF"] = 2;
        values["EFType_AIFF"] = 2;
        values[valuesById[3] = "MXF"] = 3;
        values["EFType_MXF"] = 3;
        values[valuesById[4] = "MP3"] = 4;
        values["EFType_MP3"] = 4;
        values[valuesById[5] = "QuickTime"] = 5;
        values["EFType_QuickTime"] = 5;
        return values;
    })();

    /**
     * Available bit depth for exported file.
     * @name ptsl.BitDepth
     * @enum {number}
     * @property {number} BDepth_Unknown=0 BDepth_Unknown value
     * @property {number} Bit_None=1 * @deprecated ptsl::BitDepth::Bit_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::BitDepth::BDepth_None
     * @property {number} BDepth_None=1 BDepth_None value
     * @property {number} Bit16=2 * @deprecated ptsl::BitDepth::Bit16 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::BitDepth::BDepth_16
     * @property {number} BDepth_16=2 BDepth_16 value
     * @property {number} Bit24=3 * @deprecated ptsl::BitDepth::Bit24 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::BitDepth::BDepth_24
     * @property {number} BDepth_24=3 BDepth_24 value
     * @property {number} Bit32Float=4 * @deprecated ptsl::BitDepth::Bit32Float is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::BitDepth::BDepth_32Float
     * @property {number} BDepth_32Float=4 BDepth_32Float value
     */
    ptsl.BitDepth = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BDepth_Unknown"] = 0;
        values[valuesById[1] = "Bit_None"] = 1;
        values["BDepth_None"] = 1;
        values[valuesById[2] = "Bit16"] = 2;
        values["BDepth_16"] = 2;
        values[valuesById[3] = "Bit24"] = 3;
        values["BDepth_24"] = 3;
        values[valuesById[4] = "Bit32Float"] = 4;
        values["BDepth_32Float"] = 4;
        return values;
    })();

    /**
     * Types of possible duplicate names resolution.
     * @name ptsl.ResolveDuplicateNamesBy
     * @enum {number}
     * @property {number} RDNBy_Unknown=0 RDNBy_Unknown value
     * @property {number} AutoRenaming=1 * @deprecated ptsl::ResolveDuplicateNamesBy::AutoRenaming is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ResolveDuplicateNamesBy::RDNBy_AutoRenaming
     * @property {number} RDNBy_AutoRenaming=1 RDNBy_AutoRenaming value
     * @property {number} ReplacingWithNewFiles=2 * @deprecated ptsl::ResolveDuplicateNamesBy::ReplacingWithNewFiles is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ResolveDuplicateNamesBy::RDNBy_ReplacingWithNewFiles
     * @property {number} RDNBy_ReplacingWithNewFiles=2 RDNBy_ReplacingWithNewFiles value
     */
    ptsl.ResolveDuplicateNamesBy = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RDNBy_Unknown"] = 0;
        values[valuesById[1] = "AutoRenaming"] = 1;
        values["RDNBy_AutoRenaming"] = 1;
        values[valuesById[2] = "ReplacingWithNewFiles"] = 2;
        values["RDNBy_ReplacingWithNewFiles"] = 2;
        return values;
    })();

    ptsl.ExportClipsAsFilesRequestBody = (function() {

        /**
         * Properties of an ExportClipsAsFilesRequestBody.
         * @memberof ptsl
         * @interface IExportClipsAsFilesRequestBody
         * @property {string|null} [filePath] ExportClipsAsFilesRequestBody filePath
         * @property {ptsl.ExportFormat|null} [format] ExportClipsAsFilesRequestBody format
         * @property {ptsl.ExportFileType|null} [fileType] ExportClipsAsFilesRequestBody fileType
         * @property {ptsl.BitDepth|null} [bitDepth] ExportClipsAsFilesRequestBody bitDepth
         * @property {ptsl.ResolveDuplicateNamesBy|null} [duplicateNames] ExportClipsAsFilesRequestBody duplicateNames
         * @property {boolean|null} [enforceAvidCompatibility] ExportClipsAsFilesRequestBody enforceAvidCompatibility
         * @property {number|null} [sampleRateCustom] ExportClipsAsFilesRequestBody sampleRateCustom
         */

        /**
         * Constructs a new ExportClipsAsFilesRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExportClipsAsFiles request data.
         * @implements IExportClipsAsFilesRequestBody
         * @constructor
         * @param {ptsl.IExportClipsAsFilesRequestBody=} [properties] Properties to set
         */
        function ExportClipsAsFilesRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportClipsAsFilesRequestBody filePath.
         * @member {string} filePath
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         */
        ExportClipsAsFilesRequestBody.prototype.filePath = "";

        /**
         * ExportClipsAsFilesRequestBody format.
         * @member {ptsl.ExportFormat} format
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         */
        ExportClipsAsFilesRequestBody.prototype.format = 0;

        /**
         * ExportClipsAsFilesRequestBody fileType.
         * @member {ptsl.ExportFileType} fileType
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         */
        ExportClipsAsFilesRequestBody.prototype.fileType = 0;

        /**
         * ExportClipsAsFilesRequestBody bitDepth.
         * @member {ptsl.BitDepth} bitDepth
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         */
        ExportClipsAsFilesRequestBody.prototype.bitDepth = 0;

        /**
         * ExportClipsAsFilesRequestBody duplicateNames.
         * @member {ptsl.ResolveDuplicateNamesBy} duplicateNames
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         */
        ExportClipsAsFilesRequestBody.prototype.duplicateNames = 0;

        /**
         * ExportClipsAsFilesRequestBody enforceAvidCompatibility.
         * @member {boolean} enforceAvidCompatibility
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         */
        ExportClipsAsFilesRequestBody.prototype.enforceAvidCompatibility = false;

        /**
         * ExportClipsAsFilesRequestBody sampleRateCustom.
         * @member {number} sampleRateCustom
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         */
        ExportClipsAsFilesRequestBody.prototype.sampleRateCustom = 0;

        /**
         * Creates a new ExportClipsAsFilesRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {ptsl.IExportClipsAsFilesRequestBody=} [properties] Properties to set
         * @returns {ptsl.ExportClipsAsFilesRequestBody} ExportClipsAsFilesRequestBody instance
         */
        ExportClipsAsFilesRequestBody.create = function create(properties) {
            return new ExportClipsAsFilesRequestBody(properties);
        };

        /**
         * Encodes the specified ExportClipsAsFilesRequestBody message. Does not implicitly {@link ptsl.ExportClipsAsFilesRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {ptsl.IExportClipsAsFilesRequestBody} message ExportClipsAsFilesRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportClipsAsFilesRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.filePath);
            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.format);
            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fileType);
            if (message.bitDepth != null && Object.hasOwnProperty.call(message, "bitDepth"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bitDepth);
            if (message.duplicateNames != null && Object.hasOwnProperty.call(message, "duplicateNames"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.duplicateNames);
            if (message.enforceAvidCompatibility != null && Object.hasOwnProperty.call(message, "enforceAvidCompatibility"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.enforceAvidCompatibility);
            if (message.sampleRateCustom != null && Object.hasOwnProperty.call(message, "sampleRateCustom"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.sampleRateCustom);
            return writer;
        };

        /**
         * Encodes the specified ExportClipsAsFilesRequestBody message, length delimited. Does not implicitly {@link ptsl.ExportClipsAsFilesRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {ptsl.IExportClipsAsFilesRequestBody} message ExportClipsAsFilesRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportClipsAsFilesRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportClipsAsFilesRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExportClipsAsFilesRequestBody} ExportClipsAsFilesRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportClipsAsFilesRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExportClipsAsFilesRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.filePath = reader.string();
                        break;
                    }
                case 2: {
                        message.format = reader.int32();
                        break;
                    }
                case 3: {
                        message.fileType = reader.int32();
                        break;
                    }
                case 4: {
                        message.bitDepth = reader.int32();
                        break;
                    }
                case 5: {
                        message.duplicateNames = reader.int32();
                        break;
                    }
                case 6: {
                        message.enforceAvidCompatibility = reader.bool();
                        break;
                    }
                case 7: {
                        message.sampleRateCustom = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportClipsAsFilesRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExportClipsAsFilesRequestBody} ExportClipsAsFilesRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportClipsAsFilesRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportClipsAsFilesRequestBody message.
         * @function verify
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportClipsAsFilesRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                if (!$util.isString(message.filePath))
                    return "filePath: string expected";
            if (message.format != null && message.hasOwnProperty("format"))
                switch (message.format) {
                default:
                    return "format: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                switch (message.fileType) {
                default:
                    return "fileType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                switch (message.bitDepth) {
                default:
                    return "bitDepth: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.duplicateNames != null && message.hasOwnProperty("duplicateNames"))
                switch (message.duplicateNames) {
                default:
                    return "duplicateNames: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.enforceAvidCompatibility != null && message.hasOwnProperty("enforceAvidCompatibility"))
                if (typeof message.enforceAvidCompatibility !== "boolean")
                    return "enforceAvidCompatibility: boolean expected";
            if (message.sampleRateCustom != null && message.hasOwnProperty("sampleRateCustom"))
                if (!$util.isInteger(message.sampleRateCustom))
                    return "sampleRateCustom: integer expected";
            return null;
        };

        /**
         * Creates an ExportClipsAsFilesRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExportClipsAsFilesRequestBody} ExportClipsAsFilesRequestBody
         */
        ExportClipsAsFilesRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExportClipsAsFilesRequestBody)
                return object;
            var message = new $root.ptsl.ExportClipsAsFilesRequestBody();
            if (object.filePath != null)
                message.filePath = String(object.filePath);
            switch (object.format) {
            default:
                if (typeof object.format === "number") {
                    message.format = object.format;
                    break;
                }
                break;
            case "EFormat_Unknown":
            case 0:
                message.format = 0;
                break;
            case "EF_None":
            case 1:
                message.format = 1;
                break;
            case "EFormat_None":
            case 1:
                message.format = 1;
                break;
            case "EF_Mono":
            case 2:
                message.format = 2;
                break;
            case "EFormat_Mono":
            case 2:
                message.format = 2;
                break;
            case "EF_MultipleMono":
            case 3:
                message.format = 3;
                break;
            case "EFormat_MultipleMono":
            case 3:
                message.format = 3;
                break;
            case "EF_Interleaved":
            case 4:
                message.format = 4;
                break;
            case "EFormat_Interleaved":
            case 4:
                message.format = 4;
                break;
            }
            switch (object.fileType) {
            default:
                if (typeof object.fileType === "number") {
                    message.fileType = object.fileType;
                    break;
                }
                break;
            case "EFType_Unknown":
            case 0:
                message.fileType = 0;
                break;
            case "WAV":
            case 1:
                message.fileType = 1;
                break;
            case "EFType_WAV":
            case 1:
                message.fileType = 1;
                break;
            case "AIFF":
            case 2:
                message.fileType = 2;
                break;
            case "EFType_AIFF":
            case 2:
                message.fileType = 2;
                break;
            case "MXF":
            case 3:
                message.fileType = 3;
                break;
            case "EFType_MXF":
            case 3:
                message.fileType = 3;
                break;
            case "MP3":
            case 4:
                message.fileType = 4;
                break;
            case "EFType_MP3":
            case 4:
                message.fileType = 4;
                break;
            case "QuickTime":
            case 5:
                message.fileType = 5;
                break;
            case "EFType_QuickTime":
            case 5:
                message.fileType = 5;
                break;
            }
            switch (object.bitDepth) {
            default:
                if (typeof object.bitDepth === "number") {
                    message.bitDepth = object.bitDepth;
                    break;
                }
                break;
            case "BDepth_Unknown":
            case 0:
                message.bitDepth = 0;
                break;
            case "Bit_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "BDepth_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "Bit16":
            case 2:
                message.bitDepth = 2;
                break;
            case "BDepth_16":
            case 2:
                message.bitDepth = 2;
                break;
            case "Bit24":
            case 3:
                message.bitDepth = 3;
                break;
            case "BDepth_24":
            case 3:
                message.bitDepth = 3;
                break;
            case "Bit32Float":
            case 4:
                message.bitDepth = 4;
                break;
            case "BDepth_32Float":
            case 4:
                message.bitDepth = 4;
                break;
            }
            switch (object.duplicateNames) {
            default:
                if (typeof object.duplicateNames === "number") {
                    message.duplicateNames = object.duplicateNames;
                    break;
                }
                break;
            case "RDNBy_Unknown":
            case 0:
                message.duplicateNames = 0;
                break;
            case "AutoRenaming":
            case 1:
                message.duplicateNames = 1;
                break;
            case "RDNBy_AutoRenaming":
            case 1:
                message.duplicateNames = 1;
                break;
            case "ReplacingWithNewFiles":
            case 2:
                message.duplicateNames = 2;
                break;
            case "RDNBy_ReplacingWithNewFiles":
            case 2:
                message.duplicateNames = 2;
                break;
            }
            if (object.enforceAvidCompatibility != null)
                message.enforceAvidCompatibility = Boolean(object.enforceAvidCompatibility);
            if (object.sampleRateCustom != null)
                message.sampleRateCustom = object.sampleRateCustom | 0;
            return message;
        };

        /**
         * Creates a plain object from an ExportClipsAsFilesRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {ptsl.ExportClipsAsFilesRequestBody} message ExportClipsAsFilesRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportClipsAsFilesRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filePath = "";
                object.format = options.enums === String ? "EFormat_Unknown" : 0;
                object.fileType = options.enums === String ? "EFType_Unknown" : 0;
                object.bitDepth = options.enums === String ? "BDepth_Unknown" : 0;
                object.duplicateNames = options.enums === String ? "RDNBy_Unknown" : 0;
                object.enforceAvidCompatibility = false;
                object.sampleRateCustom = 0;
            }
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                object.filePath = message.filePath;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = options.enums === String ? $root.ptsl.ExportFormat[message.format] === undefined ? message.format : $root.ptsl.ExportFormat[message.format] : message.format;
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.ptsl.ExportFileType[message.fileType] === undefined ? message.fileType : $root.ptsl.ExportFileType[message.fileType] : message.fileType;
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                object.bitDepth = options.enums === String ? $root.ptsl.BitDepth[message.bitDepth] === undefined ? message.bitDepth : $root.ptsl.BitDepth[message.bitDepth] : message.bitDepth;
            if (message.duplicateNames != null && message.hasOwnProperty("duplicateNames"))
                object.duplicateNames = options.enums === String ? $root.ptsl.ResolveDuplicateNamesBy[message.duplicateNames] === undefined ? message.duplicateNames : $root.ptsl.ResolveDuplicateNamesBy[message.duplicateNames] : message.duplicateNames;
            if (message.enforceAvidCompatibility != null && message.hasOwnProperty("enforceAvidCompatibility"))
                object.enforceAvidCompatibility = message.enforceAvidCompatibility;
            if (message.sampleRateCustom != null && message.hasOwnProperty("sampleRateCustom"))
                object.sampleRateCustom = message.sampleRateCustom;
            return object;
        };

        /**
         * Converts this ExportClipsAsFilesRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportClipsAsFilesRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExportClipsAsFilesRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ExportClipsAsFilesRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExportClipsAsFilesRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExportClipsAsFilesRequestBody";
        };

        return ExportClipsAsFilesRequestBody;
    })();

    /**
     * The types of files which the tracks will be exported to as AAF/OMF.
     * @name ptsl.ExportAsAAFFileType
     * @enum {number}
     * @property {number} EAAFFType_Unknown=0 EAAFFType_Unknown value
     * @property {number} EAAFFType_None=1 EAAFFType_None value
     * @property {number} AAF_WAV=2 * @deprecated ptsl::ExportAsAAFFileType::AAF_WAV is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportAsAAFFileType::EAAFFType_WAV
     * @property {number} EAAFFType_WAV=2 EAAFFType_WAV value
     * @property {number} AAF_AIFF=3 * @deprecated ptsl::ExportAsAAFFileType::AAF_AIFF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportAsAAFFileType::EAAFFType_AIFF
     * @property {number} EAAFFType_AIFF=3 EAAFFType_AIFF value
     * @property {number} AAF_MXF=4 * @deprecated ptsl::ExportAsAAFFileType::AAF_MXF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportAsAAFFileType::EAAFFType_MXF
     * @property {number} EAAFFType_MXF=4 EAAFFType_MXF value
     * @property {number} AAF_Embedded=5 * @deprecated ptsl::ExportAsAAFFileType::AAF_Embedded is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ExportAsAAFFileType::EAAFFType_Embedded
     * @property {number} EAAFFType_Embedded=5 EAAFFType_Embedded value
     */
    ptsl.ExportAsAAFFileType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EAAFFType_Unknown"] = 0;
        values[valuesById[1] = "EAAFFType_None"] = 1;
        values[valuesById[2] = "AAF_WAV"] = 2;
        values["EAAFFType_WAV"] = 2;
        values[valuesById[3] = "AAF_AIFF"] = 3;
        values["EAAFFType_AIFF"] = 3;
        values[valuesById[4] = "AAF_MXF"] = 4;
        values["EAAFFType_MXF"] = 4;
        values[valuesById[5] = "AAF_Embedded"] = 5;
        values["EAAFFType_Embedded"] = 5;
        return values;
    })();

    /**
     * Available bit depth for file exported as AAF/OMF.
     * @name ptsl.AAFFileBitDepth
     * @enum {number}
     * @property {number} AAFFBDepth_Unknown=0 AAFFBDepth_Unknown value
     * @property {number} AAFFBDepth_None=1 AAFFBDepth_None value
     * @property {number} AAF_Bit16=2 * @deprecated ptsl::AAFFileBitDepth::AAF_Bit16 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AAFFileBitDepth::AAFFBDepth_Bit16
     * @property {number} AAFFBDepth_Bit16=2 AAFFBDepth_Bit16 value
     * @property {number} AAF_Bit24=3 * @deprecated ptsl::AAFFileBitDepth::AAF_Bit24 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AAFFileBitDepth::AAFFBDepth_Bit24
     * @property {number} AAFFBDepth_Bit24=3 AAFFBDepth_Bit24 value
     */
    ptsl.AAFFileBitDepth = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AAFFBDepth_Unknown"] = 0;
        values[valuesById[1] = "AAFFBDepth_None"] = 1;
        values[valuesById[2] = "AAF_Bit16"] = 2;
        values["AAFFBDepth_Bit16"] = 2;
        values[valuesById[3] = "AAF_Bit24"] = 3;
        values["AAFFBDepth_Bit24"] = 3;
        return values;
    })();

    /**
     * Available options for copying media while exporting tracks as AAF/OMF files.
     * @name ptsl.CopyOption
     * @enum {number}
     * @property {number} COption_Unknown=0 COption_Unknown value
     * @property {number} ConsolidateFromSourceMedia=1 * @deprecated ptsl::CopyOption::ConsolidateFromSourceMedia is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::CopyOption::COption_ConsolidateFromSourceMedia
     * @property {number} COption_ConsolidateFromSourceMedia=1 COption_ConsolidateFromSourceMedia value
     * @property {number} CopyFromSourceMedia=2 * @deprecated ptsl::CopyOption::CopyFromSourceMedia is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::CopyOption::COption_CopyFromSourceMedia
     * @property {number} COption_CopyFromSourceMedia=2 COption_CopyFromSourceMedia value
     * @property {number} LinkFromSourceMedia=3 * @deprecated ptsl::CopyOption::LinkFromSourceMedia is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::CopyOption::COption_LinkFromSourceMedia
     * @property {number} COption_LinkFromSourceMedia=3 COption_LinkFromSourceMedia value
     */
    ptsl.CopyOption = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "COption_Unknown"] = 0;
        values[valuesById[1] = "ConsolidateFromSourceMedia"] = 1;
        values["COption_ConsolidateFromSourceMedia"] = 1;
        values[valuesById[2] = "CopyFromSourceMedia"] = 2;
        values["COption_CopyFromSourceMedia"] = 2;
        values[valuesById[3] = "LinkFromSourceMedia"] = 3;
        values["COption_LinkFromSourceMedia"] = 3;
        return values;
    })();

    ptsl.ExportSelectedTracksAsAAFOMFRequestBody = (function() {

        /**
         * Properties of an ExportSelectedTracksAsAAFOMFRequestBody.
         * @memberof ptsl
         * @interface IExportSelectedTracksAsAAFOMFRequestBody
         * @property {ptsl.ExportAsAAFFileType|null} [fileType] ExportSelectedTracksAsAAFOMFRequestBody fileType
         * @property {ptsl.AAFFileBitDepth|null} [bitDepth] ExportSelectedTracksAsAAFOMFRequestBody bitDepth
         * @property {ptsl.CopyOption|null} [copyOption] ExportSelectedTracksAsAAFOMFRequestBody copyOption
         * @property {boolean|null} [enforceMediaComposerCompatibility] ExportSelectedTracksAsAAFOMFRequestBody enforceMediaComposerCompatibility
         * @property {boolean|null} [quantizeEditsToFrameBoundaries] ExportSelectedTracksAsAAFOMFRequestBody quantizeEditsToFrameBoundaries
         * @property {boolean|null} [exportStereoAsMultichannel] ExportSelectedTracksAsAAFOMFRequestBody exportStereoAsMultichannel
         * @property {string|null} [containerFileName] ExportSelectedTracksAsAAFOMFRequestBody containerFileName
         * @property {string|null} [containerFileLocation] ExportSelectedTracksAsAAFOMFRequestBody containerFileLocation
         * @property {string|null} [assetFileLocation] ExportSelectedTracksAsAAFOMFRequestBody assetFileLocation
         * @property {string|null} [comments] ExportSelectedTracksAsAAFOMFRequestBody comments
         * @property {string|null} [sequenceName] ExportSelectedTracksAsAAFOMFRequestBody sequenceName
         */

        /**
         * Constructs a new ExportSelectedTracksAsAAFOMFRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExportSelectedTracksAsAAFOMF request data.
         * @implements IExportSelectedTracksAsAAFOMFRequestBody
         * @constructor
         * @param {ptsl.IExportSelectedTracksAsAAFOMFRequestBody=} [properties] Properties to set
         */
        function ExportSelectedTracksAsAAFOMFRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody fileType.
         * @member {ptsl.ExportAsAAFFileType} fileType
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.fileType = 0;

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody bitDepth.
         * @member {ptsl.AAFFileBitDepth} bitDepth
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.bitDepth = 0;

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody copyOption.
         * @member {ptsl.CopyOption} copyOption
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.copyOption = 0;

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody enforceMediaComposerCompatibility.
         * @member {boolean} enforceMediaComposerCompatibility
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.enforceMediaComposerCompatibility = false;

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody quantizeEditsToFrameBoundaries.
         * @member {boolean} quantizeEditsToFrameBoundaries
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.quantizeEditsToFrameBoundaries = false;

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody exportStereoAsMultichannel.
         * @member {boolean} exportStereoAsMultichannel
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.exportStereoAsMultichannel = false;

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody containerFileName.
         * @member {string} containerFileName
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.containerFileName = "";

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody containerFileLocation.
         * @member {string} containerFileLocation
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.containerFileLocation = "";

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody assetFileLocation.
         * @member {string} assetFileLocation
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.assetFileLocation = "";

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody comments.
         * @member {string} comments
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.comments = "";

        /**
         * ExportSelectedTracksAsAAFOMFRequestBody sequenceName.
         * @member {string} sequenceName
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.sequenceName = "";

        /**
         * Creates a new ExportSelectedTracksAsAAFOMFRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {ptsl.IExportSelectedTracksAsAAFOMFRequestBody=} [properties] Properties to set
         * @returns {ptsl.ExportSelectedTracksAsAAFOMFRequestBody} ExportSelectedTracksAsAAFOMFRequestBody instance
         */
        ExportSelectedTracksAsAAFOMFRequestBody.create = function create(properties) {
            return new ExportSelectedTracksAsAAFOMFRequestBody(properties);
        };

        /**
         * Encodes the specified ExportSelectedTracksAsAAFOMFRequestBody message. Does not implicitly {@link ptsl.ExportSelectedTracksAsAAFOMFRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {ptsl.IExportSelectedTracksAsAAFOMFRequestBody} message ExportSelectedTracksAsAAFOMFRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportSelectedTracksAsAAFOMFRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fileType);
            if (message.bitDepth != null && Object.hasOwnProperty.call(message, "bitDepth"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bitDepth);
            if (message.copyOption != null && Object.hasOwnProperty.call(message, "copyOption"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.copyOption);
            if (message.enforceMediaComposerCompatibility != null && Object.hasOwnProperty.call(message, "enforceMediaComposerCompatibility"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.enforceMediaComposerCompatibility);
            if (message.quantizeEditsToFrameBoundaries != null && Object.hasOwnProperty.call(message, "quantizeEditsToFrameBoundaries"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.quantizeEditsToFrameBoundaries);
            if (message.exportStereoAsMultichannel != null && Object.hasOwnProperty.call(message, "exportStereoAsMultichannel"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.exportStereoAsMultichannel);
            if (message.containerFileName != null && Object.hasOwnProperty.call(message, "containerFileName"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.containerFileName);
            if (message.containerFileLocation != null && Object.hasOwnProperty.call(message, "containerFileLocation"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.containerFileLocation);
            if (message.assetFileLocation != null && Object.hasOwnProperty.call(message, "assetFileLocation"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.assetFileLocation);
            if (message.comments != null && Object.hasOwnProperty.call(message, "comments"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.comments);
            if (message.sequenceName != null && Object.hasOwnProperty.call(message, "sequenceName"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.sequenceName);
            return writer;
        };

        /**
         * Encodes the specified ExportSelectedTracksAsAAFOMFRequestBody message, length delimited. Does not implicitly {@link ptsl.ExportSelectedTracksAsAAFOMFRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {ptsl.IExportSelectedTracksAsAAFOMFRequestBody} message ExportSelectedTracksAsAAFOMFRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportSelectedTracksAsAAFOMFRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportSelectedTracksAsAAFOMFRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExportSelectedTracksAsAAFOMFRequestBody} ExportSelectedTracksAsAAFOMFRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportSelectedTracksAsAAFOMFRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExportSelectedTracksAsAAFOMFRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 2: {
                        message.fileType = reader.int32();
                        break;
                    }
                case 3: {
                        message.bitDepth = reader.int32();
                        break;
                    }
                case 4: {
                        message.copyOption = reader.int32();
                        break;
                    }
                case 5: {
                        message.enforceMediaComposerCompatibility = reader.bool();
                        break;
                    }
                case 6: {
                        message.quantizeEditsToFrameBoundaries = reader.bool();
                        break;
                    }
                case 7: {
                        message.exportStereoAsMultichannel = reader.bool();
                        break;
                    }
                case 9: {
                        message.containerFileName = reader.string();
                        break;
                    }
                case 10: {
                        message.containerFileLocation = reader.string();
                        break;
                    }
                case 11: {
                        message.assetFileLocation = reader.string();
                        break;
                    }
                case 12: {
                        message.comments = reader.string();
                        break;
                    }
                case 13: {
                        message.sequenceName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportSelectedTracksAsAAFOMFRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExportSelectedTracksAsAAFOMFRequestBody} ExportSelectedTracksAsAAFOMFRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportSelectedTracksAsAAFOMFRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportSelectedTracksAsAAFOMFRequestBody message.
         * @function verify
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportSelectedTracksAsAAFOMFRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                switch (message.fileType) {
                default:
                    return "fileType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                switch (message.bitDepth) {
                default:
                    return "bitDepth: enum value expected";
                case 0:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.copyOption != null && message.hasOwnProperty("copyOption"))
                switch (message.copyOption) {
                default:
                    return "copyOption: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.enforceMediaComposerCompatibility != null && message.hasOwnProperty("enforceMediaComposerCompatibility"))
                if (typeof message.enforceMediaComposerCompatibility !== "boolean")
                    return "enforceMediaComposerCompatibility: boolean expected";
            if (message.quantizeEditsToFrameBoundaries != null && message.hasOwnProperty("quantizeEditsToFrameBoundaries"))
                if (typeof message.quantizeEditsToFrameBoundaries !== "boolean")
                    return "quantizeEditsToFrameBoundaries: boolean expected";
            if (message.exportStereoAsMultichannel != null && message.hasOwnProperty("exportStereoAsMultichannel"))
                if (typeof message.exportStereoAsMultichannel !== "boolean")
                    return "exportStereoAsMultichannel: boolean expected";
            if (message.containerFileName != null && message.hasOwnProperty("containerFileName"))
                if (!$util.isString(message.containerFileName))
                    return "containerFileName: string expected";
            if (message.containerFileLocation != null && message.hasOwnProperty("containerFileLocation"))
                if (!$util.isString(message.containerFileLocation))
                    return "containerFileLocation: string expected";
            if (message.assetFileLocation != null && message.hasOwnProperty("assetFileLocation"))
                if (!$util.isString(message.assetFileLocation))
                    return "assetFileLocation: string expected";
            if (message.comments != null && message.hasOwnProperty("comments"))
                if (!$util.isString(message.comments))
                    return "comments: string expected";
            if (message.sequenceName != null && message.hasOwnProperty("sequenceName"))
                if (!$util.isString(message.sequenceName))
                    return "sequenceName: string expected";
            return null;
        };

        /**
         * Creates an ExportSelectedTracksAsAAFOMFRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExportSelectedTracksAsAAFOMFRequestBody} ExportSelectedTracksAsAAFOMFRequestBody
         */
        ExportSelectedTracksAsAAFOMFRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExportSelectedTracksAsAAFOMFRequestBody)
                return object;
            var message = new $root.ptsl.ExportSelectedTracksAsAAFOMFRequestBody();
            switch (object.fileType) {
            default:
                if (typeof object.fileType === "number") {
                    message.fileType = object.fileType;
                    break;
                }
                break;
            case "EAAFFType_Unknown":
            case 0:
                message.fileType = 0;
                break;
            case "EAAFFType_None":
            case 1:
                message.fileType = 1;
                break;
            case "AAF_WAV":
            case 2:
                message.fileType = 2;
                break;
            case "EAAFFType_WAV":
            case 2:
                message.fileType = 2;
                break;
            case "AAF_AIFF":
            case 3:
                message.fileType = 3;
                break;
            case "EAAFFType_AIFF":
            case 3:
                message.fileType = 3;
                break;
            case "AAF_MXF":
            case 4:
                message.fileType = 4;
                break;
            case "EAAFFType_MXF":
            case 4:
                message.fileType = 4;
                break;
            case "AAF_Embedded":
            case 5:
                message.fileType = 5;
                break;
            case "EAAFFType_Embedded":
            case 5:
                message.fileType = 5;
                break;
            }
            switch (object.bitDepth) {
            default:
                if (typeof object.bitDepth === "number") {
                    message.bitDepth = object.bitDepth;
                    break;
                }
                break;
            case "AAFFBDepth_Unknown":
            case 0:
                message.bitDepth = 0;
                break;
            case "AAFFBDepth_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "AAF_Bit16":
            case 2:
                message.bitDepth = 2;
                break;
            case "AAFFBDepth_Bit16":
            case 2:
                message.bitDepth = 2;
                break;
            case "AAF_Bit24":
            case 3:
                message.bitDepth = 3;
                break;
            case "AAFFBDepth_Bit24":
            case 3:
                message.bitDepth = 3;
                break;
            }
            switch (object.copyOption) {
            default:
                if (typeof object.copyOption === "number") {
                    message.copyOption = object.copyOption;
                    break;
                }
                break;
            case "COption_Unknown":
            case 0:
                message.copyOption = 0;
                break;
            case "ConsolidateFromSourceMedia":
            case 1:
                message.copyOption = 1;
                break;
            case "COption_ConsolidateFromSourceMedia":
            case 1:
                message.copyOption = 1;
                break;
            case "CopyFromSourceMedia":
            case 2:
                message.copyOption = 2;
                break;
            case "COption_CopyFromSourceMedia":
            case 2:
                message.copyOption = 2;
                break;
            case "LinkFromSourceMedia":
            case 3:
                message.copyOption = 3;
                break;
            case "COption_LinkFromSourceMedia":
            case 3:
                message.copyOption = 3;
                break;
            }
            if (object.enforceMediaComposerCompatibility != null)
                message.enforceMediaComposerCompatibility = Boolean(object.enforceMediaComposerCompatibility);
            if (object.quantizeEditsToFrameBoundaries != null)
                message.quantizeEditsToFrameBoundaries = Boolean(object.quantizeEditsToFrameBoundaries);
            if (object.exportStereoAsMultichannel != null)
                message.exportStereoAsMultichannel = Boolean(object.exportStereoAsMultichannel);
            if (object.containerFileName != null)
                message.containerFileName = String(object.containerFileName);
            if (object.containerFileLocation != null)
                message.containerFileLocation = String(object.containerFileLocation);
            if (object.assetFileLocation != null)
                message.assetFileLocation = String(object.assetFileLocation);
            if (object.comments != null)
                message.comments = String(object.comments);
            if (object.sequenceName != null)
                message.sequenceName = String(object.sequenceName);
            return message;
        };

        /**
         * Creates a plain object from an ExportSelectedTracksAsAAFOMFRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {ptsl.ExportSelectedTracksAsAAFOMFRequestBody} message ExportSelectedTracksAsAAFOMFRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportSelectedTracksAsAAFOMFRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fileType = options.enums === String ? "EAAFFType_Unknown" : 0;
                object.bitDepth = options.enums === String ? "AAFFBDepth_Unknown" : 0;
                object.copyOption = options.enums === String ? "COption_Unknown" : 0;
                object.enforceMediaComposerCompatibility = false;
                object.quantizeEditsToFrameBoundaries = false;
                object.exportStereoAsMultichannel = false;
                object.containerFileName = "";
                object.containerFileLocation = "";
                object.assetFileLocation = "";
                object.comments = "";
                object.sequenceName = "";
            }
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.ptsl.ExportAsAAFFileType[message.fileType] === undefined ? message.fileType : $root.ptsl.ExportAsAAFFileType[message.fileType] : message.fileType;
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                object.bitDepth = options.enums === String ? $root.ptsl.AAFFileBitDepth[message.bitDepth] === undefined ? message.bitDepth : $root.ptsl.AAFFileBitDepth[message.bitDepth] : message.bitDepth;
            if (message.copyOption != null && message.hasOwnProperty("copyOption"))
                object.copyOption = options.enums === String ? $root.ptsl.CopyOption[message.copyOption] === undefined ? message.copyOption : $root.ptsl.CopyOption[message.copyOption] : message.copyOption;
            if (message.enforceMediaComposerCompatibility != null && message.hasOwnProperty("enforceMediaComposerCompatibility"))
                object.enforceMediaComposerCompatibility = message.enforceMediaComposerCompatibility;
            if (message.quantizeEditsToFrameBoundaries != null && message.hasOwnProperty("quantizeEditsToFrameBoundaries"))
                object.quantizeEditsToFrameBoundaries = message.quantizeEditsToFrameBoundaries;
            if (message.exportStereoAsMultichannel != null && message.hasOwnProperty("exportStereoAsMultichannel"))
                object.exportStereoAsMultichannel = message.exportStereoAsMultichannel;
            if (message.containerFileName != null && message.hasOwnProperty("containerFileName"))
                object.containerFileName = message.containerFileName;
            if (message.containerFileLocation != null && message.hasOwnProperty("containerFileLocation"))
                object.containerFileLocation = message.containerFileLocation;
            if (message.assetFileLocation != null && message.hasOwnProperty("assetFileLocation"))
                object.assetFileLocation = message.assetFileLocation;
            if (message.comments != null && message.hasOwnProperty("comments"))
                object.comments = message.comments;
            if (message.sequenceName != null && message.hasOwnProperty("sequenceName"))
                object.sequenceName = message.sequenceName;
            return object;
        };

        /**
         * Converts this ExportSelectedTracksAsAAFOMFRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportSelectedTracksAsAAFOMFRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExportSelectedTracksAsAAFOMFRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ExportSelectedTracksAsAAFOMFRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExportSelectedTracksAsAAFOMFRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExportSelectedTracksAsAAFOMFRequestBody";
        };

        return ExportSelectedTracksAsAAFOMFRequestBody;
    })();

    ptsl.RefreshTargetAudioFilesRequestBody = (function() {

        /**
         * Properties of a RefreshTargetAudioFilesRequestBody.
         * @memberof ptsl
         * @interface IRefreshTargetAudioFilesRequestBody
         * @property {Array.<string>|null} [fileList] RefreshTargetAudioFilesRequestBody fileList
         */

        /**
         * Constructs a new RefreshTargetAudioFilesRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes RefreshTargetAudioFiles request data.
         * @implements IRefreshTargetAudioFilesRequestBody
         * @constructor
         * @param {ptsl.IRefreshTargetAudioFilesRequestBody=} [properties] Properties to set
         */
        function RefreshTargetAudioFilesRequestBody(properties) {
            this.fileList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RefreshTargetAudioFilesRequestBody fileList.
         * @member {Array.<string>} fileList
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @instance
         */
        RefreshTargetAudioFilesRequestBody.prototype.fileList = $util.emptyArray;

        /**
         * Creates a new RefreshTargetAudioFilesRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {ptsl.IRefreshTargetAudioFilesRequestBody=} [properties] Properties to set
         * @returns {ptsl.RefreshTargetAudioFilesRequestBody} RefreshTargetAudioFilesRequestBody instance
         */
        RefreshTargetAudioFilesRequestBody.create = function create(properties) {
            return new RefreshTargetAudioFilesRequestBody(properties);
        };

        /**
         * Encodes the specified RefreshTargetAudioFilesRequestBody message. Does not implicitly {@link ptsl.RefreshTargetAudioFilesRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {ptsl.IRefreshTargetAudioFilesRequestBody} message RefreshTargetAudioFilesRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshTargetAudioFilesRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileList != null && message.fileList.length)
                for (var i = 0; i < message.fileList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileList[i]);
            return writer;
        };

        /**
         * Encodes the specified RefreshTargetAudioFilesRequestBody message, length delimited. Does not implicitly {@link ptsl.RefreshTargetAudioFilesRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {ptsl.IRefreshTargetAudioFilesRequestBody} message RefreshTargetAudioFilesRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshTargetAudioFilesRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefreshTargetAudioFilesRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RefreshTargetAudioFilesRequestBody} RefreshTargetAudioFilesRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshTargetAudioFilesRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RefreshTargetAudioFilesRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.fileList && message.fileList.length))
                            message.fileList = [];
                        message.fileList.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshTargetAudioFilesRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RefreshTargetAudioFilesRequestBody} RefreshTargetAudioFilesRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshTargetAudioFilesRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefreshTargetAudioFilesRequestBody message.
         * @function verify
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefreshTargetAudioFilesRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileList != null && message.hasOwnProperty("fileList")) {
                if (!Array.isArray(message.fileList))
                    return "fileList: array expected";
                for (var i = 0; i < message.fileList.length; ++i)
                    if (!$util.isString(message.fileList[i]))
                        return "fileList: string[] expected";
            }
            return null;
        };

        /**
         * Creates a RefreshTargetAudioFilesRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RefreshTargetAudioFilesRequestBody} RefreshTargetAudioFilesRequestBody
         */
        RefreshTargetAudioFilesRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RefreshTargetAudioFilesRequestBody)
                return object;
            var message = new $root.ptsl.RefreshTargetAudioFilesRequestBody();
            if (object.fileList) {
                if (!Array.isArray(object.fileList))
                    throw TypeError(".ptsl.RefreshTargetAudioFilesRequestBody.fileList: array expected");
                message.fileList = [];
                for (var i = 0; i < object.fileList.length; ++i)
                    message.fileList[i] = String(object.fileList[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a RefreshTargetAudioFilesRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {ptsl.RefreshTargetAudioFilesRequestBody} message RefreshTargetAudioFilesRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RefreshTargetAudioFilesRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fileList = [];
            if (message.fileList && message.fileList.length) {
                object.fileList = [];
                for (var j = 0; j < message.fileList.length; ++j)
                    object.fileList[j] = message.fileList[j];
            }
            return object;
        };

        /**
         * Converts this RefreshTargetAudioFilesRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RefreshTargetAudioFilesRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RefreshTargetAudioFilesRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RefreshTargetAudioFilesRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RefreshTargetAudioFilesRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RefreshTargetAudioFilesRequestBody";
        };

        return RefreshTargetAudioFilesRequestBody;
    })();

    ptsl.RefreshTargetAudioFilesResponseBody = (function() {

        /**
         * Properties of a RefreshTargetAudioFilesResponseBody.
         * @memberof ptsl
         * @interface IRefreshTargetAudioFilesResponseBody
         * @property {number|null} [successCount] RefreshTargetAudioFilesResponseBody successCount
         * @property {number|null} [failureCount] RefreshTargetAudioFilesResponseBody failureCount
         * @property {Array.<string>|null} [failureList] RefreshTargetAudioFilesResponseBody failureList
         */

        /**
         * Constructs a new RefreshTargetAudioFilesResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes RefreshTargetAudioFiles response data.
         * @implements IRefreshTargetAudioFilesResponseBody
         * @constructor
         * @param {ptsl.IRefreshTargetAudioFilesResponseBody=} [properties] Properties to set
         */
        function RefreshTargetAudioFilesResponseBody(properties) {
            this.failureList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RefreshTargetAudioFilesResponseBody successCount.
         * @member {number} successCount
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @instance
         */
        RefreshTargetAudioFilesResponseBody.prototype.successCount = 0;

        /**
         * RefreshTargetAudioFilesResponseBody failureCount.
         * @member {number} failureCount
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @instance
         */
        RefreshTargetAudioFilesResponseBody.prototype.failureCount = 0;

        /**
         * RefreshTargetAudioFilesResponseBody failureList.
         * @member {Array.<string>} failureList
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @instance
         */
        RefreshTargetAudioFilesResponseBody.prototype.failureList = $util.emptyArray;

        /**
         * Creates a new RefreshTargetAudioFilesResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {ptsl.IRefreshTargetAudioFilesResponseBody=} [properties] Properties to set
         * @returns {ptsl.RefreshTargetAudioFilesResponseBody} RefreshTargetAudioFilesResponseBody instance
         */
        RefreshTargetAudioFilesResponseBody.create = function create(properties) {
            return new RefreshTargetAudioFilesResponseBody(properties);
        };

        /**
         * Encodes the specified RefreshTargetAudioFilesResponseBody message. Does not implicitly {@link ptsl.RefreshTargetAudioFilesResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {ptsl.IRefreshTargetAudioFilesResponseBody} message RefreshTargetAudioFilesResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshTargetAudioFilesResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.successCount != null && Object.hasOwnProperty.call(message, "successCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.successCount);
            if (message.failureCount != null && Object.hasOwnProperty.call(message, "failureCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.failureCount);
            if (message.failureList != null && message.failureList.length)
                for (var i = 0; i < message.failureList.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.failureList[i]);
            return writer;
        };

        /**
         * Encodes the specified RefreshTargetAudioFilesResponseBody message, length delimited. Does not implicitly {@link ptsl.RefreshTargetAudioFilesResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {ptsl.IRefreshTargetAudioFilesResponseBody} message RefreshTargetAudioFilesResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshTargetAudioFilesResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefreshTargetAudioFilesResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RefreshTargetAudioFilesResponseBody} RefreshTargetAudioFilesResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshTargetAudioFilesResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RefreshTargetAudioFilesResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.successCount = reader.int32();
                        break;
                    }
                case 2: {
                        message.failureCount = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.failureList && message.failureList.length))
                            message.failureList = [];
                        message.failureList.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshTargetAudioFilesResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RefreshTargetAudioFilesResponseBody} RefreshTargetAudioFilesResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshTargetAudioFilesResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefreshTargetAudioFilesResponseBody message.
         * @function verify
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefreshTargetAudioFilesResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.successCount != null && message.hasOwnProperty("successCount"))
                if (!$util.isInteger(message.successCount))
                    return "successCount: integer expected";
            if (message.failureCount != null && message.hasOwnProperty("failureCount"))
                if (!$util.isInteger(message.failureCount))
                    return "failureCount: integer expected";
            if (message.failureList != null && message.hasOwnProperty("failureList")) {
                if (!Array.isArray(message.failureList))
                    return "failureList: array expected";
                for (var i = 0; i < message.failureList.length; ++i)
                    if (!$util.isString(message.failureList[i]))
                        return "failureList: string[] expected";
            }
            return null;
        };

        /**
         * Creates a RefreshTargetAudioFilesResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RefreshTargetAudioFilesResponseBody} RefreshTargetAudioFilesResponseBody
         */
        RefreshTargetAudioFilesResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RefreshTargetAudioFilesResponseBody)
                return object;
            var message = new $root.ptsl.RefreshTargetAudioFilesResponseBody();
            if (object.successCount != null)
                message.successCount = object.successCount | 0;
            if (object.failureCount != null)
                message.failureCount = object.failureCount | 0;
            if (object.failureList) {
                if (!Array.isArray(object.failureList))
                    throw TypeError(".ptsl.RefreshTargetAudioFilesResponseBody.failureList: array expected");
                message.failureList = [];
                for (var i = 0; i < object.failureList.length; ++i)
                    message.failureList[i] = String(object.failureList[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a RefreshTargetAudioFilesResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {ptsl.RefreshTargetAudioFilesResponseBody} message RefreshTargetAudioFilesResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RefreshTargetAudioFilesResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.failureList = [];
            if (options.defaults) {
                object.successCount = 0;
                object.failureCount = 0;
            }
            if (message.successCount != null && message.hasOwnProperty("successCount"))
                object.successCount = message.successCount;
            if (message.failureCount != null && message.hasOwnProperty("failureCount"))
                object.failureCount = message.failureCount;
            if (message.failureList && message.failureList.length) {
                object.failureList = [];
                for (var j = 0; j < message.failureList.length; ++j)
                    object.failureList[j] = message.failureList[j];
            }
            return object;
        };

        /**
         * Converts this RefreshTargetAudioFilesResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RefreshTargetAudioFilesResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RefreshTargetAudioFilesResponseBody
         * @function getTypeUrl
         * @memberof ptsl.RefreshTargetAudioFilesResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RefreshTargetAudioFilesResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RefreshTargetAudioFilesResponseBody";
        };

        return RefreshTargetAudioFilesResponseBody;
    })();

    /**
     * Types of the filters which can be applied for session file gathering.
     * @name ptsl.FileLocationTypeFilter
     * @enum {number}
     * @property {number} FLTFilter_Unknown=0 FLTFilter_Unknown value
     * @property {number} All_Files=1 * @deprecated ptsl::FileLocationTypeFilter::All_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_AllFiles
     * @property {number} FLTFilter_AllFiles=1 FLTFilter_AllFiles value
     * @property {number} OnTimeline_Files=2 * @deprecated ptsl::FileLocationTypeFilter::OnTimeline_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_OnTimelineFiles
     * @property {number} FLTFilter_OnTimelineFiles=2 FLTFilter_OnTimelineFiles value
     * @property {number} NotOnTimeline_Files=3 * @deprecated ptsl::FileLocationTypeFilter::NotOnTimeline_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_NotOnTimelineFiles
     * @property {number} FLTFilter_NotOnTimelineFiles=3 FLTFilter_NotOnTimelineFiles value
     * @property {number} Online_Files=4 * @deprecated ptsl::FileLocationTypeFilter::Online_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_OnlineFiles
     * @property {number} FLTFilter_OnlineFiles=4 FLTFilter_OnlineFiles value
     * @property {number} Offline_Files=5 * @deprecated ptsl::FileLocationTypeFilter::Offline_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_OfflineFiles
     * @property {number} FLTFilter_OfflineFiles=5 FLTFilter_OfflineFiles value
     * @property {number} Audio_Files=6 * @deprecated ptsl::FileLocationTypeFilter::Audio_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_AudioFiles
     * @property {number} FLTFilter_AudioFiles=6 FLTFilter_AudioFiles value
     * @property {number} Video_Files=7 * @deprecated ptsl::FileLocationTypeFilter::Video_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_VideoFiles
     * @property {number} FLTFilter_VideoFiles=7 FLTFilter_VideoFiles value
     * @property {number} Rendered_Files=8 * @deprecated ptsl::FileLocationTypeFilter::Rendered_Files is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_RenderedFiles
     * @property {number} FLTFilter_RenderedFiles=8 FLTFilter_RenderedFiles value
     * @property {number} SelectedClipsTimeline=101 * @deprecated ptsl::FileLocationTypeFilter::SelectedClipsTimeline is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_SelectedClipsTimeline
     * @property {number} FLTFilter_SelectedClipsTimeline=101 FLTFilter_SelectedClipsTimeline value
     * @property {number} SelectedClipsClipsList=102 * @deprecated ptsl::FileLocationTypeFilter::SelectedClipsClipsList is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FileLocationTypeFilter::FLTFilter_SelectedClipsClipsList
     * @property {number} FLTFilter_SelectedClipsClipsList=102 FLTFilter_SelectedClipsClipsList value
     */
    ptsl.FileLocationTypeFilter = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FLTFilter_Unknown"] = 0;
        values[valuesById[1] = "All_Files"] = 1;
        values["FLTFilter_AllFiles"] = 1;
        values[valuesById[2] = "OnTimeline_Files"] = 2;
        values["FLTFilter_OnTimelineFiles"] = 2;
        values[valuesById[3] = "NotOnTimeline_Files"] = 3;
        values["FLTFilter_NotOnTimelineFiles"] = 3;
        values[valuesById[4] = "Online_Files"] = 4;
        values["FLTFilter_OnlineFiles"] = 4;
        values[valuesById[5] = "Offline_Files"] = 5;
        values["FLTFilter_OfflineFiles"] = 5;
        values[valuesById[6] = "Audio_Files"] = 6;
        values["FLTFilter_AudioFiles"] = 6;
        values[valuesById[7] = "Video_Files"] = 7;
        values["FLTFilter_VideoFiles"] = 7;
        values[valuesById[8] = "Rendered_Files"] = 8;
        values["FLTFilter_RenderedFiles"] = 8;
        values[valuesById[101] = "SelectedClipsTimeline"] = 101;
        values["FLTFilter_SelectedClipsTimeline"] = 101;
        values[valuesById[102] = "SelectedClipsClipsList"] = 102;
        values["FLTFilter_SelectedClipsClipsList"] = 102;
        return values;
    })();

    ptsl.FileLocationInfo = (function() {

        /**
         * Properties of a FileLocationInfo.
         * @memberof ptsl
         * @interface IFileLocationInfo
         * @property {boolean|null} [isOnline] FileLocationInfo isOnline
         */

        /**
         * Constructs a new FileLocationInfo.
         * @memberof ptsl
         * @classdesc Structure that describes file info.
         * @implements IFileLocationInfo
         * @constructor
         * @param {ptsl.IFileLocationInfo=} [properties] Properties to set
         */
        function FileLocationInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileLocationInfo isOnline.
         * @member {boolean} isOnline
         * @memberof ptsl.FileLocationInfo
         * @instance
         */
        FileLocationInfo.prototype.isOnline = false;

        /**
         * Creates a new FileLocationInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {ptsl.IFileLocationInfo=} [properties] Properties to set
         * @returns {ptsl.FileLocationInfo} FileLocationInfo instance
         */
        FileLocationInfo.create = function create(properties) {
            return new FileLocationInfo(properties);
        };

        /**
         * Encodes the specified FileLocationInfo message. Does not implicitly {@link ptsl.FileLocationInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {ptsl.IFileLocationInfo} message FileLocationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileLocationInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isOnline != null && Object.hasOwnProperty.call(message, "isOnline"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isOnline);
            return writer;
        };

        /**
         * Encodes the specified FileLocationInfo message, length delimited. Does not implicitly {@link ptsl.FileLocationInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {ptsl.IFileLocationInfo} message FileLocationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileLocationInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileLocationInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.FileLocationInfo} FileLocationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileLocationInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.FileLocationInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.isOnline = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FileLocationInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.FileLocationInfo} FileLocationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileLocationInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileLocationInfo message.
         * @function verify
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileLocationInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                if (typeof message.isOnline !== "boolean")
                    return "isOnline: boolean expected";
            return null;
        };

        /**
         * Creates a FileLocationInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.FileLocationInfo} FileLocationInfo
         */
        FileLocationInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.FileLocationInfo)
                return object;
            var message = new $root.ptsl.FileLocationInfo();
            if (object.isOnline != null)
                message.isOnline = Boolean(object.isOnline);
            return message;
        };

        /**
         * Creates a plain object from a FileLocationInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {ptsl.FileLocationInfo} message FileLocationInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileLocationInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isOnline = false;
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                object.isOnline = message.isOnline;
            return object;
        };

        /**
         * Converts this FileLocationInfo to JSON.
         * @function toJSON
         * @memberof ptsl.FileLocationInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileLocationInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FileLocationInfo
         * @function getTypeUrl
         * @memberof ptsl.FileLocationInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileLocationInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.FileLocationInfo";
        };

        return FileLocationInfo;
    })();

    ptsl.FileLocation = (function() {

        /**
         * Properties of a FileLocation.
         * @memberof ptsl
         * @interface IFileLocation
         * @property {string|null} [path] FileLocation path
         * @property {ptsl.IFileLocationInfo|null} [info] FileLocation info
         * @property {string|null} [fileId] * The id of the file.
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new FileLocation.
         * @memberof ptsl
         * @classdesc Structure that describes file location and its info.
         * @implements IFileLocation
         * @constructor
         * @param {ptsl.IFileLocation=} [properties] Properties to set
         */
        function FileLocation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileLocation path.
         * @member {string} path
         * @memberof ptsl.FileLocation
         * @instance
         */
        FileLocation.prototype.path = "";

        /**
         * FileLocation info.
         * @member {ptsl.IFileLocationInfo|null|undefined} info
         * @memberof ptsl.FileLocation
         * @instance
         */
        FileLocation.prototype.info = null;

        /**
         * * The id of the file.
         * * @since Pro Tools 2025.06
         * @member {string} fileId
         * @memberof ptsl.FileLocation
         * @instance
         */
        FileLocation.prototype.fileId = "";

        /**
         * Creates a new FileLocation instance using the specified properties.
         * @function create
         * @memberof ptsl.FileLocation
         * @static
         * @param {ptsl.IFileLocation=} [properties] Properties to set
         * @returns {ptsl.FileLocation} FileLocation instance
         */
        FileLocation.create = function create(properties) {
            return new FileLocation(properties);
        };

        /**
         * Encodes the specified FileLocation message. Does not implicitly {@link ptsl.FileLocation.verify|verify} messages.
         * @function encode
         * @memberof ptsl.FileLocation
         * @static
         * @param {ptsl.IFileLocation} message FileLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileLocation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.ptsl.FileLocationInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fileId);
            return writer;
        };

        /**
         * Encodes the specified FileLocation message, length delimited. Does not implicitly {@link ptsl.FileLocation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.FileLocation
         * @static
         * @param {ptsl.IFileLocation} message FileLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileLocation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileLocation message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.FileLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.FileLocation} FileLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileLocation.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.FileLocation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.path = reader.string();
                        break;
                    }
                case 2: {
                        message.info = $root.ptsl.FileLocationInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.fileId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FileLocation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.FileLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.FileLocation} FileLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileLocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileLocation message.
         * @function verify
         * @memberof ptsl.FileLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.ptsl.FileLocationInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                if (!$util.isString(message.fileId))
                    return "fileId: string expected";
            return null;
        };

        /**
         * Creates a FileLocation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.FileLocation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.FileLocation} FileLocation
         */
        FileLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.FileLocation)
                return object;
            var message = new $root.ptsl.FileLocation();
            if (object.path != null)
                message.path = String(object.path);
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".ptsl.FileLocation.info: object expected");
                message.info = $root.ptsl.FileLocationInfo.fromObject(object.info);
            }
            if (object.fileId != null)
                message.fileId = String(object.fileId);
            return message;
        };

        /**
         * Creates a plain object from a FileLocation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.FileLocation
         * @static
         * @param {ptsl.FileLocation} message FileLocation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileLocation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.path = "";
                object.info = null;
                object.fileId = "";
            }
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.ptsl.FileLocationInfo.toObject(message.info, options);
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                object.fileId = message.fileId;
            return object;
        };

        /**
         * Converts this FileLocation to JSON.
         * @function toJSON
         * @memberof ptsl.FileLocation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FileLocation
         * @function getTypeUrl
         * @memberof ptsl.FileLocation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.FileLocation";
        };

        return FileLocation;
    })();

    ptsl.GetFileLocationRequestBody = (function() {

        /**
         * Properties of a GetFileLocationRequestBody.
         * @memberof ptsl
         * @interface IGetFileLocationRequestBody
         * @property {number|null} [pageLimit] * @deprecated since Pro Tools 2023.09, use pagination_request
         * @property {Array.<ptsl.FileLocationTypeFilter>|null} [fileFilters] GetFileLocationRequestBody fileFilters
         * @property {ptsl.IPaginationRequest|null} [paginationRequest] * Enable pagination and control limit and offset
         * * @since Pro Tools 2023.09
         */

        /**
         * Constructs a new GetFileLocationRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetFileLocation request data.
         * @implements IGetFileLocationRequestBody
         * @constructor
         * @param {ptsl.IGetFileLocationRequestBody=} [properties] Properties to set
         */
        function GetFileLocationRequestBody(properties) {
            this.fileFilters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2023.09, use pagination_request
         * @member {number} pageLimit
         * @memberof ptsl.GetFileLocationRequestBody
         * @instance
         */
        GetFileLocationRequestBody.prototype.pageLimit = 0;

        /**
         * GetFileLocationRequestBody fileFilters.
         * @member {Array.<ptsl.FileLocationTypeFilter>} fileFilters
         * @memberof ptsl.GetFileLocationRequestBody
         * @instance
         */
        GetFileLocationRequestBody.prototype.fileFilters = $util.emptyArray;

        /**
         * * Enable pagination and control limit and offset
         * * @since Pro Tools 2023.09
         * @member {ptsl.IPaginationRequest|null|undefined} paginationRequest
         * @memberof ptsl.GetFileLocationRequestBody
         * @instance
         */
        GetFileLocationRequestBody.prototype.paginationRequest = null;

        /**
         * Creates a new GetFileLocationRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {ptsl.IGetFileLocationRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetFileLocationRequestBody} GetFileLocationRequestBody instance
         */
        GetFileLocationRequestBody.create = function create(properties) {
            return new GetFileLocationRequestBody(properties);
        };

        /**
         * Encodes the specified GetFileLocationRequestBody message. Does not implicitly {@link ptsl.GetFileLocationRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {ptsl.IGetFileLocationRequestBody} message GetFileLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFileLocationRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pageLimit != null && Object.hasOwnProperty.call(message, "pageLimit"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pageLimit);
            if (message.fileFilters != null && message.fileFilters.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.fileFilters.length; ++i)
                    writer.int32(message.fileFilters[i]);
                writer.ldelim();
            }
            if (message.paginationRequest != null && Object.hasOwnProperty.call(message, "paginationRequest"))
                $root.ptsl.PaginationRequest.encode(message.paginationRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetFileLocationRequestBody message, length delimited. Does not implicitly {@link ptsl.GetFileLocationRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {ptsl.IGetFileLocationRequestBody} message GetFileLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFileLocationRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFileLocationRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetFileLocationRequestBody} GetFileLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFileLocationRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetFileLocationRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.pageLimit = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.fileFilters && message.fileFilters.length))
                            message.fileFilters = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.fileFilters.push(reader.int32());
                        } else
                            message.fileFilters.push(reader.int32());
                        break;
                    }
                case 3: {
                        message.paginationRequest = $root.ptsl.PaginationRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFileLocationRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetFileLocationRequestBody} GetFileLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFileLocationRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFileLocationRequestBody message.
         * @function verify
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFileLocationRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pageLimit != null && message.hasOwnProperty("pageLimit"))
                if (!$util.isInteger(message.pageLimit))
                    return "pageLimit: integer expected";
            if (message.fileFilters != null && message.hasOwnProperty("fileFilters")) {
                if (!Array.isArray(message.fileFilters))
                    return "fileFilters: array expected";
                for (var i = 0; i < message.fileFilters.length; ++i)
                    switch (message.fileFilters[i]) {
                    default:
                        return "fileFilters: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                    case 8:
                    case 101:
                    case 101:
                    case 102:
                    case 102:
                        break;
                    }
            }
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest")) {
                var error = $root.ptsl.PaginationRequest.verify(message.paginationRequest);
                if (error)
                    return "paginationRequest." + error;
            }
            return null;
        };

        /**
         * Creates a GetFileLocationRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetFileLocationRequestBody} GetFileLocationRequestBody
         */
        GetFileLocationRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetFileLocationRequestBody)
                return object;
            var message = new $root.ptsl.GetFileLocationRequestBody();
            if (object.pageLimit != null)
                message.pageLimit = object.pageLimit | 0;
            if (object.fileFilters) {
                if (!Array.isArray(object.fileFilters))
                    throw TypeError(".ptsl.GetFileLocationRequestBody.fileFilters: array expected");
                message.fileFilters = [];
                for (var i = 0; i < object.fileFilters.length; ++i)
                    switch (object.fileFilters[i]) {
                    default:
                        if (typeof object.fileFilters[i] === "number") {
                            message.fileFilters[i] = object.fileFilters[i];
                            break;
                        }
                    case "FLTFilter_Unknown":
                    case 0:
                        message.fileFilters[i] = 0;
                        break;
                    case "All_Files":
                    case 1:
                        message.fileFilters[i] = 1;
                        break;
                    case "FLTFilter_AllFiles":
                    case 1:
                        message.fileFilters[i] = 1;
                        break;
                    case "OnTimeline_Files":
                    case 2:
                        message.fileFilters[i] = 2;
                        break;
                    case "FLTFilter_OnTimelineFiles":
                    case 2:
                        message.fileFilters[i] = 2;
                        break;
                    case "NotOnTimeline_Files":
                    case 3:
                        message.fileFilters[i] = 3;
                        break;
                    case "FLTFilter_NotOnTimelineFiles":
                    case 3:
                        message.fileFilters[i] = 3;
                        break;
                    case "Online_Files":
                    case 4:
                        message.fileFilters[i] = 4;
                        break;
                    case "FLTFilter_OnlineFiles":
                    case 4:
                        message.fileFilters[i] = 4;
                        break;
                    case "Offline_Files":
                    case 5:
                        message.fileFilters[i] = 5;
                        break;
                    case "FLTFilter_OfflineFiles":
                    case 5:
                        message.fileFilters[i] = 5;
                        break;
                    case "Audio_Files":
                    case 6:
                        message.fileFilters[i] = 6;
                        break;
                    case "FLTFilter_AudioFiles":
                    case 6:
                        message.fileFilters[i] = 6;
                        break;
                    case "Video_Files":
                    case 7:
                        message.fileFilters[i] = 7;
                        break;
                    case "FLTFilter_VideoFiles":
                    case 7:
                        message.fileFilters[i] = 7;
                        break;
                    case "Rendered_Files":
                    case 8:
                        message.fileFilters[i] = 8;
                        break;
                    case "FLTFilter_RenderedFiles":
                    case 8:
                        message.fileFilters[i] = 8;
                        break;
                    case "SelectedClipsTimeline":
                    case 101:
                        message.fileFilters[i] = 101;
                        break;
                    case "FLTFilter_SelectedClipsTimeline":
                    case 101:
                        message.fileFilters[i] = 101;
                        break;
                    case "SelectedClipsClipsList":
                    case 102:
                        message.fileFilters[i] = 102;
                        break;
                    case "FLTFilter_SelectedClipsClipsList":
                    case 102:
                        message.fileFilters[i] = 102;
                        break;
                    }
            }
            if (object.paginationRequest != null) {
                if (typeof object.paginationRequest !== "object")
                    throw TypeError(".ptsl.GetFileLocationRequestBody.paginationRequest: object expected");
                message.paginationRequest = $root.ptsl.PaginationRequest.fromObject(object.paginationRequest);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetFileLocationRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {ptsl.GetFileLocationRequestBody} message GetFileLocationRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetFileLocationRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fileFilters = [];
            if (options.defaults) {
                object.pageLimit = 0;
                object.paginationRequest = null;
            }
            if (message.pageLimit != null && message.hasOwnProperty("pageLimit"))
                object.pageLimit = message.pageLimit;
            if (message.fileFilters && message.fileFilters.length) {
                object.fileFilters = [];
                for (var j = 0; j < message.fileFilters.length; ++j)
                    object.fileFilters[j] = options.enums === String ? $root.ptsl.FileLocationTypeFilter[message.fileFilters[j]] === undefined ? message.fileFilters[j] : $root.ptsl.FileLocationTypeFilter[message.fileFilters[j]] : message.fileFilters[j];
            }
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest"))
                object.paginationRequest = $root.ptsl.PaginationRequest.toObject(message.paginationRequest, options);
            return object;
        };

        /**
         * Converts this GetFileLocationRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetFileLocationRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetFileLocationRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetFileLocationRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetFileLocationRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetFileLocationRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetFileLocationRequestBody";
        };

        return GetFileLocationRequestBody;
    })();

    ptsl.GetFileLocationResponseBody = (function() {

        /**
         * Properties of a GetFileLocationResponseBody.
         * @memberof ptsl
         * @interface IGetFileLocationResponseBody
         * @property {ptsl.IPagination|null} [stats] * @deprecated since Pro Tools 2023.09, use pagination_response
         * @property {Array.<ptsl.IFileLocation>|null} [fileLocations] GetFileLocationResponseBody fileLocations
         * @property {ptsl.IPaginationResponse|null} [paginationResponse] * @since Pro Tools 2023.09
         */

        /**
         * Constructs a new GetFileLocationResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetFileLocation response data.
         * @implements IGetFileLocationResponseBody
         * @constructor
         * @param {ptsl.IGetFileLocationResponseBody=} [properties] Properties to set
         */
        function GetFileLocationResponseBody(properties) {
            this.fileLocations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2023.09, use pagination_response
         * @member {ptsl.IPagination|null|undefined} stats
         * @memberof ptsl.GetFileLocationResponseBody
         * @instance
         */
        GetFileLocationResponseBody.prototype.stats = null;

        /**
         * GetFileLocationResponseBody fileLocations.
         * @member {Array.<ptsl.IFileLocation>} fileLocations
         * @memberof ptsl.GetFileLocationResponseBody
         * @instance
         */
        GetFileLocationResponseBody.prototype.fileLocations = $util.emptyArray;

        /**
         * * @since Pro Tools 2023.09
         * @member {ptsl.IPaginationResponse|null|undefined} paginationResponse
         * @memberof ptsl.GetFileLocationResponseBody
         * @instance
         */
        GetFileLocationResponseBody.prototype.paginationResponse = null;

        /**
         * Creates a new GetFileLocationResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {ptsl.IGetFileLocationResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetFileLocationResponseBody} GetFileLocationResponseBody instance
         */
        GetFileLocationResponseBody.create = function create(properties) {
            return new GetFileLocationResponseBody(properties);
        };

        /**
         * Encodes the specified GetFileLocationResponseBody message. Does not implicitly {@link ptsl.GetFileLocationResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {ptsl.IGetFileLocationResponseBody} message GetFileLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFileLocationResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stats != null && Object.hasOwnProperty.call(message, "stats"))
                $root.ptsl.Pagination.encode(message.stats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.fileLocations != null && message.fileLocations.length)
                for (var i = 0; i < message.fileLocations.length; ++i)
                    $root.ptsl.FileLocation.encode(message.fileLocations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.paginationResponse != null && Object.hasOwnProperty.call(message, "paginationResponse"))
                $root.ptsl.PaginationResponse.encode(message.paginationResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetFileLocationResponseBody message, length delimited. Does not implicitly {@link ptsl.GetFileLocationResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {ptsl.IGetFileLocationResponseBody} message GetFileLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFileLocationResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFileLocationResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetFileLocationResponseBody} GetFileLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFileLocationResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetFileLocationResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.stats = $root.ptsl.Pagination.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.fileLocations && message.fileLocations.length))
                            message.fileLocations = [];
                        message.fileLocations.push($root.ptsl.FileLocation.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.paginationResponse = $root.ptsl.PaginationResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFileLocationResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetFileLocationResponseBody} GetFileLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFileLocationResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFileLocationResponseBody message.
         * @function verify
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFileLocationResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stats != null && message.hasOwnProperty("stats")) {
                var error = $root.ptsl.Pagination.verify(message.stats);
                if (error)
                    return "stats." + error;
            }
            if (message.fileLocations != null && message.hasOwnProperty("fileLocations")) {
                if (!Array.isArray(message.fileLocations))
                    return "fileLocations: array expected";
                for (var i = 0; i < message.fileLocations.length; ++i) {
                    var error = $root.ptsl.FileLocation.verify(message.fileLocations[i]);
                    if (error)
                        return "fileLocations." + error;
                }
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse")) {
                var error = $root.ptsl.PaginationResponse.verify(message.paginationResponse);
                if (error)
                    return "paginationResponse." + error;
            }
            return null;
        };

        /**
         * Creates a GetFileLocationResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetFileLocationResponseBody} GetFileLocationResponseBody
         */
        GetFileLocationResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetFileLocationResponseBody)
                return object;
            var message = new $root.ptsl.GetFileLocationResponseBody();
            if (object.stats != null) {
                if (typeof object.stats !== "object")
                    throw TypeError(".ptsl.GetFileLocationResponseBody.stats: object expected");
                message.stats = $root.ptsl.Pagination.fromObject(object.stats);
            }
            if (object.fileLocations) {
                if (!Array.isArray(object.fileLocations))
                    throw TypeError(".ptsl.GetFileLocationResponseBody.fileLocations: array expected");
                message.fileLocations = [];
                for (var i = 0; i < object.fileLocations.length; ++i) {
                    if (typeof object.fileLocations[i] !== "object")
                        throw TypeError(".ptsl.GetFileLocationResponseBody.fileLocations: object expected");
                    message.fileLocations[i] = $root.ptsl.FileLocation.fromObject(object.fileLocations[i]);
                }
            }
            if (object.paginationResponse != null) {
                if (typeof object.paginationResponse !== "object")
                    throw TypeError(".ptsl.GetFileLocationResponseBody.paginationResponse: object expected");
                message.paginationResponse = $root.ptsl.PaginationResponse.fromObject(object.paginationResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetFileLocationResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {ptsl.GetFileLocationResponseBody} message GetFileLocationResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetFileLocationResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fileLocations = [];
            if (options.defaults) {
                object.stats = null;
                object.paginationResponse = null;
            }
            if (message.stats != null && message.hasOwnProperty("stats"))
                object.stats = $root.ptsl.Pagination.toObject(message.stats, options);
            if (message.fileLocations && message.fileLocations.length) {
                object.fileLocations = [];
                for (var j = 0; j < message.fileLocations.length; ++j)
                    object.fileLocations[j] = $root.ptsl.FileLocation.toObject(message.fileLocations[j], options);
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse"))
                object.paginationResponse = $root.ptsl.PaginationResponse.toObject(message.paginationResponse, options);
            return object;
        };

        /**
         * Converts this GetFileLocationResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetFileLocationResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetFileLocationResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetFileLocationResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetFileLocationResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetFileLocationResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetFileLocationResponseBody";
        };

        return GetFileLocationResponseBody;
    })();

    ptsl.CloseSessionRequestBody = (function() {

        /**
         * Properties of a CloseSessionRequestBody.
         * @memberof ptsl
         * @interface ICloseSessionRequestBody
         * @property {boolean|null} [saveOnClose] CloseSessionRequestBody saveOnClose
         */

        /**
         * Constructs a new CloseSessionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CloseSession request data.
         * @implements ICloseSessionRequestBody
         * @constructor
         * @param {ptsl.ICloseSessionRequestBody=} [properties] Properties to set
         */
        function CloseSessionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CloseSessionRequestBody saveOnClose.
         * @member {boolean} saveOnClose
         * @memberof ptsl.CloseSessionRequestBody
         * @instance
         */
        CloseSessionRequestBody.prototype.saveOnClose = false;

        /**
         * Creates a new CloseSessionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {ptsl.ICloseSessionRequestBody=} [properties] Properties to set
         * @returns {ptsl.CloseSessionRequestBody} CloseSessionRequestBody instance
         */
        CloseSessionRequestBody.create = function create(properties) {
            return new CloseSessionRequestBody(properties);
        };

        /**
         * Encodes the specified CloseSessionRequestBody message. Does not implicitly {@link ptsl.CloseSessionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {ptsl.ICloseSessionRequestBody} message CloseSessionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseSessionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.saveOnClose != null && Object.hasOwnProperty.call(message, "saveOnClose"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.saveOnClose);
            return writer;
        };

        /**
         * Encodes the specified CloseSessionRequestBody message, length delimited. Does not implicitly {@link ptsl.CloseSessionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {ptsl.ICloseSessionRequestBody} message CloseSessionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseSessionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseSessionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CloseSessionRequestBody} CloseSessionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseSessionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CloseSessionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.saveOnClose = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseSessionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CloseSessionRequestBody} CloseSessionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseSessionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseSessionRequestBody message.
         * @function verify
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseSessionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.saveOnClose != null && message.hasOwnProperty("saveOnClose"))
                if (typeof message.saveOnClose !== "boolean")
                    return "saveOnClose: boolean expected";
            return null;
        };

        /**
         * Creates a CloseSessionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CloseSessionRequestBody} CloseSessionRequestBody
         */
        CloseSessionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CloseSessionRequestBody)
                return object;
            var message = new $root.ptsl.CloseSessionRequestBody();
            if (object.saveOnClose != null)
                message.saveOnClose = Boolean(object.saveOnClose);
            return message;
        };

        /**
         * Creates a plain object from a CloseSessionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {ptsl.CloseSessionRequestBody} message CloseSessionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseSessionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.saveOnClose = false;
            if (message.saveOnClose != null && message.hasOwnProperty("saveOnClose"))
                object.saveOnClose = message.saveOnClose;
            return object;
        };

        /**
         * Converts this CloseSessionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CloseSessionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseSessionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CloseSessionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CloseSessionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CloseSessionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CloseSessionRequestBody";
        };

        return CloseSessionRequestBody;
    })();

    ptsl.SaveSessionAsRequestBody = (function() {

        /**
         * Properties of a SaveSessionAsRequestBody.
         * @memberof ptsl
         * @interface ISaveSessionAsRequestBody
         * @property {string|null} [sessionName] SaveSessionAsRequestBody sessionName
         * @property {string|null} [sessionLocation] SaveSessionAsRequestBody sessionLocation
         */

        /**
         * Constructs a new SaveSessionAsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SaveSessionAs request data.
         * @implements ISaveSessionAsRequestBody
         * @constructor
         * @param {ptsl.ISaveSessionAsRequestBody=} [properties] Properties to set
         */
        function SaveSessionAsRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SaveSessionAsRequestBody sessionName.
         * @member {string} sessionName
         * @memberof ptsl.SaveSessionAsRequestBody
         * @instance
         */
        SaveSessionAsRequestBody.prototype.sessionName = "";

        /**
         * SaveSessionAsRequestBody sessionLocation.
         * @member {string} sessionLocation
         * @memberof ptsl.SaveSessionAsRequestBody
         * @instance
         */
        SaveSessionAsRequestBody.prototype.sessionLocation = "";

        /**
         * Creates a new SaveSessionAsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {ptsl.ISaveSessionAsRequestBody=} [properties] Properties to set
         * @returns {ptsl.SaveSessionAsRequestBody} SaveSessionAsRequestBody instance
         */
        SaveSessionAsRequestBody.create = function create(properties) {
            return new SaveSessionAsRequestBody(properties);
        };

        /**
         * Encodes the specified SaveSessionAsRequestBody message. Does not implicitly {@link ptsl.SaveSessionAsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {ptsl.ISaveSessionAsRequestBody} message SaveSessionAsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaveSessionAsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionName != null && Object.hasOwnProperty.call(message, "sessionName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionName);
            if (message.sessionLocation != null && Object.hasOwnProperty.call(message, "sessionLocation"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessionLocation);
            return writer;
        };

        /**
         * Encodes the specified SaveSessionAsRequestBody message, length delimited. Does not implicitly {@link ptsl.SaveSessionAsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {ptsl.ISaveSessionAsRequestBody} message SaveSessionAsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaveSessionAsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SaveSessionAsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SaveSessionAsRequestBody} SaveSessionAsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaveSessionAsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SaveSessionAsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionName = reader.string();
                        break;
                    }
                case 2: {
                        message.sessionLocation = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SaveSessionAsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SaveSessionAsRequestBody} SaveSessionAsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaveSessionAsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SaveSessionAsRequestBody message.
         * @function verify
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SaveSessionAsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionName != null && message.hasOwnProperty("sessionName"))
                if (!$util.isString(message.sessionName))
                    return "sessionName: string expected";
            if (message.sessionLocation != null && message.hasOwnProperty("sessionLocation"))
                if (!$util.isString(message.sessionLocation))
                    return "sessionLocation: string expected";
            return null;
        };

        /**
         * Creates a SaveSessionAsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SaveSessionAsRequestBody} SaveSessionAsRequestBody
         */
        SaveSessionAsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SaveSessionAsRequestBody)
                return object;
            var message = new $root.ptsl.SaveSessionAsRequestBody();
            if (object.sessionName != null)
                message.sessionName = String(object.sessionName);
            if (object.sessionLocation != null)
                message.sessionLocation = String(object.sessionLocation);
            return message;
        };

        /**
         * Creates a plain object from a SaveSessionAsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {ptsl.SaveSessionAsRequestBody} message SaveSessionAsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SaveSessionAsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sessionName = "";
                object.sessionLocation = "";
            }
            if (message.sessionName != null && message.hasOwnProperty("sessionName"))
                object.sessionName = message.sessionName;
            if (message.sessionLocation != null && message.hasOwnProperty("sessionLocation"))
                object.sessionLocation = message.sessionLocation;
            return object;
        };

        /**
         * Converts this SaveSessionAsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SaveSessionAsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SaveSessionAsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SaveSessionAsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SaveSessionAsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SaveSessionAsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SaveSessionAsRequestBody";
        };

        return SaveSessionAsRequestBody;
    })();

    /**
     * Automation data options used with cut/copy/clear commands.
     * @name ptsl.AutomationDataOptions
     * @enum {number}
     * @property {number} ADOptions_Unknown=0 ADOptions_Unknown value
     * @property {number} All_Automation=1 * @deprecated ptsl::AutomationDataOptions::All_Automation is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AutomationDataOptions::ADOptions_AllAutomation
     * @property {number} ADOptions_AllAutomation=1 ADOptions_AllAutomation value
     * @property {number} Pan_Automation=2 * @deprecated ptsl::AutomationDataOptions::Pan_Automation is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AutomationDataOptions::ADOptions_PanAutomation
     * @property {number} ADOptions_PanAutomation=2 ADOptions_PanAutomation value
     * @property {number} PlugIn_Automation=3 * @deprecated ptsl::AutomationDataOptions::PlugIn_Automation is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AutomationDataOptions::ADOptions_PlugInAutomation
     * @property {number} ADOptions_PlugInAutomation=3 ADOptions_PlugInAutomation value
     * @property {number} Clip_Gain=4 * @deprecated ptsl::AutomationDataOptions::Clip_Gain is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AutomationDataOptions::ADOptions_ClipGain
     * @property {number} ADOptions_ClipGain=4 ADOptions_ClipGain value
     * @property {number} Clip_Effects=5 * @deprecated ptsl::AutomationDataOptions::Clip_Effects is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::AutomationDataOptions::ADOptions_ClipEffects
     * @property {number} ADOptions_ClipEffects=5 ADOptions_ClipEffects value
     */
    ptsl.AutomationDataOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ADOptions_Unknown"] = 0;
        values[valuesById[1] = "All_Automation"] = 1;
        values["ADOptions_AllAutomation"] = 1;
        values[valuesById[2] = "Pan_Automation"] = 2;
        values["ADOptions_PanAutomation"] = 2;
        values[valuesById[3] = "PlugIn_Automation"] = 3;
        values["ADOptions_PlugInAutomation"] = 3;
        values[valuesById[4] = "Clip_Gain"] = 4;
        values["ADOptions_ClipGain"] = 4;
        values[valuesById[5] = "Clip_Effects"] = 5;
        values["ADOptions_ClipEffects"] = 5;
        return values;
    })();

    /**
     * Options used with the paste special command.
     * @name ptsl.PasteSpecialOptions
     * @enum {number}
     * @property {number} PSOptions_Unknown=0 PSOptions_Unknown value
     * @property {number} Merge=1 Merge value
     * @property {number} MergeMidi=1 MergeMidi value
     * @property {number} PSOptions_MergeMidi=1 PSOptions_MergeMidi value
     * @property {number} Repeat_To_Fill_Selection=2 * @deprecated ptsl::PasteSpecialOptions::Repeat_To_Fill_Selection is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::PasteSpecialOptions::PSOptions_RepeatToFillSelection
     * @property {number} PSOptions_RepeatToFillSelection=2 PSOptions_RepeatToFillSelection value
     * @property {number} To_Current_Automation_Type=3 * @deprecated ptsl::PasteSpecialOptions::To_Current_Automation_Type is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::PasteSpecialOptions::PSOptions_ToCurrentAutomationType
     * @property {number} PSOptions_ToCurrentAutomationType=3 PSOptions_ToCurrentAutomationType value
     * @property {number} MergeMarkers=4 * @deprecated ptsl::PasteSpecialOptions::MergeMarkers is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::PasteSpecialOptions::PSOptions_MergeMarkers
     * @property {number} PSOptions_MergeMarkers=4 PSOptions_MergeMarkers value
     */
    ptsl.PasteSpecialOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PSOptions_Unknown"] = 0;
        values[valuesById[1] = "Merge"] = 1;
        values["MergeMidi"] = 1;
        values["PSOptions_MergeMidi"] = 1;
        values[valuesById[2] = "Repeat_To_Fill_Selection"] = 2;
        values["PSOptions_RepeatToFillSelection"] = 2;
        values[valuesById[3] = "To_Current_Automation_Type"] = 3;
        values["PSOptions_ToCurrentAutomationType"] = 3;
        values[valuesById[4] = "MergeMarkers"] = 4;
        values["PSOptions_MergeMarkers"] = 4;
        return values;
    })();

    ptsl.CutSpecialRequestBody = (function() {

        /**
         * Properties of a CutSpecialRequestBody.
         * @memberof ptsl
         * @interface ICutSpecialRequestBody
         * @property {ptsl.AutomationDataOptions|null} [automationDataOption] CutSpecialRequestBody automationDataOption
         */

        /**
         * Constructs a new CutSpecialRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CutSpecial request data.
         * @implements ICutSpecialRequestBody
         * @constructor
         * @param {ptsl.ICutSpecialRequestBody=} [properties] Properties to set
         */
        function CutSpecialRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CutSpecialRequestBody automationDataOption.
         * @member {ptsl.AutomationDataOptions} automationDataOption
         * @memberof ptsl.CutSpecialRequestBody
         * @instance
         */
        CutSpecialRequestBody.prototype.automationDataOption = 0;

        /**
         * Creates a new CutSpecialRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {ptsl.ICutSpecialRequestBody=} [properties] Properties to set
         * @returns {ptsl.CutSpecialRequestBody} CutSpecialRequestBody instance
         */
        CutSpecialRequestBody.create = function create(properties) {
            return new CutSpecialRequestBody(properties);
        };

        /**
         * Encodes the specified CutSpecialRequestBody message. Does not implicitly {@link ptsl.CutSpecialRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {ptsl.ICutSpecialRequestBody} message CutSpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CutSpecialRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.automationDataOption != null && Object.hasOwnProperty.call(message, "automationDataOption"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.automationDataOption);
            return writer;
        };

        /**
         * Encodes the specified CutSpecialRequestBody message, length delimited. Does not implicitly {@link ptsl.CutSpecialRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {ptsl.ICutSpecialRequestBody} message CutSpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CutSpecialRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CutSpecialRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CutSpecialRequestBody} CutSpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CutSpecialRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CutSpecialRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.automationDataOption = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CutSpecialRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CutSpecialRequestBody} CutSpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CutSpecialRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CutSpecialRequestBody message.
         * @function verify
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CutSpecialRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.automationDataOption != null && message.hasOwnProperty("automationDataOption"))
                switch (message.automationDataOption) {
                default:
                    return "automationDataOption: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a CutSpecialRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CutSpecialRequestBody} CutSpecialRequestBody
         */
        CutSpecialRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CutSpecialRequestBody)
                return object;
            var message = new $root.ptsl.CutSpecialRequestBody();
            switch (object.automationDataOption) {
            default:
                if (typeof object.automationDataOption === "number") {
                    message.automationDataOption = object.automationDataOption;
                    break;
                }
                break;
            case "ADOptions_Unknown":
            case 0:
                message.automationDataOption = 0;
                break;
            case "All_Automation":
            case 1:
                message.automationDataOption = 1;
                break;
            case "ADOptions_AllAutomation":
            case 1:
                message.automationDataOption = 1;
                break;
            case "Pan_Automation":
            case 2:
                message.automationDataOption = 2;
                break;
            case "ADOptions_PanAutomation":
            case 2:
                message.automationDataOption = 2;
                break;
            case "PlugIn_Automation":
            case 3:
                message.automationDataOption = 3;
                break;
            case "ADOptions_PlugInAutomation":
            case 3:
                message.automationDataOption = 3;
                break;
            case "Clip_Gain":
            case 4:
                message.automationDataOption = 4;
                break;
            case "ADOptions_ClipGain":
            case 4:
                message.automationDataOption = 4;
                break;
            case "Clip_Effects":
            case 5:
                message.automationDataOption = 5;
                break;
            case "ADOptions_ClipEffects":
            case 5:
                message.automationDataOption = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CutSpecialRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {ptsl.CutSpecialRequestBody} message CutSpecialRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CutSpecialRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.automationDataOption = options.enums === String ? "ADOptions_Unknown" : 0;
            if (message.automationDataOption != null && message.hasOwnProperty("automationDataOption"))
                object.automationDataOption = options.enums === String ? $root.ptsl.AutomationDataOptions[message.automationDataOption] === undefined ? message.automationDataOption : $root.ptsl.AutomationDataOptions[message.automationDataOption] : message.automationDataOption;
            return object;
        };

        /**
         * Converts this CutSpecialRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CutSpecialRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CutSpecialRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CutSpecialRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CutSpecialRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CutSpecialRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CutSpecialRequestBody";
        };

        return CutSpecialRequestBody;
    })();

    ptsl.CopySpecialRequestBody = (function() {

        /**
         * Properties of a CopySpecialRequestBody.
         * @memberof ptsl
         * @interface ICopySpecialRequestBody
         * @property {ptsl.AutomationDataOptions|null} [automationDataOption] CopySpecialRequestBody automationDataOption
         */

        /**
         * Constructs a new CopySpecialRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CopySpecial request data.
         * @implements ICopySpecialRequestBody
         * @constructor
         * @param {ptsl.ICopySpecialRequestBody=} [properties] Properties to set
         */
        function CopySpecialRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopySpecialRequestBody automationDataOption.
         * @member {ptsl.AutomationDataOptions} automationDataOption
         * @memberof ptsl.CopySpecialRequestBody
         * @instance
         */
        CopySpecialRequestBody.prototype.automationDataOption = 0;

        /**
         * Creates a new CopySpecialRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {ptsl.ICopySpecialRequestBody=} [properties] Properties to set
         * @returns {ptsl.CopySpecialRequestBody} CopySpecialRequestBody instance
         */
        CopySpecialRequestBody.create = function create(properties) {
            return new CopySpecialRequestBody(properties);
        };

        /**
         * Encodes the specified CopySpecialRequestBody message. Does not implicitly {@link ptsl.CopySpecialRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {ptsl.ICopySpecialRequestBody} message CopySpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopySpecialRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.automationDataOption != null && Object.hasOwnProperty.call(message, "automationDataOption"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.automationDataOption);
            return writer;
        };

        /**
         * Encodes the specified CopySpecialRequestBody message, length delimited. Does not implicitly {@link ptsl.CopySpecialRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {ptsl.ICopySpecialRequestBody} message CopySpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopySpecialRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopySpecialRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CopySpecialRequestBody} CopySpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopySpecialRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CopySpecialRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.automationDataOption = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopySpecialRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CopySpecialRequestBody} CopySpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopySpecialRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopySpecialRequestBody message.
         * @function verify
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopySpecialRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.automationDataOption != null && message.hasOwnProperty("automationDataOption"))
                switch (message.automationDataOption) {
                default:
                    return "automationDataOption: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a CopySpecialRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CopySpecialRequestBody} CopySpecialRequestBody
         */
        CopySpecialRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CopySpecialRequestBody)
                return object;
            var message = new $root.ptsl.CopySpecialRequestBody();
            switch (object.automationDataOption) {
            default:
                if (typeof object.automationDataOption === "number") {
                    message.automationDataOption = object.automationDataOption;
                    break;
                }
                break;
            case "ADOptions_Unknown":
            case 0:
                message.automationDataOption = 0;
                break;
            case "All_Automation":
            case 1:
                message.automationDataOption = 1;
                break;
            case "ADOptions_AllAutomation":
            case 1:
                message.automationDataOption = 1;
                break;
            case "Pan_Automation":
            case 2:
                message.automationDataOption = 2;
                break;
            case "ADOptions_PanAutomation":
            case 2:
                message.automationDataOption = 2;
                break;
            case "PlugIn_Automation":
            case 3:
                message.automationDataOption = 3;
                break;
            case "ADOptions_PlugInAutomation":
            case 3:
                message.automationDataOption = 3;
                break;
            case "Clip_Gain":
            case 4:
                message.automationDataOption = 4;
                break;
            case "ADOptions_ClipGain":
            case 4:
                message.automationDataOption = 4;
                break;
            case "Clip_Effects":
            case 5:
                message.automationDataOption = 5;
                break;
            case "ADOptions_ClipEffects":
            case 5:
                message.automationDataOption = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CopySpecialRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {ptsl.CopySpecialRequestBody} message CopySpecialRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopySpecialRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.automationDataOption = options.enums === String ? "ADOptions_Unknown" : 0;
            if (message.automationDataOption != null && message.hasOwnProperty("automationDataOption"))
                object.automationDataOption = options.enums === String ? $root.ptsl.AutomationDataOptions[message.automationDataOption] === undefined ? message.automationDataOption : $root.ptsl.AutomationDataOptions[message.automationDataOption] : message.automationDataOption;
            return object;
        };

        /**
         * Converts this CopySpecialRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CopySpecialRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopySpecialRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CopySpecialRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CopySpecialRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CopySpecialRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CopySpecialRequestBody";
        };

        return CopySpecialRequestBody;
    })();

    ptsl.ClearSpecialRequestBody = (function() {

        /**
         * Properties of a ClearSpecialRequestBody.
         * @memberof ptsl
         * @interface IClearSpecialRequestBody
         * @property {ptsl.AutomationDataOptions|null} [automationDataOption] ClearSpecialRequestBody automationDataOption
         */

        /**
         * Constructs a new ClearSpecialRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ClearSpecial request data.
         * @implements IClearSpecialRequestBody
         * @constructor
         * @param {ptsl.IClearSpecialRequestBody=} [properties] Properties to set
         */
        function ClearSpecialRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClearSpecialRequestBody automationDataOption.
         * @member {ptsl.AutomationDataOptions} automationDataOption
         * @memberof ptsl.ClearSpecialRequestBody
         * @instance
         */
        ClearSpecialRequestBody.prototype.automationDataOption = 0;

        /**
         * Creates a new ClearSpecialRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {ptsl.IClearSpecialRequestBody=} [properties] Properties to set
         * @returns {ptsl.ClearSpecialRequestBody} ClearSpecialRequestBody instance
         */
        ClearSpecialRequestBody.create = function create(properties) {
            return new ClearSpecialRequestBody(properties);
        };

        /**
         * Encodes the specified ClearSpecialRequestBody message. Does not implicitly {@link ptsl.ClearSpecialRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {ptsl.IClearSpecialRequestBody} message ClearSpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearSpecialRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.automationDataOption != null && Object.hasOwnProperty.call(message, "automationDataOption"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.automationDataOption);
            return writer;
        };

        /**
         * Encodes the specified ClearSpecialRequestBody message, length delimited. Does not implicitly {@link ptsl.ClearSpecialRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {ptsl.IClearSpecialRequestBody} message ClearSpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearSpecialRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClearSpecialRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ClearSpecialRequestBody} ClearSpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearSpecialRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ClearSpecialRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.automationDataOption = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClearSpecialRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ClearSpecialRequestBody} ClearSpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearSpecialRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClearSpecialRequestBody message.
         * @function verify
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearSpecialRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.automationDataOption != null && message.hasOwnProperty("automationDataOption"))
                switch (message.automationDataOption) {
                default:
                    return "automationDataOption: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a ClearSpecialRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ClearSpecialRequestBody} ClearSpecialRequestBody
         */
        ClearSpecialRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ClearSpecialRequestBody)
                return object;
            var message = new $root.ptsl.ClearSpecialRequestBody();
            switch (object.automationDataOption) {
            default:
                if (typeof object.automationDataOption === "number") {
                    message.automationDataOption = object.automationDataOption;
                    break;
                }
                break;
            case "ADOptions_Unknown":
            case 0:
                message.automationDataOption = 0;
                break;
            case "All_Automation":
            case 1:
                message.automationDataOption = 1;
                break;
            case "ADOptions_AllAutomation":
            case 1:
                message.automationDataOption = 1;
                break;
            case "Pan_Automation":
            case 2:
                message.automationDataOption = 2;
                break;
            case "ADOptions_PanAutomation":
            case 2:
                message.automationDataOption = 2;
                break;
            case "PlugIn_Automation":
            case 3:
                message.automationDataOption = 3;
                break;
            case "ADOptions_PlugInAutomation":
            case 3:
                message.automationDataOption = 3;
                break;
            case "Clip_Gain":
            case 4:
                message.automationDataOption = 4;
                break;
            case "ADOptions_ClipGain":
            case 4:
                message.automationDataOption = 4;
                break;
            case "Clip_Effects":
            case 5:
                message.automationDataOption = 5;
                break;
            case "ADOptions_ClipEffects":
            case 5:
                message.automationDataOption = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClearSpecialRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {ptsl.ClearSpecialRequestBody} message ClearSpecialRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearSpecialRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.automationDataOption = options.enums === String ? "ADOptions_Unknown" : 0;
            if (message.automationDataOption != null && message.hasOwnProperty("automationDataOption"))
                object.automationDataOption = options.enums === String ? $root.ptsl.AutomationDataOptions[message.automationDataOption] === undefined ? message.automationDataOption : $root.ptsl.AutomationDataOptions[message.automationDataOption] : message.automationDataOption;
            return object;
        };

        /**
         * Converts this ClearSpecialRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ClearSpecialRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearSpecialRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClearSpecialRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ClearSpecialRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClearSpecialRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ClearSpecialRequestBody";
        };

        return ClearSpecialRequestBody;
    })();

    ptsl.PasteSpecialRequestBody = (function() {

        /**
         * Properties of a PasteSpecialRequestBody.
         * @memberof ptsl
         * @interface IPasteSpecialRequestBody
         * @property {ptsl.PasteSpecialOptions|null} [pasteSpecialOption] PasteSpecialRequestBody pasteSpecialOption
         */

        /**
         * Constructs a new PasteSpecialRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes PasteSpecial request data.
         * @implements IPasteSpecialRequestBody
         * @constructor
         * @param {ptsl.IPasteSpecialRequestBody=} [properties] Properties to set
         */
        function PasteSpecialRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PasteSpecialRequestBody pasteSpecialOption.
         * @member {ptsl.PasteSpecialOptions} pasteSpecialOption
         * @memberof ptsl.PasteSpecialRequestBody
         * @instance
         */
        PasteSpecialRequestBody.prototype.pasteSpecialOption = 0;

        /**
         * Creates a new PasteSpecialRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {ptsl.IPasteSpecialRequestBody=} [properties] Properties to set
         * @returns {ptsl.PasteSpecialRequestBody} PasteSpecialRequestBody instance
         */
        PasteSpecialRequestBody.create = function create(properties) {
            return new PasteSpecialRequestBody(properties);
        };

        /**
         * Encodes the specified PasteSpecialRequestBody message. Does not implicitly {@link ptsl.PasteSpecialRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {ptsl.IPasteSpecialRequestBody} message PasteSpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PasteSpecialRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pasteSpecialOption != null && Object.hasOwnProperty.call(message, "pasteSpecialOption"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pasteSpecialOption);
            return writer;
        };

        /**
         * Encodes the specified PasteSpecialRequestBody message, length delimited. Does not implicitly {@link ptsl.PasteSpecialRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {ptsl.IPasteSpecialRequestBody} message PasteSpecialRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PasteSpecialRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PasteSpecialRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.PasteSpecialRequestBody} PasteSpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PasteSpecialRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.PasteSpecialRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.pasteSpecialOption = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PasteSpecialRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.PasteSpecialRequestBody} PasteSpecialRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PasteSpecialRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PasteSpecialRequestBody message.
         * @function verify
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PasteSpecialRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pasteSpecialOption != null && message.hasOwnProperty("pasteSpecialOption"))
                switch (message.pasteSpecialOption) {
                default:
                    return "pasteSpecialOption: enum value expected";
                case 0:
                case 1:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a PasteSpecialRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.PasteSpecialRequestBody} PasteSpecialRequestBody
         */
        PasteSpecialRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.PasteSpecialRequestBody)
                return object;
            var message = new $root.ptsl.PasteSpecialRequestBody();
            switch (object.pasteSpecialOption) {
            default:
                if (typeof object.pasteSpecialOption === "number") {
                    message.pasteSpecialOption = object.pasteSpecialOption;
                    break;
                }
                break;
            case "PSOptions_Unknown":
            case 0:
                message.pasteSpecialOption = 0;
                break;
            case "Merge":
            case 1:
                message.pasteSpecialOption = 1;
                break;
            case "MergeMidi":
            case 1:
                message.pasteSpecialOption = 1;
                break;
            case "PSOptions_MergeMidi":
            case 1:
                message.pasteSpecialOption = 1;
                break;
            case "Repeat_To_Fill_Selection":
            case 2:
                message.pasteSpecialOption = 2;
                break;
            case "PSOptions_RepeatToFillSelection":
            case 2:
                message.pasteSpecialOption = 2;
                break;
            case "To_Current_Automation_Type":
            case 3:
                message.pasteSpecialOption = 3;
                break;
            case "PSOptions_ToCurrentAutomationType":
            case 3:
                message.pasteSpecialOption = 3;
                break;
            case "MergeMarkers":
            case 4:
                message.pasteSpecialOption = 4;
                break;
            case "PSOptions_MergeMarkers":
            case 4:
                message.pasteSpecialOption = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PasteSpecialRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {ptsl.PasteSpecialRequestBody} message PasteSpecialRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PasteSpecialRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pasteSpecialOption = options.enums === String ? "PSOptions_Unknown" : 0;
            if (message.pasteSpecialOption != null && message.hasOwnProperty("pasteSpecialOption"))
                object.pasteSpecialOption = options.enums === String ? $root.ptsl.PasteSpecialOptions[message.pasteSpecialOption] === undefined ? message.pasteSpecialOption : $root.ptsl.PasteSpecialOptions[message.pasteSpecialOption] : message.pasteSpecialOption;
            return object;
        };

        /**
         * Converts this PasteSpecialRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.PasteSpecialRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PasteSpecialRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PasteSpecialRequestBody
         * @function getTypeUrl
         * @memberof ptsl.PasteSpecialRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PasteSpecialRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.PasteSpecialRequestBody";
        };

        return PasteSpecialRequestBody;
    })();

    /**
     * Boolean with "unset" value.
     * @name ptsl.TripleBool
     * @enum {number}
     * @property {number} TBool_Unknown=0 TBool_Unknown value
     * @property {number} TB_None=1 TB_None value
     * @property {number} TBool_None=1 TBool_None value
     * @property {number} TB_False=2 TB_False value
     * @property {number} TBool_False=2 TBool_False value
     * @property {number} TB_True=3 TB_True value
     * @property {number} TBool_True=3 TBool_True value
     */
    ptsl.TripleBool = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TBool_Unknown"] = 0;
        values[valuesById[1] = "TB_None"] = 1;
        values["TBool_None"] = 1;
        values[valuesById[2] = "TB_False"] = 2;
        values["TBool_False"] = 2;
        values[valuesById[3] = "TB_True"] = 3;
        values["TBool_True"] = 3;
        return values;
    })();

    /**
     * Available source types for mix source.
     * @name ptsl.EM_SourceType
     * @enum {number}
     * @property {number} EMSType_Unknown=0 EMSType_Unknown value
     * @property {number} PhysicalOut=1 * @deprecated ptsl::EM_SourceType::PhysicalOut is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_SourceType::EMSType_PhysicalOut
     * @property {number} EMSType_PhysicalOut=1 EMSType_PhysicalOut value
     * @property {number} Bus=2 * @deprecated ptsl::EM_SourceType::Bus is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_SourceType::EMSType_Bus
     * @property {number} EMSType_Bus=2 EMSType_Bus value
     * @property {number} Output=3 * @deprecated ptsl::EM_SourceType::Output is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_SourceType::EMSType_Output
     * @property {number} EMSType_Output=3 EMSType_Output value
     */
    ptsl.EM_SourceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EMSType_Unknown"] = 0;
        values[valuesById[1] = "PhysicalOut"] = 1;
        values["EMSType_PhysicalOut"] = 1;
        values[valuesById[2] = "Bus"] = 2;
        values["EMSType_Bus"] = 2;
        values[valuesById[3] = "Output"] = 3;
        values["EMSType_Output"] = 3;
        return values;
    })();

    /**
     * Available compression type for audio.
     * @name ptsl.CompressionType
     * @enum {number}
     * @property {number} CType_Unknown=0 CType_Unknown value
     * @property {number} CT_None=1 * @deprecated ptsl::CompressionType::CT_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::CompressionType::CType_None
     * @property {number} CType_None=1 CType_None value
     * @property {number} CT_PCM=2 * @deprecated ptsl::CompressionType::CT_PCM is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::CompressionType::CType_PCM
     * @property {number} CType_PCM=2 CType_PCM value
     */
    ptsl.CompressionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CType_Unknown"] = 0;
        values[valuesById[1] = "CT_None"] = 1;
        values["CType_None"] = 1;
        values[valuesById[2] = "CT_PCM"] = 2;
        values["CType_PCM"] = 2;
        return values;
    })();

    /**
     * Type of Pro Tools session/project sample rate.
     * @name ptsl.SampleRate
     * @enum {number}
     * @property {number} SRate_Unknown=0 SRate_Unknown value
     * @property {number} SR_None=1 * @deprecated ptsl::SampleRate::SR_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SampleRate::SRate_None
     * @property {number} SRate_None=1 SRate_None value
     * @property {number} SR_44100=44100 * @deprecated ptsl::SampleRate::SR_44100 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SampleRate::SRate_44100
     * @property {number} SRate_44100=44100 SRate_44100 value
     * @property {number} SR_48000=48000 * @deprecated ptsl::SampleRate::SR_48000 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SampleRate::SRate_48000
     * @property {number} SRate_48000=48000 SRate_48000 value
     * @property {number} SR_88200=88200 * @deprecated ptsl::SampleRate::SR_88200 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SampleRate::SRate_88200
     * @property {number} SRate_88200=88200 SRate_88200 value
     * @property {number} SR_96000=96000 * @deprecated ptsl::SampleRate::SR_96000 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SampleRate::SRate_96000
     * @property {number} SRate_96000=96000 SRate_96000 value
     * @property {number} SR_176400=176400 * @deprecated ptsl::SampleRate::SR_176400 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SampleRate::SRate_176400
     * @property {number} SRate_176400=176400 SRate_176400 value
     * @property {number} SR_192000=192000 * @deprecated ptsl::SampleRate::SR_192000 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SampleRate::SRate_192000
     * @property {number} SRate_192000=192000 SRate_192000 value
     */
    ptsl.SampleRate = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SRate_Unknown"] = 0;
        values[valuesById[1] = "SR_None"] = 1;
        values["SRate_None"] = 1;
        values[valuesById[44100] = "SR_44100"] = 44100;
        values["SRate_44100"] = 44100;
        values[valuesById[48000] = "SR_48000"] = 48000;
        values["SRate_48000"] = 48000;
        values[valuesById[88200] = "SR_88200"] = 88200;
        values["SRate_88200"] = 88200;
        values[valuesById[96000] = "SR_96000"] = 96000;
        values["SRate_96000"] = 96000;
        values[valuesById[176400] = "SR_176400"] = 176400;
        values["SRate_176400"] = 176400;
        values[valuesById[192000] = "SR_192000"] = 192000;
        values["SRate_192000"] = 192000;
        return values;
    })();

    /**
     * Available options for export video.
     * @name ptsl.EM_VideoExportOptions
     * @enum {number}
     * @property {number} EMVEOptions_Unknown=0 EMVEOptions_Unknown value
     * @property {number} VE_None=1 * @deprecated ptsl::EM_VideoExportOptions::VE_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_VideoExportOptions::EMVEOptions_None
     * @property {number} EMVEOptions_None=1 EMVEOptions_None value
     * @property {number} VE_SameAsSource=2 * @deprecated ptsl::EM_VideoExportOptions::VE_SameAsSource is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_VideoExportOptions::EMVEOptions_SameAsSource
     * @property {number} EMVEOptions_SameAsSource=2 EMVEOptions_SameAsSource value
     * @property {number} VE_Transcode=3 * @deprecated ptsl::EM_VideoExportOptions::VE_Transcode is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_VideoExportOptions::EMVEOptions_Transcode
     * @property {number} EMVEOptions_Transcode=3 EMVEOptions_Transcode value
     */
    ptsl.EM_VideoExportOptions = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EMVEOptions_Unknown"] = 0;
        values[valuesById[1] = "VE_None"] = 1;
        values["EMVEOptions_None"] = 1;
        values[valuesById[2] = "VE_SameAsSource"] = 2;
        values["EMVEOptions_SameAsSource"] = 2;
        values[valuesById[3] = "VE_Transcode"] = 3;
        values["EMVEOptions_Transcode"] = 3;
        return values;
    })();

    /**
     * Available file type for mix export.
     * @name ptsl.EM_FileType
     * @enum {number}
     * @property {number} EMFType_Unknown=0 EMFType_Unknown value
     * @property {number} EM_None=1 * @deprecated ptsl::EM_FileType::EM_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileType::EMFType_None
     * @property {number} EMFType_None=1 EMFType_None value
     * @property {number} EM_MOV=2 * @deprecated ptsl::EM_FileType::EM_MOV is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileType::EMFType_MOV
     * @property {number} EMFType_MOV=2 EMFType_MOV value
     * @property {number} EM_WAV=3 * @deprecated ptsl::EM_FileType::EM_WAV is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileType::EMFType_WAV
     * @property {number} EMFType_WAV=3 EMFType_WAV value
     * @property {number} EM_AIFF=4 * @deprecated ptsl::EM_FileType::EM_AIFF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileType::EMFType_AIFF
     * @property {number} EMFType_AIFF=4 EMFType_AIFF value
     * @property {number} EM_MP3=5 * @deprecated ptsl::EM_FileType::EM_MP3 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileType::EMFType_MP3
     * @property {number} EMFType_MP3=5 EMFType_MP3 value
     * @property {number} EM_MXFOPAtom=6 * @deprecated ptsl::EM_FileType::EM_MXFOPAtom is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileType::EMFType_MXFOPAtom
     * @property {number} EMFType_MXFOPAtom=6 EMFType_MXFOPAtom value
     * @property {number} EM_WAVADM=7 * @deprecated ptsl::EM_FileType::EM_WAVADM is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileType::EMFType_WAVADM
     * @property {number} EMFType_WAVADM=7 EMFType_WAVADM value
     * @property {number} EMFType_M4A=8 * Replaced with @ref ptsl::EM_FileType::EMFType_M4A
     */
    ptsl.EM_FileType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EMFType_Unknown"] = 0;
        values[valuesById[1] = "EM_None"] = 1;
        values["EMFType_None"] = 1;
        values[valuesById[2] = "EM_MOV"] = 2;
        values["EMFType_MOV"] = 2;
        values[valuesById[3] = "EM_WAV"] = 3;
        values["EMFType_WAV"] = 3;
        values[valuesById[4] = "EM_AIFF"] = 4;
        values["EMFType_AIFF"] = 4;
        values[valuesById[5] = "EM_MP3"] = 5;
        values["EMFType_MP3"] = 5;
        values[valuesById[6] = "EM_MXFOPAtom"] = 6;
        values["EMFType_MXFOPAtom"] = 6;
        values[valuesById[7] = "EM_WAVADM"] = 7;
        values["EMFType_WAVADM"] = 7;
        values[valuesById[8] = "EMFType_M4A"] = 8;
        return values;
    })();

    /**
     * Available types that describe file destination.
     * @name ptsl.EM_FileDestination
     * @enum {number}
     * @property {number} EMFDestination_Unknown=0 EMFDestination_Unknown value
     * @property {number} EM_FD_None=1 * @deprecated ptsl::EM_FileDestination::EM_FD_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_FileDestination::EMFDestination_None
     * @property {number} EMFDestination_None=1 EMFDestination_None value
     * @property {number} EM_FD_SessionFolder=2 * @deprecated ptsl::EM_VideoExportOptions::EM_FD_SessionFolder is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_VideoExportOptions::EMFDestination_SessionFolder
     * @property {number} EMFDestination_SessionFolder=2 EMFDestination_SessionFolder value
     * @property {number} EM_FD_Directory=3 * @deprecated ptsl::EM_VideoExportOptions::EM_FD_Directory is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_VideoExportOptions::EMFDestination_Directory
     * @property {number} EMFDestination_Directory=3 EMFDestination_Directory value
     */
    ptsl.EM_FileDestination = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EMFDestination_Unknown"] = 0;
        values[valuesById[1] = "EM_FD_None"] = 1;
        values["EMFDestination_None"] = 1;
        values[valuesById[2] = "EM_FD_SessionFolder"] = 2;
        values["EMFDestination_SessionFolder"] = 2;
        values[valuesById[3] = "EM_FD_Directory"] = 3;
        values["EMFDestination_Directory"] = 3;
        return values;
    })();

    /**
     * Available delivery formats.
     * @name ptsl.EM_DeliveryFormat
     * @enum {number}
     * @property {number} EMDFormat_Unknown=0 EMDFormat_Unknown value
     * @property {number} EM_DF_None=1 * @deprecated ptsl::EM_DeliveryFormat::EM_DF_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_DeliveryFormat::EMDFormat_None
     * @property {number} EMDFormat_None=1 EMDFormat_None value
     * @property {number} EM_DF_FilePerMixSource=2 * @deprecated ptsl::EM_DeliveryFormat::EM_DF_FilePerMixSource is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_DeliveryFormat::EMDFormat_FilePerMixSource
     * @property {number} EMDFormat_FilePerMixSource=2 EMDFormat_FilePerMixSource value
     * @property {number} EM_DF_SingleFile=3 * @deprecated ptsl::EM_DeliveryFormat::EM_DF_SingleFile is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EM_DeliveryFormat::EMDFormat_SingleFile
     * @property {number} EMDFormat_SingleFile=3 EMDFormat_SingleFile value
     */
    ptsl.EM_DeliveryFormat = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EMDFormat_Unknown"] = 0;
        values[valuesById[1] = "EM_DF_None"] = 1;
        values["EMDFormat_None"] = 1;
        values[valuesById[2] = "EM_DF_FilePerMixSource"] = 2;
        values["EMDFormat_FilePerMixSource"] = 2;
        values[valuesById[3] = "EM_DF_SingleFile"] = 3;
        values["EMDFormat_SingleFile"] = 3;
        return values;
    })();

    ptsl.EM_SourceInfo = (function() {

        /**
         * Properties of a EM_SourceInfo.
         * @memberof ptsl
         * @interface IEM_SourceInfo
         * @property {ptsl.EM_SourceType|null} [sourceType] EM_SourceInfo sourceType
         * @property {string|null} [name] EM_SourceInfo name
         */

        /**
         * Constructs a new EM_SourceInfo.
         * @memberof ptsl
         * @classdesc Structure that describes mix source.
         * @implements IEM_SourceInfo
         * @constructor
         * @param {ptsl.IEM_SourceInfo=} [properties] Properties to set
         */
        function EM_SourceInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EM_SourceInfo sourceType.
         * @member {ptsl.EM_SourceType} sourceType
         * @memberof ptsl.EM_SourceInfo
         * @instance
         */
        EM_SourceInfo.prototype.sourceType = 0;

        /**
         * EM_SourceInfo name.
         * @member {string} name
         * @memberof ptsl.EM_SourceInfo
         * @instance
         */
        EM_SourceInfo.prototype.name = "";

        /**
         * Creates a new EM_SourceInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {ptsl.IEM_SourceInfo=} [properties] Properties to set
         * @returns {ptsl.EM_SourceInfo} EM_SourceInfo instance
         */
        EM_SourceInfo.create = function create(properties) {
            return new EM_SourceInfo(properties);
        };

        /**
         * Encodes the specified EM_SourceInfo message. Does not implicitly {@link ptsl.EM_SourceInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {ptsl.IEM_SourceInfo} message EM_SourceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_SourceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sourceType != null && Object.hasOwnProperty.call(message, "sourceType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sourceType);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified EM_SourceInfo message, length delimited. Does not implicitly {@link ptsl.EM_SourceInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {ptsl.IEM_SourceInfo} message EM_SourceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_SourceInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a EM_SourceInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EM_SourceInfo} EM_SourceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_SourceInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EM_SourceInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sourceType = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a EM_SourceInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EM_SourceInfo} EM_SourceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_SourceInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a EM_SourceInfo message.
         * @function verify
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EM_SourceInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sourceType != null && message.hasOwnProperty("sourceType"))
                switch (message.sourceType) {
                default:
                    return "sourceType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a EM_SourceInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EM_SourceInfo} EM_SourceInfo
         */
        EM_SourceInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EM_SourceInfo)
                return object;
            var message = new $root.ptsl.EM_SourceInfo();
            switch (object.sourceType) {
            default:
                if (typeof object.sourceType === "number") {
                    message.sourceType = object.sourceType;
                    break;
                }
                break;
            case "EMSType_Unknown":
            case 0:
                message.sourceType = 0;
                break;
            case "PhysicalOut":
            case 1:
                message.sourceType = 1;
                break;
            case "EMSType_PhysicalOut":
            case 1:
                message.sourceType = 1;
                break;
            case "Bus":
            case 2:
                message.sourceType = 2;
                break;
            case "EMSType_Bus":
            case 2:
                message.sourceType = 2;
                break;
            case "Output":
            case 3:
                message.sourceType = 3;
                break;
            case "EMSType_Output":
            case 3:
                message.sourceType = 3;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a EM_SourceInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {ptsl.EM_SourceInfo} message EM_SourceInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EM_SourceInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sourceType = options.enums === String ? "EMSType_Unknown" : 0;
                object.name = "";
            }
            if (message.sourceType != null && message.hasOwnProperty("sourceType"))
                object.sourceType = options.enums === String ? $root.ptsl.EM_SourceType[message.sourceType] === undefined ? message.sourceType : $root.ptsl.EM_SourceType[message.sourceType] : message.sourceType;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this EM_SourceInfo to JSON.
         * @function toJSON
         * @memberof ptsl.EM_SourceInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EM_SourceInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EM_SourceInfo
         * @function getTypeUrl
         * @memberof ptsl.EM_SourceInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EM_SourceInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EM_SourceInfo";
        };

        return EM_SourceInfo;
    })();

    ptsl.EM_AudioInfo = (function() {

        /**
         * Properties of a EM_AudioInfo.
         * @memberof ptsl
         * @interface IEM_AudioInfo
         * @property {ptsl.CompressionType|null} [compressionType] EM_AudioInfo compressionType
         * @property {ptsl.ExportFormat|null} [exportFormat] EM_AudioInfo exportFormat
         * @property {ptsl.BitDepth|null} [bitDepth] EM_AudioInfo bitDepth
         * @property {ptsl.SampleRate|null} [sampleRate] EM_AudioInfo sampleRate
         * @property {ptsl.TripleBool|null} [padToFrameBoundary] EM_AudioInfo padToFrameBoundary
         * @property {ptsl.EM_DeliveryFormat|null} [deliveryFormat] EM_AudioInfo deliveryFormat
         * @property {number|null} [sampleRateCustom] * Custom sample rate to override the sample_rate field. Use non zero values to enable this field.
         * *
         * * @since Pro Tools 2024.06
         */

        /**
         * Constructs a new EM_AudioInfo.
         * @memberof ptsl
         * @classdesc Structure that describes information for audio section in the Bounce Mix window.
         * @implements IEM_AudioInfo
         * @constructor
         * @param {ptsl.IEM_AudioInfo=} [properties] Properties to set
         */
        function EM_AudioInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EM_AudioInfo compressionType.
         * @member {ptsl.CompressionType} compressionType
         * @memberof ptsl.EM_AudioInfo
         * @instance
         */
        EM_AudioInfo.prototype.compressionType = 0;

        /**
         * EM_AudioInfo exportFormat.
         * @member {ptsl.ExportFormat} exportFormat
         * @memberof ptsl.EM_AudioInfo
         * @instance
         */
        EM_AudioInfo.prototype.exportFormat = 0;

        /**
         * EM_AudioInfo bitDepth.
         * @member {ptsl.BitDepth} bitDepth
         * @memberof ptsl.EM_AudioInfo
         * @instance
         */
        EM_AudioInfo.prototype.bitDepth = 0;

        /**
         * EM_AudioInfo sampleRate.
         * @member {ptsl.SampleRate} sampleRate
         * @memberof ptsl.EM_AudioInfo
         * @instance
         */
        EM_AudioInfo.prototype.sampleRate = 0;

        /**
         * EM_AudioInfo padToFrameBoundary.
         * @member {ptsl.TripleBool} padToFrameBoundary
         * @memberof ptsl.EM_AudioInfo
         * @instance
         */
        EM_AudioInfo.prototype.padToFrameBoundary = 0;

        /**
         * EM_AudioInfo deliveryFormat.
         * @member {ptsl.EM_DeliveryFormat} deliveryFormat
         * @memberof ptsl.EM_AudioInfo
         * @instance
         */
        EM_AudioInfo.prototype.deliveryFormat = 0;

        /**
         * * Custom sample rate to override the sample_rate field. Use non zero values to enable this field.
         * *
         * * @since Pro Tools 2024.06
         * @member {number} sampleRateCustom
         * @memberof ptsl.EM_AudioInfo
         * @instance
         */
        EM_AudioInfo.prototype.sampleRateCustom = 0;

        /**
         * Creates a new EM_AudioInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {ptsl.IEM_AudioInfo=} [properties] Properties to set
         * @returns {ptsl.EM_AudioInfo} EM_AudioInfo instance
         */
        EM_AudioInfo.create = function create(properties) {
            return new EM_AudioInfo(properties);
        };

        /**
         * Encodes the specified EM_AudioInfo message. Does not implicitly {@link ptsl.EM_AudioInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {ptsl.IEM_AudioInfo} message EM_AudioInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_AudioInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compressionType != null && Object.hasOwnProperty.call(message, "compressionType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.compressionType);
            if (message.exportFormat != null && Object.hasOwnProperty.call(message, "exportFormat"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.exportFormat);
            if (message.bitDepth != null && Object.hasOwnProperty.call(message, "bitDepth"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bitDepth);
            if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sampleRate);
            if (message.padToFrameBoundary != null && Object.hasOwnProperty.call(message, "padToFrameBoundary"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.padToFrameBoundary);
            if (message.deliveryFormat != null && Object.hasOwnProperty.call(message, "deliveryFormat"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.deliveryFormat);
            if (message.sampleRateCustom != null && Object.hasOwnProperty.call(message, "sampleRateCustom"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.sampleRateCustom);
            return writer;
        };

        /**
         * Encodes the specified EM_AudioInfo message, length delimited. Does not implicitly {@link ptsl.EM_AudioInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {ptsl.IEM_AudioInfo} message EM_AudioInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_AudioInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a EM_AudioInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EM_AudioInfo} EM_AudioInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_AudioInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EM_AudioInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.compressionType = reader.int32();
                        break;
                    }
                case 2: {
                        message.exportFormat = reader.int32();
                        break;
                    }
                case 3: {
                        message.bitDepth = reader.int32();
                        break;
                    }
                case 4: {
                        message.sampleRate = reader.int32();
                        break;
                    }
                case 5: {
                        message.padToFrameBoundary = reader.int32();
                        break;
                    }
                case 6: {
                        message.deliveryFormat = reader.int32();
                        break;
                    }
                case 7: {
                        message.sampleRateCustom = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a EM_AudioInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EM_AudioInfo} EM_AudioInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_AudioInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a EM_AudioInfo message.
         * @function verify
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EM_AudioInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                switch (message.compressionType) {
                default:
                    return "compressionType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.exportFormat != null && message.hasOwnProperty("exportFormat"))
                switch (message.exportFormat) {
                default:
                    return "exportFormat: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                switch (message.bitDepth) {
                default:
                    return "bitDepth: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                switch (message.sampleRate) {
                default:
                    return "sampleRate: enum value expected";
                case 0:
                case 1:
                case 1:
                case 44100:
                case 44100:
                case 48000:
                case 48000:
                case 88200:
                case 88200:
                case 96000:
                case 96000:
                case 176400:
                case 176400:
                case 192000:
                case 192000:
                    break;
                }
            if (message.padToFrameBoundary != null && message.hasOwnProperty("padToFrameBoundary"))
                switch (message.padToFrameBoundary) {
                default:
                    return "padToFrameBoundary: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.deliveryFormat != null && message.hasOwnProperty("deliveryFormat"))
                switch (message.deliveryFormat) {
                default:
                    return "deliveryFormat: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.sampleRateCustom != null && message.hasOwnProperty("sampleRateCustom"))
                if (!$util.isInteger(message.sampleRateCustom))
                    return "sampleRateCustom: integer expected";
            return null;
        };

        /**
         * Creates a EM_AudioInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EM_AudioInfo} EM_AudioInfo
         */
        EM_AudioInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EM_AudioInfo)
                return object;
            var message = new $root.ptsl.EM_AudioInfo();
            switch (object.compressionType) {
            default:
                if (typeof object.compressionType === "number") {
                    message.compressionType = object.compressionType;
                    break;
                }
                break;
            case "CType_Unknown":
            case 0:
                message.compressionType = 0;
                break;
            case "CT_None":
            case 1:
                message.compressionType = 1;
                break;
            case "CType_None":
            case 1:
                message.compressionType = 1;
                break;
            case "CT_PCM":
            case 2:
                message.compressionType = 2;
                break;
            case "CType_PCM":
            case 2:
                message.compressionType = 2;
                break;
            }
            switch (object.exportFormat) {
            default:
                if (typeof object.exportFormat === "number") {
                    message.exportFormat = object.exportFormat;
                    break;
                }
                break;
            case "EFormat_Unknown":
            case 0:
                message.exportFormat = 0;
                break;
            case "EF_None":
            case 1:
                message.exportFormat = 1;
                break;
            case "EFormat_None":
            case 1:
                message.exportFormat = 1;
                break;
            case "EF_Mono":
            case 2:
                message.exportFormat = 2;
                break;
            case "EFormat_Mono":
            case 2:
                message.exportFormat = 2;
                break;
            case "EF_MultipleMono":
            case 3:
                message.exportFormat = 3;
                break;
            case "EFormat_MultipleMono":
            case 3:
                message.exportFormat = 3;
                break;
            case "EF_Interleaved":
            case 4:
                message.exportFormat = 4;
                break;
            case "EFormat_Interleaved":
            case 4:
                message.exportFormat = 4;
                break;
            }
            switch (object.bitDepth) {
            default:
                if (typeof object.bitDepth === "number") {
                    message.bitDepth = object.bitDepth;
                    break;
                }
                break;
            case "BDepth_Unknown":
            case 0:
                message.bitDepth = 0;
                break;
            case "Bit_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "BDepth_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "Bit16":
            case 2:
                message.bitDepth = 2;
                break;
            case "BDepth_16":
            case 2:
                message.bitDepth = 2;
                break;
            case "Bit24":
            case 3:
                message.bitDepth = 3;
                break;
            case "BDepth_24":
            case 3:
                message.bitDepth = 3;
                break;
            case "Bit32Float":
            case 4:
                message.bitDepth = 4;
                break;
            case "BDepth_32Float":
            case 4:
                message.bitDepth = 4;
                break;
            }
            switch (object.sampleRate) {
            default:
                if (typeof object.sampleRate === "number") {
                    message.sampleRate = object.sampleRate;
                    break;
                }
                break;
            case "SRate_Unknown":
            case 0:
                message.sampleRate = 0;
                break;
            case "SR_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SRate_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SR_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SRate_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SR_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SRate_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SR_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SRate_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SR_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SRate_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SR_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SRate_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SR_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            case "SRate_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            }
            switch (object.padToFrameBoundary) {
            default:
                if (typeof object.padToFrameBoundary === "number") {
                    message.padToFrameBoundary = object.padToFrameBoundary;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.padToFrameBoundary = 0;
                break;
            case "TB_None":
            case 1:
                message.padToFrameBoundary = 1;
                break;
            case "TBool_None":
            case 1:
                message.padToFrameBoundary = 1;
                break;
            case "TB_False":
            case 2:
                message.padToFrameBoundary = 2;
                break;
            case "TBool_False":
            case 2:
                message.padToFrameBoundary = 2;
                break;
            case "TB_True":
            case 3:
                message.padToFrameBoundary = 3;
                break;
            case "TBool_True":
            case 3:
                message.padToFrameBoundary = 3;
                break;
            }
            switch (object.deliveryFormat) {
            default:
                if (typeof object.deliveryFormat === "number") {
                    message.deliveryFormat = object.deliveryFormat;
                    break;
                }
                break;
            case "EMDFormat_Unknown":
            case 0:
                message.deliveryFormat = 0;
                break;
            case "EM_DF_None":
            case 1:
                message.deliveryFormat = 1;
                break;
            case "EMDFormat_None":
            case 1:
                message.deliveryFormat = 1;
                break;
            case "EM_DF_FilePerMixSource":
            case 2:
                message.deliveryFormat = 2;
                break;
            case "EMDFormat_FilePerMixSource":
            case 2:
                message.deliveryFormat = 2;
                break;
            case "EM_DF_SingleFile":
            case 3:
                message.deliveryFormat = 3;
                break;
            case "EMDFormat_SingleFile":
            case 3:
                message.deliveryFormat = 3;
                break;
            }
            if (object.sampleRateCustom != null)
                message.sampleRateCustom = object.sampleRateCustom | 0;
            return message;
        };

        /**
         * Creates a plain object from a EM_AudioInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {ptsl.EM_AudioInfo} message EM_AudioInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EM_AudioInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.compressionType = options.enums === String ? "CType_Unknown" : 0;
                object.exportFormat = options.enums === String ? "EFormat_Unknown" : 0;
                object.bitDepth = options.enums === String ? "BDepth_Unknown" : 0;
                object.sampleRate = options.enums === String ? "SRate_Unknown" : 0;
                object.padToFrameBoundary = options.enums === String ? "TBool_Unknown" : 0;
                object.deliveryFormat = options.enums === String ? "EMDFormat_Unknown" : 0;
                object.sampleRateCustom = 0;
            }
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                object.compressionType = options.enums === String ? $root.ptsl.CompressionType[message.compressionType] === undefined ? message.compressionType : $root.ptsl.CompressionType[message.compressionType] : message.compressionType;
            if (message.exportFormat != null && message.hasOwnProperty("exportFormat"))
                object.exportFormat = options.enums === String ? $root.ptsl.ExportFormat[message.exportFormat] === undefined ? message.exportFormat : $root.ptsl.ExportFormat[message.exportFormat] : message.exportFormat;
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                object.bitDepth = options.enums === String ? $root.ptsl.BitDepth[message.bitDepth] === undefined ? message.bitDepth : $root.ptsl.BitDepth[message.bitDepth] : message.bitDepth;
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                object.sampleRate = options.enums === String ? $root.ptsl.SampleRate[message.sampleRate] === undefined ? message.sampleRate : $root.ptsl.SampleRate[message.sampleRate] : message.sampleRate;
            if (message.padToFrameBoundary != null && message.hasOwnProperty("padToFrameBoundary"))
                object.padToFrameBoundary = options.enums === String ? $root.ptsl.TripleBool[message.padToFrameBoundary] === undefined ? message.padToFrameBoundary : $root.ptsl.TripleBool[message.padToFrameBoundary] : message.padToFrameBoundary;
            if (message.deliveryFormat != null && message.hasOwnProperty("deliveryFormat"))
                object.deliveryFormat = options.enums === String ? $root.ptsl.EM_DeliveryFormat[message.deliveryFormat] === undefined ? message.deliveryFormat : $root.ptsl.EM_DeliveryFormat[message.deliveryFormat] : message.deliveryFormat;
            if (message.sampleRateCustom != null && message.hasOwnProperty("sampleRateCustom"))
                object.sampleRateCustom = message.sampleRateCustom;
            return object;
        };

        /**
         * Converts this EM_AudioInfo to JSON.
         * @function toJSON
         * @memberof ptsl.EM_AudioInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EM_AudioInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EM_AudioInfo
         * @function getTypeUrl
         * @memberof ptsl.EM_AudioInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EM_AudioInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EM_AudioInfo";
        };

        return EM_AudioInfo;
    })();

    ptsl.PropertyContainer = (function() {

        /**
         * Properties of a PropertyContainer.
         * @memberof ptsl
         * @interface IPropertyContainer
         * @property {string|null} [containerName] PropertyContainer containerName
         * @property {ptsl.DP_ValueTypes|null} [type] PropertyContainer type
         * @property {string|null} [value] PropertyContainer value
         */

        /**
         * Constructs a new PropertyContainer.
         * @memberof ptsl
         * @classdesc Structure that describes container for property.
         * @implements IPropertyContainer
         * @constructor
         * @param {ptsl.IPropertyContainer=} [properties] Properties to set
         */
        function PropertyContainer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PropertyContainer containerName.
         * @member {string} containerName
         * @memberof ptsl.PropertyContainer
         * @instance
         */
        PropertyContainer.prototype.containerName = "";

        /**
         * PropertyContainer type.
         * @member {ptsl.DP_ValueTypes} type
         * @memberof ptsl.PropertyContainer
         * @instance
         */
        PropertyContainer.prototype.type = 0;

        /**
         * PropertyContainer value.
         * @member {string} value
         * @memberof ptsl.PropertyContainer
         * @instance
         */
        PropertyContainer.prototype.value = "";

        /**
         * Creates a new PropertyContainer instance using the specified properties.
         * @function create
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {ptsl.IPropertyContainer=} [properties] Properties to set
         * @returns {ptsl.PropertyContainer} PropertyContainer instance
         */
        PropertyContainer.create = function create(properties) {
            return new PropertyContainer(properties);
        };

        /**
         * Encodes the specified PropertyContainer message. Does not implicitly {@link ptsl.PropertyContainer.verify|verify} messages.
         * @function encode
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {ptsl.IPropertyContainer} message PropertyContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PropertyContainer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.containerName != null && Object.hasOwnProperty.call(message, "containerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.containerName);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified PropertyContainer message, length delimited. Does not implicitly {@link ptsl.PropertyContainer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {ptsl.IPropertyContainer} message PropertyContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PropertyContainer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PropertyContainer message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.PropertyContainer} PropertyContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PropertyContainer.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.PropertyContainer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.containerName = reader.string();
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        message.value = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PropertyContainer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.PropertyContainer} PropertyContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PropertyContainer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PropertyContainer message.
         * @function verify
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PropertyContainer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.containerName != null && message.hasOwnProperty("containerName"))
                if (!$util.isString(message.containerName))
                    return "containerName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                    break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a PropertyContainer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.PropertyContainer} PropertyContainer
         */
        PropertyContainer.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.PropertyContainer)
                return object;
            var message = new $root.ptsl.PropertyContainer();
            if (object.containerName != null)
                message.containerName = String(object.containerName);
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "DPVTypes_Unknown":
            case 0:
                message.type = 0;
                break;
            case "DP_VT_double":
            case 1:
                message.type = 1;
                break;
            case "DPVTypes_Double":
            case 1:
                message.type = 1;
                break;
            case "DP_VT_float":
            case 2:
                message.type = 2;
                break;
            case "DPVTypes_Float":
            case 2:
                message.type = 2;
                break;
            case "DP_VT_int32":
            case 3:
                message.type = 3;
                break;
            case "DPVTypes_Int32":
            case 3:
                message.type = 3;
                break;
            case "DP_VT_int64":
            case 4:
                message.type = 4;
                break;
            case "DPVTypes_Int64":
            case 4:
                message.type = 4;
                break;
            case "DP_VT_uint32":
            case 5:
                message.type = 5;
                break;
            case "DPVTypes_Uint32":
            case 5:
                message.type = 5;
                break;
            case "DP_VT_uint64":
            case 6:
                message.type = 6;
                break;
            case "DPVTypes_Uint64":
            case 6:
                message.type = 6;
                break;
            case "DP_VT_sint32":
            case 7:
                message.type = 7;
                break;
            case "DPVTypes_Sint32":
            case 7:
                message.type = 7;
                break;
            case "DP_VT_sint64":
            case 8:
                message.type = 8;
                break;
            case "DPVTypes_Sint64":
            case 8:
                message.type = 8;
                break;
            case "DP_VT_fixed32":
            case 9:
                message.type = 9;
                break;
            case "DPVTypes_Fixed32":
            case 9:
                message.type = 9;
                break;
            case "DP_VT_fixed64":
            case 10:
                message.type = 10;
                break;
            case "DPVTypes_Fixed64":
            case 10:
                message.type = 10;
                break;
            case "DP_VT_sfixed32":
            case 11:
                message.type = 11;
                break;
            case "DPVTypes_Sfixed32":
            case 11:
                message.type = 11;
                break;
            case "DP_VT_sfixed64":
            case 12:
                message.type = 12;
                break;
            case "DPVTypes_Sfixed64":
            case 12:
                message.type = 12;
                break;
            case "DP_VT_bool":
            case 13:
                message.type = 13;
                break;
            case "DPVTypes_Bool":
            case 13:
                message.type = 13;
                break;
            case "DP_VT_string":
            case 14:
                message.type = 14;
                break;
            case "DPVTypes_String":
            case 14:
                message.type = 14;
                break;
            case "DP_VT_bytes":
            case 15:
                message.type = 15;
                break;
            case "DPVTypes_Bytes":
            case 15:
                message.type = 15;
                break;
            case "DP_VT_enum":
            case 16:
                message.type = 16;
                break;
            case "DPVTypes_Enum":
            case 16:
                message.type = 16;
                break;
            case "DP_VT_object":
            case 17:
                message.type = 17;
                break;
            case "DPVTypes_Object":
            case 17:
                message.type = 17;
                break;
            }
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PropertyContainer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {ptsl.PropertyContainer} message PropertyContainer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PropertyContainer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.containerName = "";
                object.type = options.enums === String ? "DPVTypes_Unknown" : 0;
                object.value = "";
            }
            if (message.containerName != null && message.hasOwnProperty("containerName"))
                object.containerName = message.containerName;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ptsl.DP_ValueTypes[message.type] === undefined ? message.type : $root.ptsl.DP_ValueTypes[message.type] : message.type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PropertyContainer to JSON.
         * @function toJSON
         * @memberof ptsl.PropertyContainer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PropertyContainer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PropertyContainer
         * @function getTypeUrl
         * @memberof ptsl.PropertyContainer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PropertyContainer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.PropertyContainer";
        };

        return PropertyContainer;
    })();

    ptsl.EM_CodecInfo = (function() {

        /**
         * Properties of a EM_CodecInfo.
         * @memberof ptsl
         * @interface IEM_CodecInfo
         * @property {string|null} [codecName] EM_CodecInfo codecName
         * @property {Array.<ptsl.IPropertyContainer>|null} [propertyList] EM_CodecInfo propertyList
         */

        /**
         * Constructs a new EM_CodecInfo.
         * @memberof ptsl
         * @classdesc Structure that describes information for codec in video section for Export Mix.
         * @implements IEM_CodecInfo
         * @constructor
         * @param {ptsl.IEM_CodecInfo=} [properties] Properties to set
         */
        function EM_CodecInfo(properties) {
            this.propertyList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EM_CodecInfo codecName.
         * @member {string} codecName
         * @memberof ptsl.EM_CodecInfo
         * @instance
         */
        EM_CodecInfo.prototype.codecName = "";

        /**
         * EM_CodecInfo propertyList.
         * @member {Array.<ptsl.IPropertyContainer>} propertyList
         * @memberof ptsl.EM_CodecInfo
         * @instance
         */
        EM_CodecInfo.prototype.propertyList = $util.emptyArray;

        /**
         * Creates a new EM_CodecInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {ptsl.IEM_CodecInfo=} [properties] Properties to set
         * @returns {ptsl.EM_CodecInfo} EM_CodecInfo instance
         */
        EM_CodecInfo.create = function create(properties) {
            return new EM_CodecInfo(properties);
        };

        /**
         * Encodes the specified EM_CodecInfo message. Does not implicitly {@link ptsl.EM_CodecInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {ptsl.IEM_CodecInfo} message EM_CodecInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_CodecInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.codecName != null && Object.hasOwnProperty.call(message, "codecName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.codecName);
            if (message.propertyList != null && message.propertyList.length)
                for (var i = 0; i < message.propertyList.length; ++i)
                    $root.ptsl.PropertyContainer.encode(message.propertyList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EM_CodecInfo message, length delimited. Does not implicitly {@link ptsl.EM_CodecInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {ptsl.IEM_CodecInfo} message EM_CodecInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_CodecInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a EM_CodecInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EM_CodecInfo} EM_CodecInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_CodecInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EM_CodecInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.codecName = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.propertyList && message.propertyList.length))
                            message.propertyList = [];
                        message.propertyList.push($root.ptsl.PropertyContainer.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a EM_CodecInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EM_CodecInfo} EM_CodecInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_CodecInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a EM_CodecInfo message.
         * @function verify
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EM_CodecInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.codecName != null && message.hasOwnProperty("codecName"))
                if (!$util.isString(message.codecName))
                    return "codecName: string expected";
            if (message.propertyList != null && message.hasOwnProperty("propertyList")) {
                if (!Array.isArray(message.propertyList))
                    return "propertyList: array expected";
                for (var i = 0; i < message.propertyList.length; ++i) {
                    var error = $root.ptsl.PropertyContainer.verify(message.propertyList[i]);
                    if (error)
                        return "propertyList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a EM_CodecInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EM_CodecInfo} EM_CodecInfo
         */
        EM_CodecInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EM_CodecInfo)
                return object;
            var message = new $root.ptsl.EM_CodecInfo();
            if (object.codecName != null)
                message.codecName = String(object.codecName);
            if (object.propertyList) {
                if (!Array.isArray(object.propertyList))
                    throw TypeError(".ptsl.EM_CodecInfo.propertyList: array expected");
                message.propertyList = [];
                for (var i = 0; i < object.propertyList.length; ++i) {
                    if (typeof object.propertyList[i] !== "object")
                        throw TypeError(".ptsl.EM_CodecInfo.propertyList: object expected");
                    message.propertyList[i] = $root.ptsl.PropertyContainer.fromObject(object.propertyList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a EM_CodecInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {ptsl.EM_CodecInfo} message EM_CodecInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EM_CodecInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.propertyList = [];
            if (options.defaults)
                object.codecName = "";
            if (message.codecName != null && message.hasOwnProperty("codecName"))
                object.codecName = message.codecName;
            if (message.propertyList && message.propertyList.length) {
                object.propertyList = [];
                for (var j = 0; j < message.propertyList.length; ++j)
                    object.propertyList[j] = $root.ptsl.PropertyContainer.toObject(message.propertyList[j], options);
            }
            return object;
        };

        /**
         * Converts this EM_CodecInfo to JSON.
         * @function toJSON
         * @memberof ptsl.EM_CodecInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EM_CodecInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EM_CodecInfo
         * @function getTypeUrl
         * @memberof ptsl.EM_CodecInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EM_CodecInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EM_CodecInfo";
        };

        return EM_CodecInfo;
    })();

    ptsl.EM_VideoInfo = (function() {

        /**
         * Properties of a EM_VideoInfo.
         * @memberof ptsl
         * @interface IEM_VideoInfo
         * @property {ptsl.TripleBool|null} [includeVideo] EM_VideoInfo includeVideo
         * @property {ptsl.EM_VideoExportOptions|null} [exportOption] EM_VideoInfo exportOption
         * @property {ptsl.TripleBool|null} [replaceTimecodeTrack] EM_VideoInfo replaceTimecodeTrack
         * @property {ptsl.IEM_CodecInfo|null} [codecInfo] EM_VideoInfo codecInfo
         */

        /**
         * Constructs a new EM_VideoInfo.
         * @memberof ptsl
         * @classdesc Structure that describes information for video section in the Bounce Mix window.
         * @implements IEM_VideoInfo
         * @constructor
         * @param {ptsl.IEM_VideoInfo=} [properties] Properties to set
         */
        function EM_VideoInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EM_VideoInfo includeVideo.
         * @member {ptsl.TripleBool} includeVideo
         * @memberof ptsl.EM_VideoInfo
         * @instance
         */
        EM_VideoInfo.prototype.includeVideo = 0;

        /**
         * EM_VideoInfo exportOption.
         * @member {ptsl.EM_VideoExportOptions} exportOption
         * @memberof ptsl.EM_VideoInfo
         * @instance
         */
        EM_VideoInfo.prototype.exportOption = 0;

        /**
         * EM_VideoInfo replaceTimecodeTrack.
         * @member {ptsl.TripleBool} replaceTimecodeTrack
         * @memberof ptsl.EM_VideoInfo
         * @instance
         */
        EM_VideoInfo.prototype.replaceTimecodeTrack = 0;

        /**
         * EM_VideoInfo codecInfo.
         * @member {ptsl.IEM_CodecInfo|null|undefined} codecInfo
         * @memberof ptsl.EM_VideoInfo
         * @instance
         */
        EM_VideoInfo.prototype.codecInfo = null;

        /**
         * Creates a new EM_VideoInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {ptsl.IEM_VideoInfo=} [properties] Properties to set
         * @returns {ptsl.EM_VideoInfo} EM_VideoInfo instance
         */
        EM_VideoInfo.create = function create(properties) {
            return new EM_VideoInfo(properties);
        };

        /**
         * Encodes the specified EM_VideoInfo message. Does not implicitly {@link ptsl.EM_VideoInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {ptsl.IEM_VideoInfo} message EM_VideoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_VideoInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.includeVideo != null && Object.hasOwnProperty.call(message, "includeVideo"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.includeVideo);
            if (message.exportOption != null && Object.hasOwnProperty.call(message, "exportOption"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.exportOption);
            if (message.replaceTimecodeTrack != null && Object.hasOwnProperty.call(message, "replaceTimecodeTrack"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.replaceTimecodeTrack);
            if (message.codecInfo != null && Object.hasOwnProperty.call(message, "codecInfo"))
                $root.ptsl.EM_CodecInfo.encode(message.codecInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EM_VideoInfo message, length delimited. Does not implicitly {@link ptsl.EM_VideoInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {ptsl.IEM_VideoInfo} message EM_VideoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_VideoInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a EM_VideoInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EM_VideoInfo} EM_VideoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_VideoInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EM_VideoInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.includeVideo = reader.int32();
                        break;
                    }
                case 2: {
                        message.exportOption = reader.int32();
                        break;
                    }
                case 3: {
                        message.replaceTimecodeTrack = reader.int32();
                        break;
                    }
                case 4: {
                        message.codecInfo = $root.ptsl.EM_CodecInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a EM_VideoInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EM_VideoInfo} EM_VideoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_VideoInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a EM_VideoInfo message.
         * @function verify
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EM_VideoInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.includeVideo != null && message.hasOwnProperty("includeVideo"))
                switch (message.includeVideo) {
                default:
                    return "includeVideo: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.exportOption != null && message.hasOwnProperty("exportOption"))
                switch (message.exportOption) {
                default:
                    return "exportOption: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.replaceTimecodeTrack != null && message.hasOwnProperty("replaceTimecodeTrack"))
                switch (message.replaceTimecodeTrack) {
                default:
                    return "replaceTimecodeTrack: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.codecInfo != null && message.hasOwnProperty("codecInfo")) {
                var error = $root.ptsl.EM_CodecInfo.verify(message.codecInfo);
                if (error)
                    return "codecInfo." + error;
            }
            return null;
        };

        /**
         * Creates a EM_VideoInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EM_VideoInfo} EM_VideoInfo
         */
        EM_VideoInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EM_VideoInfo)
                return object;
            var message = new $root.ptsl.EM_VideoInfo();
            switch (object.includeVideo) {
            default:
                if (typeof object.includeVideo === "number") {
                    message.includeVideo = object.includeVideo;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.includeVideo = 0;
                break;
            case "TB_None":
            case 1:
                message.includeVideo = 1;
                break;
            case "TBool_None":
            case 1:
                message.includeVideo = 1;
                break;
            case "TB_False":
            case 2:
                message.includeVideo = 2;
                break;
            case "TBool_False":
            case 2:
                message.includeVideo = 2;
                break;
            case "TB_True":
            case 3:
                message.includeVideo = 3;
                break;
            case "TBool_True":
            case 3:
                message.includeVideo = 3;
                break;
            }
            switch (object.exportOption) {
            default:
                if (typeof object.exportOption === "number") {
                    message.exportOption = object.exportOption;
                    break;
                }
                break;
            case "EMVEOptions_Unknown":
            case 0:
                message.exportOption = 0;
                break;
            case "VE_None":
            case 1:
                message.exportOption = 1;
                break;
            case "EMVEOptions_None":
            case 1:
                message.exportOption = 1;
                break;
            case "VE_SameAsSource":
            case 2:
                message.exportOption = 2;
                break;
            case "EMVEOptions_SameAsSource":
            case 2:
                message.exportOption = 2;
                break;
            case "VE_Transcode":
            case 3:
                message.exportOption = 3;
                break;
            case "EMVEOptions_Transcode":
            case 3:
                message.exportOption = 3;
                break;
            }
            switch (object.replaceTimecodeTrack) {
            default:
                if (typeof object.replaceTimecodeTrack === "number") {
                    message.replaceTimecodeTrack = object.replaceTimecodeTrack;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.replaceTimecodeTrack = 0;
                break;
            case "TB_None":
            case 1:
                message.replaceTimecodeTrack = 1;
                break;
            case "TBool_None":
            case 1:
                message.replaceTimecodeTrack = 1;
                break;
            case "TB_False":
            case 2:
                message.replaceTimecodeTrack = 2;
                break;
            case "TBool_False":
            case 2:
                message.replaceTimecodeTrack = 2;
                break;
            case "TB_True":
            case 3:
                message.replaceTimecodeTrack = 3;
                break;
            case "TBool_True":
            case 3:
                message.replaceTimecodeTrack = 3;
                break;
            }
            if (object.codecInfo != null) {
                if (typeof object.codecInfo !== "object")
                    throw TypeError(".ptsl.EM_VideoInfo.codecInfo: object expected");
                message.codecInfo = $root.ptsl.EM_CodecInfo.fromObject(object.codecInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a EM_VideoInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {ptsl.EM_VideoInfo} message EM_VideoInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EM_VideoInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.includeVideo = options.enums === String ? "TBool_Unknown" : 0;
                object.exportOption = options.enums === String ? "EMVEOptions_Unknown" : 0;
                object.replaceTimecodeTrack = options.enums === String ? "TBool_Unknown" : 0;
                object.codecInfo = null;
            }
            if (message.includeVideo != null && message.hasOwnProperty("includeVideo"))
                object.includeVideo = options.enums === String ? $root.ptsl.TripleBool[message.includeVideo] === undefined ? message.includeVideo : $root.ptsl.TripleBool[message.includeVideo] : message.includeVideo;
            if (message.exportOption != null && message.hasOwnProperty("exportOption"))
                object.exportOption = options.enums === String ? $root.ptsl.EM_VideoExportOptions[message.exportOption] === undefined ? message.exportOption : $root.ptsl.EM_VideoExportOptions[message.exportOption] : message.exportOption;
            if (message.replaceTimecodeTrack != null && message.hasOwnProperty("replaceTimecodeTrack"))
                object.replaceTimecodeTrack = options.enums === String ? $root.ptsl.TripleBool[message.replaceTimecodeTrack] === undefined ? message.replaceTimecodeTrack : $root.ptsl.TripleBool[message.replaceTimecodeTrack] : message.replaceTimecodeTrack;
            if (message.codecInfo != null && message.hasOwnProperty("codecInfo"))
                object.codecInfo = $root.ptsl.EM_CodecInfo.toObject(message.codecInfo, options);
            return object;
        };

        /**
         * Converts this EM_VideoInfo to JSON.
         * @function toJSON
         * @memberof ptsl.EM_VideoInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EM_VideoInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EM_VideoInfo
         * @function getTypeUrl
         * @memberof ptsl.EM_VideoInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EM_VideoInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EM_VideoInfo";
        };

        return EM_VideoInfo;
    })();

    ptsl.EM_ImportOptions = (function() {

        /**
         * Properties of a EM_ImportOptions.
         * @memberof ptsl
         * @interface IEM_ImportOptions
         * @property {ptsl.MediaDestination|null} [importDestination] EM_ImportOptions importDestination
         * @property {ptsl.MediaLocation|null} [importLocation] EM_ImportOptions importLocation
         * @property {number|null} [gapsBetweenClips] EM_ImportOptions gapsBetweenClips
         * @property {ptsl.TripleBool|null} [importAudioFromFile] EM_ImportOptions importAudioFromFile
         * @property {ptsl.TripleBool|null} [removeExistingVideoTracks] EM_ImportOptions removeExistingVideoTracks
         * @property {ptsl.TripleBool|null} [removeExistingVideoClips] EM_ImportOptions removeExistingVideoClips
         * @property {ptsl.TripleBool|null} [clearDestinationVideoTrackPlaylist] EM_ImportOptions clearDestinationVideoTrackPlaylist
         */

        /**
         * Constructs a new EM_ImportOptions.
         * @memberof ptsl
         * @classdesc Structure that describes information for import options if importAfterBounce is true.
         * @implements IEM_ImportOptions
         * @constructor
         * @param {ptsl.IEM_ImportOptions=} [properties] Properties to set
         */
        function EM_ImportOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EM_ImportOptions importDestination.
         * @member {ptsl.MediaDestination} importDestination
         * @memberof ptsl.EM_ImportOptions
         * @instance
         */
        EM_ImportOptions.prototype.importDestination = 0;

        /**
         * EM_ImportOptions importLocation.
         * @member {ptsl.MediaLocation} importLocation
         * @memberof ptsl.EM_ImportOptions
         * @instance
         */
        EM_ImportOptions.prototype.importLocation = 0;

        /**
         * EM_ImportOptions gapsBetweenClips.
         * @member {number} gapsBetweenClips
         * @memberof ptsl.EM_ImportOptions
         * @instance
         */
        EM_ImportOptions.prototype.gapsBetweenClips = 0;

        /**
         * EM_ImportOptions importAudioFromFile.
         * @member {ptsl.TripleBool} importAudioFromFile
         * @memberof ptsl.EM_ImportOptions
         * @instance
         */
        EM_ImportOptions.prototype.importAudioFromFile = 0;

        /**
         * EM_ImportOptions removeExistingVideoTracks.
         * @member {ptsl.TripleBool} removeExistingVideoTracks
         * @memberof ptsl.EM_ImportOptions
         * @instance
         */
        EM_ImportOptions.prototype.removeExistingVideoTracks = 0;

        /**
         * EM_ImportOptions removeExistingVideoClips.
         * @member {ptsl.TripleBool} removeExistingVideoClips
         * @memberof ptsl.EM_ImportOptions
         * @instance
         */
        EM_ImportOptions.prototype.removeExistingVideoClips = 0;

        /**
         * EM_ImportOptions clearDestinationVideoTrackPlaylist.
         * @member {ptsl.TripleBool} clearDestinationVideoTrackPlaylist
         * @memberof ptsl.EM_ImportOptions
         * @instance
         */
        EM_ImportOptions.prototype.clearDestinationVideoTrackPlaylist = 0;

        /**
         * Creates a new EM_ImportOptions instance using the specified properties.
         * @function create
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {ptsl.IEM_ImportOptions=} [properties] Properties to set
         * @returns {ptsl.EM_ImportOptions} EM_ImportOptions instance
         */
        EM_ImportOptions.create = function create(properties) {
            return new EM_ImportOptions(properties);
        };

        /**
         * Encodes the specified EM_ImportOptions message. Does not implicitly {@link ptsl.EM_ImportOptions.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {ptsl.IEM_ImportOptions} message EM_ImportOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_ImportOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.importDestination != null && Object.hasOwnProperty.call(message, "importDestination"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.importDestination);
            if (message.importLocation != null && Object.hasOwnProperty.call(message, "importLocation"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.importLocation);
            if (message.gapsBetweenClips != null && Object.hasOwnProperty.call(message, "gapsBetweenClips"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.gapsBetweenClips);
            if (message.importAudioFromFile != null && Object.hasOwnProperty.call(message, "importAudioFromFile"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.importAudioFromFile);
            if (message.removeExistingVideoTracks != null && Object.hasOwnProperty.call(message, "removeExistingVideoTracks"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.removeExistingVideoTracks);
            if (message.removeExistingVideoClips != null && Object.hasOwnProperty.call(message, "removeExistingVideoClips"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.removeExistingVideoClips);
            if (message.clearDestinationVideoTrackPlaylist != null && Object.hasOwnProperty.call(message, "clearDestinationVideoTrackPlaylist"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.clearDestinationVideoTrackPlaylist);
            return writer;
        };

        /**
         * Encodes the specified EM_ImportOptions message, length delimited. Does not implicitly {@link ptsl.EM_ImportOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {ptsl.IEM_ImportOptions} message EM_ImportOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_ImportOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a EM_ImportOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EM_ImportOptions} EM_ImportOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_ImportOptions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EM_ImportOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.importDestination = reader.int32();
                        break;
                    }
                case 2: {
                        message.importLocation = reader.int32();
                        break;
                    }
                case 3: {
                        message.gapsBetweenClips = reader.int32();
                        break;
                    }
                case 4: {
                        message.importAudioFromFile = reader.int32();
                        break;
                    }
                case 5: {
                        message.removeExistingVideoTracks = reader.int32();
                        break;
                    }
                case 6: {
                        message.removeExistingVideoClips = reader.int32();
                        break;
                    }
                case 7: {
                        message.clearDestinationVideoTrackPlaylist = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a EM_ImportOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EM_ImportOptions} EM_ImportOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_ImportOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a EM_ImportOptions message.
         * @function verify
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EM_ImportOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.importDestination != null && message.hasOwnProperty("importDestination"))
                switch (message.importDestination) {
                default:
                    return "importDestination: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.importLocation != null && message.hasOwnProperty("importLocation"))
                switch (message.importLocation) {
                default:
                    return "importLocation: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.gapsBetweenClips != null && message.hasOwnProperty("gapsBetweenClips"))
                if (!$util.isInteger(message.gapsBetweenClips))
                    return "gapsBetweenClips: integer expected";
            if (message.importAudioFromFile != null && message.hasOwnProperty("importAudioFromFile"))
                switch (message.importAudioFromFile) {
                default:
                    return "importAudioFromFile: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.removeExistingVideoTracks != null && message.hasOwnProperty("removeExistingVideoTracks"))
                switch (message.removeExistingVideoTracks) {
                default:
                    return "removeExistingVideoTracks: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.removeExistingVideoClips != null && message.hasOwnProperty("removeExistingVideoClips"))
                switch (message.removeExistingVideoClips) {
                default:
                    return "removeExistingVideoClips: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.clearDestinationVideoTrackPlaylist != null && message.hasOwnProperty("clearDestinationVideoTrackPlaylist"))
                switch (message.clearDestinationVideoTrackPlaylist) {
                default:
                    return "clearDestinationVideoTrackPlaylist: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a EM_ImportOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EM_ImportOptions} EM_ImportOptions
         */
        EM_ImportOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EM_ImportOptions)
                return object;
            var message = new $root.ptsl.EM_ImportOptions();
            switch (object.importDestination) {
            default:
                if (typeof object.importDestination === "number") {
                    message.importDestination = object.importDestination;
                    break;
                }
                break;
            case "MDestination_Unknown":
            case 0:
                message.importDestination = 0;
                break;
            case "MD_None":
            case 1:
                message.importDestination = 1;
                break;
            case "MDestination_None":
            case 1:
                message.importDestination = 1;
                break;
            case "MD_MainVideoTrack":
            case 2:
                message.importDestination = 2;
                break;
            case "MDestination_MainVideoTrack":
            case 2:
                message.importDestination = 2;
                break;
            case "MD_NewTrack":
            case 3:
                message.importDestination = 3;
                break;
            case "MDestination_NewTrack":
            case 3:
                message.importDestination = 3;
                break;
            case "MD_ClipList":
            case 4:
                message.importDestination = 4;
                break;
            case "MDestination_ClipList":
            case 4:
                message.importDestination = 4;
                break;
            }
            switch (object.importLocation) {
            default:
                if (typeof object.importLocation === "number") {
                    message.importLocation = object.importLocation;
                    break;
                }
                break;
            case "MLocation_Unknown":
            case 0:
                message.importLocation = 0;
                break;
            case "ML_None":
            case 1:
                message.importLocation = 1;
                break;
            case "MLocation_None":
            case 1:
                message.importLocation = 1;
                break;
            case "ML_SessionStart":
            case 2:
                message.importLocation = 2;
                break;
            case "MLocation_SessionStart":
            case 2:
                message.importLocation = 2;
                break;
            case "ML_SongStart":
            case 3:
                message.importLocation = 3;
                break;
            case "MLocation_SongStart":
            case 3:
                message.importLocation = 3;
                break;
            case "ML_Selection":
            case 4:
                message.importLocation = 4;
                break;
            case "MLocation_Selection":
            case 4:
                message.importLocation = 4;
                break;
            case "ML_Spot":
            case 5:
                message.importLocation = 5;
                break;
            case "MLocation_Spot":
            case 5:
                message.importLocation = 5;
                break;
            }
            if (object.gapsBetweenClips != null)
                message.gapsBetweenClips = object.gapsBetweenClips | 0;
            switch (object.importAudioFromFile) {
            default:
                if (typeof object.importAudioFromFile === "number") {
                    message.importAudioFromFile = object.importAudioFromFile;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.importAudioFromFile = 0;
                break;
            case "TB_None":
            case 1:
                message.importAudioFromFile = 1;
                break;
            case "TBool_None":
            case 1:
                message.importAudioFromFile = 1;
                break;
            case "TB_False":
            case 2:
                message.importAudioFromFile = 2;
                break;
            case "TBool_False":
            case 2:
                message.importAudioFromFile = 2;
                break;
            case "TB_True":
            case 3:
                message.importAudioFromFile = 3;
                break;
            case "TBool_True":
            case 3:
                message.importAudioFromFile = 3;
                break;
            }
            switch (object.removeExistingVideoTracks) {
            default:
                if (typeof object.removeExistingVideoTracks === "number") {
                    message.removeExistingVideoTracks = object.removeExistingVideoTracks;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.removeExistingVideoTracks = 0;
                break;
            case "TB_None":
            case 1:
                message.removeExistingVideoTracks = 1;
                break;
            case "TBool_None":
            case 1:
                message.removeExistingVideoTracks = 1;
                break;
            case "TB_False":
            case 2:
                message.removeExistingVideoTracks = 2;
                break;
            case "TBool_False":
            case 2:
                message.removeExistingVideoTracks = 2;
                break;
            case "TB_True":
            case 3:
                message.removeExistingVideoTracks = 3;
                break;
            case "TBool_True":
            case 3:
                message.removeExistingVideoTracks = 3;
                break;
            }
            switch (object.removeExistingVideoClips) {
            default:
                if (typeof object.removeExistingVideoClips === "number") {
                    message.removeExistingVideoClips = object.removeExistingVideoClips;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.removeExistingVideoClips = 0;
                break;
            case "TB_None":
            case 1:
                message.removeExistingVideoClips = 1;
                break;
            case "TBool_None":
            case 1:
                message.removeExistingVideoClips = 1;
                break;
            case "TB_False":
            case 2:
                message.removeExistingVideoClips = 2;
                break;
            case "TBool_False":
            case 2:
                message.removeExistingVideoClips = 2;
                break;
            case "TB_True":
            case 3:
                message.removeExistingVideoClips = 3;
                break;
            case "TBool_True":
            case 3:
                message.removeExistingVideoClips = 3;
                break;
            }
            switch (object.clearDestinationVideoTrackPlaylist) {
            default:
                if (typeof object.clearDestinationVideoTrackPlaylist === "number") {
                    message.clearDestinationVideoTrackPlaylist = object.clearDestinationVideoTrackPlaylist;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.clearDestinationVideoTrackPlaylist = 0;
                break;
            case "TB_None":
            case 1:
                message.clearDestinationVideoTrackPlaylist = 1;
                break;
            case "TBool_None":
            case 1:
                message.clearDestinationVideoTrackPlaylist = 1;
                break;
            case "TB_False":
            case 2:
                message.clearDestinationVideoTrackPlaylist = 2;
                break;
            case "TBool_False":
            case 2:
                message.clearDestinationVideoTrackPlaylist = 2;
                break;
            case "TB_True":
            case 3:
                message.clearDestinationVideoTrackPlaylist = 3;
                break;
            case "TBool_True":
            case 3:
                message.clearDestinationVideoTrackPlaylist = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a EM_ImportOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {ptsl.EM_ImportOptions} message EM_ImportOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EM_ImportOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.importDestination = options.enums === String ? "MDestination_Unknown" : 0;
                object.importLocation = options.enums === String ? "MLocation_Unknown" : 0;
                object.gapsBetweenClips = 0;
                object.importAudioFromFile = options.enums === String ? "TBool_Unknown" : 0;
                object.removeExistingVideoTracks = options.enums === String ? "TBool_Unknown" : 0;
                object.removeExistingVideoClips = options.enums === String ? "TBool_Unknown" : 0;
                object.clearDestinationVideoTrackPlaylist = options.enums === String ? "TBool_Unknown" : 0;
            }
            if (message.importDestination != null && message.hasOwnProperty("importDestination"))
                object.importDestination = options.enums === String ? $root.ptsl.MediaDestination[message.importDestination] === undefined ? message.importDestination : $root.ptsl.MediaDestination[message.importDestination] : message.importDestination;
            if (message.importLocation != null && message.hasOwnProperty("importLocation"))
                object.importLocation = options.enums === String ? $root.ptsl.MediaLocation[message.importLocation] === undefined ? message.importLocation : $root.ptsl.MediaLocation[message.importLocation] : message.importLocation;
            if (message.gapsBetweenClips != null && message.hasOwnProperty("gapsBetweenClips"))
                object.gapsBetweenClips = message.gapsBetweenClips;
            if (message.importAudioFromFile != null && message.hasOwnProperty("importAudioFromFile"))
                object.importAudioFromFile = options.enums === String ? $root.ptsl.TripleBool[message.importAudioFromFile] === undefined ? message.importAudioFromFile : $root.ptsl.TripleBool[message.importAudioFromFile] : message.importAudioFromFile;
            if (message.removeExistingVideoTracks != null && message.hasOwnProperty("removeExistingVideoTracks"))
                object.removeExistingVideoTracks = options.enums === String ? $root.ptsl.TripleBool[message.removeExistingVideoTracks] === undefined ? message.removeExistingVideoTracks : $root.ptsl.TripleBool[message.removeExistingVideoTracks] : message.removeExistingVideoTracks;
            if (message.removeExistingVideoClips != null && message.hasOwnProperty("removeExistingVideoClips"))
                object.removeExistingVideoClips = options.enums === String ? $root.ptsl.TripleBool[message.removeExistingVideoClips] === undefined ? message.removeExistingVideoClips : $root.ptsl.TripleBool[message.removeExistingVideoClips] : message.removeExistingVideoClips;
            if (message.clearDestinationVideoTrackPlaylist != null && message.hasOwnProperty("clearDestinationVideoTrackPlaylist"))
                object.clearDestinationVideoTrackPlaylist = options.enums === String ? $root.ptsl.TripleBool[message.clearDestinationVideoTrackPlaylist] === undefined ? message.clearDestinationVideoTrackPlaylist : $root.ptsl.TripleBool[message.clearDestinationVideoTrackPlaylist] : message.clearDestinationVideoTrackPlaylist;
            return object;
        };

        /**
         * Converts this EM_ImportOptions to JSON.
         * @function toJSON
         * @memberof ptsl.EM_ImportOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EM_ImportOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EM_ImportOptions
         * @function getTypeUrl
         * @memberof ptsl.EM_ImportOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EM_ImportOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EM_ImportOptions";
        };

        return EM_ImportOptions;
    })();

    ptsl.EM_LocationInfo = (function() {

        /**
         * Properties of a EM_LocationInfo.
         * @memberof ptsl
         * @interface IEM_LocationInfo
         * @property {ptsl.TripleBool|null} [importAfterBounce] EM_LocationInfo importAfterBounce
         * @property {ptsl.IEM_ImportOptions|null} [importOptions] EM_LocationInfo importOptions
         * @property {ptsl.EM_FileDestination|null} [fileDestination] EM_LocationInfo fileDestination
         * @property {string|null} [directory] * Depending on the file_destination value, this field can be either:
         * * - directory relative to the session directory (if file_destination is EMFDestination_SessionFolder)
         * * - absolute path to a directory (if file_destination is EMFDestination_Directory)
         */

        /**
         * Constructs a new EM_LocationInfo.
         * @memberof ptsl
         * @classdesc Structure that describes information for location section in the Bounce Mix window.
         * @implements IEM_LocationInfo
         * @constructor
         * @param {ptsl.IEM_LocationInfo=} [properties] Properties to set
         */
        function EM_LocationInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EM_LocationInfo importAfterBounce.
         * @member {ptsl.TripleBool} importAfterBounce
         * @memberof ptsl.EM_LocationInfo
         * @instance
         */
        EM_LocationInfo.prototype.importAfterBounce = 0;

        /**
         * EM_LocationInfo importOptions.
         * @member {ptsl.IEM_ImportOptions|null|undefined} importOptions
         * @memberof ptsl.EM_LocationInfo
         * @instance
         */
        EM_LocationInfo.prototype.importOptions = null;

        /**
         * EM_LocationInfo fileDestination.
         * @member {ptsl.EM_FileDestination} fileDestination
         * @memberof ptsl.EM_LocationInfo
         * @instance
         */
        EM_LocationInfo.prototype.fileDestination = 0;

        /**
         * * Depending on the file_destination value, this field can be either:
         * * - directory relative to the session directory (if file_destination is EMFDestination_SessionFolder)
         * * - absolute path to a directory (if file_destination is EMFDestination_Directory)
         * @member {string} directory
         * @memberof ptsl.EM_LocationInfo
         * @instance
         */
        EM_LocationInfo.prototype.directory = "";

        /**
         * Creates a new EM_LocationInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {ptsl.IEM_LocationInfo=} [properties] Properties to set
         * @returns {ptsl.EM_LocationInfo} EM_LocationInfo instance
         */
        EM_LocationInfo.create = function create(properties) {
            return new EM_LocationInfo(properties);
        };

        /**
         * Encodes the specified EM_LocationInfo message. Does not implicitly {@link ptsl.EM_LocationInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {ptsl.IEM_LocationInfo} message EM_LocationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_LocationInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.importAfterBounce != null && Object.hasOwnProperty.call(message, "importAfterBounce"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.importAfterBounce);
            if (message.importOptions != null && Object.hasOwnProperty.call(message, "importOptions"))
                $root.ptsl.EM_ImportOptions.encode(message.importOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.fileDestination != null && Object.hasOwnProperty.call(message, "fileDestination"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fileDestination);
            if (message.directory != null && Object.hasOwnProperty.call(message, "directory"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.directory);
            return writer;
        };

        /**
         * Encodes the specified EM_LocationInfo message, length delimited. Does not implicitly {@link ptsl.EM_LocationInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {ptsl.IEM_LocationInfo} message EM_LocationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_LocationInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a EM_LocationInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EM_LocationInfo} EM_LocationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_LocationInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EM_LocationInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.importAfterBounce = reader.int32();
                        break;
                    }
                case 2: {
                        message.importOptions = $root.ptsl.EM_ImportOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.fileDestination = reader.int32();
                        break;
                    }
                case 4: {
                        message.directory = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a EM_LocationInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EM_LocationInfo} EM_LocationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_LocationInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a EM_LocationInfo message.
         * @function verify
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EM_LocationInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.importAfterBounce != null && message.hasOwnProperty("importAfterBounce"))
                switch (message.importAfterBounce) {
                default:
                    return "importAfterBounce: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.importOptions != null && message.hasOwnProperty("importOptions")) {
                var error = $root.ptsl.EM_ImportOptions.verify(message.importOptions);
                if (error)
                    return "importOptions." + error;
            }
            if (message.fileDestination != null && message.hasOwnProperty("fileDestination"))
                switch (message.fileDestination) {
                default:
                    return "fileDestination: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.directory != null && message.hasOwnProperty("directory"))
                if (!$util.isString(message.directory))
                    return "directory: string expected";
            return null;
        };

        /**
         * Creates a EM_LocationInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EM_LocationInfo} EM_LocationInfo
         */
        EM_LocationInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EM_LocationInfo)
                return object;
            var message = new $root.ptsl.EM_LocationInfo();
            switch (object.importAfterBounce) {
            default:
                if (typeof object.importAfterBounce === "number") {
                    message.importAfterBounce = object.importAfterBounce;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.importAfterBounce = 0;
                break;
            case "TB_None":
            case 1:
                message.importAfterBounce = 1;
                break;
            case "TBool_None":
            case 1:
                message.importAfterBounce = 1;
                break;
            case "TB_False":
            case 2:
                message.importAfterBounce = 2;
                break;
            case "TBool_False":
            case 2:
                message.importAfterBounce = 2;
                break;
            case "TB_True":
            case 3:
                message.importAfterBounce = 3;
                break;
            case "TBool_True":
            case 3:
                message.importAfterBounce = 3;
                break;
            }
            if (object.importOptions != null) {
                if (typeof object.importOptions !== "object")
                    throw TypeError(".ptsl.EM_LocationInfo.importOptions: object expected");
                message.importOptions = $root.ptsl.EM_ImportOptions.fromObject(object.importOptions);
            }
            switch (object.fileDestination) {
            default:
                if (typeof object.fileDestination === "number") {
                    message.fileDestination = object.fileDestination;
                    break;
                }
                break;
            case "EMFDestination_Unknown":
            case 0:
                message.fileDestination = 0;
                break;
            case "EM_FD_None":
            case 1:
                message.fileDestination = 1;
                break;
            case "EMFDestination_None":
            case 1:
                message.fileDestination = 1;
                break;
            case "EM_FD_SessionFolder":
            case 2:
                message.fileDestination = 2;
                break;
            case "EMFDestination_SessionFolder":
            case 2:
                message.fileDestination = 2;
                break;
            case "EM_FD_Directory":
            case 3:
                message.fileDestination = 3;
                break;
            case "EMFDestination_Directory":
            case 3:
                message.fileDestination = 3;
                break;
            }
            if (object.directory != null)
                message.directory = String(object.directory);
            return message;
        };

        /**
         * Creates a plain object from a EM_LocationInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {ptsl.EM_LocationInfo} message EM_LocationInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EM_LocationInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.importAfterBounce = options.enums === String ? "TBool_Unknown" : 0;
                object.importOptions = null;
                object.fileDestination = options.enums === String ? "EMFDestination_Unknown" : 0;
                object.directory = "";
            }
            if (message.importAfterBounce != null && message.hasOwnProperty("importAfterBounce"))
                object.importAfterBounce = options.enums === String ? $root.ptsl.TripleBool[message.importAfterBounce] === undefined ? message.importAfterBounce : $root.ptsl.TripleBool[message.importAfterBounce] : message.importAfterBounce;
            if (message.importOptions != null && message.hasOwnProperty("importOptions"))
                object.importOptions = $root.ptsl.EM_ImportOptions.toObject(message.importOptions, options);
            if (message.fileDestination != null && message.hasOwnProperty("fileDestination"))
                object.fileDestination = options.enums === String ? $root.ptsl.EM_FileDestination[message.fileDestination] === undefined ? message.fileDestination : $root.ptsl.EM_FileDestination[message.fileDestination] : message.fileDestination;
            if (message.directory != null && message.hasOwnProperty("directory"))
                object.directory = message.directory;
            return object;
        };

        /**
         * Converts this EM_LocationInfo to JSON.
         * @function toJSON
         * @memberof ptsl.EM_LocationInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EM_LocationInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EM_LocationInfo
         * @function getTypeUrl
         * @memberof ptsl.EM_LocationInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EM_LocationInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EM_LocationInfo";
        };

        return EM_LocationInfo;
    })();

    ptsl.EM_DolbyAtmosInfo = (function() {

        /**
         * Properties of a EM_DolbyAtmosInfo.
         * @memberof ptsl
         * @interface IEM_DolbyAtmosInfo
         * @property {ptsl.TripleBool|null} [addFirstFrameOfAction] EM_DolbyAtmosInfo addFirstFrameOfAction
         * @property {string|null} [timecodeValue] EM_DolbyAtmosInfo timecodeValue
         * @property {number|null} [frameRate] EM_DolbyAtmosInfo frameRate
         * @property {Array.<ptsl.IPropertyContainer>|null} [propertyList] EM_DolbyAtmosInfo propertyList
         */

        /**
         * Constructs a new EM_DolbyAtmosInfo.
         * @memberof ptsl
         * @classdesc Structure that describes information for dolby atmos section in the Bounce Mix window.
         * @implements IEM_DolbyAtmosInfo
         * @constructor
         * @param {ptsl.IEM_DolbyAtmosInfo=} [properties] Properties to set
         */
        function EM_DolbyAtmosInfo(properties) {
            this.propertyList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EM_DolbyAtmosInfo addFirstFrameOfAction.
         * @member {ptsl.TripleBool} addFirstFrameOfAction
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @instance
         */
        EM_DolbyAtmosInfo.prototype.addFirstFrameOfAction = 0;

        /**
         * EM_DolbyAtmosInfo timecodeValue.
         * @member {string} timecodeValue
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @instance
         */
        EM_DolbyAtmosInfo.prototype.timecodeValue = "";

        /**
         * EM_DolbyAtmosInfo frameRate.
         * @member {number} frameRate
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @instance
         */
        EM_DolbyAtmosInfo.prototype.frameRate = 0;

        /**
         * EM_DolbyAtmosInfo propertyList.
         * @member {Array.<ptsl.IPropertyContainer>} propertyList
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @instance
         */
        EM_DolbyAtmosInfo.prototype.propertyList = $util.emptyArray;

        /**
         * Creates a new EM_DolbyAtmosInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {ptsl.IEM_DolbyAtmosInfo=} [properties] Properties to set
         * @returns {ptsl.EM_DolbyAtmosInfo} EM_DolbyAtmosInfo instance
         */
        EM_DolbyAtmosInfo.create = function create(properties) {
            return new EM_DolbyAtmosInfo(properties);
        };

        /**
         * Encodes the specified EM_DolbyAtmosInfo message. Does not implicitly {@link ptsl.EM_DolbyAtmosInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {ptsl.IEM_DolbyAtmosInfo} message EM_DolbyAtmosInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_DolbyAtmosInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addFirstFrameOfAction != null && Object.hasOwnProperty.call(message, "addFirstFrameOfAction"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.addFirstFrameOfAction);
            if (message.timecodeValue != null && Object.hasOwnProperty.call(message, "timecodeValue"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.timecodeValue);
            if (message.frameRate != null && Object.hasOwnProperty.call(message, "frameRate"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.frameRate);
            if (message.propertyList != null && message.propertyList.length)
                for (var i = 0; i < message.propertyList.length; ++i)
                    $root.ptsl.PropertyContainer.encode(message.propertyList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EM_DolbyAtmosInfo message, length delimited. Does not implicitly {@link ptsl.EM_DolbyAtmosInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {ptsl.IEM_DolbyAtmosInfo} message EM_DolbyAtmosInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EM_DolbyAtmosInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a EM_DolbyAtmosInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EM_DolbyAtmosInfo} EM_DolbyAtmosInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_DolbyAtmosInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EM_DolbyAtmosInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.addFirstFrameOfAction = reader.int32();
                        break;
                    }
                case 2: {
                        message.timecodeValue = reader.string();
                        break;
                    }
                case 3: {
                        message.frameRate = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.propertyList && message.propertyList.length))
                            message.propertyList = [];
                        message.propertyList.push($root.ptsl.PropertyContainer.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a EM_DolbyAtmosInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EM_DolbyAtmosInfo} EM_DolbyAtmosInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EM_DolbyAtmosInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a EM_DolbyAtmosInfo message.
         * @function verify
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EM_DolbyAtmosInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addFirstFrameOfAction != null && message.hasOwnProperty("addFirstFrameOfAction"))
                switch (message.addFirstFrameOfAction) {
                default:
                    return "addFirstFrameOfAction: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.timecodeValue != null && message.hasOwnProperty("timecodeValue"))
                if (!$util.isString(message.timecodeValue))
                    return "timecodeValue: string expected";
            if (message.frameRate != null && message.hasOwnProperty("frameRate"))
                if (!$util.isInteger(message.frameRate))
                    return "frameRate: integer expected";
            if (message.propertyList != null && message.hasOwnProperty("propertyList")) {
                if (!Array.isArray(message.propertyList))
                    return "propertyList: array expected";
                for (var i = 0; i < message.propertyList.length; ++i) {
                    var error = $root.ptsl.PropertyContainer.verify(message.propertyList[i]);
                    if (error)
                        return "propertyList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a EM_DolbyAtmosInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EM_DolbyAtmosInfo} EM_DolbyAtmosInfo
         */
        EM_DolbyAtmosInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EM_DolbyAtmosInfo)
                return object;
            var message = new $root.ptsl.EM_DolbyAtmosInfo();
            switch (object.addFirstFrameOfAction) {
            default:
                if (typeof object.addFirstFrameOfAction === "number") {
                    message.addFirstFrameOfAction = object.addFirstFrameOfAction;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.addFirstFrameOfAction = 0;
                break;
            case "TB_None":
            case 1:
                message.addFirstFrameOfAction = 1;
                break;
            case "TBool_None":
            case 1:
                message.addFirstFrameOfAction = 1;
                break;
            case "TB_False":
            case 2:
                message.addFirstFrameOfAction = 2;
                break;
            case "TBool_False":
            case 2:
                message.addFirstFrameOfAction = 2;
                break;
            case "TB_True":
            case 3:
                message.addFirstFrameOfAction = 3;
                break;
            case "TBool_True":
            case 3:
                message.addFirstFrameOfAction = 3;
                break;
            }
            if (object.timecodeValue != null)
                message.timecodeValue = String(object.timecodeValue);
            if (object.frameRate != null)
                message.frameRate = object.frameRate | 0;
            if (object.propertyList) {
                if (!Array.isArray(object.propertyList))
                    throw TypeError(".ptsl.EM_DolbyAtmosInfo.propertyList: array expected");
                message.propertyList = [];
                for (var i = 0; i < object.propertyList.length; ++i) {
                    if (typeof object.propertyList[i] !== "object")
                        throw TypeError(".ptsl.EM_DolbyAtmosInfo.propertyList: object expected");
                    message.propertyList[i] = $root.ptsl.PropertyContainer.fromObject(object.propertyList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a EM_DolbyAtmosInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {ptsl.EM_DolbyAtmosInfo} message EM_DolbyAtmosInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EM_DolbyAtmosInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.propertyList = [];
            if (options.defaults) {
                object.addFirstFrameOfAction = options.enums === String ? "TBool_Unknown" : 0;
                object.timecodeValue = "";
                object.frameRate = 0;
            }
            if (message.addFirstFrameOfAction != null && message.hasOwnProperty("addFirstFrameOfAction"))
                object.addFirstFrameOfAction = options.enums === String ? $root.ptsl.TripleBool[message.addFirstFrameOfAction] === undefined ? message.addFirstFrameOfAction : $root.ptsl.TripleBool[message.addFirstFrameOfAction] : message.addFirstFrameOfAction;
            if (message.timecodeValue != null && message.hasOwnProperty("timecodeValue"))
                object.timecodeValue = message.timecodeValue;
            if (message.frameRate != null && message.hasOwnProperty("frameRate"))
                object.frameRate = message.frameRate;
            if (message.propertyList && message.propertyList.length) {
                object.propertyList = [];
                for (var j = 0; j < message.propertyList.length; ++j)
                    object.propertyList[j] = $root.ptsl.PropertyContainer.toObject(message.propertyList[j], options);
            }
            return object;
        };

        /**
         * Converts this EM_DolbyAtmosInfo to JSON.
         * @function toJSON
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EM_DolbyAtmosInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EM_DolbyAtmosInfo
         * @function getTypeUrl
         * @memberof ptsl.EM_DolbyAtmosInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EM_DolbyAtmosInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EM_DolbyAtmosInfo";
        };

        return EM_DolbyAtmosInfo;
    })();

    /**
     * MP3 encoding options constant bit rate.
     * @since Pro Tools 2025.06
     * @name ptsl.MP3EncodingOptionsConstantBitRate
     * @enum {number}
     * @property {number} MP3EOCBRate_Unknown=0 MP3EOCBRate_Unknown value
     * @property {number} MP3EOCBRate_320kbps=320000 MP3EOCBRate_320kbps value
     * @property {number} MP3EOCBRate_256kbps=256000 MP3EOCBRate_256kbps value
     * @property {number} MP3EOCBRate_224kbps=224000 MP3EOCBRate_224kbps value
     * @property {number} MP3EOCBRate_192kbps=192000 MP3EOCBRate_192kbps value
     * @property {number} MP3EOCBRate_160kbps=160000 MP3EOCBRate_160kbps value
     * @property {number} MP3EOCBRate_128kbps=128000 MP3EOCBRate_128kbps value
     * @property {number} MP3EOCBRate_112kbps=112000 MP3EOCBRate_112kbps value
     * @property {number} MP3EOCBRate_96kbps=96000 MP3EOCBRate_96kbps value
     * @property {number} MP3EOCBRate_80kbps=80000 MP3EOCBRate_80kbps value
     * @property {number} MP3EOCBRate_64kbps=64000 MP3EOCBRate_64kbps value
     * @property {number} MP3EOCBRate_56kbps=56000 MP3EOCBRate_56kbps value
     * @property {number} MP3EOCBRate_48kbps=48000 MP3EOCBRate_48kbps value
     * @property {number} MP3EOCBRate_40kbps=40000 MP3EOCBRate_40kbps value
     * @property {number} MP3EOCBRate_32kbps=32000 MP3EOCBRate_32kbps value
     * @property {number} MP3EOCBRate_24kbps=24000 MP3EOCBRate_24kbps value
     * @property {number} MP3EOCBRate_20kbps=20000 MP3EOCBRate_20kbps value
     * @property {number} MP3EOCBRate_18kbps=18000 MP3EOCBRate_18kbps value
     * @property {number} MP3EOCBRate_16kbps=16000 MP3EOCBRate_16kbps value
     */
    ptsl.MP3EncodingOptionsConstantBitRate = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MP3EOCBRate_Unknown"] = 0;
        values[valuesById[320000] = "MP3EOCBRate_320kbps"] = 320000;
        values[valuesById[256000] = "MP3EOCBRate_256kbps"] = 256000;
        values[valuesById[224000] = "MP3EOCBRate_224kbps"] = 224000;
        values[valuesById[192000] = "MP3EOCBRate_192kbps"] = 192000;
        values[valuesById[160000] = "MP3EOCBRate_160kbps"] = 160000;
        values[valuesById[128000] = "MP3EOCBRate_128kbps"] = 128000;
        values[valuesById[112000] = "MP3EOCBRate_112kbps"] = 112000;
        values[valuesById[96000] = "MP3EOCBRate_96kbps"] = 96000;
        values[valuesById[80000] = "MP3EOCBRate_80kbps"] = 80000;
        values[valuesById[64000] = "MP3EOCBRate_64kbps"] = 64000;
        values[valuesById[56000] = "MP3EOCBRate_56kbps"] = 56000;
        values[valuesById[48000] = "MP3EOCBRate_48kbps"] = 48000;
        values[valuesById[40000] = "MP3EOCBRate_40kbps"] = 40000;
        values[valuesById[32000] = "MP3EOCBRate_32kbps"] = 32000;
        values[valuesById[24000] = "MP3EOCBRate_24kbps"] = 24000;
        values[valuesById[20000] = "MP3EOCBRate_20kbps"] = 20000;
        values[valuesById[18000] = "MP3EOCBRate_18kbps"] = 18000;
        values[valuesById[16000] = "MP3EOCBRate_16kbps"] = 16000;
        return values;
    })();

    /**
     * MP3 encoding options quality.
     * @since Pro Tools 2025.06
     * @name ptsl.MP3EncodingOptionsQuality
     * @enum {number}
     * @property {number} MP3EOQuality_Unknown=0 MP3EOQuality_Unknown value
     * @property {number} MP3EOQuality_Low=1 MP3EOQuality_Low value
     * @property {number} MP3EOQuality_Highest=2 MP3EOQuality_Highest value
     */
    ptsl.MP3EncodingOptionsQuality = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MP3EOQuality_Unknown"] = 0;
        values[valuesById[1] = "MP3EOQuality_Low"] = 1;
        values[valuesById[2] = "MP3EOQuality_Highest"] = 2;
        return values;
    })();

    ptsl.MP3EncodingOptions = (function() {

        /**
         * Properties of a MP3EncodingOptions.
         * @memberof ptsl
         * @interface IMP3EncodingOptions
         * @property {ptsl.MP3EncodingOptionsConstantBitRate|null} [bitRate] MP3EncodingOptions bitRate
         * @property {ptsl.MP3EncodingOptionsQuality|null} [quality] MP3EncodingOptions quality
         */

        /**
         * Constructs a new MP3EncodingOptions.
         * @memberof ptsl
         * @classdesc Structure that describes MP3 encoding options.
         * @since Pro Tools 2025.06
         * @implements IMP3EncodingOptions
         * @constructor
         * @param {ptsl.IMP3EncodingOptions=} [properties] Properties to set
         */
        function MP3EncodingOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MP3EncodingOptions bitRate.
         * @member {ptsl.MP3EncodingOptionsConstantBitRate} bitRate
         * @memberof ptsl.MP3EncodingOptions
         * @instance
         */
        MP3EncodingOptions.prototype.bitRate = 0;

        /**
         * MP3EncodingOptions quality.
         * @member {ptsl.MP3EncodingOptionsQuality} quality
         * @memberof ptsl.MP3EncodingOptions
         * @instance
         */
        MP3EncodingOptions.prototype.quality = 0;

        /**
         * Creates a new MP3EncodingOptions instance using the specified properties.
         * @function create
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {ptsl.IMP3EncodingOptions=} [properties] Properties to set
         * @returns {ptsl.MP3EncodingOptions} MP3EncodingOptions instance
         */
        MP3EncodingOptions.create = function create(properties) {
            return new MP3EncodingOptions(properties);
        };

        /**
         * Encodes the specified MP3EncodingOptions message. Does not implicitly {@link ptsl.MP3EncodingOptions.verify|verify} messages.
         * @function encode
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {ptsl.IMP3EncodingOptions} message MP3EncodingOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MP3EncodingOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bitRate != null && Object.hasOwnProperty.call(message, "bitRate"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bitRate);
            if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.quality);
            return writer;
        };

        /**
         * Encodes the specified MP3EncodingOptions message, length delimited. Does not implicitly {@link ptsl.MP3EncodingOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {ptsl.IMP3EncodingOptions} message MP3EncodingOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MP3EncodingOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MP3EncodingOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.MP3EncodingOptions} MP3EncodingOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MP3EncodingOptions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.MP3EncodingOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.bitRate = reader.int32();
                        break;
                    }
                case 2: {
                        message.quality = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MP3EncodingOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.MP3EncodingOptions} MP3EncodingOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MP3EncodingOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MP3EncodingOptions message.
         * @function verify
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MP3EncodingOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bitRate != null && message.hasOwnProperty("bitRate"))
                switch (message.bitRate) {
                default:
                    return "bitRate: enum value expected";
                case 0:
                case 320000:
                case 256000:
                case 224000:
                case 192000:
                case 160000:
                case 128000:
                case 112000:
                case 96000:
                case 80000:
                case 64000:
                case 56000:
                case 48000:
                case 40000:
                case 32000:
                case 24000:
                case 20000:
                case 18000:
                case 16000:
                    break;
                }
            if (message.quality != null && message.hasOwnProperty("quality"))
                switch (message.quality) {
                default:
                    return "quality: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a MP3EncodingOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.MP3EncodingOptions} MP3EncodingOptions
         */
        MP3EncodingOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.MP3EncodingOptions)
                return object;
            var message = new $root.ptsl.MP3EncodingOptions();
            switch (object.bitRate) {
            default:
                if (typeof object.bitRate === "number") {
                    message.bitRate = object.bitRate;
                    break;
                }
                break;
            case "MP3EOCBRate_Unknown":
            case 0:
                message.bitRate = 0;
                break;
            case "MP3EOCBRate_320kbps":
            case 320000:
                message.bitRate = 320000;
                break;
            case "MP3EOCBRate_256kbps":
            case 256000:
                message.bitRate = 256000;
                break;
            case "MP3EOCBRate_224kbps":
            case 224000:
                message.bitRate = 224000;
                break;
            case "MP3EOCBRate_192kbps":
            case 192000:
                message.bitRate = 192000;
                break;
            case "MP3EOCBRate_160kbps":
            case 160000:
                message.bitRate = 160000;
                break;
            case "MP3EOCBRate_128kbps":
            case 128000:
                message.bitRate = 128000;
                break;
            case "MP3EOCBRate_112kbps":
            case 112000:
                message.bitRate = 112000;
                break;
            case "MP3EOCBRate_96kbps":
            case 96000:
                message.bitRate = 96000;
                break;
            case "MP3EOCBRate_80kbps":
            case 80000:
                message.bitRate = 80000;
                break;
            case "MP3EOCBRate_64kbps":
            case 64000:
                message.bitRate = 64000;
                break;
            case "MP3EOCBRate_56kbps":
            case 56000:
                message.bitRate = 56000;
                break;
            case "MP3EOCBRate_48kbps":
            case 48000:
                message.bitRate = 48000;
                break;
            case "MP3EOCBRate_40kbps":
            case 40000:
                message.bitRate = 40000;
                break;
            case "MP3EOCBRate_32kbps":
            case 32000:
                message.bitRate = 32000;
                break;
            case "MP3EOCBRate_24kbps":
            case 24000:
                message.bitRate = 24000;
                break;
            case "MP3EOCBRate_20kbps":
            case 20000:
                message.bitRate = 20000;
                break;
            case "MP3EOCBRate_18kbps":
            case 18000:
                message.bitRate = 18000;
                break;
            case "MP3EOCBRate_16kbps":
            case 16000:
                message.bitRate = 16000;
                break;
            }
            switch (object.quality) {
            default:
                if (typeof object.quality === "number") {
                    message.quality = object.quality;
                    break;
                }
                break;
            case "MP3EOQuality_Unknown":
            case 0:
                message.quality = 0;
                break;
            case "MP3EOQuality_Low":
            case 1:
                message.quality = 1;
                break;
            case "MP3EOQuality_Highest":
            case 2:
                message.quality = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MP3EncodingOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {ptsl.MP3EncodingOptions} message MP3EncodingOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MP3EncodingOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bitRate = options.enums === String ? "MP3EOCBRate_Unknown" : 0;
                object.quality = options.enums === String ? "MP3EOQuality_Unknown" : 0;
            }
            if (message.bitRate != null && message.hasOwnProperty("bitRate"))
                object.bitRate = options.enums === String ? $root.ptsl.MP3EncodingOptionsConstantBitRate[message.bitRate] === undefined ? message.bitRate : $root.ptsl.MP3EncodingOptionsConstantBitRate[message.bitRate] : message.bitRate;
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = options.enums === String ? $root.ptsl.MP3EncodingOptionsQuality[message.quality] === undefined ? message.quality : $root.ptsl.MP3EncodingOptionsQuality[message.quality] : message.quality;
            return object;
        };

        /**
         * Converts this MP3EncodingOptions to JSON.
         * @function toJSON
         * @memberof ptsl.MP3EncodingOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MP3EncodingOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MP3EncodingOptions
         * @function getTypeUrl
         * @memberof ptsl.MP3EncodingOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MP3EncodingOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.MP3EncodingOptions";
        };

        return MP3EncodingOptions;
    })();

    ptsl.AudioEncodingOptions = (function() {

        /**
         * Properties of an AudioEncodingOptions.
         * @memberof ptsl
         * @interface IAudioEncodingOptions
         * @property {ptsl.IMP3EncodingOptions|null} [encodingOptionsMp3] AudioEncodingOptions encodingOptionsMp3
         */

        /**
         * Constructs a new AudioEncodingOptions.
         * @memberof ptsl
         * @classdesc Abstract message that may contain MP3 or other audio encoding options.
         * @since Pro Tools 2025.06
         * @implements IAudioEncodingOptions
         * @constructor
         * @param {ptsl.IAudioEncodingOptions=} [properties] Properties to set
         */
        function AudioEncodingOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AudioEncodingOptions encodingOptionsMp3.
         * @member {ptsl.IMP3EncodingOptions|null|undefined} encodingOptionsMp3
         * @memberof ptsl.AudioEncodingOptions
         * @instance
         */
        AudioEncodingOptions.prototype.encodingOptionsMp3 = null;

        /**
         * Creates a new AudioEncodingOptions instance using the specified properties.
         * @function create
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {ptsl.IAudioEncodingOptions=} [properties] Properties to set
         * @returns {ptsl.AudioEncodingOptions} AudioEncodingOptions instance
         */
        AudioEncodingOptions.create = function create(properties) {
            return new AudioEncodingOptions(properties);
        };

        /**
         * Encodes the specified AudioEncodingOptions message. Does not implicitly {@link ptsl.AudioEncodingOptions.verify|verify} messages.
         * @function encode
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {ptsl.IAudioEncodingOptions} message AudioEncodingOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioEncodingOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encodingOptionsMp3 != null && Object.hasOwnProperty.call(message, "encodingOptionsMp3"))
                $root.ptsl.MP3EncodingOptions.encode(message.encodingOptionsMp3, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AudioEncodingOptions message, length delimited. Does not implicitly {@link ptsl.AudioEncodingOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {ptsl.IAudioEncodingOptions} message AudioEncodingOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioEncodingOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AudioEncodingOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.AudioEncodingOptions} AudioEncodingOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioEncodingOptions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.AudioEncodingOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.encodingOptionsMp3 = $root.ptsl.MP3EncodingOptions.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AudioEncodingOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.AudioEncodingOptions} AudioEncodingOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioEncodingOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AudioEncodingOptions message.
         * @function verify
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AudioEncodingOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encodingOptionsMp3 != null && message.hasOwnProperty("encodingOptionsMp3")) {
                var error = $root.ptsl.MP3EncodingOptions.verify(message.encodingOptionsMp3);
                if (error)
                    return "encodingOptionsMp3." + error;
            }
            return null;
        };

        /**
         * Creates an AudioEncodingOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.AudioEncodingOptions} AudioEncodingOptions
         */
        AudioEncodingOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.AudioEncodingOptions)
                return object;
            var message = new $root.ptsl.AudioEncodingOptions();
            if (object.encodingOptionsMp3 != null) {
                if (typeof object.encodingOptionsMp3 !== "object")
                    throw TypeError(".ptsl.AudioEncodingOptions.encodingOptionsMp3: object expected");
                message.encodingOptionsMp3 = $root.ptsl.MP3EncodingOptions.fromObject(object.encodingOptionsMp3);
            }
            return message;
        };

        /**
         * Creates a plain object from an AudioEncodingOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {ptsl.AudioEncodingOptions} message AudioEncodingOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AudioEncodingOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.encodingOptionsMp3 = null;
            if (message.encodingOptionsMp3 != null && message.hasOwnProperty("encodingOptionsMp3"))
                object.encodingOptionsMp3 = $root.ptsl.MP3EncodingOptions.toObject(message.encodingOptionsMp3, options);
            return object;
        };

        /**
         * Converts this AudioEncodingOptions to JSON.
         * @function toJSON
         * @memberof ptsl.AudioEncodingOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AudioEncodingOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AudioEncodingOptions
         * @function getTypeUrl
         * @memberof ptsl.AudioEncodingOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AudioEncodingOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.AudioEncodingOptions";
        };

        return AudioEncodingOptions;
    })();

    ptsl.ExportMixRequestBody = (function() {

        /**
         * Properties of an ExportMixRequestBody.
         * @memberof ptsl
         * @interface IExportMixRequestBody
         * @property {string|null} [presetPath] ExportMixRequestBody presetPath
         * @property {string|null} [fileName] ExportMixRequestBody fileName
         * @property {ptsl.EM_FileType|null} [fileType] ExportMixRequestBody fileType
         * @property {Array.<ptsl.IEM_SourceInfo>|null} [filesList] @deprecated
         * * files_list is deprecated starting in Pro Tools 2023.03
         * * Use ExportMixRequestBody::mix_source_list instead
         * @property {ptsl.IEM_AudioInfo|null} [audioInfo] ExportMixRequestBody audioInfo
         * @property {ptsl.IEM_VideoInfo|null} [videoInfo] ExportMixRequestBody videoInfo
         * @property {ptsl.IEM_LocationInfo|null} [locationInfo] ExportMixRequestBody locationInfo
         * @property {ptsl.IEM_DolbyAtmosInfo|null} [dolbyAtmosInfo] ExportMixRequestBody dolbyAtmosInfo
         * @property {ptsl.TripleBool|null} [offlineBounce] ExportMixRequestBody offlineBounce
         * @property {Array.<ptsl.IEM_SourceInfo>|null} [mixSourceList] ExportMixRequestBody mixSourceList
         * @property {ptsl.IAudioEncodingOptions|null} [audioEncodingOptions] ExportMixRequestBody audioEncodingOptions
         * @property {ptsl.ITimelineLocation|null} [startTime] ExportMixRequestBody startTime
         * @property {ptsl.ITimelineLocation|null} [endTime] ExportMixRequestBody endTime
         */

        /**
         * Constructs a new ExportMixRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExportMix request data.
         * @implements IExportMixRequestBody
         * @constructor
         * @param {ptsl.IExportMixRequestBody=} [properties] Properties to set
         */
        function ExportMixRequestBody(properties) {
            this.filesList = [];
            this.mixSourceList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportMixRequestBody presetPath.
         * @member {string} presetPath
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.presetPath = "";

        /**
         * ExportMixRequestBody fileName.
         * @member {string} fileName
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.fileName = "";

        /**
         * ExportMixRequestBody fileType.
         * @member {ptsl.EM_FileType} fileType
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.fileType = 0;

        /**
         * @deprecated
         * * files_list is deprecated starting in Pro Tools 2023.03
         * * Use ExportMixRequestBody::mix_source_list instead
         * @member {Array.<ptsl.IEM_SourceInfo>} filesList
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.filesList = $util.emptyArray;

        /**
         * ExportMixRequestBody audioInfo.
         * @member {ptsl.IEM_AudioInfo|null|undefined} audioInfo
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.audioInfo = null;

        /**
         * ExportMixRequestBody videoInfo.
         * @member {ptsl.IEM_VideoInfo|null|undefined} videoInfo
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.videoInfo = null;

        /**
         * ExportMixRequestBody locationInfo.
         * @member {ptsl.IEM_LocationInfo|null|undefined} locationInfo
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.locationInfo = null;

        /**
         * ExportMixRequestBody dolbyAtmosInfo.
         * @member {ptsl.IEM_DolbyAtmosInfo|null|undefined} dolbyAtmosInfo
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.dolbyAtmosInfo = null;

        /**
         * ExportMixRequestBody offlineBounce.
         * @member {ptsl.TripleBool} offlineBounce
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.offlineBounce = 0;

        /**
         * ExportMixRequestBody mixSourceList.
         * @member {Array.<ptsl.IEM_SourceInfo>} mixSourceList
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.mixSourceList = $util.emptyArray;

        /**
         * ExportMixRequestBody audioEncodingOptions.
         * @member {ptsl.IAudioEncodingOptions|null|undefined} audioEncodingOptions
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.audioEncodingOptions = null;

        /**
         * ExportMixRequestBody startTime.
         * @member {ptsl.ITimelineLocation|null|undefined} startTime
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.startTime = null;

        /**
         * ExportMixRequestBody endTime.
         * @member {ptsl.ITimelineLocation|null|undefined} endTime
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         */
        ExportMixRequestBody.prototype.endTime = null;

        /**
         * Creates a new ExportMixRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {ptsl.IExportMixRequestBody=} [properties] Properties to set
         * @returns {ptsl.ExportMixRequestBody} ExportMixRequestBody instance
         */
        ExportMixRequestBody.create = function create(properties) {
            return new ExportMixRequestBody(properties);
        };

        /**
         * Encodes the specified ExportMixRequestBody message. Does not implicitly {@link ptsl.ExportMixRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {ptsl.IExportMixRequestBody} message ExportMixRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportMixRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.presetPath != null && Object.hasOwnProperty.call(message, "presetPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetPath);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fileType);
            if (message.filesList != null && message.filesList.length)
                for (var i = 0; i < message.filesList.length; ++i)
                    $root.ptsl.EM_SourceInfo.encode(message.filesList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.audioInfo != null && Object.hasOwnProperty.call(message, "audioInfo"))
                $root.ptsl.EM_AudioInfo.encode(message.audioInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.videoInfo != null && Object.hasOwnProperty.call(message, "videoInfo"))
                $root.ptsl.EM_VideoInfo.encode(message.videoInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.locationInfo != null && Object.hasOwnProperty.call(message, "locationInfo"))
                $root.ptsl.EM_LocationInfo.encode(message.locationInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.dolbyAtmosInfo != null && Object.hasOwnProperty.call(message, "dolbyAtmosInfo"))
                $root.ptsl.EM_DolbyAtmosInfo.encode(message.dolbyAtmosInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.offlineBounce != null && Object.hasOwnProperty.call(message, "offlineBounce"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.offlineBounce);
            if (message.mixSourceList != null && message.mixSourceList.length)
                for (var i = 0; i < message.mixSourceList.length; ++i)
                    $root.ptsl.EM_SourceInfo.encode(message.mixSourceList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.audioEncodingOptions != null && Object.hasOwnProperty.call(message, "audioEncodingOptions"))
                $root.ptsl.AudioEncodingOptions.encode(message.audioEncodingOptions, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                $root.ptsl.TimelineLocation.encode(message.startTime, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                $root.ptsl.TimelineLocation.encode(message.endTime, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExportMixRequestBody message, length delimited. Does not implicitly {@link ptsl.ExportMixRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {ptsl.IExportMixRequestBody} message ExportMixRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportMixRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportMixRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExportMixRequestBody} ExportMixRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportMixRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExportMixRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.presetPath = reader.string();
                        break;
                    }
                case 2: {
                        message.fileName = reader.string();
                        break;
                    }
                case 3: {
                        message.fileType = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.filesList && message.filesList.length))
                            message.filesList = [];
                        message.filesList.push($root.ptsl.EM_SourceInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.audioInfo = $root.ptsl.EM_AudioInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.videoInfo = $root.ptsl.EM_VideoInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.locationInfo = $root.ptsl.EM_LocationInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.dolbyAtmosInfo = $root.ptsl.EM_DolbyAtmosInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.offlineBounce = reader.int32();
                        break;
                    }
                case 10: {
                        if (!(message.mixSourceList && message.mixSourceList.length))
                            message.mixSourceList = [];
                        message.mixSourceList.push($root.ptsl.EM_SourceInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        message.audioEncodingOptions = $root.ptsl.AudioEncodingOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.startTime = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.endTime = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportMixRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExportMixRequestBody} ExportMixRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportMixRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportMixRequestBody message.
         * @function verify
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportMixRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.presetPath != null && message.hasOwnProperty("presetPath"))
                if (!$util.isString(message.presetPath))
                    return "presetPath: string expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                switch (message.fileType) {
                default:
                    return "fileType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                    break;
                }
            if (message.filesList != null && message.hasOwnProperty("filesList")) {
                if (!Array.isArray(message.filesList))
                    return "filesList: array expected";
                for (var i = 0; i < message.filesList.length; ++i) {
                    var error = $root.ptsl.EM_SourceInfo.verify(message.filesList[i]);
                    if (error)
                        return "filesList." + error;
                }
            }
            if (message.audioInfo != null && message.hasOwnProperty("audioInfo")) {
                var error = $root.ptsl.EM_AudioInfo.verify(message.audioInfo);
                if (error)
                    return "audioInfo." + error;
            }
            if (message.videoInfo != null && message.hasOwnProperty("videoInfo")) {
                var error = $root.ptsl.EM_VideoInfo.verify(message.videoInfo);
                if (error)
                    return "videoInfo." + error;
            }
            if (message.locationInfo != null && message.hasOwnProperty("locationInfo")) {
                var error = $root.ptsl.EM_LocationInfo.verify(message.locationInfo);
                if (error)
                    return "locationInfo." + error;
            }
            if (message.dolbyAtmosInfo != null && message.hasOwnProperty("dolbyAtmosInfo")) {
                var error = $root.ptsl.EM_DolbyAtmosInfo.verify(message.dolbyAtmosInfo);
                if (error)
                    return "dolbyAtmosInfo." + error;
            }
            if (message.offlineBounce != null && message.hasOwnProperty("offlineBounce"))
                switch (message.offlineBounce) {
                default:
                    return "offlineBounce: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.mixSourceList != null && message.hasOwnProperty("mixSourceList")) {
                if (!Array.isArray(message.mixSourceList))
                    return "mixSourceList: array expected";
                for (var i = 0; i < message.mixSourceList.length; ++i) {
                    var error = $root.ptsl.EM_SourceInfo.verify(message.mixSourceList[i]);
                    if (error)
                        return "mixSourceList." + error;
                }
            }
            if (message.audioEncodingOptions != null && message.hasOwnProperty("audioEncodingOptions")) {
                var error = $root.ptsl.AudioEncodingOptions.verify(message.audioEncodingOptions);
                if (error)
                    return "audioEncodingOptions." + error;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime")) {
                var error = $root.ptsl.TimelineLocation.verify(message.startTime);
                if (error)
                    return "startTime." + error;
            }
            if (message.endTime != null && message.hasOwnProperty("endTime")) {
                var error = $root.ptsl.TimelineLocation.verify(message.endTime);
                if (error)
                    return "endTime." + error;
            }
            return null;
        };

        /**
         * Creates an ExportMixRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExportMixRequestBody} ExportMixRequestBody
         */
        ExportMixRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExportMixRequestBody)
                return object;
            var message = new $root.ptsl.ExportMixRequestBody();
            if (object.presetPath != null)
                message.presetPath = String(object.presetPath);
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            switch (object.fileType) {
            default:
                if (typeof object.fileType === "number") {
                    message.fileType = object.fileType;
                    break;
                }
                break;
            case "EMFType_Unknown":
            case 0:
                message.fileType = 0;
                break;
            case "EM_None":
            case 1:
                message.fileType = 1;
                break;
            case "EMFType_None":
            case 1:
                message.fileType = 1;
                break;
            case "EM_MOV":
            case 2:
                message.fileType = 2;
                break;
            case "EMFType_MOV":
            case 2:
                message.fileType = 2;
                break;
            case "EM_WAV":
            case 3:
                message.fileType = 3;
                break;
            case "EMFType_WAV":
            case 3:
                message.fileType = 3;
                break;
            case "EM_AIFF":
            case 4:
                message.fileType = 4;
                break;
            case "EMFType_AIFF":
            case 4:
                message.fileType = 4;
                break;
            case "EM_MP3":
            case 5:
                message.fileType = 5;
                break;
            case "EMFType_MP3":
            case 5:
                message.fileType = 5;
                break;
            case "EM_MXFOPAtom":
            case 6:
                message.fileType = 6;
                break;
            case "EMFType_MXFOPAtom":
            case 6:
                message.fileType = 6;
                break;
            case "EM_WAVADM":
            case 7:
                message.fileType = 7;
                break;
            case "EMFType_WAVADM":
            case 7:
                message.fileType = 7;
                break;
            case "EMFType_M4A":
            case 8:
                message.fileType = 8;
                break;
            }
            if (object.filesList) {
                if (!Array.isArray(object.filesList))
                    throw TypeError(".ptsl.ExportMixRequestBody.filesList: array expected");
                message.filesList = [];
                for (var i = 0; i < object.filesList.length; ++i) {
                    if (typeof object.filesList[i] !== "object")
                        throw TypeError(".ptsl.ExportMixRequestBody.filesList: object expected");
                    message.filesList[i] = $root.ptsl.EM_SourceInfo.fromObject(object.filesList[i]);
                }
            }
            if (object.audioInfo != null) {
                if (typeof object.audioInfo !== "object")
                    throw TypeError(".ptsl.ExportMixRequestBody.audioInfo: object expected");
                message.audioInfo = $root.ptsl.EM_AudioInfo.fromObject(object.audioInfo);
            }
            if (object.videoInfo != null) {
                if (typeof object.videoInfo !== "object")
                    throw TypeError(".ptsl.ExportMixRequestBody.videoInfo: object expected");
                message.videoInfo = $root.ptsl.EM_VideoInfo.fromObject(object.videoInfo);
            }
            if (object.locationInfo != null) {
                if (typeof object.locationInfo !== "object")
                    throw TypeError(".ptsl.ExportMixRequestBody.locationInfo: object expected");
                message.locationInfo = $root.ptsl.EM_LocationInfo.fromObject(object.locationInfo);
            }
            if (object.dolbyAtmosInfo != null) {
                if (typeof object.dolbyAtmosInfo !== "object")
                    throw TypeError(".ptsl.ExportMixRequestBody.dolbyAtmosInfo: object expected");
                message.dolbyAtmosInfo = $root.ptsl.EM_DolbyAtmosInfo.fromObject(object.dolbyAtmosInfo);
            }
            switch (object.offlineBounce) {
            default:
                if (typeof object.offlineBounce === "number") {
                    message.offlineBounce = object.offlineBounce;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.offlineBounce = 0;
                break;
            case "TB_None":
            case 1:
                message.offlineBounce = 1;
                break;
            case "TBool_None":
            case 1:
                message.offlineBounce = 1;
                break;
            case "TB_False":
            case 2:
                message.offlineBounce = 2;
                break;
            case "TBool_False":
            case 2:
                message.offlineBounce = 2;
                break;
            case "TB_True":
            case 3:
                message.offlineBounce = 3;
                break;
            case "TBool_True":
            case 3:
                message.offlineBounce = 3;
                break;
            }
            if (object.mixSourceList) {
                if (!Array.isArray(object.mixSourceList))
                    throw TypeError(".ptsl.ExportMixRequestBody.mixSourceList: array expected");
                message.mixSourceList = [];
                for (var i = 0; i < object.mixSourceList.length; ++i) {
                    if (typeof object.mixSourceList[i] !== "object")
                        throw TypeError(".ptsl.ExportMixRequestBody.mixSourceList: object expected");
                    message.mixSourceList[i] = $root.ptsl.EM_SourceInfo.fromObject(object.mixSourceList[i]);
                }
            }
            if (object.audioEncodingOptions != null) {
                if (typeof object.audioEncodingOptions !== "object")
                    throw TypeError(".ptsl.ExportMixRequestBody.audioEncodingOptions: object expected");
                message.audioEncodingOptions = $root.ptsl.AudioEncodingOptions.fromObject(object.audioEncodingOptions);
            }
            if (object.startTime != null) {
                if (typeof object.startTime !== "object")
                    throw TypeError(".ptsl.ExportMixRequestBody.startTime: object expected");
                message.startTime = $root.ptsl.TimelineLocation.fromObject(object.startTime);
            }
            if (object.endTime != null) {
                if (typeof object.endTime !== "object")
                    throw TypeError(".ptsl.ExportMixRequestBody.endTime: object expected");
                message.endTime = $root.ptsl.TimelineLocation.fromObject(object.endTime);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExportMixRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {ptsl.ExportMixRequestBody} message ExportMixRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportMixRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.filesList = [];
                object.mixSourceList = [];
            }
            if (options.defaults) {
                object.presetPath = "";
                object.fileName = "";
                object.fileType = options.enums === String ? "EMFType_Unknown" : 0;
                object.audioInfo = null;
                object.videoInfo = null;
                object.locationInfo = null;
                object.dolbyAtmosInfo = null;
                object.offlineBounce = options.enums === String ? "TBool_Unknown" : 0;
                object.audioEncodingOptions = null;
                object.startTime = null;
                object.endTime = null;
            }
            if (message.presetPath != null && message.hasOwnProperty("presetPath"))
                object.presetPath = message.presetPath;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.ptsl.EM_FileType[message.fileType] === undefined ? message.fileType : $root.ptsl.EM_FileType[message.fileType] : message.fileType;
            if (message.filesList && message.filesList.length) {
                object.filesList = [];
                for (var j = 0; j < message.filesList.length; ++j)
                    object.filesList[j] = $root.ptsl.EM_SourceInfo.toObject(message.filesList[j], options);
            }
            if (message.audioInfo != null && message.hasOwnProperty("audioInfo"))
                object.audioInfo = $root.ptsl.EM_AudioInfo.toObject(message.audioInfo, options);
            if (message.videoInfo != null && message.hasOwnProperty("videoInfo"))
                object.videoInfo = $root.ptsl.EM_VideoInfo.toObject(message.videoInfo, options);
            if (message.locationInfo != null && message.hasOwnProperty("locationInfo"))
                object.locationInfo = $root.ptsl.EM_LocationInfo.toObject(message.locationInfo, options);
            if (message.dolbyAtmosInfo != null && message.hasOwnProperty("dolbyAtmosInfo"))
                object.dolbyAtmosInfo = $root.ptsl.EM_DolbyAtmosInfo.toObject(message.dolbyAtmosInfo, options);
            if (message.offlineBounce != null && message.hasOwnProperty("offlineBounce"))
                object.offlineBounce = options.enums === String ? $root.ptsl.TripleBool[message.offlineBounce] === undefined ? message.offlineBounce : $root.ptsl.TripleBool[message.offlineBounce] : message.offlineBounce;
            if (message.mixSourceList && message.mixSourceList.length) {
                object.mixSourceList = [];
                for (var j = 0; j < message.mixSourceList.length; ++j)
                    object.mixSourceList[j] = $root.ptsl.EM_SourceInfo.toObject(message.mixSourceList[j], options);
            }
            if (message.audioEncodingOptions != null && message.hasOwnProperty("audioEncodingOptions"))
                object.audioEncodingOptions = $root.ptsl.AudioEncodingOptions.toObject(message.audioEncodingOptions, options);
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                object.startTime = $root.ptsl.TimelineLocation.toObject(message.startTime, options);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = $root.ptsl.TimelineLocation.toObject(message.endTime, options);
            return object;
        };

        /**
         * Converts this ExportMixRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExportMixRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportMixRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExportMixRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ExportMixRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExportMixRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExportMixRequestBody";
        };

        return ExportMixRequestBody;
    })();

    /**
     * Available data types that describe dynamic property.
     * @name ptsl.DP_ValueTypes
     * @enum {number}
     * @property {number} DPVTypes_Unknown=0 DPVTypes_Unknown value
     * @property {number} DP_VT_double=1 * @deprecated ptsl::DP_ValueTypes::DP_VT_double is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Double
     * @property {number} DPVTypes_Double=1 DPVTypes_Double value
     * @property {number} DP_VT_float=2 * @deprecated ptsl::DP_ValueTypes::DP_VT_float is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Float
     * @property {number} DPVTypes_Float=2 DPVTypes_Float value
     * @property {number} DP_VT_int32=3 * @deprecated ptsl::DP_ValueTypes::DP_VT_int32 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Int32
     * @property {number} DPVTypes_Int32=3 DPVTypes_Int32 value
     * @property {number} DP_VT_int64=4 * @deprecated ptsl::DP_ValueTypes::DP_VT_int64 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Int64
     * @property {number} DPVTypes_Int64=4 DPVTypes_Int64 value
     * @property {number} DP_VT_uint32=5 * @deprecated ptsl::DP_ValueTypes::DP_VT_uint32 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Uint32
     * @property {number} DPVTypes_Uint32=5 DPVTypes_Uint32 value
     * @property {number} DP_VT_uint64=6 * @deprecated ptsl::DP_ValueTypes::DP_VT_uint64 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Uint64
     * @property {number} DPVTypes_Uint64=6 DPVTypes_Uint64 value
     * @property {number} DP_VT_sint32=7 * @deprecated ptsl::DP_ValueTypes::DP_VT_sint32 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Sint32
     * @property {number} DPVTypes_Sint32=7 DPVTypes_Sint32 value
     * @property {number} DP_VT_sint64=8 * @deprecated ptsl::DP_ValueTypes::DP_VT_sint64 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Sint64
     * @property {number} DPVTypes_Sint64=8 DPVTypes_Sint64 value
     * @property {number} DP_VT_fixed32=9 * @deprecated ptsl::DP_ValueTypes::DP_VT_fixed32 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Fixed32
     * @property {number} DPVTypes_Fixed32=9 DPVTypes_Fixed32 value
     * @property {number} DP_VT_fixed64=10 * @deprecated ptsl::DP_ValueTypes::DP_VT_fixed64 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Fixed64
     * @property {number} DPVTypes_Fixed64=10 DPVTypes_Fixed64 value
     * @property {number} DP_VT_sfixed32=11 * @deprecated ptsl::DP_ValueTypes::DP_VT_sfixed32 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Sfixed32
     * @property {number} DPVTypes_Sfixed32=11 DPVTypes_Sfixed32 value
     * @property {number} DP_VT_sfixed64=12 * @deprecated ptsl::DP_ValueTypes::DP_VT_sfixed64 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Sfixed64
     * @property {number} DPVTypes_Sfixed64=12 DPVTypes_Sfixed64 value
     * @property {number} DP_VT_bool=13 * @deprecated ptsl::DP_ValueTypes::DP_VT_bool is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Bool
     * @property {number} DPVTypes_Bool=13 DPVTypes_Bool value
     * @property {number} DP_VT_string=14 * @deprecated ptsl::DP_ValueTypes::DP_VT_string is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_String
     * @property {number} DPVTypes_String=14 DPVTypes_String value
     * @property {number} DP_VT_bytes=15 * @deprecated ptsl::DP_ValueTypes::DP_VT_bytes is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Bytes
     * @property {number} DPVTypes_Bytes=15 DPVTypes_Bytes value
     * @property {number} DP_VT_enum=16 * @deprecated ptsl::DP_ValueTypes::DP_VT_enum is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Enum
     * @property {number} DPVTypes_Enum=16 DPVTypes_Enum value
     * @property {number} DP_VT_object=17 * @deprecated ptsl::DP_ValueTypes::DP_VT_object is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DP_ValueTypes::DPVTypes_Object
     * @property {number} DPVTypes_Object=17 DPVTypes_Object value
     */
    ptsl.DP_ValueTypes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DPVTypes_Unknown"] = 0;
        values[valuesById[1] = "DP_VT_double"] = 1;
        values["DPVTypes_Double"] = 1;
        values[valuesById[2] = "DP_VT_float"] = 2;
        values["DPVTypes_Float"] = 2;
        values[valuesById[3] = "DP_VT_int32"] = 3;
        values["DPVTypes_Int32"] = 3;
        values[valuesById[4] = "DP_VT_int64"] = 4;
        values["DPVTypes_Int64"] = 4;
        values[valuesById[5] = "DP_VT_uint32"] = 5;
        values["DPVTypes_Uint32"] = 5;
        values[valuesById[6] = "DP_VT_uint64"] = 6;
        values["DPVTypes_Uint64"] = 6;
        values[valuesById[7] = "DP_VT_sint32"] = 7;
        values["DPVTypes_Sint32"] = 7;
        values[valuesById[8] = "DP_VT_sint64"] = 8;
        values["DPVTypes_Sint64"] = 8;
        values[valuesById[9] = "DP_VT_fixed32"] = 9;
        values["DPVTypes_Fixed32"] = 9;
        values[valuesById[10] = "DP_VT_fixed64"] = 10;
        values["DPVTypes_Fixed64"] = 10;
        values[valuesById[11] = "DP_VT_sfixed32"] = 11;
        values["DPVTypes_Sfixed32"] = 11;
        values[valuesById[12] = "DP_VT_sfixed64"] = 12;
        values["DPVTypes_Sfixed64"] = 12;
        values[valuesById[13] = "DP_VT_bool"] = 13;
        values["DPVTypes_Bool"] = 13;
        values[valuesById[14] = "DP_VT_string"] = 14;
        values["DPVTypes_String"] = 14;
        values[valuesById[15] = "DP_VT_bytes"] = 15;
        values["DPVTypes_Bytes"] = 15;
        values[valuesById[16] = "DP_VT_enum"] = 16;
        values["DPVTypes_Enum"] = 16;
        values[valuesById[17] = "DP_VT_object"] = 17;
        values["DPVTypes_Object"] = 17;
        return values;
    })();

    ptsl.PropertyDescriptor = (function() {

        /**
         * Properties of a PropertyDescriptor.
         * @memberof ptsl
         * @interface IPropertyDescriptor
         * @property {string|null} [name] PropertyDescriptor name
         * @property {ptsl.DP_ValueTypes|null} [valueType] PropertyDescriptor valueType
         * @property {string|null} [objectType] PropertyDescriptor objectType
         * @property {boolean|null} [required] PropertyDescriptor required
         * @property {string|null} [description] PropertyDescriptor description
         * @property {string|null} [units] PropertyDescriptor units
         * @property {Array.<string>|null} [acceptedValues] PropertyDescriptor acceptedValues
         * @property {string|null} [maxValue] PropertyDescriptor maxValue
         * @property {string|null} [minValue] PropertyDescriptor minValue
         */

        /**
         * Constructs a new PropertyDescriptor.
         * @memberof ptsl
         * @classdesc Structure that describes dynamic property.
         * @implements IPropertyDescriptor
         * @constructor
         * @param {ptsl.IPropertyDescriptor=} [properties] Properties to set
         */
        function PropertyDescriptor(properties) {
            this.acceptedValues = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PropertyDescriptor name.
         * @member {string} name
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.name = "";

        /**
         * PropertyDescriptor valueType.
         * @member {ptsl.DP_ValueTypes} valueType
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.valueType = 0;

        /**
         * PropertyDescriptor objectType.
         * @member {string} objectType
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.objectType = "";

        /**
         * PropertyDescriptor required.
         * @member {boolean} required
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.required = false;

        /**
         * PropertyDescriptor description.
         * @member {string} description
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.description = "";

        /**
         * PropertyDescriptor units.
         * @member {string} units
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.units = "";

        /**
         * PropertyDescriptor acceptedValues.
         * @member {Array.<string>} acceptedValues
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.acceptedValues = $util.emptyArray;

        /**
         * PropertyDescriptor maxValue.
         * @member {string} maxValue
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.maxValue = "";

        /**
         * PropertyDescriptor minValue.
         * @member {string} minValue
         * @memberof ptsl.PropertyDescriptor
         * @instance
         */
        PropertyDescriptor.prototype.minValue = "";

        /**
         * Creates a new PropertyDescriptor instance using the specified properties.
         * @function create
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {ptsl.IPropertyDescriptor=} [properties] Properties to set
         * @returns {ptsl.PropertyDescriptor} PropertyDescriptor instance
         */
        PropertyDescriptor.create = function create(properties) {
            return new PropertyDescriptor(properties);
        };

        /**
         * Encodes the specified PropertyDescriptor message. Does not implicitly {@link ptsl.PropertyDescriptor.verify|verify} messages.
         * @function encode
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {ptsl.IPropertyDescriptor} message PropertyDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PropertyDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.valueType != null && Object.hasOwnProperty.call(message, "valueType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.valueType);
            if (message.objectType != null && Object.hasOwnProperty.call(message, "objectType"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.objectType);
            if (message.required != null && Object.hasOwnProperty.call(message, "required"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.required);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.units);
            if (message.acceptedValues != null && message.acceptedValues.length)
                for (var i = 0; i < message.acceptedValues.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.acceptedValues[i]);
            if (message.maxValue != null && Object.hasOwnProperty.call(message, "maxValue"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.maxValue);
            if (message.minValue != null && Object.hasOwnProperty.call(message, "minValue"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.minValue);
            return writer;
        };

        /**
         * Encodes the specified PropertyDescriptor message, length delimited. Does not implicitly {@link ptsl.PropertyDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {ptsl.IPropertyDescriptor} message PropertyDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PropertyDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PropertyDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.PropertyDescriptor} PropertyDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PropertyDescriptor.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.PropertyDescriptor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.valueType = reader.int32();
                        break;
                    }
                case 3: {
                        message.objectType = reader.string();
                        break;
                    }
                case 4: {
                        message.required = reader.bool();
                        break;
                    }
                case 5: {
                        message.description = reader.string();
                        break;
                    }
                case 6: {
                        message.units = reader.string();
                        break;
                    }
                case 7: {
                        if (!(message.acceptedValues && message.acceptedValues.length))
                            message.acceptedValues = [];
                        message.acceptedValues.push(reader.string());
                        break;
                    }
                case 8: {
                        message.maxValue = reader.string();
                        break;
                    }
                case 9: {
                        message.minValue = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PropertyDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.PropertyDescriptor} PropertyDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PropertyDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PropertyDescriptor message.
         * @function verify
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PropertyDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                switch (message.valueType) {
                default:
                    return "valueType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                    break;
                }
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                if (!$util.isString(message.objectType))
                    return "objectType: string expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.units != null && message.hasOwnProperty("units"))
                if (!$util.isString(message.units))
                    return "units: string expected";
            if (message.acceptedValues != null && message.hasOwnProperty("acceptedValues")) {
                if (!Array.isArray(message.acceptedValues))
                    return "acceptedValues: array expected";
                for (var i = 0; i < message.acceptedValues.length; ++i)
                    if (!$util.isString(message.acceptedValues[i]))
                        return "acceptedValues: string[] expected";
            }
            if (message.maxValue != null && message.hasOwnProperty("maxValue"))
                if (!$util.isString(message.maxValue))
                    return "maxValue: string expected";
            if (message.minValue != null && message.hasOwnProperty("minValue"))
                if (!$util.isString(message.minValue))
                    return "minValue: string expected";
            return null;
        };

        /**
         * Creates a PropertyDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.PropertyDescriptor} PropertyDescriptor
         */
        PropertyDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.PropertyDescriptor)
                return object;
            var message = new $root.ptsl.PropertyDescriptor();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.valueType) {
            default:
                if (typeof object.valueType === "number") {
                    message.valueType = object.valueType;
                    break;
                }
                break;
            case "DPVTypes_Unknown":
            case 0:
                message.valueType = 0;
                break;
            case "DP_VT_double":
            case 1:
                message.valueType = 1;
                break;
            case "DPVTypes_Double":
            case 1:
                message.valueType = 1;
                break;
            case "DP_VT_float":
            case 2:
                message.valueType = 2;
                break;
            case "DPVTypes_Float":
            case 2:
                message.valueType = 2;
                break;
            case "DP_VT_int32":
            case 3:
                message.valueType = 3;
                break;
            case "DPVTypes_Int32":
            case 3:
                message.valueType = 3;
                break;
            case "DP_VT_int64":
            case 4:
                message.valueType = 4;
                break;
            case "DPVTypes_Int64":
            case 4:
                message.valueType = 4;
                break;
            case "DP_VT_uint32":
            case 5:
                message.valueType = 5;
                break;
            case "DPVTypes_Uint32":
            case 5:
                message.valueType = 5;
                break;
            case "DP_VT_uint64":
            case 6:
                message.valueType = 6;
                break;
            case "DPVTypes_Uint64":
            case 6:
                message.valueType = 6;
                break;
            case "DP_VT_sint32":
            case 7:
                message.valueType = 7;
                break;
            case "DPVTypes_Sint32":
            case 7:
                message.valueType = 7;
                break;
            case "DP_VT_sint64":
            case 8:
                message.valueType = 8;
                break;
            case "DPVTypes_Sint64":
            case 8:
                message.valueType = 8;
                break;
            case "DP_VT_fixed32":
            case 9:
                message.valueType = 9;
                break;
            case "DPVTypes_Fixed32":
            case 9:
                message.valueType = 9;
                break;
            case "DP_VT_fixed64":
            case 10:
                message.valueType = 10;
                break;
            case "DPVTypes_Fixed64":
            case 10:
                message.valueType = 10;
                break;
            case "DP_VT_sfixed32":
            case 11:
                message.valueType = 11;
                break;
            case "DPVTypes_Sfixed32":
            case 11:
                message.valueType = 11;
                break;
            case "DP_VT_sfixed64":
            case 12:
                message.valueType = 12;
                break;
            case "DPVTypes_Sfixed64":
            case 12:
                message.valueType = 12;
                break;
            case "DP_VT_bool":
            case 13:
                message.valueType = 13;
                break;
            case "DPVTypes_Bool":
            case 13:
                message.valueType = 13;
                break;
            case "DP_VT_string":
            case 14:
                message.valueType = 14;
                break;
            case "DPVTypes_String":
            case 14:
                message.valueType = 14;
                break;
            case "DP_VT_bytes":
            case 15:
                message.valueType = 15;
                break;
            case "DPVTypes_Bytes":
            case 15:
                message.valueType = 15;
                break;
            case "DP_VT_enum":
            case 16:
                message.valueType = 16;
                break;
            case "DPVTypes_Enum":
            case 16:
                message.valueType = 16;
                break;
            case "DP_VT_object":
            case 17:
                message.valueType = 17;
                break;
            case "DPVTypes_Object":
            case 17:
                message.valueType = 17;
                break;
            }
            if (object.objectType != null)
                message.objectType = String(object.objectType);
            if (object.required != null)
                message.required = Boolean(object.required);
            if (object.description != null)
                message.description = String(object.description);
            if (object.units != null)
                message.units = String(object.units);
            if (object.acceptedValues) {
                if (!Array.isArray(object.acceptedValues))
                    throw TypeError(".ptsl.PropertyDescriptor.acceptedValues: array expected");
                message.acceptedValues = [];
                for (var i = 0; i < object.acceptedValues.length; ++i)
                    message.acceptedValues[i] = String(object.acceptedValues[i]);
            }
            if (object.maxValue != null)
                message.maxValue = String(object.maxValue);
            if (object.minValue != null)
                message.minValue = String(object.minValue);
            return message;
        };

        /**
         * Creates a plain object from a PropertyDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {ptsl.PropertyDescriptor} message PropertyDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PropertyDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.acceptedValues = [];
            if (options.defaults) {
                object.name = "";
                object.valueType = options.enums === String ? "DPVTypes_Unknown" : 0;
                object.objectType = "";
                object.required = false;
                object.description = "";
                object.units = "";
                object.maxValue = "";
                object.minValue = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                object.valueType = options.enums === String ? $root.ptsl.DP_ValueTypes[message.valueType] === undefined ? message.valueType : $root.ptsl.DP_ValueTypes[message.valueType] : message.valueType;
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                object.objectType = message.objectType;
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.units != null && message.hasOwnProperty("units"))
                object.units = message.units;
            if (message.acceptedValues && message.acceptedValues.length) {
                object.acceptedValues = [];
                for (var j = 0; j < message.acceptedValues.length; ++j)
                    object.acceptedValues[j] = message.acceptedValues[j];
            }
            if (message.maxValue != null && message.hasOwnProperty("maxValue"))
                object.maxValue = message.maxValue;
            if (message.minValue != null && message.hasOwnProperty("minValue"))
                object.minValue = message.minValue;
            return object;
        };

        /**
         * Converts this PropertyDescriptor to JSON.
         * @function toJSON
         * @memberof ptsl.PropertyDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PropertyDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PropertyDescriptor
         * @function getTypeUrl
         * @memberof ptsl.PropertyDescriptor
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PropertyDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.PropertyDescriptor";
        };

        return PropertyDescriptor;
    })();

    /**
     * Available dynamic properties types.
     * @name ptsl.DynamicPropertyType
     * @enum {number}
     * @property {number} DPType_Unknown=0 DPType_Unknown value
     * @property {number} DP_EM_CodecInfo=1 * @deprecated ptsl::DynamicPropertyType::DP_EM_CodecInfo is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DynamicPropertyType::DPType_CodecInfo
     * @property {number} DPType_CodecInfo=1 DPType_CodecInfo value
     * @property {number} DP_EM_DolbyAtmosInfo=2 * @deprecated ptsl::DynamicPropertyType::DP_EM_DolbyAtmosInfo is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::DynamicPropertyType::DPType_DolbyAtmosInfo
     * @property {number} DPType_DolbyAtmosInfo=2 DPType_DolbyAtmosInfo value
     */
    ptsl.DynamicPropertyType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DPType_Unknown"] = 0;
        values[valuesById[1] = "DP_EM_CodecInfo"] = 1;
        values["DPType_CodecInfo"] = 1;
        values[valuesById[2] = "DP_EM_DolbyAtmosInfo"] = 2;
        values["DPType_DolbyAtmosInfo"] = 2;
        return values;
    })();

    ptsl.GetDynamicPropertiesRequestBody = (function() {

        /**
         * Properties of a GetDynamicPropertiesRequestBody.
         * @memberof ptsl
         * @interface IGetDynamicPropertiesRequestBody
         * @property {ptsl.DynamicPropertyType|null} [propertyType] GetDynamicPropertiesRequestBody propertyType
         */

        /**
         * Constructs a new GetDynamicPropertiesRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetDynamicProperties request data.
         * @implements IGetDynamicPropertiesRequestBody
         * @constructor
         * @param {ptsl.IGetDynamicPropertiesRequestBody=} [properties] Properties to set
         */
        function GetDynamicPropertiesRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetDynamicPropertiesRequestBody propertyType.
         * @member {ptsl.DynamicPropertyType} propertyType
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @instance
         */
        GetDynamicPropertiesRequestBody.prototype.propertyType = 0;

        /**
         * Creates a new GetDynamicPropertiesRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {ptsl.IGetDynamicPropertiesRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetDynamicPropertiesRequestBody} GetDynamicPropertiesRequestBody instance
         */
        GetDynamicPropertiesRequestBody.create = function create(properties) {
            return new GetDynamicPropertiesRequestBody(properties);
        };

        /**
         * Encodes the specified GetDynamicPropertiesRequestBody message. Does not implicitly {@link ptsl.GetDynamicPropertiesRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {ptsl.IGetDynamicPropertiesRequestBody} message GetDynamicPropertiesRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicPropertiesRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.propertyType != null && Object.hasOwnProperty.call(message, "propertyType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propertyType);
            return writer;
        };

        /**
         * Encodes the specified GetDynamicPropertiesRequestBody message, length delimited. Does not implicitly {@link ptsl.GetDynamicPropertiesRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {ptsl.IGetDynamicPropertiesRequestBody} message GetDynamicPropertiesRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicPropertiesRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetDynamicPropertiesRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetDynamicPropertiesRequestBody} GetDynamicPropertiesRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicPropertiesRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetDynamicPropertiesRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.propertyType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetDynamicPropertiesRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetDynamicPropertiesRequestBody} GetDynamicPropertiesRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicPropertiesRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetDynamicPropertiesRequestBody message.
         * @function verify
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetDynamicPropertiesRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.propertyType != null && message.hasOwnProperty("propertyType"))
                switch (message.propertyType) {
                default:
                    return "propertyType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetDynamicPropertiesRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetDynamicPropertiesRequestBody} GetDynamicPropertiesRequestBody
         */
        GetDynamicPropertiesRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetDynamicPropertiesRequestBody)
                return object;
            var message = new $root.ptsl.GetDynamicPropertiesRequestBody();
            switch (object.propertyType) {
            default:
                if (typeof object.propertyType === "number") {
                    message.propertyType = object.propertyType;
                    break;
                }
                break;
            case "DPType_Unknown":
            case 0:
                message.propertyType = 0;
                break;
            case "DP_EM_CodecInfo":
            case 1:
                message.propertyType = 1;
                break;
            case "DPType_CodecInfo":
            case 1:
                message.propertyType = 1;
                break;
            case "DP_EM_DolbyAtmosInfo":
            case 2:
                message.propertyType = 2;
                break;
            case "DPType_DolbyAtmosInfo":
            case 2:
                message.propertyType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetDynamicPropertiesRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {ptsl.GetDynamicPropertiesRequestBody} message GetDynamicPropertiesRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetDynamicPropertiesRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.propertyType = options.enums === String ? "DPType_Unknown" : 0;
            if (message.propertyType != null && message.hasOwnProperty("propertyType"))
                object.propertyType = options.enums === String ? $root.ptsl.DynamicPropertyType[message.propertyType] === undefined ? message.propertyType : $root.ptsl.DynamicPropertyType[message.propertyType] : message.propertyType;
            return object;
        };

        /**
         * Converts this GetDynamicPropertiesRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetDynamicPropertiesRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetDynamicPropertiesRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetDynamicPropertiesRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetDynamicPropertiesRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetDynamicPropertiesRequestBody";
        };

        return GetDynamicPropertiesRequestBody;
    })();

    ptsl.GetDynamicPropertiesGroup = (function() {

        /**
         * Properties of a GetDynamicPropertiesGroup.
         * @memberof ptsl
         * @interface IGetDynamicPropertiesGroup
         * @property {Array.<ptsl.IPropertyContainer>|null} [keyList] GetDynamicPropertiesGroup keyList
         * @property {Array.<ptsl.IPropertyDescriptor>|null} [propertyList] GetDynamicPropertiesGroup propertyList
         */

        /**
         * Constructs a new GetDynamicPropertiesGroup.
         * @memberof ptsl
         * @classdesc Structure that describes GetDynamicProperties group.
         * @implements IGetDynamicPropertiesGroup
         * @constructor
         * @param {ptsl.IGetDynamicPropertiesGroup=} [properties] Properties to set
         */
        function GetDynamicPropertiesGroup(properties) {
            this.keyList = [];
            this.propertyList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetDynamicPropertiesGroup keyList.
         * @member {Array.<ptsl.IPropertyContainer>} keyList
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @instance
         */
        GetDynamicPropertiesGroup.prototype.keyList = $util.emptyArray;

        /**
         * GetDynamicPropertiesGroup propertyList.
         * @member {Array.<ptsl.IPropertyDescriptor>} propertyList
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @instance
         */
        GetDynamicPropertiesGroup.prototype.propertyList = $util.emptyArray;

        /**
         * Creates a new GetDynamicPropertiesGroup instance using the specified properties.
         * @function create
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {ptsl.IGetDynamicPropertiesGroup=} [properties] Properties to set
         * @returns {ptsl.GetDynamicPropertiesGroup} GetDynamicPropertiesGroup instance
         */
        GetDynamicPropertiesGroup.create = function create(properties) {
            return new GetDynamicPropertiesGroup(properties);
        };

        /**
         * Encodes the specified GetDynamicPropertiesGroup message. Does not implicitly {@link ptsl.GetDynamicPropertiesGroup.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {ptsl.IGetDynamicPropertiesGroup} message GetDynamicPropertiesGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicPropertiesGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyList != null && message.keyList.length)
                for (var i = 0; i < message.keyList.length; ++i)
                    $root.ptsl.PropertyContainer.encode(message.keyList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.propertyList != null && message.propertyList.length)
                for (var i = 0; i < message.propertyList.length; ++i)
                    $root.ptsl.PropertyDescriptor.encode(message.propertyList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetDynamicPropertiesGroup message, length delimited. Does not implicitly {@link ptsl.GetDynamicPropertiesGroup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {ptsl.IGetDynamicPropertiesGroup} message GetDynamicPropertiesGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicPropertiesGroup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetDynamicPropertiesGroup message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetDynamicPropertiesGroup} GetDynamicPropertiesGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicPropertiesGroup.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetDynamicPropertiesGroup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.keyList && message.keyList.length))
                            message.keyList = [];
                        message.keyList.push($root.ptsl.PropertyContainer.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.propertyList && message.propertyList.length))
                            message.propertyList = [];
                        message.propertyList.push($root.ptsl.PropertyDescriptor.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetDynamicPropertiesGroup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetDynamicPropertiesGroup} GetDynamicPropertiesGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicPropertiesGroup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetDynamicPropertiesGroup message.
         * @function verify
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetDynamicPropertiesGroup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyList != null && message.hasOwnProperty("keyList")) {
                if (!Array.isArray(message.keyList))
                    return "keyList: array expected";
                for (var i = 0; i < message.keyList.length; ++i) {
                    var error = $root.ptsl.PropertyContainer.verify(message.keyList[i]);
                    if (error)
                        return "keyList." + error;
                }
            }
            if (message.propertyList != null && message.hasOwnProperty("propertyList")) {
                if (!Array.isArray(message.propertyList))
                    return "propertyList: array expected";
                for (var i = 0; i < message.propertyList.length; ++i) {
                    var error = $root.ptsl.PropertyDescriptor.verify(message.propertyList[i]);
                    if (error)
                        return "propertyList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetDynamicPropertiesGroup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetDynamicPropertiesGroup} GetDynamicPropertiesGroup
         */
        GetDynamicPropertiesGroup.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetDynamicPropertiesGroup)
                return object;
            var message = new $root.ptsl.GetDynamicPropertiesGroup();
            if (object.keyList) {
                if (!Array.isArray(object.keyList))
                    throw TypeError(".ptsl.GetDynamicPropertiesGroup.keyList: array expected");
                message.keyList = [];
                for (var i = 0; i < object.keyList.length; ++i) {
                    if (typeof object.keyList[i] !== "object")
                        throw TypeError(".ptsl.GetDynamicPropertiesGroup.keyList: object expected");
                    message.keyList[i] = $root.ptsl.PropertyContainer.fromObject(object.keyList[i]);
                }
            }
            if (object.propertyList) {
                if (!Array.isArray(object.propertyList))
                    throw TypeError(".ptsl.GetDynamicPropertiesGroup.propertyList: array expected");
                message.propertyList = [];
                for (var i = 0; i < object.propertyList.length; ++i) {
                    if (typeof object.propertyList[i] !== "object")
                        throw TypeError(".ptsl.GetDynamicPropertiesGroup.propertyList: object expected");
                    message.propertyList[i] = $root.ptsl.PropertyDescriptor.fromObject(object.propertyList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetDynamicPropertiesGroup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {ptsl.GetDynamicPropertiesGroup} message GetDynamicPropertiesGroup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetDynamicPropertiesGroup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.keyList = [];
                object.propertyList = [];
            }
            if (message.keyList && message.keyList.length) {
                object.keyList = [];
                for (var j = 0; j < message.keyList.length; ++j)
                    object.keyList[j] = $root.ptsl.PropertyContainer.toObject(message.keyList[j], options);
            }
            if (message.propertyList && message.propertyList.length) {
                object.propertyList = [];
                for (var j = 0; j < message.propertyList.length; ++j)
                    object.propertyList[j] = $root.ptsl.PropertyDescriptor.toObject(message.propertyList[j], options);
            }
            return object;
        };

        /**
         * Converts this GetDynamicPropertiesGroup to JSON.
         * @function toJSON
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetDynamicPropertiesGroup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetDynamicPropertiesGroup
         * @function getTypeUrl
         * @memberof ptsl.GetDynamicPropertiesGroup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetDynamicPropertiesGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetDynamicPropertiesGroup";
        };

        return GetDynamicPropertiesGroup;
    })();

    ptsl.GetDynamicPropertiesResponseBody = (function() {

        /**
         * Properties of a GetDynamicPropertiesResponseBody.
         * @memberof ptsl
         * @interface IGetDynamicPropertiesResponseBody
         * @property {ptsl.DynamicPropertyType|null} [propertyType] GetDynamicPropertiesResponseBody propertyType
         * @property {Array.<ptsl.IGetDynamicPropertiesGroup>|null} [groupList] GetDynamicPropertiesResponseBody groupList
         */

        /**
         * Constructs a new GetDynamicPropertiesResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetDynamicProperties response data.
         * @implements IGetDynamicPropertiesResponseBody
         * @constructor
         * @param {ptsl.IGetDynamicPropertiesResponseBody=} [properties] Properties to set
         */
        function GetDynamicPropertiesResponseBody(properties) {
            this.groupList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetDynamicPropertiesResponseBody propertyType.
         * @member {ptsl.DynamicPropertyType} propertyType
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @instance
         */
        GetDynamicPropertiesResponseBody.prototype.propertyType = 0;

        /**
         * GetDynamicPropertiesResponseBody groupList.
         * @member {Array.<ptsl.IGetDynamicPropertiesGroup>} groupList
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @instance
         */
        GetDynamicPropertiesResponseBody.prototype.groupList = $util.emptyArray;

        /**
         * Creates a new GetDynamicPropertiesResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {ptsl.IGetDynamicPropertiesResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetDynamicPropertiesResponseBody} GetDynamicPropertiesResponseBody instance
         */
        GetDynamicPropertiesResponseBody.create = function create(properties) {
            return new GetDynamicPropertiesResponseBody(properties);
        };

        /**
         * Encodes the specified GetDynamicPropertiesResponseBody message. Does not implicitly {@link ptsl.GetDynamicPropertiesResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {ptsl.IGetDynamicPropertiesResponseBody} message GetDynamicPropertiesResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicPropertiesResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.propertyType != null && Object.hasOwnProperty.call(message, "propertyType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propertyType);
            if (message.groupList != null && message.groupList.length)
                for (var i = 0; i < message.groupList.length; ++i)
                    $root.ptsl.GetDynamicPropertiesGroup.encode(message.groupList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetDynamicPropertiesResponseBody message, length delimited. Does not implicitly {@link ptsl.GetDynamicPropertiesResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {ptsl.IGetDynamicPropertiesResponseBody} message GetDynamicPropertiesResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicPropertiesResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetDynamicPropertiesResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetDynamicPropertiesResponseBody} GetDynamicPropertiesResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicPropertiesResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetDynamicPropertiesResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.propertyType = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.groupList && message.groupList.length))
                            message.groupList = [];
                        message.groupList.push($root.ptsl.GetDynamicPropertiesGroup.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetDynamicPropertiesResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetDynamicPropertiesResponseBody} GetDynamicPropertiesResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicPropertiesResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetDynamicPropertiesResponseBody message.
         * @function verify
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetDynamicPropertiesResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.propertyType != null && message.hasOwnProperty("propertyType"))
                switch (message.propertyType) {
                default:
                    return "propertyType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.groupList != null && message.hasOwnProperty("groupList")) {
                if (!Array.isArray(message.groupList))
                    return "groupList: array expected";
                for (var i = 0; i < message.groupList.length; ++i) {
                    var error = $root.ptsl.GetDynamicPropertiesGroup.verify(message.groupList[i]);
                    if (error)
                        return "groupList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetDynamicPropertiesResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetDynamicPropertiesResponseBody} GetDynamicPropertiesResponseBody
         */
        GetDynamicPropertiesResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetDynamicPropertiesResponseBody)
                return object;
            var message = new $root.ptsl.GetDynamicPropertiesResponseBody();
            switch (object.propertyType) {
            default:
                if (typeof object.propertyType === "number") {
                    message.propertyType = object.propertyType;
                    break;
                }
                break;
            case "DPType_Unknown":
            case 0:
                message.propertyType = 0;
                break;
            case "DP_EM_CodecInfo":
            case 1:
                message.propertyType = 1;
                break;
            case "DPType_CodecInfo":
            case 1:
                message.propertyType = 1;
                break;
            case "DP_EM_DolbyAtmosInfo":
            case 2:
                message.propertyType = 2;
                break;
            case "DPType_DolbyAtmosInfo":
            case 2:
                message.propertyType = 2;
                break;
            }
            if (object.groupList) {
                if (!Array.isArray(object.groupList))
                    throw TypeError(".ptsl.GetDynamicPropertiesResponseBody.groupList: array expected");
                message.groupList = [];
                for (var i = 0; i < object.groupList.length; ++i) {
                    if (typeof object.groupList[i] !== "object")
                        throw TypeError(".ptsl.GetDynamicPropertiesResponseBody.groupList: object expected");
                    message.groupList[i] = $root.ptsl.GetDynamicPropertiesGroup.fromObject(object.groupList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetDynamicPropertiesResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {ptsl.GetDynamicPropertiesResponseBody} message GetDynamicPropertiesResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetDynamicPropertiesResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.groupList = [];
            if (options.defaults)
                object.propertyType = options.enums === String ? "DPType_Unknown" : 0;
            if (message.propertyType != null && message.hasOwnProperty("propertyType"))
                object.propertyType = options.enums === String ? $root.ptsl.DynamicPropertyType[message.propertyType] === undefined ? message.propertyType : $root.ptsl.DynamicPropertyType[message.propertyType] : message.propertyType;
            if (message.groupList && message.groupList.length) {
                object.groupList = [];
                for (var j = 0; j < message.groupList.length; ++j)
                    object.groupList[j] = $root.ptsl.GetDynamicPropertiesGroup.toObject(message.groupList[j], options);
            }
            return object;
        };

        /**
         * Converts this GetDynamicPropertiesResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetDynamicPropertiesResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetDynamicPropertiesResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetDynamicPropertiesResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetDynamicPropertiesResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetDynamicPropertiesResponseBody";
        };

        return GetDynamicPropertiesResponseBody;
    })();

    ptsl.SpotRequestBody = (function() {

        /**
         * Properties of a SpotRequestBody.
         * @memberof ptsl
         * @interface ISpotRequestBody
         * @property {ptsl.TrackOffsetOptions|null} [trackOffsetOptions] @deprecated
         * * track_offset_options is deprecated starting in Pro Tools 2023.06
         * * Use SpotRequestBody::location_data::location_options instead
         * @property {ptsl.ISpotLocationData|null} [locationData] SpotRequestBody locationData
         */

        /**
         * Constructs a new SpotRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes Spot request data.
         * @implements ISpotRequestBody
         * @constructor
         * @param {ptsl.ISpotRequestBody=} [properties] Properties to set
         */
        function SpotRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * @deprecated
         * * track_offset_options is deprecated starting in Pro Tools 2023.06
         * * Use SpotRequestBody::location_data::location_options instead
         * @member {ptsl.TrackOffsetOptions} trackOffsetOptions
         * @memberof ptsl.SpotRequestBody
         * @instance
         */
        SpotRequestBody.prototype.trackOffsetOptions = 0;

        /**
         * SpotRequestBody locationData.
         * @member {ptsl.ISpotLocationData|null|undefined} locationData
         * @memberof ptsl.SpotRequestBody
         * @instance
         */
        SpotRequestBody.prototype.locationData = null;

        /**
         * Creates a new SpotRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {ptsl.ISpotRequestBody=} [properties] Properties to set
         * @returns {ptsl.SpotRequestBody} SpotRequestBody instance
         */
        SpotRequestBody.create = function create(properties) {
            return new SpotRequestBody(properties);
        };

        /**
         * Encodes the specified SpotRequestBody message. Does not implicitly {@link ptsl.SpotRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {ptsl.ISpotRequestBody} message SpotRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpotRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackOffsetOptions != null && Object.hasOwnProperty.call(message, "trackOffsetOptions"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trackOffsetOptions);
            if (message.locationData != null && Object.hasOwnProperty.call(message, "locationData"))
                $root.ptsl.SpotLocationData.encode(message.locationData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SpotRequestBody message, length delimited. Does not implicitly {@link ptsl.SpotRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {ptsl.ISpotRequestBody} message SpotRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpotRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpotRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SpotRequestBody} SpotRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpotRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SpotRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.trackOffsetOptions = reader.int32();
                        break;
                    }
                case 2: {
                        message.locationData = $root.ptsl.SpotLocationData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpotRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SpotRequestBody} SpotRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpotRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpotRequestBody message.
         * @function verify
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpotRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackOffsetOptions != null && message.hasOwnProperty("trackOffsetOptions"))
                switch (message.trackOffsetOptions) {
                default:
                    return "trackOffsetOptions: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.locationData != null && message.hasOwnProperty("locationData")) {
                var error = $root.ptsl.SpotLocationData.verify(message.locationData);
                if (error)
                    return "locationData." + error;
            }
            return null;
        };

        /**
         * Creates a SpotRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SpotRequestBody} SpotRequestBody
         */
        SpotRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SpotRequestBody)
                return object;
            var message = new $root.ptsl.SpotRequestBody();
            switch (object.trackOffsetOptions) {
            default:
                if (typeof object.trackOffsetOptions === "number") {
                    message.trackOffsetOptions = object.trackOffsetOptions;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.trackOffsetOptions = 0;
                break;
            case "BarsBeats":
            case 1:
                message.trackOffsetOptions = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.trackOffsetOptions = 1;
                break;
            case "MinSecs":
            case 2:
                message.trackOffsetOptions = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.trackOffsetOptions = 2;
                break;
            case "TimeCode":
            case 3:
                message.trackOffsetOptions = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.trackOffsetOptions = 3;
                break;
            case "FeetFrames":
            case 4:
                message.trackOffsetOptions = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.trackOffsetOptions = 4;
                break;
            case "Samples":
            case 5:
                message.trackOffsetOptions = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.trackOffsetOptions = 5;
                break;
            }
            if (object.locationData != null) {
                if (typeof object.locationData !== "object")
                    throw TypeError(".ptsl.SpotRequestBody.locationData: object expected");
                message.locationData = $root.ptsl.SpotLocationData.fromObject(object.locationData);
            }
            return message;
        };

        /**
         * Creates a plain object from a SpotRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {ptsl.SpotRequestBody} message SpotRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpotRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trackOffsetOptions = options.enums === String ? "TOOptions_Unknown" : 0;
                object.locationData = null;
            }
            if (message.trackOffsetOptions != null && message.hasOwnProperty("trackOffsetOptions"))
                object.trackOffsetOptions = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.trackOffsetOptions] === undefined ? message.trackOffsetOptions : $root.ptsl.TrackOffsetOptions[message.trackOffsetOptions] : message.trackOffsetOptions;
            if (message.locationData != null && message.hasOwnProperty("locationData"))
                object.locationData = $root.ptsl.SpotLocationData.toObject(message.locationData, options);
            return object;
        };

        /**
         * Converts this SpotRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SpotRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpotRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SpotRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SpotRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SpotRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SpotRequestBody";
        };

        return SpotRequestBody;
    })();

    /**
     * Available track list types.
     * @name ptsl.TrackListType
     * @enum {number}
     * @property {number} TListType_Unknown=0 TListType_Unknown value
     * @property {number} AllTracks=1 * @deprecated ptsl::TrackListType::AllTracks is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListType::TListType_AllTracks
     * @property {number} TListType_AllTracks=1 TListType_AllTracks value
     * @property {number} SelectedTracksOnly=2 * @deprecated ptsl::TrackListType::SelectedTracksOnly is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TrackListType::TListType_SelectedTracksOnly
     * @property {number} TListType_SelectedTracksOnly=2 TListType_SelectedTracksOnly value
     */
    ptsl.TrackListType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TListType_Unknown"] = 0;
        values[valuesById[1] = "AllTracks"] = 1;
        values["TListType_AllTracks"] = 1;
        values[valuesById[2] = "SelectedTracksOnly"] = 2;
        values["TListType_SelectedTracksOnly"] = 2;
        return values;
    })();

    /**
     * Available fade handling types.
     * @name ptsl.FadeHandlingType
     * @enum {number}
     * @property {number} FHType_Unknown=0 FHType_Unknown value
     * @property {number} ShowCrossfades=1 * @deprecated ptsl::FadeHandlingType::ShowCrossfades is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FadeHandlingType::FHType_ShowCrossfades
     * @property {number} FHType_ShowCrossfades=1 FHType_ShowCrossfades value
     * @property {number} DontShowCrossfades=2 * @deprecated ptsl::FadeHandlingType::DontShowCrossfades is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FadeHandlingType::FHType_DontShowCrossfades
     * @property {number} FHType_DontShowCrossfades=2 FHType_DontShowCrossfades value
     * @property {number} CombineCrossfadedClips=3 * @deprecated ptsl::FadeHandlingType::CombineCrossfadedClips is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::FadeHandlingType::FHType_CombineCrossfadedClips
     * @property {number} FHType_CombineCrossfadedClips=3 FHType_CombineCrossfadedClips value
     */
    ptsl.FadeHandlingType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FHType_Unknown"] = 0;
        values[valuesById[1] = "ShowCrossfades"] = 1;
        values["FHType_ShowCrossfades"] = 1;
        values[valuesById[2] = "DontShowCrossfades"] = 2;
        values["FHType_DontShowCrossfades"] = 2;
        values[valuesById[3] = "CombineCrossfadedClips"] = 3;
        values["FHType_CombineCrossfadedClips"] = 3;
        return values;
    })();

    /**
     * Available file formats.
     * @name ptsl.TextAsFileFormat
     * @enum {number}
     * @property {number} TFFormat_Unknown=0 TFFormat_Unknown value
     * @property {number} TextEdit=1 * @deprecated ptsl::TextAsFileFormat::TextEdit is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TextAsFileFormat::TFFormat_TextEdit
     * @property {number} TFFormat_TextEdit=1 TFFormat_TextEdit value
     * @property {number} UTF8=2 * @deprecated ptsl::TextAsFileFormat::UTF8 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TextAsFileFormat::TFFormat_UTF8
     * @property {number} TFFormat_UTF8=2 TFFormat_UTF8 value
     */
    ptsl.TextAsFileFormat = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TFFormat_Unknown"] = 0;
        values[valuesById[1] = "TextEdit"] = 1;
        values["TFFormat_TextEdit"] = 1;
        values[valuesById[2] = "UTF8"] = 2;
        values["TFFormat_UTF8"] = 2;
        return values;
    })();

    /**
     * Available output types.
     * @name ptsl.ESI_OutputType
     * @enum {number}
     * @property {number} ESI_Unknown=0 * @deprecated ptsl::ESI_OutputType::ESI_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ESI_OutputType::ESIOType_Unknown
     * @property {number} ESIOType_Unknown=0 ESIOType_Unknown value
     * @property {number} ESI_File=1 * @deprecated ptsl::ESI_OutputType::ESI_File is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ESI_OutputType::ESIOType_File
     * @property {number} ESIOType_File=1 ESIOType_File value
     * @property {number} ESI_String=2 * @deprecated ptsl::ESI_OutputType::ESI_String is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ESI_OutputType::ESIOType_String
     * @property {number} ESIOType_String=2 ESIOType_String value
     */
    ptsl.ESI_OutputType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ESI_Unknown"] = 0;
        values["ESIOType_Unknown"] = 0;
        values[valuesById[1] = "ESI_File"] = 1;
        values["ESIOType_File"] = 1;
        values[valuesById[2] = "ESI_String"] = 2;
        values["ESIOType_String"] = 2;
        return values;
    })();

    ptsl.ExportSessionInfoAsTextRequestBody = (function() {

        /**
         * Properties of an ExportSessionInfoAsTextRequestBody.
         * @memberof ptsl
         * @interface IExportSessionInfoAsTextRequestBody
         * @property {boolean|null} [includeFileList] ExportSessionInfoAsTextRequestBody includeFileList
         * @property {boolean|null} [includeClipList] ExportSessionInfoAsTextRequestBody includeClipList
         * @property {boolean|null} [includeMarkers] ExportSessionInfoAsTextRequestBody includeMarkers
         * @property {boolean|null} [includePluginList] ExportSessionInfoAsTextRequestBody includePluginList
         * @property {boolean|null} [includeTrackEdls] ExportSessionInfoAsTextRequestBody includeTrackEdls
         * @property {boolean|null} [showSubFrames] ExportSessionInfoAsTextRequestBody showSubFrames
         * @property {boolean|null} [includeUserTimestamps] ExportSessionInfoAsTextRequestBody includeUserTimestamps
         * @property {ptsl.TrackListType|null} [trackListType] ExportSessionInfoAsTextRequestBody trackListType
         * @property {ptsl.FadeHandlingType|null} [fadeHandlingType] ExportSessionInfoAsTextRequestBody fadeHandlingType
         * @property {ptsl.TrackOffsetOptions|null} [trackOffsetOptions] ExportSessionInfoAsTextRequestBody trackOffsetOptions
         * @property {ptsl.TextAsFileFormat|null} [textAsFileFormat] ExportSessionInfoAsTextRequestBody textAsFileFormat
         * @property {ptsl.ESI_OutputType|null} [outputType] ExportSessionInfoAsTextRequestBody outputType
         * @property {string|null} [outputPath] ExportSessionInfoAsTextRequestBody outputPath
         * @property {ptsl.TimelineLocationType|null} [locationType] * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new ExportSessionInfoAsTextRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExportSessionInfoAsText request data.
         * @implements IExportSessionInfoAsTextRequestBody
         * @constructor
         * @param {ptsl.IExportSessionInfoAsTextRequestBody=} [properties] Properties to set
         */
        function ExportSessionInfoAsTextRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportSessionInfoAsTextRequestBody includeFileList.
         * @member {boolean} includeFileList
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.includeFileList = false;

        /**
         * ExportSessionInfoAsTextRequestBody includeClipList.
         * @member {boolean} includeClipList
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.includeClipList = false;

        /**
         * ExportSessionInfoAsTextRequestBody includeMarkers.
         * @member {boolean} includeMarkers
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.includeMarkers = false;

        /**
         * ExportSessionInfoAsTextRequestBody includePluginList.
         * @member {boolean} includePluginList
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.includePluginList = false;

        /**
         * ExportSessionInfoAsTextRequestBody includeTrackEdls.
         * @member {boolean} includeTrackEdls
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.includeTrackEdls = false;

        /**
         * ExportSessionInfoAsTextRequestBody showSubFrames.
         * @member {boolean} showSubFrames
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.showSubFrames = false;

        /**
         * ExportSessionInfoAsTextRequestBody includeUserTimestamps.
         * @member {boolean} includeUserTimestamps
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.includeUserTimestamps = false;

        /**
         * ExportSessionInfoAsTextRequestBody trackListType.
         * @member {ptsl.TrackListType} trackListType
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.trackListType = 0;

        /**
         * ExportSessionInfoAsTextRequestBody fadeHandlingType.
         * @member {ptsl.FadeHandlingType} fadeHandlingType
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.fadeHandlingType = 0;

        /**
         * ExportSessionInfoAsTextRequestBody trackOffsetOptions.
         * @member {ptsl.TrackOffsetOptions} trackOffsetOptions
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.trackOffsetOptions = 0;

        /**
         * ExportSessionInfoAsTextRequestBody textAsFileFormat.
         * @member {ptsl.TextAsFileFormat} textAsFileFormat
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.textAsFileFormat = 0;

        /**
         * ExportSessionInfoAsTextRequestBody outputType.
         * @member {ptsl.ESI_OutputType} outputType
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.outputType = 0;

        /**
         * ExportSessionInfoAsTextRequestBody outputPath.
         * @member {string} outputPath
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.outputPath = "";

        /**
         * * @since Pro Tools 2025.06
         * @member {ptsl.TimelineLocationType} locationType
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         */
        ExportSessionInfoAsTextRequestBody.prototype.locationType = 0;

        /**
         * Creates a new ExportSessionInfoAsTextRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {ptsl.IExportSessionInfoAsTextRequestBody=} [properties] Properties to set
         * @returns {ptsl.ExportSessionInfoAsTextRequestBody} ExportSessionInfoAsTextRequestBody instance
         */
        ExportSessionInfoAsTextRequestBody.create = function create(properties) {
            return new ExportSessionInfoAsTextRequestBody(properties);
        };

        /**
         * Encodes the specified ExportSessionInfoAsTextRequestBody message. Does not implicitly {@link ptsl.ExportSessionInfoAsTextRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {ptsl.IExportSessionInfoAsTextRequestBody} message ExportSessionInfoAsTextRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportSessionInfoAsTextRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.includeFileList != null && Object.hasOwnProperty.call(message, "includeFileList"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.includeFileList);
            if (message.includeClipList != null && Object.hasOwnProperty.call(message, "includeClipList"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeClipList);
            if (message.includeMarkers != null && Object.hasOwnProperty.call(message, "includeMarkers"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeMarkers);
            if (message.includePluginList != null && Object.hasOwnProperty.call(message, "includePluginList"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includePluginList);
            if (message.includeTrackEdls != null && Object.hasOwnProperty.call(message, "includeTrackEdls"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeTrackEdls);
            if (message.showSubFrames != null && Object.hasOwnProperty.call(message, "showSubFrames"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.showSubFrames);
            if (message.includeUserTimestamps != null && Object.hasOwnProperty.call(message, "includeUserTimestamps"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.includeUserTimestamps);
            if (message.trackListType != null && Object.hasOwnProperty.call(message, "trackListType"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.trackListType);
            if (message.fadeHandlingType != null && Object.hasOwnProperty.call(message, "fadeHandlingType"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.fadeHandlingType);
            if (message.trackOffsetOptions != null && Object.hasOwnProperty.call(message, "trackOffsetOptions"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.trackOffsetOptions);
            if (message.textAsFileFormat != null && Object.hasOwnProperty.call(message, "textAsFileFormat"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.textAsFileFormat);
            if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.outputType);
            if (message.outputPath != null && Object.hasOwnProperty.call(message, "outputPath"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.outputPath);
            if (message.locationType != null && Object.hasOwnProperty.call(message, "locationType"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.locationType);
            return writer;
        };

        /**
         * Encodes the specified ExportSessionInfoAsTextRequestBody message, length delimited. Does not implicitly {@link ptsl.ExportSessionInfoAsTextRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {ptsl.IExportSessionInfoAsTextRequestBody} message ExportSessionInfoAsTextRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportSessionInfoAsTextRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportSessionInfoAsTextRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExportSessionInfoAsTextRequestBody} ExportSessionInfoAsTextRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportSessionInfoAsTextRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExportSessionInfoAsTextRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.includeFileList = reader.bool();
                        break;
                    }
                case 2: {
                        message.includeClipList = reader.bool();
                        break;
                    }
                case 3: {
                        message.includeMarkers = reader.bool();
                        break;
                    }
                case 4: {
                        message.includePluginList = reader.bool();
                        break;
                    }
                case 5: {
                        message.includeTrackEdls = reader.bool();
                        break;
                    }
                case 6: {
                        message.showSubFrames = reader.bool();
                        break;
                    }
                case 7: {
                        message.includeUserTimestamps = reader.bool();
                        break;
                    }
                case 8: {
                        message.trackListType = reader.int32();
                        break;
                    }
                case 9: {
                        message.fadeHandlingType = reader.int32();
                        break;
                    }
                case 10: {
                        message.trackOffsetOptions = reader.int32();
                        break;
                    }
                case 11: {
                        message.textAsFileFormat = reader.int32();
                        break;
                    }
                case 12: {
                        message.outputType = reader.int32();
                        break;
                    }
                case 13: {
                        message.outputPath = reader.string();
                        break;
                    }
                case 14: {
                        message.locationType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportSessionInfoAsTextRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExportSessionInfoAsTextRequestBody} ExportSessionInfoAsTextRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportSessionInfoAsTextRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportSessionInfoAsTextRequestBody message.
         * @function verify
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportSessionInfoAsTextRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.includeFileList != null && message.hasOwnProperty("includeFileList"))
                if (typeof message.includeFileList !== "boolean")
                    return "includeFileList: boolean expected";
            if (message.includeClipList != null && message.hasOwnProperty("includeClipList"))
                if (typeof message.includeClipList !== "boolean")
                    return "includeClipList: boolean expected";
            if (message.includeMarkers != null && message.hasOwnProperty("includeMarkers"))
                if (typeof message.includeMarkers !== "boolean")
                    return "includeMarkers: boolean expected";
            if (message.includePluginList != null && message.hasOwnProperty("includePluginList"))
                if (typeof message.includePluginList !== "boolean")
                    return "includePluginList: boolean expected";
            if (message.includeTrackEdls != null && message.hasOwnProperty("includeTrackEdls"))
                if (typeof message.includeTrackEdls !== "boolean")
                    return "includeTrackEdls: boolean expected";
            if (message.showSubFrames != null && message.hasOwnProperty("showSubFrames"))
                if (typeof message.showSubFrames !== "boolean")
                    return "showSubFrames: boolean expected";
            if (message.includeUserTimestamps != null && message.hasOwnProperty("includeUserTimestamps"))
                if (typeof message.includeUserTimestamps !== "boolean")
                    return "includeUserTimestamps: boolean expected";
            if (message.trackListType != null && message.hasOwnProperty("trackListType"))
                switch (message.trackListType) {
                default:
                    return "trackListType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.fadeHandlingType != null && message.hasOwnProperty("fadeHandlingType"))
                switch (message.fadeHandlingType) {
                default:
                    return "fadeHandlingType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.trackOffsetOptions != null && message.hasOwnProperty("trackOffsetOptions"))
                switch (message.trackOffsetOptions) {
                default:
                    return "trackOffsetOptions: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.textAsFileFormat != null && message.hasOwnProperty("textAsFileFormat"))
                switch (message.textAsFileFormat) {
                default:
                    return "textAsFileFormat: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.outputType != null && message.hasOwnProperty("outputType"))
                switch (message.outputType) {
                default:
                    return "outputType: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.outputPath != null && message.hasOwnProperty("outputPath"))
                if (!$util.isString(message.outputPath))
                    return "outputPath: string expected";
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                switch (message.locationType) {
                default:
                    return "locationType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates an ExportSessionInfoAsTextRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExportSessionInfoAsTextRequestBody} ExportSessionInfoAsTextRequestBody
         */
        ExportSessionInfoAsTextRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExportSessionInfoAsTextRequestBody)
                return object;
            var message = new $root.ptsl.ExportSessionInfoAsTextRequestBody();
            if (object.includeFileList != null)
                message.includeFileList = Boolean(object.includeFileList);
            if (object.includeClipList != null)
                message.includeClipList = Boolean(object.includeClipList);
            if (object.includeMarkers != null)
                message.includeMarkers = Boolean(object.includeMarkers);
            if (object.includePluginList != null)
                message.includePluginList = Boolean(object.includePluginList);
            if (object.includeTrackEdls != null)
                message.includeTrackEdls = Boolean(object.includeTrackEdls);
            if (object.showSubFrames != null)
                message.showSubFrames = Boolean(object.showSubFrames);
            if (object.includeUserTimestamps != null)
                message.includeUserTimestamps = Boolean(object.includeUserTimestamps);
            switch (object.trackListType) {
            default:
                if (typeof object.trackListType === "number") {
                    message.trackListType = object.trackListType;
                    break;
                }
                break;
            case "TListType_Unknown":
            case 0:
                message.trackListType = 0;
                break;
            case "AllTracks":
            case 1:
                message.trackListType = 1;
                break;
            case "TListType_AllTracks":
            case 1:
                message.trackListType = 1;
                break;
            case "SelectedTracksOnly":
            case 2:
                message.trackListType = 2;
                break;
            case "TListType_SelectedTracksOnly":
            case 2:
                message.trackListType = 2;
                break;
            }
            switch (object.fadeHandlingType) {
            default:
                if (typeof object.fadeHandlingType === "number") {
                    message.fadeHandlingType = object.fadeHandlingType;
                    break;
                }
                break;
            case "FHType_Unknown":
            case 0:
                message.fadeHandlingType = 0;
                break;
            case "ShowCrossfades":
            case 1:
                message.fadeHandlingType = 1;
                break;
            case "FHType_ShowCrossfades":
            case 1:
                message.fadeHandlingType = 1;
                break;
            case "DontShowCrossfades":
            case 2:
                message.fadeHandlingType = 2;
                break;
            case "FHType_DontShowCrossfades":
            case 2:
                message.fadeHandlingType = 2;
                break;
            case "CombineCrossfadedClips":
            case 3:
                message.fadeHandlingType = 3;
                break;
            case "FHType_CombineCrossfadedClips":
            case 3:
                message.fadeHandlingType = 3;
                break;
            }
            switch (object.trackOffsetOptions) {
            default:
                if (typeof object.trackOffsetOptions === "number") {
                    message.trackOffsetOptions = object.trackOffsetOptions;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.trackOffsetOptions = 0;
                break;
            case "BarsBeats":
            case 1:
                message.trackOffsetOptions = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.trackOffsetOptions = 1;
                break;
            case "MinSecs":
            case 2:
                message.trackOffsetOptions = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.trackOffsetOptions = 2;
                break;
            case "TimeCode":
            case 3:
                message.trackOffsetOptions = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.trackOffsetOptions = 3;
                break;
            case "FeetFrames":
            case 4:
                message.trackOffsetOptions = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.trackOffsetOptions = 4;
                break;
            case "Samples":
            case 5:
                message.trackOffsetOptions = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.trackOffsetOptions = 5;
                break;
            }
            switch (object.textAsFileFormat) {
            default:
                if (typeof object.textAsFileFormat === "number") {
                    message.textAsFileFormat = object.textAsFileFormat;
                    break;
                }
                break;
            case "TFFormat_Unknown":
            case 0:
                message.textAsFileFormat = 0;
                break;
            case "TextEdit":
            case 1:
                message.textAsFileFormat = 1;
                break;
            case "TFFormat_TextEdit":
            case 1:
                message.textAsFileFormat = 1;
                break;
            case "UTF8":
            case 2:
                message.textAsFileFormat = 2;
                break;
            case "TFFormat_UTF8":
            case 2:
                message.textAsFileFormat = 2;
                break;
            }
            switch (object.outputType) {
            default:
                if (typeof object.outputType === "number") {
                    message.outputType = object.outputType;
                    break;
                }
                break;
            case "ESI_Unknown":
            case 0:
                message.outputType = 0;
                break;
            case "ESIOType_Unknown":
            case 0:
                message.outputType = 0;
                break;
            case "ESI_File":
            case 1:
                message.outputType = 1;
                break;
            case "ESIOType_File":
            case 1:
                message.outputType = 1;
                break;
            case "ESI_String":
            case 2:
                message.outputType = 2;
                break;
            case "ESIOType_String":
            case 2:
                message.outputType = 2;
                break;
            }
            if (object.outputPath != null)
                message.outputPath = String(object.outputPath);
            switch (object.locationType) {
            default:
                if (typeof object.locationType === "number") {
                    message.locationType = object.locationType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.locationType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.locationType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.locationType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.locationType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.locationType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.locationType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.locationType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.locationType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.locationType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an ExportSessionInfoAsTextRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {ptsl.ExportSessionInfoAsTextRequestBody} message ExportSessionInfoAsTextRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportSessionInfoAsTextRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.includeFileList = false;
                object.includeClipList = false;
                object.includeMarkers = false;
                object.includePluginList = false;
                object.includeTrackEdls = false;
                object.showSubFrames = false;
                object.includeUserTimestamps = false;
                object.trackListType = options.enums === String ? "TListType_Unknown" : 0;
                object.fadeHandlingType = options.enums === String ? "FHType_Unknown" : 0;
                object.trackOffsetOptions = options.enums === String ? "TOOptions_Unknown" : 0;
                object.textAsFileFormat = options.enums === String ? "TFFormat_Unknown" : 0;
                object.outputType = options.enums === String ? "ESI_Unknown" : 0;
                object.outputPath = "";
                object.locationType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.includeFileList != null && message.hasOwnProperty("includeFileList"))
                object.includeFileList = message.includeFileList;
            if (message.includeClipList != null && message.hasOwnProperty("includeClipList"))
                object.includeClipList = message.includeClipList;
            if (message.includeMarkers != null && message.hasOwnProperty("includeMarkers"))
                object.includeMarkers = message.includeMarkers;
            if (message.includePluginList != null && message.hasOwnProperty("includePluginList"))
                object.includePluginList = message.includePluginList;
            if (message.includeTrackEdls != null && message.hasOwnProperty("includeTrackEdls"))
                object.includeTrackEdls = message.includeTrackEdls;
            if (message.showSubFrames != null && message.hasOwnProperty("showSubFrames"))
                object.showSubFrames = message.showSubFrames;
            if (message.includeUserTimestamps != null && message.hasOwnProperty("includeUserTimestamps"))
                object.includeUserTimestamps = message.includeUserTimestamps;
            if (message.trackListType != null && message.hasOwnProperty("trackListType"))
                object.trackListType = options.enums === String ? $root.ptsl.TrackListType[message.trackListType] === undefined ? message.trackListType : $root.ptsl.TrackListType[message.trackListType] : message.trackListType;
            if (message.fadeHandlingType != null && message.hasOwnProperty("fadeHandlingType"))
                object.fadeHandlingType = options.enums === String ? $root.ptsl.FadeHandlingType[message.fadeHandlingType] === undefined ? message.fadeHandlingType : $root.ptsl.FadeHandlingType[message.fadeHandlingType] : message.fadeHandlingType;
            if (message.trackOffsetOptions != null && message.hasOwnProperty("trackOffsetOptions"))
                object.trackOffsetOptions = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.trackOffsetOptions] === undefined ? message.trackOffsetOptions : $root.ptsl.TrackOffsetOptions[message.trackOffsetOptions] : message.trackOffsetOptions;
            if (message.textAsFileFormat != null && message.hasOwnProperty("textAsFileFormat"))
                object.textAsFileFormat = options.enums === String ? $root.ptsl.TextAsFileFormat[message.textAsFileFormat] === undefined ? message.textAsFileFormat : $root.ptsl.TextAsFileFormat[message.textAsFileFormat] : message.textAsFileFormat;
            if (message.outputType != null && message.hasOwnProperty("outputType"))
                object.outputType = options.enums === String ? $root.ptsl.ESI_OutputType[message.outputType] === undefined ? message.outputType : $root.ptsl.ESI_OutputType[message.outputType] : message.outputType;
            if (message.outputPath != null && message.hasOwnProperty("outputPath"))
                object.outputPath = message.outputPath;
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                object.locationType = options.enums === String ? $root.ptsl.TimelineLocationType[message.locationType] === undefined ? message.locationType : $root.ptsl.TimelineLocationType[message.locationType] : message.locationType;
            return object;
        };

        /**
         * Converts this ExportSessionInfoAsTextRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportSessionInfoAsTextRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExportSessionInfoAsTextRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ExportSessionInfoAsTextRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExportSessionInfoAsTextRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExportSessionInfoAsTextRequestBody";
        };

        return ExportSessionInfoAsTextRequestBody;
    })();

    ptsl.ExportSessionInfoAsTextResponseBody = (function() {

        /**
         * Properties of an ExportSessionInfoAsTextResponseBody.
         * @memberof ptsl
         * @interface IExportSessionInfoAsTextResponseBody
         * @property {string|null} [sessionInfo] ExportSessionInfoAsTextResponseBody sessionInfo
         */

        /**
         * Constructs a new ExportSessionInfoAsTextResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExportSessionInfoAsText response data.
         * @implements IExportSessionInfoAsTextResponseBody
         * @constructor
         * @param {ptsl.IExportSessionInfoAsTextResponseBody=} [properties] Properties to set
         */
        function ExportSessionInfoAsTextResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportSessionInfoAsTextResponseBody sessionInfo.
         * @member {string} sessionInfo
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @instance
         */
        ExportSessionInfoAsTextResponseBody.prototype.sessionInfo = "";

        /**
         * Creates a new ExportSessionInfoAsTextResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {ptsl.IExportSessionInfoAsTextResponseBody=} [properties] Properties to set
         * @returns {ptsl.ExportSessionInfoAsTextResponseBody} ExportSessionInfoAsTextResponseBody instance
         */
        ExportSessionInfoAsTextResponseBody.create = function create(properties) {
            return new ExportSessionInfoAsTextResponseBody(properties);
        };

        /**
         * Encodes the specified ExportSessionInfoAsTextResponseBody message. Does not implicitly {@link ptsl.ExportSessionInfoAsTextResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {ptsl.IExportSessionInfoAsTextResponseBody} message ExportSessionInfoAsTextResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportSessionInfoAsTextResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionInfo != null && Object.hasOwnProperty.call(message, "sessionInfo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionInfo);
            return writer;
        };

        /**
         * Encodes the specified ExportSessionInfoAsTextResponseBody message, length delimited. Does not implicitly {@link ptsl.ExportSessionInfoAsTextResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {ptsl.IExportSessionInfoAsTextResponseBody} message ExportSessionInfoAsTextResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportSessionInfoAsTextResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportSessionInfoAsTextResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExportSessionInfoAsTextResponseBody} ExportSessionInfoAsTextResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportSessionInfoAsTextResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExportSessionInfoAsTextResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionInfo = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportSessionInfoAsTextResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExportSessionInfoAsTextResponseBody} ExportSessionInfoAsTextResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportSessionInfoAsTextResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportSessionInfoAsTextResponseBody message.
         * @function verify
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportSessionInfoAsTextResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionInfo != null && message.hasOwnProperty("sessionInfo"))
                if (!$util.isString(message.sessionInfo))
                    return "sessionInfo: string expected";
            return null;
        };

        /**
         * Creates an ExportSessionInfoAsTextResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExportSessionInfoAsTextResponseBody} ExportSessionInfoAsTextResponseBody
         */
        ExportSessionInfoAsTextResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExportSessionInfoAsTextResponseBody)
                return object;
            var message = new $root.ptsl.ExportSessionInfoAsTextResponseBody();
            if (object.sessionInfo != null)
                message.sessionInfo = String(object.sessionInfo);
            return message;
        };

        /**
         * Creates a plain object from an ExportSessionInfoAsTextResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {ptsl.ExportSessionInfoAsTextResponseBody} message ExportSessionInfoAsTextResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportSessionInfoAsTextResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionInfo = "";
            if (message.sessionInfo != null && message.hasOwnProperty("sessionInfo"))
                object.sessionInfo = message.sessionInfo;
            return object;
        };

        /**
         * Converts this ExportSessionInfoAsTextResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportSessionInfoAsTextResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExportSessionInfoAsTextResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ExportSessionInfoAsTextResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExportSessionInfoAsTextResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExportSessionInfoAsTextResponseBody";
        };

        return ExportSessionInfoAsTextResponseBody;
    })();

    /**
     * Types of the playback mode.
     * Renamed to PlaybackMode starting in Pro Tools 2025.06 (was PM_PlaybackMode)
     * @name ptsl.PlaybackMode
     * @enum {number}
     * @property {number} PMode_Unknown=0 PMode_Unknown value
     * @property {number} PM_Normal=1 * @deprecated ptsl::PlaybackMode::PM_Normal is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::PlaybackMode::PMode_Normal
     * @property {number} PMode_Normal=1 PMode_Normal value
     * @property {number} PM_Loop=2 * @deprecated ptsl::PlaybackMode::PM_Loop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::PlaybackMode::PMode_Loop
     * @property {number} PMode_Loop=2 PMode_Loop value
     * @property {number} PM_DynamicTransport=3 * @deprecated ptsl::PlaybackMode::PM_DynamicTransport is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::PlaybackMode::PMode_DynamicTransport
     * @property {number} PMode_DynamicTransport=3 PMode_DynamicTransport value
     */
    ptsl.PlaybackMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PMode_Unknown"] = 0;
        values[valuesById[1] = "PM_Normal"] = 1;
        values["PMode_Normal"] = 1;
        values[valuesById[2] = "PM_Loop"] = 2;
        values["PMode_Loop"] = 2;
        values[valuesById[3] = "PM_DynamicTransport"] = 3;
        values["PMode_DynamicTransport"] = 3;
        return values;
    })();

    ptsl.SetPlaybackModeRequestBody = (function() {

        /**
         * Properties of a SetPlaybackModeRequestBody.
         * @memberof ptsl
         * @interface ISetPlaybackModeRequestBody
         * @property {ptsl.PlaybackMode|null} [playbackMode] SetPlaybackModeRequestBody playbackMode
         */

        /**
         * Constructs a new SetPlaybackModeRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetPlaybackMode request data.
         * @implements ISetPlaybackModeRequestBody
         * @constructor
         * @param {ptsl.ISetPlaybackModeRequestBody=} [properties] Properties to set
         */
        function SetPlaybackModeRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetPlaybackModeRequestBody playbackMode.
         * @member {ptsl.PlaybackMode} playbackMode
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @instance
         */
        SetPlaybackModeRequestBody.prototype.playbackMode = 0;

        /**
         * Creates a new SetPlaybackModeRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {ptsl.ISetPlaybackModeRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetPlaybackModeRequestBody} SetPlaybackModeRequestBody instance
         */
        SetPlaybackModeRequestBody.create = function create(properties) {
            return new SetPlaybackModeRequestBody(properties);
        };

        /**
         * Encodes the specified SetPlaybackModeRequestBody message. Does not implicitly {@link ptsl.SetPlaybackModeRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {ptsl.ISetPlaybackModeRequestBody} message SetPlaybackModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetPlaybackModeRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playbackMode != null && Object.hasOwnProperty.call(message, "playbackMode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playbackMode);
            return writer;
        };

        /**
         * Encodes the specified SetPlaybackModeRequestBody message, length delimited. Does not implicitly {@link ptsl.SetPlaybackModeRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {ptsl.ISetPlaybackModeRequestBody} message SetPlaybackModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetPlaybackModeRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetPlaybackModeRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetPlaybackModeRequestBody} SetPlaybackModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetPlaybackModeRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetPlaybackModeRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.playbackMode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetPlaybackModeRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetPlaybackModeRequestBody} SetPlaybackModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetPlaybackModeRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetPlaybackModeRequestBody message.
         * @function verify
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetPlaybackModeRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playbackMode != null && message.hasOwnProperty("playbackMode"))
                switch (message.playbackMode) {
                default:
                    return "playbackMode: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetPlaybackModeRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetPlaybackModeRequestBody} SetPlaybackModeRequestBody
         */
        SetPlaybackModeRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetPlaybackModeRequestBody)
                return object;
            var message = new $root.ptsl.SetPlaybackModeRequestBody();
            switch (object.playbackMode) {
            default:
                if (typeof object.playbackMode === "number") {
                    message.playbackMode = object.playbackMode;
                    break;
                }
                break;
            case "PMode_Unknown":
            case 0:
                message.playbackMode = 0;
                break;
            case "PM_Normal":
            case 1:
                message.playbackMode = 1;
                break;
            case "PMode_Normal":
            case 1:
                message.playbackMode = 1;
                break;
            case "PM_Loop":
            case 2:
                message.playbackMode = 2;
                break;
            case "PMode_Loop":
            case 2:
                message.playbackMode = 2;
                break;
            case "PM_DynamicTransport":
            case 3:
                message.playbackMode = 3;
                break;
            case "PMode_DynamicTransport":
            case 3:
                message.playbackMode = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetPlaybackModeRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {ptsl.SetPlaybackModeRequestBody} message SetPlaybackModeRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetPlaybackModeRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playbackMode = options.enums === String ? "PMode_Unknown" : 0;
            if (message.playbackMode != null && message.hasOwnProperty("playbackMode"))
                object.playbackMode = options.enums === String ? $root.ptsl.PlaybackMode[message.playbackMode] === undefined ? message.playbackMode : $root.ptsl.PlaybackMode[message.playbackMode] : message.playbackMode;
            return object;
        };

        /**
         * Converts this SetPlaybackModeRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetPlaybackModeRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetPlaybackModeRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetPlaybackModeRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetPlaybackModeRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetPlaybackModeRequestBody";
        };

        return SetPlaybackModeRequestBody;
    })();

    ptsl.SetPlaybackModeResponseBody = (function() {

        /**
         * Properties of a SetPlaybackModeResponseBody.
         * @memberof ptsl
         * @interface ISetPlaybackModeResponseBody
         * @property {ptsl.PlaybackMode|null} [currentPlaybackMode] SetPlaybackModeResponseBody currentPlaybackMode
         * @property {Array.<ptsl.PlaybackMode>|null} [playbackModeList] SetPlaybackModeResponseBody playbackModeList
         */

        /**
         * Constructs a new SetPlaybackModeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetPlaybackMode response data.
         * @implements ISetPlaybackModeResponseBody
         * @constructor
         * @param {ptsl.ISetPlaybackModeResponseBody=} [properties] Properties to set
         */
        function SetPlaybackModeResponseBody(properties) {
            this.playbackModeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetPlaybackModeResponseBody currentPlaybackMode.
         * @member {ptsl.PlaybackMode} currentPlaybackMode
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @instance
         */
        SetPlaybackModeResponseBody.prototype.currentPlaybackMode = 0;

        /**
         * SetPlaybackModeResponseBody playbackModeList.
         * @member {Array.<ptsl.PlaybackMode>} playbackModeList
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @instance
         */
        SetPlaybackModeResponseBody.prototype.playbackModeList = $util.emptyArray;

        /**
         * Creates a new SetPlaybackModeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {ptsl.ISetPlaybackModeResponseBody=} [properties] Properties to set
         * @returns {ptsl.SetPlaybackModeResponseBody} SetPlaybackModeResponseBody instance
         */
        SetPlaybackModeResponseBody.create = function create(properties) {
            return new SetPlaybackModeResponseBody(properties);
        };

        /**
         * Encodes the specified SetPlaybackModeResponseBody message. Does not implicitly {@link ptsl.SetPlaybackModeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {ptsl.ISetPlaybackModeResponseBody} message SetPlaybackModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetPlaybackModeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentPlaybackMode != null && Object.hasOwnProperty.call(message, "currentPlaybackMode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentPlaybackMode);
            if (message.playbackModeList != null && message.playbackModeList.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.playbackModeList.length; ++i)
                    writer.int32(message.playbackModeList[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SetPlaybackModeResponseBody message, length delimited. Does not implicitly {@link ptsl.SetPlaybackModeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {ptsl.ISetPlaybackModeResponseBody} message SetPlaybackModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetPlaybackModeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetPlaybackModeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetPlaybackModeResponseBody} SetPlaybackModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetPlaybackModeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetPlaybackModeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentPlaybackMode = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.playbackModeList && message.playbackModeList.length))
                            message.playbackModeList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.playbackModeList.push(reader.int32());
                        } else
                            message.playbackModeList.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetPlaybackModeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetPlaybackModeResponseBody} SetPlaybackModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetPlaybackModeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetPlaybackModeResponseBody message.
         * @function verify
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetPlaybackModeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentPlaybackMode != null && message.hasOwnProperty("currentPlaybackMode"))
                switch (message.currentPlaybackMode) {
                default:
                    return "currentPlaybackMode: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.playbackModeList != null && message.hasOwnProperty("playbackModeList")) {
                if (!Array.isArray(message.playbackModeList))
                    return "playbackModeList: array expected";
                for (var i = 0; i < message.playbackModeList.length; ++i)
                    switch (message.playbackModeList[i]) {
                    default:
                        return "playbackModeList: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a SetPlaybackModeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetPlaybackModeResponseBody} SetPlaybackModeResponseBody
         */
        SetPlaybackModeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetPlaybackModeResponseBody)
                return object;
            var message = new $root.ptsl.SetPlaybackModeResponseBody();
            switch (object.currentPlaybackMode) {
            default:
                if (typeof object.currentPlaybackMode === "number") {
                    message.currentPlaybackMode = object.currentPlaybackMode;
                    break;
                }
                break;
            case "PMode_Unknown":
            case 0:
                message.currentPlaybackMode = 0;
                break;
            case "PM_Normal":
            case 1:
                message.currentPlaybackMode = 1;
                break;
            case "PMode_Normal":
            case 1:
                message.currentPlaybackMode = 1;
                break;
            case "PM_Loop":
            case 2:
                message.currentPlaybackMode = 2;
                break;
            case "PMode_Loop":
            case 2:
                message.currentPlaybackMode = 2;
                break;
            case "PM_DynamicTransport":
            case 3:
                message.currentPlaybackMode = 3;
                break;
            case "PMode_DynamicTransport":
            case 3:
                message.currentPlaybackMode = 3;
                break;
            }
            if (object.playbackModeList) {
                if (!Array.isArray(object.playbackModeList))
                    throw TypeError(".ptsl.SetPlaybackModeResponseBody.playbackModeList: array expected");
                message.playbackModeList = [];
                for (var i = 0; i < object.playbackModeList.length; ++i)
                    switch (object.playbackModeList[i]) {
                    default:
                        if (typeof object.playbackModeList[i] === "number") {
                            message.playbackModeList[i] = object.playbackModeList[i];
                            break;
                        }
                    case "PMode_Unknown":
                    case 0:
                        message.playbackModeList[i] = 0;
                        break;
                    case "PM_Normal":
                    case 1:
                        message.playbackModeList[i] = 1;
                        break;
                    case "PMode_Normal":
                    case 1:
                        message.playbackModeList[i] = 1;
                        break;
                    case "PM_Loop":
                    case 2:
                        message.playbackModeList[i] = 2;
                        break;
                    case "PMode_Loop":
                    case 2:
                        message.playbackModeList[i] = 2;
                        break;
                    case "PM_DynamicTransport":
                    case 3:
                        message.playbackModeList[i] = 3;
                        break;
                    case "PMode_DynamicTransport":
                    case 3:
                        message.playbackModeList[i] = 3;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a SetPlaybackModeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {ptsl.SetPlaybackModeResponseBody} message SetPlaybackModeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetPlaybackModeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.playbackModeList = [];
            if (options.defaults)
                object.currentPlaybackMode = options.enums === String ? "PMode_Unknown" : 0;
            if (message.currentPlaybackMode != null && message.hasOwnProperty("currentPlaybackMode"))
                object.currentPlaybackMode = options.enums === String ? $root.ptsl.PlaybackMode[message.currentPlaybackMode] === undefined ? message.currentPlaybackMode : $root.ptsl.PlaybackMode[message.currentPlaybackMode] : message.currentPlaybackMode;
            if (message.playbackModeList && message.playbackModeList.length) {
                object.playbackModeList = [];
                for (var j = 0; j < message.playbackModeList.length; ++j)
                    object.playbackModeList[j] = options.enums === String ? $root.ptsl.PlaybackMode[message.playbackModeList[j]] === undefined ? message.playbackModeList[j] : $root.ptsl.PlaybackMode[message.playbackModeList[j]] : message.playbackModeList[j];
            }
            return object;
        };

        /**
         * Converts this SetPlaybackModeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetPlaybackModeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetPlaybackModeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.SetPlaybackModeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetPlaybackModeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetPlaybackModeResponseBody";
        };

        return SetPlaybackModeResponseBody;
    })();

    /**
     * Types of the record mode.
     * Renamed to RecordMode starting in Pro Tools 2025.06 (was RM_RecordMode)
     * @name ptsl.RecordMode
     * @enum {number}
     * @property {number} RMode_Unknown=0 RMode_Unknown value
     * @property {number} RM_Normal=0 * @deprecated ptsl::RecordMode::RM_Normal is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::RecordMode::RMode_Normal
     * @property {number} RMode_Normal=1 RMode_Normal value
     * @property {number} RM_Loop=1 * @deprecated ptsl::RecordMode::RM_Loop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::RecordMode::RMode_Loop
     * @property {number} RMode_Loop=2 RMode_Loop value
     * @property {number} RM_Destructive=2 * @deprecated ptsl::RecordMode::RM_Destructive is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::RecordMode::RMode_Destructive
     * @property {number} RMode_Destructive=3 RMode_Destructive value
     * @property {number} RM_QuickPunch=3 * @deprecated ptsl::RecordMode::RM_QuickPunch is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::RecordMode::RMode_QuickPunch
     * @property {number} RMode_QuickPunch=4 RMode_QuickPunch value
     * @property {number} RM_TrackPunch=4 * @deprecated ptsl::RecordMode::RM_TrackPunch is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::RecordMode::RMode_TrackPunch
     * @property {number} RMode_TrackPunch=5 RMode_TrackPunch value
     * @property {number} RM_DestructivePunch=5 * @deprecated ptsl::RecordMode::RM_DestructivePunch is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::RecordMode::RMode_DestructivePunch
     * @property {number} RMode_DestructivePunch=6 RMode_DestructivePunch value
     */
    ptsl.RecordMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RMode_Unknown"] = 0;
        values["RM_Normal"] = 0;
        values[valuesById[1] = "RMode_Normal"] = 1;
        values["RM_Loop"] = 1;
        values[valuesById[2] = "RMode_Loop"] = 2;
        values["RM_Destructive"] = 2;
        values[valuesById[3] = "RMode_Destructive"] = 3;
        values["RM_QuickPunch"] = 3;
        values[valuesById[4] = "RMode_QuickPunch"] = 4;
        values["RM_TrackPunch"] = 4;
        values[valuesById[5] = "RMode_TrackPunch"] = 5;
        values["RM_DestructivePunch"] = 5;
        values[valuesById[6] = "RMode_DestructivePunch"] = 6;
        return values;
    })();

    ptsl.SetRecordModeRequestBody = (function() {

        /**
         * Properties of a SetRecordModeRequestBody.
         * @memberof ptsl
         * @interface ISetRecordModeRequestBody
         * @property {ptsl.RecordMode|null} [recordMode] SetRecordModeRequestBody recordMode
         * @property {boolean|null} [recordArmTransport] SetRecordModeRequestBody recordArmTransport
         */

        /**
         * Constructs a new SetRecordModeRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetRecordMode request data.
         * @implements ISetRecordModeRequestBody
         * @constructor
         * @param {ptsl.ISetRecordModeRequestBody=} [properties] Properties to set
         */
        function SetRecordModeRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetRecordModeRequestBody recordMode.
         * @member {ptsl.RecordMode} recordMode
         * @memberof ptsl.SetRecordModeRequestBody
         * @instance
         */
        SetRecordModeRequestBody.prototype.recordMode = 0;

        /**
         * SetRecordModeRequestBody recordArmTransport.
         * @member {boolean} recordArmTransport
         * @memberof ptsl.SetRecordModeRequestBody
         * @instance
         */
        SetRecordModeRequestBody.prototype.recordArmTransport = false;

        /**
         * Creates a new SetRecordModeRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {ptsl.ISetRecordModeRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetRecordModeRequestBody} SetRecordModeRequestBody instance
         */
        SetRecordModeRequestBody.create = function create(properties) {
            return new SetRecordModeRequestBody(properties);
        };

        /**
         * Encodes the specified SetRecordModeRequestBody message. Does not implicitly {@link ptsl.SetRecordModeRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {ptsl.ISetRecordModeRequestBody} message SetRecordModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRecordModeRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordMode != null && Object.hasOwnProperty.call(message, "recordMode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.recordMode);
            if (message.recordArmTransport != null && Object.hasOwnProperty.call(message, "recordArmTransport"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recordArmTransport);
            return writer;
        };

        /**
         * Encodes the specified SetRecordModeRequestBody message, length delimited. Does not implicitly {@link ptsl.SetRecordModeRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {ptsl.ISetRecordModeRequestBody} message SetRecordModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRecordModeRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetRecordModeRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetRecordModeRequestBody} SetRecordModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRecordModeRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetRecordModeRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.recordMode = reader.int32();
                        break;
                    }
                case 2: {
                        message.recordArmTransport = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetRecordModeRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetRecordModeRequestBody} SetRecordModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRecordModeRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetRecordModeRequestBody message.
         * @function verify
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetRecordModeRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordMode != null && message.hasOwnProperty("recordMode"))
                switch (message.recordMode) {
                default:
                    return "recordMode: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                    break;
                }
            if (message.recordArmTransport != null && message.hasOwnProperty("recordArmTransport"))
                if (typeof message.recordArmTransport !== "boolean")
                    return "recordArmTransport: boolean expected";
            return null;
        };

        /**
         * Creates a SetRecordModeRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetRecordModeRequestBody} SetRecordModeRequestBody
         */
        SetRecordModeRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetRecordModeRequestBody)
                return object;
            var message = new $root.ptsl.SetRecordModeRequestBody();
            switch (object.recordMode) {
            default:
                if (typeof object.recordMode === "number") {
                    message.recordMode = object.recordMode;
                    break;
                }
                break;
            case "RMode_Unknown":
            case 0:
                message.recordMode = 0;
                break;
            case "RM_Normal":
            case 0:
                message.recordMode = 0;
                break;
            case "RMode_Normal":
            case 1:
                message.recordMode = 1;
                break;
            case "RM_Loop":
            case 1:
                message.recordMode = 1;
                break;
            case "RMode_Loop":
            case 2:
                message.recordMode = 2;
                break;
            case "RM_Destructive":
            case 2:
                message.recordMode = 2;
                break;
            case "RMode_Destructive":
            case 3:
                message.recordMode = 3;
                break;
            case "RM_QuickPunch":
            case 3:
                message.recordMode = 3;
                break;
            case "RMode_QuickPunch":
            case 4:
                message.recordMode = 4;
                break;
            case "RM_TrackPunch":
            case 4:
                message.recordMode = 4;
                break;
            case "RMode_TrackPunch":
            case 5:
                message.recordMode = 5;
                break;
            case "RM_DestructivePunch":
            case 5:
                message.recordMode = 5;
                break;
            case "RMode_DestructivePunch":
            case 6:
                message.recordMode = 6;
                break;
            }
            if (object.recordArmTransport != null)
                message.recordArmTransport = Boolean(object.recordArmTransport);
            return message;
        };

        /**
         * Creates a plain object from a SetRecordModeRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {ptsl.SetRecordModeRequestBody} message SetRecordModeRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetRecordModeRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.recordMode = options.enums === String ? "RMode_Unknown" : 0;
                object.recordArmTransport = false;
            }
            if (message.recordMode != null && message.hasOwnProperty("recordMode"))
                object.recordMode = options.enums === String ? $root.ptsl.RecordMode[message.recordMode] === undefined ? message.recordMode : $root.ptsl.RecordMode[message.recordMode] : message.recordMode;
            if (message.recordArmTransport != null && message.hasOwnProperty("recordArmTransport"))
                object.recordArmTransport = message.recordArmTransport;
            return object;
        };

        /**
         * Converts this SetRecordModeRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetRecordModeRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetRecordModeRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetRecordModeRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetRecordModeRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetRecordModeRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetRecordModeRequestBody";
        };

        return SetRecordModeRequestBody;
    })();

    ptsl.SetRecordModeResponseBody = (function() {

        /**
         * Properties of a SetRecordModeResponseBody.
         * @memberof ptsl
         * @interface ISetRecordModeResponseBody
         * @property {ptsl.RecordMode|null} [currentRecordMode] SetRecordModeResponseBody currentRecordMode
         * @property {Array.<ptsl.RecordMode>|null} [recordModeList] SetRecordModeResponseBody recordModeList
         */

        /**
         * Constructs a new SetRecordModeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetRecordMode response data.
         * @implements ISetRecordModeResponseBody
         * @constructor
         * @param {ptsl.ISetRecordModeResponseBody=} [properties] Properties to set
         */
        function SetRecordModeResponseBody(properties) {
            this.recordModeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetRecordModeResponseBody currentRecordMode.
         * @member {ptsl.RecordMode} currentRecordMode
         * @memberof ptsl.SetRecordModeResponseBody
         * @instance
         */
        SetRecordModeResponseBody.prototype.currentRecordMode = 0;

        /**
         * SetRecordModeResponseBody recordModeList.
         * @member {Array.<ptsl.RecordMode>} recordModeList
         * @memberof ptsl.SetRecordModeResponseBody
         * @instance
         */
        SetRecordModeResponseBody.prototype.recordModeList = $util.emptyArray;

        /**
         * Creates a new SetRecordModeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {ptsl.ISetRecordModeResponseBody=} [properties] Properties to set
         * @returns {ptsl.SetRecordModeResponseBody} SetRecordModeResponseBody instance
         */
        SetRecordModeResponseBody.create = function create(properties) {
            return new SetRecordModeResponseBody(properties);
        };

        /**
         * Encodes the specified SetRecordModeResponseBody message. Does not implicitly {@link ptsl.SetRecordModeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {ptsl.ISetRecordModeResponseBody} message SetRecordModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRecordModeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentRecordMode != null && Object.hasOwnProperty.call(message, "currentRecordMode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentRecordMode);
            if (message.recordModeList != null && message.recordModeList.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.recordModeList.length; ++i)
                    writer.int32(message.recordModeList[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SetRecordModeResponseBody message, length delimited. Does not implicitly {@link ptsl.SetRecordModeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {ptsl.ISetRecordModeResponseBody} message SetRecordModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRecordModeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetRecordModeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetRecordModeResponseBody} SetRecordModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRecordModeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetRecordModeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentRecordMode = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.recordModeList && message.recordModeList.length))
                            message.recordModeList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.recordModeList.push(reader.int32());
                        } else
                            message.recordModeList.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetRecordModeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetRecordModeResponseBody} SetRecordModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRecordModeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetRecordModeResponseBody message.
         * @function verify
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetRecordModeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentRecordMode != null && message.hasOwnProperty("currentRecordMode"))
                switch (message.currentRecordMode) {
                default:
                    return "currentRecordMode: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                    break;
                }
            if (message.recordModeList != null && message.hasOwnProperty("recordModeList")) {
                if (!Array.isArray(message.recordModeList))
                    return "recordModeList: array expected";
                for (var i = 0; i < message.recordModeList.length; ++i)
                    switch (message.recordModeList[i]) {
                    default:
                        return "recordModeList: enum value[] expected";
                    case 0:
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a SetRecordModeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetRecordModeResponseBody} SetRecordModeResponseBody
         */
        SetRecordModeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetRecordModeResponseBody)
                return object;
            var message = new $root.ptsl.SetRecordModeResponseBody();
            switch (object.currentRecordMode) {
            default:
                if (typeof object.currentRecordMode === "number") {
                    message.currentRecordMode = object.currentRecordMode;
                    break;
                }
                break;
            case "RMode_Unknown":
            case 0:
                message.currentRecordMode = 0;
                break;
            case "RM_Normal":
            case 0:
                message.currentRecordMode = 0;
                break;
            case "RMode_Normal":
            case 1:
                message.currentRecordMode = 1;
                break;
            case "RM_Loop":
            case 1:
                message.currentRecordMode = 1;
                break;
            case "RMode_Loop":
            case 2:
                message.currentRecordMode = 2;
                break;
            case "RM_Destructive":
            case 2:
                message.currentRecordMode = 2;
                break;
            case "RMode_Destructive":
            case 3:
                message.currentRecordMode = 3;
                break;
            case "RM_QuickPunch":
            case 3:
                message.currentRecordMode = 3;
                break;
            case "RMode_QuickPunch":
            case 4:
                message.currentRecordMode = 4;
                break;
            case "RM_TrackPunch":
            case 4:
                message.currentRecordMode = 4;
                break;
            case "RMode_TrackPunch":
            case 5:
                message.currentRecordMode = 5;
                break;
            case "RM_DestructivePunch":
            case 5:
                message.currentRecordMode = 5;
                break;
            case "RMode_DestructivePunch":
            case 6:
                message.currentRecordMode = 6;
                break;
            }
            if (object.recordModeList) {
                if (!Array.isArray(object.recordModeList))
                    throw TypeError(".ptsl.SetRecordModeResponseBody.recordModeList: array expected");
                message.recordModeList = [];
                for (var i = 0; i < object.recordModeList.length; ++i)
                    switch (object.recordModeList[i]) {
                    default:
                        if (typeof object.recordModeList[i] === "number") {
                            message.recordModeList[i] = object.recordModeList[i];
                            break;
                        }
                    case "RMode_Unknown":
                    case 0:
                        message.recordModeList[i] = 0;
                        break;
                    case "RM_Normal":
                    case 0:
                        message.recordModeList[i] = 0;
                        break;
                    case "RMode_Normal":
                    case 1:
                        message.recordModeList[i] = 1;
                        break;
                    case "RM_Loop":
                    case 1:
                        message.recordModeList[i] = 1;
                        break;
                    case "RMode_Loop":
                    case 2:
                        message.recordModeList[i] = 2;
                        break;
                    case "RM_Destructive":
                    case 2:
                        message.recordModeList[i] = 2;
                        break;
                    case "RMode_Destructive":
                    case 3:
                        message.recordModeList[i] = 3;
                        break;
                    case "RM_QuickPunch":
                    case 3:
                        message.recordModeList[i] = 3;
                        break;
                    case "RMode_QuickPunch":
                    case 4:
                        message.recordModeList[i] = 4;
                        break;
                    case "RM_TrackPunch":
                    case 4:
                        message.recordModeList[i] = 4;
                        break;
                    case "RMode_TrackPunch":
                    case 5:
                        message.recordModeList[i] = 5;
                        break;
                    case "RM_DestructivePunch":
                    case 5:
                        message.recordModeList[i] = 5;
                        break;
                    case "RMode_DestructivePunch":
                    case 6:
                        message.recordModeList[i] = 6;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a SetRecordModeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {ptsl.SetRecordModeResponseBody} message SetRecordModeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetRecordModeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.recordModeList = [];
            if (options.defaults)
                object.currentRecordMode = options.enums === String ? "RMode_Unknown" : 0;
            if (message.currentRecordMode != null && message.hasOwnProperty("currentRecordMode"))
                object.currentRecordMode = options.enums === String ? $root.ptsl.RecordMode[message.currentRecordMode] === undefined ? message.currentRecordMode : $root.ptsl.RecordMode[message.currentRecordMode] : message.currentRecordMode;
            if (message.recordModeList && message.recordModeList.length) {
                object.recordModeList = [];
                for (var j = 0; j < message.recordModeList.length; ++j)
                    object.recordModeList[j] = options.enums === String ? $root.ptsl.RecordMode[message.recordModeList[j]] === undefined ? message.recordModeList[j] : $root.ptsl.RecordMode[message.recordModeList[j]] : message.recordModeList[j];
            }
            return object;
        };

        /**
         * Converts this SetRecordModeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetRecordModeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetRecordModeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetRecordModeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.SetRecordModeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetRecordModeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetRecordModeResponseBody";
        };

        return SetRecordModeResponseBody;
    })();

    /**
     * Type of session audio file format.
     * @name ptsl.SessionAudioFormat
     * @enum {number}
     * @property {number} SAFormat_Unknown=0 SAFormat_Unknown value
     * @property {number} SAF_WAVE=1 * @deprecated ptsl::SessionAudioFormat::SAF_WAVE is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionAudioFormat::SAFormat_WAVE
     * @property {number} SAFormat_WAVE=1 SAFormat_WAVE value
     * @property {number} SAF_AIFF=2 * @deprecated ptsl::SessionAudioFormat::SAF_AIFF is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionAudioFormat::SAFormat_AIFF
     * @property {number} SAFormat_AIFF=2 SAFormat_AIFF value
     */
    ptsl.SessionAudioFormat = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SAFormat_Unknown"] = 0;
        values[valuesById[1] = "SAF_WAVE"] = 1;
        values["SAFormat_WAVE"] = 1;
        values[valuesById[2] = "SAF_AIFF"] = 2;
        values["SAFormat_AIFF"] = 2;
        return values;
    })();

    /**
     * Type of session time code rate.
     * @name ptsl.SessionTimeCodeRate
     * @enum {number}
     * @property {number} STCRate_Unknown=0 STCRate_Unknown value
     * @property {number} STCR_Fps23976=1 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps23976 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps23976
     * @property {number} STCRate_Fps23976=1 STCRate_Fps23976 value
     * @property {number} STCR_Fps24=2 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps24 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps24
     * @property {number} STCRate_Fps24=2 STCRate_Fps24 value
     * @property {number} STCR_Fps25=3 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps25 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps25
     * @property {number} STCRate_Fps25=3 STCRate_Fps25 value
     * @property {number} STCR_Fps2997=4 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps2997 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps2997
     * @property {number} STCRate_Fps2997=4 STCRate_Fps2997 value
     * @property {number} STCR_Fps2997Drop=5 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps2997Drop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps2997Drop
     * @property {number} SSTCRate_Fps2997Drop=5 SSTCRate_Fps2997Drop value
     * @property {number} STCR_Fps30=6 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps30 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps30
     * @property {number} STCRate_Fps30=6 STCRate_Fps30 value
     * @property {number} STCR_Fps30Drop=7 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps30Drop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps30Drop
     * @property {number} STCRate_Fps30Drop=7 STCRate_Fps30Drop value
     * @property {number} STCR_Fps47952=8 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps47952 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps47952
     * @property {number} STCRate_Fps47952=8 STCRate_Fps47952 value
     * @property {number} STCR_Fps48=9 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps48 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps48
     * @property {number} STCRate_Fps48=9 STCRate_Fps48 value
     * @property {number} STCR_Fps50=10 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps50 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps50
     * @property {number} STCRate_Fps50=10 STCRate_Fps50 value
     * @property {number} STCR_Fps5994=11 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps5994 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps5994
     * @property {number} STCRate_Fps5994=11 STCRate_Fps5994 value
     * @property {number} STCR_Fps5994Drop=12 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps5994Drop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps5994Drop
     * @property {number} STCRate_Fps5994Drop=12 STCRate_Fps5994Drop value
     * @property {number} STCR_Fps60=13 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps60 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps60
     * @property {number} STCRate_Fps60=13 STCRate_Fps60 value
     * @property {number} STCR_Fps60Drop=14 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps60Drop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps60Drop
     * @property {number} STCRate_Fps60Drop=14 STCRate_Fps60Drop value
     * @property {number} STCR_Fps100=15 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps100 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps100
     * @property {number} STCRate_Fps100=15 STCRate_Fps100 value
     * @property {number} STCR_Fps11988=16 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps11988 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps11988
     * @property {number} STCRate_Fps11988=16 STCRate_Fps11988 value
     * @property {number} STCR_Fps11988Drop=17 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps11988Drop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps11988Drop
     * @property {number} STCRate_Fps11988Drop=17 STCRate_Fps11988Drop value
     * @property {number} STCR_Fps120=18 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps120 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps120
     * @property {number} STCRate_Fps120=18 STCRate_Fps120 value
     * @property {number} STCR_Fps120Drop=19 * @deprecated ptsl::SessionTimeCodeRate::STCR_Fps120Drop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionTimeCodeRate::STCRate_Fps120Drop
     * @property {number} STCRate_Fps120Drop=19 STCRate_Fps120Drop value
     */
    ptsl.SessionTimeCodeRate = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "STCRate_Unknown"] = 0;
        values[valuesById[1] = "STCR_Fps23976"] = 1;
        values["STCRate_Fps23976"] = 1;
        values[valuesById[2] = "STCR_Fps24"] = 2;
        values["STCRate_Fps24"] = 2;
        values[valuesById[3] = "STCR_Fps25"] = 3;
        values["STCRate_Fps25"] = 3;
        values[valuesById[4] = "STCR_Fps2997"] = 4;
        values["STCRate_Fps2997"] = 4;
        values[valuesById[5] = "STCR_Fps2997Drop"] = 5;
        values["SSTCRate_Fps2997Drop"] = 5;
        values[valuesById[6] = "STCR_Fps30"] = 6;
        values["STCRate_Fps30"] = 6;
        values[valuesById[7] = "STCR_Fps30Drop"] = 7;
        values["STCRate_Fps30Drop"] = 7;
        values[valuesById[8] = "STCR_Fps47952"] = 8;
        values["STCRate_Fps47952"] = 8;
        values[valuesById[9] = "STCR_Fps48"] = 9;
        values["STCRate_Fps48"] = 9;
        values[valuesById[10] = "STCR_Fps50"] = 10;
        values["STCRate_Fps50"] = 10;
        values[valuesById[11] = "STCR_Fps5994"] = 11;
        values["STCRate_Fps5994"] = 11;
        values[valuesById[12] = "STCR_Fps5994Drop"] = 12;
        values["STCRate_Fps5994Drop"] = 12;
        values[valuesById[13] = "STCR_Fps60"] = 13;
        values["STCRate_Fps60"] = 13;
        values[valuesById[14] = "STCR_Fps60Drop"] = 14;
        values["STCRate_Fps60Drop"] = 14;
        values[valuesById[15] = "STCR_Fps100"] = 15;
        values["STCRate_Fps100"] = 15;
        values[valuesById[16] = "STCR_Fps11988"] = 16;
        values["STCRate_Fps11988"] = 16;
        values[valuesById[17] = "STCR_Fps11988Drop"] = 17;
        values["STCRate_Fps11988Drop"] = 17;
        values[valuesById[18] = "STCR_Fps120"] = 18;
        values["STCRate_Fps120"] = 18;
        values[valuesById[19] = "STCR_Fps120Drop"] = 19;
        values["STCRate_Fps120Drop"] = 19;
        return values;
    })();

    /**
     * Type of session feet+frames rate.
     * @name ptsl.SessionFeetFramesRate
     * @enum {number}
     * @property {number} SFFRate_Unknown=0 SFFRate_Unknown value
     * @property {number} SFFR_Fps23976=1 * @deprecated ptsl::SessionFeetFramesRate::SFFR_Fps23976 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionFeetFramesRate::SFFRate_Fps23976
     * @property {number} SFFRate_Fps23976=1 SFFRate_Fps23976 value
     * @property {number} SFFR_Fps24=2 * @deprecated ptsl::SessionFeetFramesRate::SFFR_Fps24 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionFeetFramesRate::SFFRate_Fps24
     * @property {number} SFFRate_Fps24=2 SFFRate_Fps24 value
     * @property {number} SFFR_Fps25=3 * @deprecated ptsl::SessionFeetFramesRate::SFFR_Fps25 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionFeetFramesRate::SFFRate_Fps25
     * @property {number} SFFRate_Fps25=3 SFFRate_Fps25 value
     */
    ptsl.SessionFeetFramesRate = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SFFRate_Unknown"] = 0;
        values[valuesById[1] = "SFFR_Fps23976"] = 1;
        values["SFFRate_Fps23976"] = 1;
        values[valuesById[2] = "SFFR_Fps24"] = 2;
        values["SFFRate_Fps24"] = 2;
        values[valuesById[3] = "SFFR_Fps25"] = 3;
        values["SFFRate_Fps25"] = 3;
        return values;
    })();

    /**
     * Type of session audio/video rate pull up/down.
     * @name ptsl.SessionRatePull
     * @enum {number}
     * @property {number} SRPull_Unknown=0 SRPull_Unknown value
     * @property {number} SRP_None=1 * @deprecated ptsl::SessionRatePull::SRP_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_None
     * @property {number} SRPull_None=1 SRPull_None value
     * @property {number} SRP_Up01=2 * @deprecated ptsl::SessionRatePull::SRP_Up01 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Up01
     * @property {number} SRPull_Up01=2 SRPull_Up01 value
     * @property {number} SRP_Down01=3 * @deprecated ptsl::SessionRatePull::SRP_Down01 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Down01
     * @property {number} SRPull_Down01=3 SRPull_Down01 value
     * @property {number} SRP_Up4=4 * @deprecated ptsl::SessionRatePull::SRP_Up4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Up4
     * @property {number} SRPull_Up4=4 SRPull_Up4 value
     * @property {number} SRP_Up4Up01=5 * @deprecated ptsl::SessionRatePull::SRP_Up4Up01 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Up4Up01
     * @property {number} SRPull_Up4Up01=5 SRPull_Up4Up01 value
     * @property {number} SRP_Up4Down01=6 * @deprecated ptsl::SessionRatePull::SRP_Up4Down01 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Up4Down01
     * @property {number} SRPull_Up4Down01=6 SRPull_Up4Down01 value
     * @property {number} SRP_Down4=7 * @deprecated ptsl::SessionRatePull::SRP_Down4 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Down4
     * @property {number} SRPull_Down4=7 SRPull_Down4 value
     * @property {number} SRP_Down4Up01=8 * @deprecated ptsl::SessionRatePull::SRP_Down4Up01 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Down4Up01
     * @property {number} SRPull_Down4Up01=8 SRPull_Down4Up01 value
     * @property {number} SRP_Down4Down01=9 * @deprecated ptsl::SessionRatePull::SRP_Down4Down01 is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SessionRatePull::SRPull_Down4Down01
     * @property {number} SRPull_Down4Down01=9 SRPull_Down4Down01 value
     */
    ptsl.SessionRatePull = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SRPull_Unknown"] = 0;
        values[valuesById[1] = "SRP_None"] = 1;
        values["SRPull_None"] = 1;
        values[valuesById[2] = "SRP_Up01"] = 2;
        values["SRPull_Up01"] = 2;
        values[valuesById[3] = "SRP_Down01"] = 3;
        values["SRPull_Down01"] = 3;
        values[valuesById[4] = "SRP_Up4"] = 4;
        values["SRPull_Up4"] = 4;
        values[valuesById[5] = "SRP_Up4Up01"] = 5;
        values["SRPull_Up4Up01"] = 5;
        values[valuesById[6] = "SRP_Up4Down01"] = 6;
        values["SRPull_Up4Down01"] = 6;
        values[valuesById[7] = "SRP_Down4"] = 7;
        values["SRPull_Down4"] = 7;
        values[valuesById[8] = "SRP_Down4Up01"] = 8;
        values["SRPull_Down4Up01"] = 8;
        values[valuesById[9] = "SRP_Down4Down01"] = 9;
        values["SRPull_Down4Down01"] = 9;
        return values;
    })();

    ptsl.GetSessionAudioFormatResponseBody = (function() {

        /**
         * Properties of a GetSessionAudioFormatResponseBody.
         * @memberof ptsl
         * @interface IGetSessionAudioFormatResponseBody
         * @property {ptsl.SessionAudioFormat|null} [currentSetting] GetSessionAudioFormatResponseBody currentSetting
         * @property {Array.<ptsl.SessionAudioFormat>|null} [possibleSettings] GetSessionAudioFormatResponseBody possibleSettings
         */

        /**
         * Constructs a new GetSessionAudioFormatResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionAudioFormat response data.
         * @implements IGetSessionAudioFormatResponseBody
         * @constructor
         * @param {ptsl.IGetSessionAudioFormatResponseBody=} [properties] Properties to set
         */
        function GetSessionAudioFormatResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionAudioFormatResponseBody currentSetting.
         * @member {ptsl.SessionAudioFormat} currentSetting
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @instance
         */
        GetSessionAudioFormatResponseBody.prototype.currentSetting = 0;

        /**
         * GetSessionAudioFormatResponseBody possibleSettings.
         * @member {Array.<ptsl.SessionAudioFormat>} possibleSettings
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @instance
         */
        GetSessionAudioFormatResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetSessionAudioFormatResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {ptsl.IGetSessionAudioFormatResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionAudioFormatResponseBody} GetSessionAudioFormatResponseBody instance
         */
        GetSessionAudioFormatResponseBody.create = function create(properties) {
            return new GetSessionAudioFormatResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionAudioFormatResponseBody message. Does not implicitly {@link ptsl.GetSessionAudioFormatResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {ptsl.IGetSessionAudioFormatResponseBody} message GetSessionAudioFormatResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionAudioFormatResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSessionAudioFormatResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionAudioFormatResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {ptsl.IGetSessionAudioFormatResponseBody} message GetSessionAudioFormatResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionAudioFormatResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionAudioFormatResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionAudioFormatResponseBody} GetSessionAudioFormatResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionAudioFormatResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionAudioFormatResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionAudioFormatResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionAudioFormatResponseBody} GetSessionAudioFormatResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionAudioFormatResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionAudioFormatResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionAudioFormatResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetSessionAudioFormatResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionAudioFormatResponseBody} GetSessionAudioFormatResponseBody
         */
        GetSessionAudioFormatResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionAudioFormatResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionAudioFormatResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "SAFormat_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "SAF_WAVE":
            case 1:
                message.currentSetting = 1;
                break;
            case "SAFormat_WAVE":
            case 1:
                message.currentSetting = 1;
                break;
            case "SAF_AIFF":
            case 2:
                message.currentSetting = 2;
                break;
            case "SAFormat_AIFF":
            case 2:
                message.currentSetting = 2;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSessionAudioFormatResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "SAFormat_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "SAF_WAVE":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SAFormat_WAVE":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SAF_AIFF":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "SAFormat_AIFF":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionAudioFormatResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {ptsl.GetSessionAudioFormatResponseBody} message GetSessionAudioFormatResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionAudioFormatResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "SAFormat_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.SessionAudioFormat[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.SessionAudioFormat[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.SessionAudioFormat[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.SessionAudioFormat[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetSessionAudioFormatResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionAudioFormatResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionAudioFormatResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionAudioFormatResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionAudioFormatResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionAudioFormatResponseBody";
        };

        return GetSessionAudioFormatResponseBody;
    })();

    ptsl.GetSessionSampleRateResponseBody = (function() {

        /**
         * Properties of a GetSessionSampleRateResponseBody.
         * @memberof ptsl
         * @interface IGetSessionSampleRateResponseBody
         * @property {ptsl.SampleRate|null} [sampleRate] GetSessionSampleRateResponseBody sampleRate
         */

        /**
         * Constructs a new GetSessionSampleRateResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionSampleRate response data.
         * @implements IGetSessionSampleRateResponseBody
         * @constructor
         * @param {ptsl.IGetSessionSampleRateResponseBody=} [properties] Properties to set
         */
        function GetSessionSampleRateResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionSampleRateResponseBody sampleRate.
         * @member {ptsl.SampleRate} sampleRate
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @instance
         */
        GetSessionSampleRateResponseBody.prototype.sampleRate = 0;

        /**
         * Creates a new GetSessionSampleRateResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {ptsl.IGetSessionSampleRateResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionSampleRateResponseBody} GetSessionSampleRateResponseBody instance
         */
        GetSessionSampleRateResponseBody.create = function create(properties) {
            return new GetSessionSampleRateResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionSampleRateResponseBody message. Does not implicitly {@link ptsl.GetSessionSampleRateResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {ptsl.IGetSessionSampleRateResponseBody} message GetSessionSampleRateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionSampleRateResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sampleRate);
            return writer;
        };

        /**
         * Encodes the specified GetSessionSampleRateResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionSampleRateResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {ptsl.IGetSessionSampleRateResponseBody} message GetSessionSampleRateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionSampleRateResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionSampleRateResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionSampleRateResponseBody} GetSessionSampleRateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionSampleRateResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionSampleRateResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sampleRate = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionSampleRateResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionSampleRateResponseBody} GetSessionSampleRateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionSampleRateResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionSampleRateResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionSampleRateResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                switch (message.sampleRate) {
                default:
                    return "sampleRate: enum value expected";
                case 0:
                case 1:
                case 1:
                case 44100:
                case 44100:
                case 48000:
                case 48000:
                case 88200:
                case 88200:
                case 96000:
                case 96000:
                case 176400:
                case 176400:
                case 192000:
                case 192000:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetSessionSampleRateResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionSampleRateResponseBody} GetSessionSampleRateResponseBody
         */
        GetSessionSampleRateResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionSampleRateResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionSampleRateResponseBody();
            switch (object.sampleRate) {
            default:
                if (typeof object.sampleRate === "number") {
                    message.sampleRate = object.sampleRate;
                    break;
                }
                break;
            case "SRate_Unknown":
            case 0:
                message.sampleRate = 0;
                break;
            case "SR_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SRate_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SR_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SRate_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SR_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SRate_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SR_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SRate_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SR_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SRate_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SR_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SRate_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SR_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            case "SRate_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionSampleRateResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {ptsl.GetSessionSampleRateResponseBody} message GetSessionSampleRateResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionSampleRateResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sampleRate = options.enums === String ? "SRate_Unknown" : 0;
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                object.sampleRate = options.enums === String ? $root.ptsl.SampleRate[message.sampleRate] === undefined ? message.sampleRate : $root.ptsl.SampleRate[message.sampleRate] : message.sampleRate;
            return object;
        };

        /**
         * Converts this GetSessionSampleRateResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionSampleRateResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionSampleRateResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionSampleRateResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionSampleRateResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionSampleRateResponseBody";
        };

        return GetSessionSampleRateResponseBody;
    })();

    ptsl.GetSessionBitDepthResponseBody = (function() {

        /**
         * Properties of a GetSessionBitDepthResponseBody.
         * @memberof ptsl
         * @interface IGetSessionBitDepthResponseBody
         * @property {ptsl.BitDepth|null} [currentSetting] GetSessionBitDepthResponseBody currentSetting
         * @property {Array.<ptsl.BitDepth>|null} [possibleSettings] GetSessionBitDepthResponseBody possibleSettings
         */

        /**
         * Constructs a new GetSessionBitDepthResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionBitDepth response data.
         * @implements IGetSessionBitDepthResponseBody
         * @constructor
         * @param {ptsl.IGetSessionBitDepthResponseBody=} [properties] Properties to set
         */
        function GetSessionBitDepthResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionBitDepthResponseBody currentSetting.
         * @member {ptsl.BitDepth} currentSetting
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @instance
         */
        GetSessionBitDepthResponseBody.prototype.currentSetting = 0;

        /**
         * GetSessionBitDepthResponseBody possibleSettings.
         * @member {Array.<ptsl.BitDepth>} possibleSettings
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @instance
         */
        GetSessionBitDepthResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetSessionBitDepthResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {ptsl.IGetSessionBitDepthResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionBitDepthResponseBody} GetSessionBitDepthResponseBody instance
         */
        GetSessionBitDepthResponseBody.create = function create(properties) {
            return new GetSessionBitDepthResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionBitDepthResponseBody message. Does not implicitly {@link ptsl.GetSessionBitDepthResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {ptsl.IGetSessionBitDepthResponseBody} message GetSessionBitDepthResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionBitDepthResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSessionBitDepthResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionBitDepthResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {ptsl.IGetSessionBitDepthResponseBody} message GetSessionBitDepthResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionBitDepthResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionBitDepthResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionBitDepthResponseBody} GetSessionBitDepthResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionBitDepthResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionBitDepthResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionBitDepthResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionBitDepthResponseBody} GetSessionBitDepthResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionBitDepthResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionBitDepthResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionBitDepthResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetSessionBitDepthResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionBitDepthResponseBody} GetSessionBitDepthResponseBody
         */
        GetSessionBitDepthResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionBitDepthResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionBitDepthResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "BDepth_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "Bit_None":
            case 1:
                message.currentSetting = 1;
                break;
            case "BDepth_None":
            case 1:
                message.currentSetting = 1;
                break;
            case "Bit16":
            case 2:
                message.currentSetting = 2;
                break;
            case "BDepth_16":
            case 2:
                message.currentSetting = 2;
                break;
            case "Bit24":
            case 3:
                message.currentSetting = 3;
                break;
            case "BDepth_24":
            case 3:
                message.currentSetting = 3;
                break;
            case "Bit32Float":
            case 4:
                message.currentSetting = 4;
                break;
            case "BDepth_32Float":
            case 4:
                message.currentSetting = 4;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSessionBitDepthResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "BDepth_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "Bit_None":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "BDepth_None":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "Bit16":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "BDepth_16":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "Bit24":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "BDepth_24":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "Bit32Float":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "BDepth_32Float":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionBitDepthResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {ptsl.GetSessionBitDepthResponseBody} message GetSessionBitDepthResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionBitDepthResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "BDepth_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.BitDepth[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.BitDepth[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.BitDepth[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.BitDepth[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetSessionBitDepthResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionBitDepthResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionBitDepthResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionBitDepthResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionBitDepthResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionBitDepthResponseBody";
        };

        return GetSessionBitDepthResponseBody;
    })();

    ptsl.GetSessionInterleavedStateResponseBody = (function() {

        /**
         * Properties of a GetSessionInterleavedStateResponseBody.
         * @memberof ptsl
         * @interface IGetSessionInterleavedStateResponseBody
         * @property {boolean|null} [currentSetting] GetSessionInterleavedStateResponseBody currentSetting
         * @property {Array.<boolean>|null} [possibleSettings] GetSessionInterleavedStateResponseBody possibleSettings
         */

        /**
         * Constructs a new GetSessionInterleavedStateResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionInterleavedState response data.
         * @implements IGetSessionInterleavedStateResponseBody
         * @constructor
         * @param {ptsl.IGetSessionInterleavedStateResponseBody=} [properties] Properties to set
         */
        function GetSessionInterleavedStateResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionInterleavedStateResponseBody currentSetting.
         * @member {boolean} currentSetting
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @instance
         */
        GetSessionInterleavedStateResponseBody.prototype.currentSetting = false;

        /**
         * GetSessionInterleavedStateResponseBody possibleSettings.
         * @member {Array.<boolean>} possibleSettings
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @instance
         */
        GetSessionInterleavedStateResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetSessionInterleavedStateResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {ptsl.IGetSessionInterleavedStateResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionInterleavedStateResponseBody} GetSessionInterleavedStateResponseBody instance
         */
        GetSessionInterleavedStateResponseBody.create = function create(properties) {
            return new GetSessionInterleavedStateResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionInterleavedStateResponseBody message. Does not implicitly {@link ptsl.GetSessionInterleavedStateResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {ptsl.IGetSessionInterleavedStateResponseBody} message GetSessionInterleavedStateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionInterleavedStateResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.bool(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSessionInterleavedStateResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionInterleavedStateResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {ptsl.IGetSessionInterleavedStateResponseBody} message GetSessionInterleavedStateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionInterleavedStateResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionInterleavedStateResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionInterleavedStateResponseBody} GetSessionInterleavedStateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionInterleavedStateResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionInterleavedStateResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.bool();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.bool());
                        } else
                            message.possibleSettings.push(reader.bool());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionInterleavedStateResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionInterleavedStateResponseBody} GetSessionInterleavedStateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionInterleavedStateResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionInterleavedStateResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionInterleavedStateResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                if (typeof message.currentSetting !== "boolean")
                    return "currentSetting: boolean expected";
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    if (typeof message.possibleSettings[i] !== "boolean")
                        return "possibleSettings: boolean[] expected";
            }
            return null;
        };

        /**
         * Creates a GetSessionInterleavedStateResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionInterleavedStateResponseBody} GetSessionInterleavedStateResponseBody
         */
        GetSessionInterleavedStateResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionInterleavedStateResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionInterleavedStateResponseBody();
            if (object.currentSetting != null)
                message.currentSetting = Boolean(object.currentSetting);
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSessionInterleavedStateResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    message.possibleSettings[i] = Boolean(object.possibleSettings[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionInterleavedStateResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {ptsl.GetSessionInterleavedStateResponseBody} message GetSessionInterleavedStateResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionInterleavedStateResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = false;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetSessionInterleavedStateResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionInterleavedStateResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionInterleavedStateResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionInterleavedStateResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionInterleavedStateResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionInterleavedStateResponseBody";
        };

        return GetSessionInterleavedStateResponseBody;
    })();

    ptsl.GetSessionTimeCodeRateResponseBody = (function() {

        /**
         * Properties of a GetSessionTimeCodeRateResponseBody.
         * @memberof ptsl
         * @interface IGetSessionTimeCodeRateResponseBody
         * @property {ptsl.SessionTimeCodeRate|null} [currentSetting] GetSessionTimeCodeRateResponseBody currentSetting
         * @property {Array.<ptsl.SessionTimeCodeRate>|null} [possibleSettings] GetSessionTimeCodeRateResponseBody possibleSettings
         */

        /**
         * Constructs a new GetSessionTimeCodeRateResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionTimeCodeRate response data.
         * @implements IGetSessionTimeCodeRateResponseBody
         * @constructor
         * @param {ptsl.IGetSessionTimeCodeRateResponseBody=} [properties] Properties to set
         */
        function GetSessionTimeCodeRateResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionTimeCodeRateResponseBody currentSetting.
         * @member {ptsl.SessionTimeCodeRate} currentSetting
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @instance
         */
        GetSessionTimeCodeRateResponseBody.prototype.currentSetting = 0;

        /**
         * GetSessionTimeCodeRateResponseBody possibleSettings.
         * @member {Array.<ptsl.SessionTimeCodeRate>} possibleSettings
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @instance
         */
        GetSessionTimeCodeRateResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetSessionTimeCodeRateResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {ptsl.IGetSessionTimeCodeRateResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionTimeCodeRateResponseBody} GetSessionTimeCodeRateResponseBody instance
         */
        GetSessionTimeCodeRateResponseBody.create = function create(properties) {
            return new GetSessionTimeCodeRateResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionTimeCodeRateResponseBody message. Does not implicitly {@link ptsl.GetSessionTimeCodeRateResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {ptsl.IGetSessionTimeCodeRateResponseBody} message GetSessionTimeCodeRateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionTimeCodeRateResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSessionTimeCodeRateResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionTimeCodeRateResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {ptsl.IGetSessionTimeCodeRateResponseBody} message GetSessionTimeCodeRateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionTimeCodeRateResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionTimeCodeRateResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionTimeCodeRateResponseBody} GetSessionTimeCodeRateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionTimeCodeRateResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionTimeCodeRateResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionTimeCodeRateResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionTimeCodeRateResponseBody} GetSessionTimeCodeRateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionTimeCodeRateResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionTimeCodeRateResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionTimeCodeRateResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                    case 8:
                    case 9:
                    case 9:
                    case 10:
                    case 10:
                    case 11:
                    case 11:
                    case 12:
                    case 12:
                    case 13:
                    case 13:
                    case 14:
                    case 14:
                    case 15:
                    case 15:
                    case 16:
                    case 16:
                    case 17:
                    case 17:
                    case 18:
                    case 18:
                    case 19:
                    case 19:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetSessionTimeCodeRateResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionTimeCodeRateResponseBody} GetSessionTimeCodeRateResponseBody
         */
        GetSessionTimeCodeRateResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionTimeCodeRateResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionTimeCodeRateResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "STCRate_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "STCR_Fps23976":
            case 1:
                message.currentSetting = 1;
                break;
            case "STCRate_Fps23976":
            case 1:
                message.currentSetting = 1;
                break;
            case "STCR_Fps24":
            case 2:
                message.currentSetting = 2;
                break;
            case "STCRate_Fps24":
            case 2:
                message.currentSetting = 2;
                break;
            case "STCR_Fps25":
            case 3:
                message.currentSetting = 3;
                break;
            case "STCRate_Fps25":
            case 3:
                message.currentSetting = 3;
                break;
            case "STCR_Fps2997":
            case 4:
                message.currentSetting = 4;
                break;
            case "STCRate_Fps2997":
            case 4:
                message.currentSetting = 4;
                break;
            case "STCR_Fps2997Drop":
            case 5:
                message.currentSetting = 5;
                break;
            case "SSTCRate_Fps2997Drop":
            case 5:
                message.currentSetting = 5;
                break;
            case "STCR_Fps30":
            case 6:
                message.currentSetting = 6;
                break;
            case "STCRate_Fps30":
            case 6:
                message.currentSetting = 6;
                break;
            case "STCR_Fps30Drop":
            case 7:
                message.currentSetting = 7;
                break;
            case "STCRate_Fps30Drop":
            case 7:
                message.currentSetting = 7;
                break;
            case "STCR_Fps47952":
            case 8:
                message.currentSetting = 8;
                break;
            case "STCRate_Fps47952":
            case 8:
                message.currentSetting = 8;
                break;
            case "STCR_Fps48":
            case 9:
                message.currentSetting = 9;
                break;
            case "STCRate_Fps48":
            case 9:
                message.currentSetting = 9;
                break;
            case "STCR_Fps50":
            case 10:
                message.currentSetting = 10;
                break;
            case "STCRate_Fps50":
            case 10:
                message.currentSetting = 10;
                break;
            case "STCR_Fps5994":
            case 11:
                message.currentSetting = 11;
                break;
            case "STCRate_Fps5994":
            case 11:
                message.currentSetting = 11;
                break;
            case "STCR_Fps5994Drop":
            case 12:
                message.currentSetting = 12;
                break;
            case "STCRate_Fps5994Drop":
            case 12:
                message.currentSetting = 12;
                break;
            case "STCR_Fps60":
            case 13:
                message.currentSetting = 13;
                break;
            case "STCRate_Fps60":
            case 13:
                message.currentSetting = 13;
                break;
            case "STCR_Fps60Drop":
            case 14:
                message.currentSetting = 14;
                break;
            case "STCRate_Fps60Drop":
            case 14:
                message.currentSetting = 14;
                break;
            case "STCR_Fps100":
            case 15:
                message.currentSetting = 15;
                break;
            case "STCRate_Fps100":
            case 15:
                message.currentSetting = 15;
                break;
            case "STCR_Fps11988":
            case 16:
                message.currentSetting = 16;
                break;
            case "STCRate_Fps11988":
            case 16:
                message.currentSetting = 16;
                break;
            case "STCR_Fps11988Drop":
            case 17:
                message.currentSetting = 17;
                break;
            case "STCRate_Fps11988Drop":
            case 17:
                message.currentSetting = 17;
                break;
            case "STCR_Fps120":
            case 18:
                message.currentSetting = 18;
                break;
            case "STCRate_Fps120":
            case 18:
                message.currentSetting = 18;
                break;
            case "STCR_Fps120Drop":
            case 19:
                message.currentSetting = 19;
                break;
            case "STCRate_Fps120Drop":
            case 19:
                message.currentSetting = 19;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSessionTimeCodeRateResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "STCRate_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "STCR_Fps23976":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "STCRate_Fps23976":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "STCR_Fps24":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "STCRate_Fps24":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "STCR_Fps25":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "STCRate_Fps25":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "STCR_Fps2997":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "STCRate_Fps2997":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "STCR_Fps2997Drop":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "SSTCRate_Fps2997Drop":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "STCR_Fps30":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "STCRate_Fps30":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "STCR_Fps30Drop":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "STCRate_Fps30Drop":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "STCR_Fps47952":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "STCRate_Fps47952":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "STCR_Fps48":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "STCRate_Fps48":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "STCR_Fps50":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "STCRate_Fps50":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "STCR_Fps5994":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    case "STCRate_Fps5994":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    case "STCR_Fps5994Drop":
                    case 12:
                        message.possibleSettings[i] = 12;
                        break;
                    case "STCRate_Fps5994Drop":
                    case 12:
                        message.possibleSettings[i] = 12;
                        break;
                    case "STCR_Fps60":
                    case 13:
                        message.possibleSettings[i] = 13;
                        break;
                    case "STCRate_Fps60":
                    case 13:
                        message.possibleSettings[i] = 13;
                        break;
                    case "STCR_Fps60Drop":
                    case 14:
                        message.possibleSettings[i] = 14;
                        break;
                    case "STCRate_Fps60Drop":
                    case 14:
                        message.possibleSettings[i] = 14;
                        break;
                    case "STCR_Fps100":
                    case 15:
                        message.possibleSettings[i] = 15;
                        break;
                    case "STCRate_Fps100":
                    case 15:
                        message.possibleSettings[i] = 15;
                        break;
                    case "STCR_Fps11988":
                    case 16:
                        message.possibleSettings[i] = 16;
                        break;
                    case "STCRate_Fps11988":
                    case 16:
                        message.possibleSettings[i] = 16;
                        break;
                    case "STCR_Fps11988Drop":
                    case 17:
                        message.possibleSettings[i] = 17;
                        break;
                    case "STCRate_Fps11988Drop":
                    case 17:
                        message.possibleSettings[i] = 17;
                        break;
                    case "STCR_Fps120":
                    case 18:
                        message.possibleSettings[i] = 18;
                        break;
                    case "STCRate_Fps120":
                    case 18:
                        message.possibleSettings[i] = 18;
                        break;
                    case "STCR_Fps120Drop":
                    case 19:
                        message.possibleSettings[i] = 19;
                        break;
                    case "STCRate_Fps120Drop":
                    case 19:
                        message.possibleSettings[i] = 19;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionTimeCodeRateResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {ptsl.GetSessionTimeCodeRateResponseBody} message GetSessionTimeCodeRateResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionTimeCodeRateResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "STCRate_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.SessionTimeCodeRate[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.SessionTimeCodeRate[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.SessionTimeCodeRate[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.SessionTimeCodeRate[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetSessionTimeCodeRateResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionTimeCodeRateResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionTimeCodeRateResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionTimeCodeRateResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionTimeCodeRateResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionTimeCodeRateResponseBody";
        };

        return GetSessionTimeCodeRateResponseBody;
    })();

    ptsl.GetSessionFeetFramesRateResponseBody = (function() {

        /**
         * Properties of a GetSessionFeetFramesRateResponseBody.
         * @memberof ptsl
         * @interface IGetSessionFeetFramesRateResponseBody
         * @property {ptsl.SessionFeetFramesRate|null} [currentSetting] GetSessionFeetFramesRateResponseBody currentSetting
         * @property {Array.<ptsl.SessionFeetFramesRate>|null} [possibleSettings] GetSessionFeetFramesRateResponseBody possibleSettings
         */

        /**
         * Constructs a new GetSessionFeetFramesRateResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionFeetFramesRate response data.
         * @implements IGetSessionFeetFramesRateResponseBody
         * @constructor
         * @param {ptsl.IGetSessionFeetFramesRateResponseBody=} [properties] Properties to set
         */
        function GetSessionFeetFramesRateResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionFeetFramesRateResponseBody currentSetting.
         * @member {ptsl.SessionFeetFramesRate} currentSetting
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @instance
         */
        GetSessionFeetFramesRateResponseBody.prototype.currentSetting = 0;

        /**
         * GetSessionFeetFramesRateResponseBody possibleSettings.
         * @member {Array.<ptsl.SessionFeetFramesRate>} possibleSettings
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @instance
         */
        GetSessionFeetFramesRateResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetSessionFeetFramesRateResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {ptsl.IGetSessionFeetFramesRateResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionFeetFramesRateResponseBody} GetSessionFeetFramesRateResponseBody instance
         */
        GetSessionFeetFramesRateResponseBody.create = function create(properties) {
            return new GetSessionFeetFramesRateResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionFeetFramesRateResponseBody message. Does not implicitly {@link ptsl.GetSessionFeetFramesRateResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {ptsl.IGetSessionFeetFramesRateResponseBody} message GetSessionFeetFramesRateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionFeetFramesRateResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSessionFeetFramesRateResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionFeetFramesRateResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {ptsl.IGetSessionFeetFramesRateResponseBody} message GetSessionFeetFramesRateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionFeetFramesRateResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionFeetFramesRateResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionFeetFramesRateResponseBody} GetSessionFeetFramesRateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionFeetFramesRateResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionFeetFramesRateResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionFeetFramesRateResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionFeetFramesRateResponseBody} GetSessionFeetFramesRateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionFeetFramesRateResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionFeetFramesRateResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionFeetFramesRateResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetSessionFeetFramesRateResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionFeetFramesRateResponseBody} GetSessionFeetFramesRateResponseBody
         */
        GetSessionFeetFramesRateResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionFeetFramesRateResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionFeetFramesRateResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "SFFRate_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "SFFR_Fps23976":
            case 1:
                message.currentSetting = 1;
                break;
            case "SFFRate_Fps23976":
            case 1:
                message.currentSetting = 1;
                break;
            case "SFFR_Fps24":
            case 2:
                message.currentSetting = 2;
                break;
            case "SFFRate_Fps24":
            case 2:
                message.currentSetting = 2;
                break;
            case "SFFR_Fps25":
            case 3:
                message.currentSetting = 3;
                break;
            case "SFFRate_Fps25":
            case 3:
                message.currentSetting = 3;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSessionFeetFramesRateResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "SFFRate_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "SFFR_Fps23976":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SFFRate_Fps23976":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SFFR_Fps24":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "SFFRate_Fps24":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "SFFR_Fps25":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "SFFRate_Fps25":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionFeetFramesRateResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {ptsl.GetSessionFeetFramesRateResponseBody} message GetSessionFeetFramesRateResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionFeetFramesRateResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "SFFRate_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.SessionFeetFramesRate[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.SessionFeetFramesRate[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.SessionFeetFramesRate[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.SessionFeetFramesRate[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetSessionFeetFramesRateResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionFeetFramesRateResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionFeetFramesRateResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionFeetFramesRateResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionFeetFramesRateResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionFeetFramesRateResponseBody";
        };

        return GetSessionFeetFramesRateResponseBody;
    })();

    ptsl.GetSessionAudioRatePullSettingsResponseBody = (function() {

        /**
         * Properties of a GetSessionAudioRatePullSettingsResponseBody.
         * @memberof ptsl
         * @interface IGetSessionAudioRatePullSettingsResponseBody
         * @property {ptsl.SessionRatePull|null} [currentSetting] GetSessionAudioRatePullSettingsResponseBody currentSetting
         * @property {Array.<ptsl.SessionRatePull>|null} [possibleSettings] GetSessionAudioRatePullSettingsResponseBody possibleSettings
         */

        /**
         * Constructs a new GetSessionAudioRatePullSettingsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionAudioRatePullSettings response data.
         * @implements IGetSessionAudioRatePullSettingsResponseBody
         * @constructor
         * @param {ptsl.IGetSessionAudioRatePullSettingsResponseBody=} [properties] Properties to set
         */
        function GetSessionAudioRatePullSettingsResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionAudioRatePullSettingsResponseBody currentSetting.
         * @member {ptsl.SessionRatePull} currentSetting
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @instance
         */
        GetSessionAudioRatePullSettingsResponseBody.prototype.currentSetting = 0;

        /**
         * GetSessionAudioRatePullSettingsResponseBody possibleSettings.
         * @member {Array.<ptsl.SessionRatePull>} possibleSettings
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @instance
         */
        GetSessionAudioRatePullSettingsResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetSessionAudioRatePullSettingsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {ptsl.IGetSessionAudioRatePullSettingsResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionAudioRatePullSettingsResponseBody} GetSessionAudioRatePullSettingsResponseBody instance
         */
        GetSessionAudioRatePullSettingsResponseBody.create = function create(properties) {
            return new GetSessionAudioRatePullSettingsResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionAudioRatePullSettingsResponseBody message. Does not implicitly {@link ptsl.GetSessionAudioRatePullSettingsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {ptsl.IGetSessionAudioRatePullSettingsResponseBody} message GetSessionAudioRatePullSettingsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionAudioRatePullSettingsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSessionAudioRatePullSettingsResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionAudioRatePullSettingsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {ptsl.IGetSessionAudioRatePullSettingsResponseBody} message GetSessionAudioRatePullSettingsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionAudioRatePullSettingsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionAudioRatePullSettingsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionAudioRatePullSettingsResponseBody} GetSessionAudioRatePullSettingsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionAudioRatePullSettingsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionAudioRatePullSettingsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionAudioRatePullSettingsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionAudioRatePullSettingsResponseBody} GetSessionAudioRatePullSettingsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionAudioRatePullSettingsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionAudioRatePullSettingsResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionAudioRatePullSettingsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                    case 8:
                    case 9:
                    case 9:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetSessionAudioRatePullSettingsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionAudioRatePullSettingsResponseBody} GetSessionAudioRatePullSettingsResponseBody
         */
        GetSessionAudioRatePullSettingsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionAudioRatePullSettingsResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionAudioRatePullSettingsResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "SRPull_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "SRP_None":
            case 1:
                message.currentSetting = 1;
                break;
            case "SRPull_None":
            case 1:
                message.currentSetting = 1;
                break;
            case "SRP_Up01":
            case 2:
                message.currentSetting = 2;
                break;
            case "SRPull_Up01":
            case 2:
                message.currentSetting = 2;
                break;
            case "SRP_Down01":
            case 3:
                message.currentSetting = 3;
                break;
            case "SRPull_Down01":
            case 3:
                message.currentSetting = 3;
                break;
            case "SRP_Up4":
            case 4:
                message.currentSetting = 4;
                break;
            case "SRPull_Up4":
            case 4:
                message.currentSetting = 4;
                break;
            case "SRP_Up4Up01":
            case 5:
                message.currentSetting = 5;
                break;
            case "SRPull_Up4Up01":
            case 5:
                message.currentSetting = 5;
                break;
            case "SRP_Up4Down01":
            case 6:
                message.currentSetting = 6;
                break;
            case "SRPull_Up4Down01":
            case 6:
                message.currentSetting = 6;
                break;
            case "SRP_Down4":
            case 7:
                message.currentSetting = 7;
                break;
            case "SRPull_Down4":
            case 7:
                message.currentSetting = 7;
                break;
            case "SRP_Down4Up01":
            case 8:
                message.currentSetting = 8;
                break;
            case "SRPull_Down4Up01":
            case 8:
                message.currentSetting = 8;
                break;
            case "SRP_Down4Down01":
            case 9:
                message.currentSetting = 9;
                break;
            case "SRPull_Down4Down01":
            case 9:
                message.currentSetting = 9;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSessionAudioRatePullSettingsResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "SRPull_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "SRP_None":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SRPull_None":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SRP_Up01":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "SRPull_Up01":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "SRP_Down01":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "SRPull_Down01":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "SRP_Up4":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "SRPull_Up4":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "SRP_Up4Up01":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "SRPull_Up4Up01":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "SRP_Up4Down01":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "SRPull_Up4Down01":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "SRP_Down4":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "SRPull_Down4":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "SRP_Down4Up01":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "SRPull_Down4Up01":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "SRP_Down4Down01":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "SRPull_Down4Down01":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionAudioRatePullSettingsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {ptsl.GetSessionAudioRatePullSettingsResponseBody} message GetSessionAudioRatePullSettingsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionAudioRatePullSettingsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "SRPull_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.SessionRatePull[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.SessionRatePull[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.SessionRatePull[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.SessionRatePull[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetSessionAudioRatePullSettingsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionAudioRatePullSettingsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionAudioRatePullSettingsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionAudioRatePullSettingsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionAudioRatePullSettingsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionAudioRatePullSettingsResponseBody";
        };

        return GetSessionAudioRatePullSettingsResponseBody;
    })();

    ptsl.GetSessionVideoRatePullSettingsResponseBody = (function() {

        /**
         * Properties of a GetSessionVideoRatePullSettingsResponseBody.
         * @memberof ptsl
         * @interface IGetSessionVideoRatePullSettingsResponseBody
         * @property {ptsl.SessionRatePull|null} [currentSetting] GetSessionVideoRatePullSettingsResponseBody currentSetting
         * @property {Array.<ptsl.SessionRatePull>|null} [possibleSettings] GetSessionVideoRatePullSettingsResponseBody possibleSettings
         */

        /**
         * Constructs a new GetSessionVideoRatePullSettingsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionVideoRatePullSettings response data.
         * @implements IGetSessionVideoRatePullSettingsResponseBody
         * @constructor
         * @param {ptsl.IGetSessionVideoRatePullSettingsResponseBody=} [properties] Properties to set
         */
        function GetSessionVideoRatePullSettingsResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionVideoRatePullSettingsResponseBody currentSetting.
         * @member {ptsl.SessionRatePull} currentSetting
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @instance
         */
        GetSessionVideoRatePullSettingsResponseBody.prototype.currentSetting = 0;

        /**
         * GetSessionVideoRatePullSettingsResponseBody possibleSettings.
         * @member {Array.<ptsl.SessionRatePull>} possibleSettings
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @instance
         */
        GetSessionVideoRatePullSettingsResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetSessionVideoRatePullSettingsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {ptsl.IGetSessionVideoRatePullSettingsResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionVideoRatePullSettingsResponseBody} GetSessionVideoRatePullSettingsResponseBody instance
         */
        GetSessionVideoRatePullSettingsResponseBody.create = function create(properties) {
            return new GetSessionVideoRatePullSettingsResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionVideoRatePullSettingsResponseBody message. Does not implicitly {@link ptsl.GetSessionVideoRatePullSettingsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {ptsl.IGetSessionVideoRatePullSettingsResponseBody} message GetSessionVideoRatePullSettingsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionVideoRatePullSettingsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSessionVideoRatePullSettingsResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionVideoRatePullSettingsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {ptsl.IGetSessionVideoRatePullSettingsResponseBody} message GetSessionVideoRatePullSettingsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionVideoRatePullSettingsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionVideoRatePullSettingsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionVideoRatePullSettingsResponseBody} GetSessionVideoRatePullSettingsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionVideoRatePullSettingsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionVideoRatePullSettingsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionVideoRatePullSettingsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionVideoRatePullSettingsResponseBody} GetSessionVideoRatePullSettingsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionVideoRatePullSettingsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionVideoRatePullSettingsResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionVideoRatePullSettingsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                    case 8:
                    case 9:
                    case 9:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetSessionVideoRatePullSettingsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionVideoRatePullSettingsResponseBody} GetSessionVideoRatePullSettingsResponseBody
         */
        GetSessionVideoRatePullSettingsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionVideoRatePullSettingsResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionVideoRatePullSettingsResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "SRPull_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "SRP_None":
            case 1:
                message.currentSetting = 1;
                break;
            case "SRPull_None":
            case 1:
                message.currentSetting = 1;
                break;
            case "SRP_Up01":
            case 2:
                message.currentSetting = 2;
                break;
            case "SRPull_Up01":
            case 2:
                message.currentSetting = 2;
                break;
            case "SRP_Down01":
            case 3:
                message.currentSetting = 3;
                break;
            case "SRPull_Down01":
            case 3:
                message.currentSetting = 3;
                break;
            case "SRP_Up4":
            case 4:
                message.currentSetting = 4;
                break;
            case "SRPull_Up4":
            case 4:
                message.currentSetting = 4;
                break;
            case "SRP_Up4Up01":
            case 5:
                message.currentSetting = 5;
                break;
            case "SRPull_Up4Up01":
            case 5:
                message.currentSetting = 5;
                break;
            case "SRP_Up4Down01":
            case 6:
                message.currentSetting = 6;
                break;
            case "SRPull_Up4Down01":
            case 6:
                message.currentSetting = 6;
                break;
            case "SRP_Down4":
            case 7:
                message.currentSetting = 7;
                break;
            case "SRPull_Down4":
            case 7:
                message.currentSetting = 7;
                break;
            case "SRP_Down4Up01":
            case 8:
                message.currentSetting = 8;
                break;
            case "SRPull_Down4Up01":
            case 8:
                message.currentSetting = 8;
                break;
            case "SRP_Down4Down01":
            case 9:
                message.currentSetting = 9;
                break;
            case "SRPull_Down4Down01":
            case 9:
                message.currentSetting = 9;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSessionVideoRatePullSettingsResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "SRPull_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "SRP_None":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SRPull_None":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "SRP_Up01":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "SRPull_Up01":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "SRP_Down01":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "SRPull_Down01":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "SRP_Up4":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "SRPull_Up4":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "SRP_Up4Up01":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "SRPull_Up4Up01":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "SRP_Up4Down01":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "SRPull_Up4Down01":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "SRP_Down4":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "SRPull_Down4":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "SRP_Down4Up01":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "SRPull_Down4Up01":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "SRP_Down4Down01":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "SRPull_Down4Down01":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionVideoRatePullSettingsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {ptsl.GetSessionVideoRatePullSettingsResponseBody} message GetSessionVideoRatePullSettingsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionVideoRatePullSettingsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "SRPull_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.SessionRatePull[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.SessionRatePull[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.SessionRatePull[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.SessionRatePull[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetSessionVideoRatePullSettingsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionVideoRatePullSettingsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionVideoRatePullSettingsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionVideoRatePullSettingsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionVideoRatePullSettingsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionVideoRatePullSettingsResponseBody";
        };

        return GetSessionVideoRatePullSettingsResponseBody;
    })();

    ptsl.GetSessionNameResponseBody = (function() {

        /**
         * Properties of a GetSessionNameResponseBody.
         * @memberof ptsl
         * @interface IGetSessionNameResponseBody
         * @property {string|null} [sessionName] GetSessionNameResponseBody sessionName
         */

        /**
         * Constructs a new GetSessionNameResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionName response data.
         * @implements IGetSessionNameResponseBody
         * @constructor
         * @param {ptsl.IGetSessionNameResponseBody=} [properties] Properties to set
         */
        function GetSessionNameResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionNameResponseBody sessionName.
         * @member {string} sessionName
         * @memberof ptsl.GetSessionNameResponseBody
         * @instance
         */
        GetSessionNameResponseBody.prototype.sessionName = "";

        /**
         * Creates a new GetSessionNameResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {ptsl.IGetSessionNameResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionNameResponseBody} GetSessionNameResponseBody instance
         */
        GetSessionNameResponseBody.create = function create(properties) {
            return new GetSessionNameResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionNameResponseBody message. Does not implicitly {@link ptsl.GetSessionNameResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {ptsl.IGetSessionNameResponseBody} message GetSessionNameResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionNameResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionName != null && Object.hasOwnProperty.call(message, "sessionName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionName);
            return writer;
        };

        /**
         * Encodes the specified GetSessionNameResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionNameResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {ptsl.IGetSessionNameResponseBody} message GetSessionNameResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionNameResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionNameResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionNameResponseBody} GetSessionNameResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionNameResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionNameResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionNameResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionNameResponseBody} GetSessionNameResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionNameResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionNameResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionNameResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionName != null && message.hasOwnProperty("sessionName"))
                if (!$util.isString(message.sessionName))
                    return "sessionName: string expected";
            return null;
        };

        /**
         * Creates a GetSessionNameResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionNameResponseBody} GetSessionNameResponseBody
         */
        GetSessionNameResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionNameResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionNameResponseBody();
            if (object.sessionName != null)
                message.sessionName = String(object.sessionName);
            return message;
        };

        /**
         * Creates a plain object from a GetSessionNameResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {ptsl.GetSessionNameResponseBody} message GetSessionNameResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionNameResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionName = "";
            if (message.sessionName != null && message.hasOwnProperty("sessionName"))
                object.sessionName = message.sessionName;
            return object;
        };

        /**
         * Converts this GetSessionNameResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionNameResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionNameResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionNameResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionNameResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionNameResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionNameResponseBody";
        };

        return GetSessionNameResponseBody;
    })();

    ptsl.GetSessionPathResponseBody = (function() {

        /**
         * Properties of a GetSessionPathResponseBody.
         * @memberof ptsl
         * @interface IGetSessionPathResponseBody
         * @property {ptsl.IFileLocation|null} [sessionPath] GetSessionPathResponseBody sessionPath
         */

        /**
         * Constructs a new GetSessionPathResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionPath response data.
         * @implements IGetSessionPathResponseBody
         * @constructor
         * @param {ptsl.IGetSessionPathResponseBody=} [properties] Properties to set
         */
        function GetSessionPathResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionPathResponseBody sessionPath.
         * @member {ptsl.IFileLocation|null|undefined} sessionPath
         * @memberof ptsl.GetSessionPathResponseBody
         * @instance
         */
        GetSessionPathResponseBody.prototype.sessionPath = null;

        /**
         * Creates a new GetSessionPathResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {ptsl.IGetSessionPathResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionPathResponseBody} GetSessionPathResponseBody instance
         */
        GetSessionPathResponseBody.create = function create(properties) {
            return new GetSessionPathResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionPathResponseBody message. Does not implicitly {@link ptsl.GetSessionPathResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {ptsl.IGetSessionPathResponseBody} message GetSessionPathResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionPathResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionPath != null && Object.hasOwnProperty.call(message, "sessionPath"))
                $root.ptsl.FileLocation.encode(message.sessionPath, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSessionPathResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionPathResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {ptsl.IGetSessionPathResponseBody} message GetSessionPathResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionPathResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionPathResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionPathResponseBody} GetSessionPathResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionPathResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionPathResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionPath = $root.ptsl.FileLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionPathResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionPathResponseBody} GetSessionPathResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionPathResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionPathResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionPathResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionPath != null && message.hasOwnProperty("sessionPath")) {
                var error = $root.ptsl.FileLocation.verify(message.sessionPath);
                if (error)
                    return "sessionPath." + error;
            }
            return null;
        };

        /**
         * Creates a GetSessionPathResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionPathResponseBody} GetSessionPathResponseBody
         */
        GetSessionPathResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionPathResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionPathResponseBody();
            if (object.sessionPath != null) {
                if (typeof object.sessionPath !== "object")
                    throw TypeError(".ptsl.GetSessionPathResponseBody.sessionPath: object expected");
                message.sessionPath = $root.ptsl.FileLocation.fromObject(object.sessionPath);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSessionPathResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {ptsl.GetSessionPathResponseBody} message GetSessionPathResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionPathResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionPath = null;
            if (message.sessionPath != null && message.hasOwnProperty("sessionPath"))
                object.sessionPath = $root.ptsl.FileLocation.toObject(message.sessionPath, options);
            return object;
        };

        /**
         * Converts this GetSessionPathResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionPathResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionPathResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionPathResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionPathResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionPathResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionPathResponseBody";
        };

        return GetSessionPathResponseBody;
    })();

    ptsl.GetSessionStartTimeResponseBody = (function() {

        /**
         * Properties of a GetSessionStartTimeResponseBody.
         * @memberof ptsl
         * @interface IGetSessionStartTimeResponseBody
         * @property {string|null} [sessionStartTime] GetSessionStartTimeResponseBody sessionStartTime
         */

        /**
         * Constructs a new GetSessionStartTimeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionStartTime response data.
         * @implements IGetSessionStartTimeResponseBody
         * @constructor
         * @param {ptsl.IGetSessionStartTimeResponseBody=} [properties] Properties to set
         */
        function GetSessionStartTimeResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionStartTimeResponseBody sessionStartTime.
         * @member {string} sessionStartTime
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @instance
         */
        GetSessionStartTimeResponseBody.prototype.sessionStartTime = "";

        /**
         * Creates a new GetSessionStartTimeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {ptsl.IGetSessionStartTimeResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionStartTimeResponseBody} GetSessionStartTimeResponseBody instance
         */
        GetSessionStartTimeResponseBody.create = function create(properties) {
            return new GetSessionStartTimeResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionStartTimeResponseBody message. Does not implicitly {@link ptsl.GetSessionStartTimeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {ptsl.IGetSessionStartTimeResponseBody} message GetSessionStartTimeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionStartTimeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionStartTime != null && Object.hasOwnProperty.call(message, "sessionStartTime"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionStartTime);
            return writer;
        };

        /**
         * Encodes the specified GetSessionStartTimeResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionStartTimeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {ptsl.IGetSessionStartTimeResponseBody} message GetSessionStartTimeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionStartTimeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionStartTimeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionStartTimeResponseBody} GetSessionStartTimeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionStartTimeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionStartTimeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionStartTime = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionStartTimeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionStartTimeResponseBody} GetSessionStartTimeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionStartTimeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionStartTimeResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionStartTimeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionStartTime != null && message.hasOwnProperty("sessionStartTime"))
                if (!$util.isString(message.sessionStartTime))
                    return "sessionStartTime: string expected";
            return null;
        };

        /**
         * Creates a GetSessionStartTimeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionStartTimeResponseBody} GetSessionStartTimeResponseBody
         */
        GetSessionStartTimeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionStartTimeResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionStartTimeResponseBody();
            if (object.sessionStartTime != null)
                message.sessionStartTime = String(object.sessionStartTime);
            return message;
        };

        /**
         * Creates a plain object from a GetSessionStartTimeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {ptsl.GetSessionStartTimeResponseBody} message GetSessionStartTimeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionStartTimeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionStartTime = "";
            if (message.sessionStartTime != null && message.hasOwnProperty("sessionStartTime"))
                object.sessionStartTime = message.sessionStartTime;
            return object;
        };

        /**
         * Converts this GetSessionStartTimeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionStartTimeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionStartTimeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionStartTimeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionStartTimeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionStartTimeResponseBody";
        };

        return GetSessionStartTimeResponseBody;
    })();

    ptsl.GetSessionLengthResponseBody = (function() {

        /**
         * Properties of a GetSessionLengthResponseBody.
         * @memberof ptsl
         * @interface IGetSessionLengthResponseBody
         * @property {string|null} [sessionLength] GetSessionLengthResponseBody sessionLength
         */

        /**
         * Constructs a new GetSessionLengthResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionLength response data.
         * @implements IGetSessionLengthResponseBody
         * @constructor
         * @param {ptsl.IGetSessionLengthResponseBody=} [properties] Properties to set
         */
        function GetSessionLengthResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionLengthResponseBody sessionLength.
         * @member {string} sessionLength
         * @memberof ptsl.GetSessionLengthResponseBody
         * @instance
         */
        GetSessionLengthResponseBody.prototype.sessionLength = "";

        /**
         * Creates a new GetSessionLengthResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {ptsl.IGetSessionLengthResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionLengthResponseBody} GetSessionLengthResponseBody instance
         */
        GetSessionLengthResponseBody.create = function create(properties) {
            return new GetSessionLengthResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionLengthResponseBody message. Does not implicitly {@link ptsl.GetSessionLengthResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {ptsl.IGetSessionLengthResponseBody} message GetSessionLengthResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionLengthResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionLength != null && Object.hasOwnProperty.call(message, "sessionLength"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionLength);
            return writer;
        };

        /**
         * Encodes the specified GetSessionLengthResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionLengthResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {ptsl.IGetSessionLengthResponseBody} message GetSessionLengthResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionLengthResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionLengthResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionLengthResponseBody} GetSessionLengthResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionLengthResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionLengthResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionLength = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionLengthResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionLengthResponseBody} GetSessionLengthResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionLengthResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionLengthResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionLengthResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionLength != null && message.hasOwnProperty("sessionLength"))
                if (!$util.isString(message.sessionLength))
                    return "sessionLength: string expected";
            return null;
        };

        /**
         * Creates a GetSessionLengthResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionLengthResponseBody} GetSessionLengthResponseBody
         */
        GetSessionLengthResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionLengthResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionLengthResponseBody();
            if (object.sessionLength != null)
                message.sessionLength = String(object.sessionLength);
            return message;
        };

        /**
         * Creates a plain object from a GetSessionLengthResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {ptsl.GetSessionLengthResponseBody} message GetSessionLengthResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionLengthResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionLength = "";
            if (message.sessionLength != null && message.hasOwnProperty("sessionLength"))
                object.sessionLength = message.sessionLength;
            return object;
        };

        /**
         * Converts this GetSessionLengthResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionLengthResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionLengthResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionLengthResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionLengthResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionLengthResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionLengthResponseBody";
        };

        return GetSessionLengthResponseBody;
    })();

    ptsl.SetSessionAudioFormatRequestBody = (function() {

        /**
         * Properties of a SetSessionAudioFormatRequestBody.
         * @memberof ptsl
         * @interface ISetSessionAudioFormatRequestBody
         * @property {ptsl.SessionAudioFormat|null} [audioFormat] SetSessionAudioFormatRequestBody audioFormat
         */

        /**
         * Constructs a new SetSessionAudioFormatRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionAudioFormat request data.
         * @implements ISetSessionAudioFormatRequestBody
         * @constructor
         * @param {ptsl.ISetSessionAudioFormatRequestBody=} [properties] Properties to set
         */
        function SetSessionAudioFormatRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionAudioFormatRequestBody audioFormat.
         * @member {ptsl.SessionAudioFormat} audioFormat
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @instance
         */
        SetSessionAudioFormatRequestBody.prototype.audioFormat = 0;

        /**
         * Creates a new SetSessionAudioFormatRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {ptsl.ISetSessionAudioFormatRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionAudioFormatRequestBody} SetSessionAudioFormatRequestBody instance
         */
        SetSessionAudioFormatRequestBody.create = function create(properties) {
            return new SetSessionAudioFormatRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionAudioFormatRequestBody message. Does not implicitly {@link ptsl.SetSessionAudioFormatRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {ptsl.ISetSessionAudioFormatRequestBody} message SetSessionAudioFormatRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionAudioFormatRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audioFormat != null && Object.hasOwnProperty.call(message, "audioFormat"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.audioFormat);
            return writer;
        };

        /**
         * Encodes the specified SetSessionAudioFormatRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionAudioFormatRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {ptsl.ISetSessionAudioFormatRequestBody} message SetSessionAudioFormatRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionAudioFormatRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionAudioFormatRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionAudioFormatRequestBody} SetSessionAudioFormatRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionAudioFormatRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionAudioFormatRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.audioFormat = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionAudioFormatRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionAudioFormatRequestBody} SetSessionAudioFormatRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionAudioFormatRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionAudioFormatRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionAudioFormatRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audioFormat != null && message.hasOwnProperty("audioFormat"))
                switch (message.audioFormat) {
                default:
                    return "audioFormat: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetSessionAudioFormatRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionAudioFormatRequestBody} SetSessionAudioFormatRequestBody
         */
        SetSessionAudioFormatRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionAudioFormatRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionAudioFormatRequestBody();
            switch (object.audioFormat) {
            default:
                if (typeof object.audioFormat === "number") {
                    message.audioFormat = object.audioFormat;
                    break;
                }
                break;
            case "SAFormat_Unknown":
            case 0:
                message.audioFormat = 0;
                break;
            case "SAF_WAVE":
            case 1:
                message.audioFormat = 1;
                break;
            case "SAFormat_WAVE":
            case 1:
                message.audioFormat = 1;
                break;
            case "SAF_AIFF":
            case 2:
                message.audioFormat = 2;
                break;
            case "SAFormat_AIFF":
            case 2:
                message.audioFormat = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSessionAudioFormatRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {ptsl.SetSessionAudioFormatRequestBody} message SetSessionAudioFormatRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionAudioFormatRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.audioFormat = options.enums === String ? "SAFormat_Unknown" : 0;
            if (message.audioFormat != null && message.hasOwnProperty("audioFormat"))
                object.audioFormat = options.enums === String ? $root.ptsl.SessionAudioFormat[message.audioFormat] === undefined ? message.audioFormat : $root.ptsl.SessionAudioFormat[message.audioFormat] : message.audioFormat;
            return object;
        };

        /**
         * Converts this SetSessionAudioFormatRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionAudioFormatRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionAudioFormatRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionAudioFormatRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionAudioFormatRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionAudioFormatRequestBody";
        };

        return SetSessionAudioFormatRequestBody;
    })();

    ptsl.SetSessionBitDepthRequestBody = (function() {

        /**
         * Properties of a SetSessionBitDepthRequestBody.
         * @memberof ptsl
         * @interface ISetSessionBitDepthRequestBody
         * @property {ptsl.BitDepth|null} [bitDepth] SetSessionBitDepthRequestBody bitDepth
         */

        /**
         * Constructs a new SetSessionBitDepthRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionBitDepth request data.
         * @implements ISetSessionBitDepthRequestBody
         * @constructor
         * @param {ptsl.ISetSessionBitDepthRequestBody=} [properties] Properties to set
         */
        function SetSessionBitDepthRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionBitDepthRequestBody bitDepth.
         * @member {ptsl.BitDepth} bitDepth
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @instance
         */
        SetSessionBitDepthRequestBody.prototype.bitDepth = 0;

        /**
         * Creates a new SetSessionBitDepthRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {ptsl.ISetSessionBitDepthRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionBitDepthRequestBody} SetSessionBitDepthRequestBody instance
         */
        SetSessionBitDepthRequestBody.create = function create(properties) {
            return new SetSessionBitDepthRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionBitDepthRequestBody message. Does not implicitly {@link ptsl.SetSessionBitDepthRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {ptsl.ISetSessionBitDepthRequestBody} message SetSessionBitDepthRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionBitDepthRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bitDepth != null && Object.hasOwnProperty.call(message, "bitDepth"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bitDepth);
            return writer;
        };

        /**
         * Encodes the specified SetSessionBitDepthRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionBitDepthRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {ptsl.ISetSessionBitDepthRequestBody} message SetSessionBitDepthRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionBitDepthRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionBitDepthRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionBitDepthRequestBody} SetSessionBitDepthRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionBitDepthRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionBitDepthRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.bitDepth = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionBitDepthRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionBitDepthRequestBody} SetSessionBitDepthRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionBitDepthRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionBitDepthRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionBitDepthRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                switch (message.bitDepth) {
                default:
                    return "bitDepth: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetSessionBitDepthRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionBitDepthRequestBody} SetSessionBitDepthRequestBody
         */
        SetSessionBitDepthRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionBitDepthRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionBitDepthRequestBody();
            switch (object.bitDepth) {
            default:
                if (typeof object.bitDepth === "number") {
                    message.bitDepth = object.bitDepth;
                    break;
                }
                break;
            case "BDepth_Unknown":
            case 0:
                message.bitDepth = 0;
                break;
            case "Bit_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "BDepth_None":
            case 1:
                message.bitDepth = 1;
                break;
            case "Bit16":
            case 2:
                message.bitDepth = 2;
                break;
            case "BDepth_16":
            case 2:
                message.bitDepth = 2;
                break;
            case "Bit24":
            case 3:
                message.bitDepth = 3;
                break;
            case "BDepth_24":
            case 3:
                message.bitDepth = 3;
                break;
            case "Bit32Float":
            case 4:
                message.bitDepth = 4;
                break;
            case "BDepth_32Float":
            case 4:
                message.bitDepth = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSessionBitDepthRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {ptsl.SetSessionBitDepthRequestBody} message SetSessionBitDepthRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionBitDepthRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bitDepth = options.enums === String ? "BDepth_Unknown" : 0;
            if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                object.bitDepth = options.enums === String ? $root.ptsl.BitDepth[message.bitDepth] === undefined ? message.bitDepth : $root.ptsl.BitDepth[message.bitDepth] : message.bitDepth;
            return object;
        };

        /**
         * Converts this SetSessionBitDepthRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionBitDepthRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionBitDepthRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionBitDepthRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionBitDepthRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionBitDepthRequestBody";
        };

        return SetSessionBitDepthRequestBody;
    })();

    ptsl.SetSessionInterleavedStateRequestBody = (function() {

        /**
         * Properties of a SetSessionInterleavedStateRequestBody.
         * @memberof ptsl
         * @interface ISetSessionInterleavedStateRequestBody
         * @property {boolean|null} [interleavedState] SetSessionInterleavedStateRequestBody interleavedState
         */

        /**
         * Constructs a new SetSessionInterleavedStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionInterleavedState request data.
         * @implements ISetSessionInterleavedStateRequestBody
         * @constructor
         * @param {ptsl.ISetSessionInterleavedStateRequestBody=} [properties] Properties to set
         */
        function SetSessionInterleavedStateRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionInterleavedStateRequestBody interleavedState.
         * @member {boolean} interleavedState
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @instance
         */
        SetSessionInterleavedStateRequestBody.prototype.interleavedState = false;

        /**
         * Creates a new SetSessionInterleavedStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {ptsl.ISetSessionInterleavedStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionInterleavedStateRequestBody} SetSessionInterleavedStateRequestBody instance
         */
        SetSessionInterleavedStateRequestBody.create = function create(properties) {
            return new SetSessionInterleavedStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionInterleavedStateRequestBody message. Does not implicitly {@link ptsl.SetSessionInterleavedStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {ptsl.ISetSessionInterleavedStateRequestBody} message SetSessionInterleavedStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionInterleavedStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.interleavedState != null && Object.hasOwnProperty.call(message, "interleavedState"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.interleavedState);
            return writer;
        };

        /**
         * Encodes the specified SetSessionInterleavedStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionInterleavedStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {ptsl.ISetSessionInterleavedStateRequestBody} message SetSessionInterleavedStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionInterleavedStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionInterleavedStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionInterleavedStateRequestBody} SetSessionInterleavedStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionInterleavedStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionInterleavedStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.interleavedState = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionInterleavedStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionInterleavedStateRequestBody} SetSessionInterleavedStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionInterleavedStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionInterleavedStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionInterleavedStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.interleavedState != null && message.hasOwnProperty("interleavedState"))
                if (typeof message.interleavedState !== "boolean")
                    return "interleavedState: boolean expected";
            return null;
        };

        /**
         * Creates a SetSessionInterleavedStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionInterleavedStateRequestBody} SetSessionInterleavedStateRequestBody
         */
        SetSessionInterleavedStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionInterleavedStateRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionInterleavedStateRequestBody();
            if (object.interleavedState != null)
                message.interleavedState = Boolean(object.interleavedState);
            return message;
        };

        /**
         * Creates a plain object from a SetSessionInterleavedStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {ptsl.SetSessionInterleavedStateRequestBody} message SetSessionInterleavedStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionInterleavedStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.interleavedState = false;
            if (message.interleavedState != null && message.hasOwnProperty("interleavedState"))
                object.interleavedState = message.interleavedState;
            return object;
        };

        /**
         * Converts this SetSessionInterleavedStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionInterleavedStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionInterleavedStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionInterleavedStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionInterleavedStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionInterleavedStateRequestBody";
        };

        return SetSessionInterleavedStateRequestBody;
    })();

    ptsl.SetSessionTimeCodeRateRequestBody = (function() {

        /**
         * Properties of a SetSessionTimeCodeRateRequestBody.
         * @memberof ptsl
         * @interface ISetSessionTimeCodeRateRequestBody
         * @property {ptsl.SessionTimeCodeRate|null} [timeCodeRate] SetSessionTimeCodeRateRequestBody timeCodeRate
         */

        /**
         * Constructs a new SetSessionTimeCodeRateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionTimeCodeRate request data.
         * @implements ISetSessionTimeCodeRateRequestBody
         * @constructor
         * @param {ptsl.ISetSessionTimeCodeRateRequestBody=} [properties] Properties to set
         */
        function SetSessionTimeCodeRateRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionTimeCodeRateRequestBody timeCodeRate.
         * @member {ptsl.SessionTimeCodeRate} timeCodeRate
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @instance
         */
        SetSessionTimeCodeRateRequestBody.prototype.timeCodeRate = 0;

        /**
         * Creates a new SetSessionTimeCodeRateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {ptsl.ISetSessionTimeCodeRateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionTimeCodeRateRequestBody} SetSessionTimeCodeRateRequestBody instance
         */
        SetSessionTimeCodeRateRequestBody.create = function create(properties) {
            return new SetSessionTimeCodeRateRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionTimeCodeRateRequestBody message. Does not implicitly {@link ptsl.SetSessionTimeCodeRateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {ptsl.ISetSessionTimeCodeRateRequestBody} message SetSessionTimeCodeRateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionTimeCodeRateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeCodeRate != null && Object.hasOwnProperty.call(message, "timeCodeRate"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.timeCodeRate);
            return writer;
        };

        /**
         * Encodes the specified SetSessionTimeCodeRateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionTimeCodeRateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {ptsl.ISetSessionTimeCodeRateRequestBody} message SetSessionTimeCodeRateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionTimeCodeRateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionTimeCodeRateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionTimeCodeRateRequestBody} SetSessionTimeCodeRateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionTimeCodeRateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionTimeCodeRateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.timeCodeRate = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionTimeCodeRateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionTimeCodeRateRequestBody} SetSessionTimeCodeRateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionTimeCodeRateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionTimeCodeRateRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionTimeCodeRateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeCodeRate != null && message.hasOwnProperty("timeCodeRate"))
                switch (message.timeCodeRate) {
                default:
                    return "timeCodeRate: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetSessionTimeCodeRateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionTimeCodeRateRequestBody} SetSessionTimeCodeRateRequestBody
         */
        SetSessionTimeCodeRateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionTimeCodeRateRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionTimeCodeRateRequestBody();
            switch (object.timeCodeRate) {
            default:
                if (typeof object.timeCodeRate === "number") {
                    message.timeCodeRate = object.timeCodeRate;
                    break;
                }
                break;
            case "STCRate_Unknown":
            case 0:
                message.timeCodeRate = 0;
                break;
            case "STCR_Fps23976":
            case 1:
                message.timeCodeRate = 1;
                break;
            case "STCRate_Fps23976":
            case 1:
                message.timeCodeRate = 1;
                break;
            case "STCR_Fps24":
            case 2:
                message.timeCodeRate = 2;
                break;
            case "STCRate_Fps24":
            case 2:
                message.timeCodeRate = 2;
                break;
            case "STCR_Fps25":
            case 3:
                message.timeCodeRate = 3;
                break;
            case "STCRate_Fps25":
            case 3:
                message.timeCodeRate = 3;
                break;
            case "STCR_Fps2997":
            case 4:
                message.timeCodeRate = 4;
                break;
            case "STCRate_Fps2997":
            case 4:
                message.timeCodeRate = 4;
                break;
            case "STCR_Fps2997Drop":
            case 5:
                message.timeCodeRate = 5;
                break;
            case "SSTCRate_Fps2997Drop":
            case 5:
                message.timeCodeRate = 5;
                break;
            case "STCR_Fps30":
            case 6:
                message.timeCodeRate = 6;
                break;
            case "STCRate_Fps30":
            case 6:
                message.timeCodeRate = 6;
                break;
            case "STCR_Fps30Drop":
            case 7:
                message.timeCodeRate = 7;
                break;
            case "STCRate_Fps30Drop":
            case 7:
                message.timeCodeRate = 7;
                break;
            case "STCR_Fps47952":
            case 8:
                message.timeCodeRate = 8;
                break;
            case "STCRate_Fps47952":
            case 8:
                message.timeCodeRate = 8;
                break;
            case "STCR_Fps48":
            case 9:
                message.timeCodeRate = 9;
                break;
            case "STCRate_Fps48":
            case 9:
                message.timeCodeRate = 9;
                break;
            case "STCR_Fps50":
            case 10:
                message.timeCodeRate = 10;
                break;
            case "STCRate_Fps50":
            case 10:
                message.timeCodeRate = 10;
                break;
            case "STCR_Fps5994":
            case 11:
                message.timeCodeRate = 11;
                break;
            case "STCRate_Fps5994":
            case 11:
                message.timeCodeRate = 11;
                break;
            case "STCR_Fps5994Drop":
            case 12:
                message.timeCodeRate = 12;
                break;
            case "STCRate_Fps5994Drop":
            case 12:
                message.timeCodeRate = 12;
                break;
            case "STCR_Fps60":
            case 13:
                message.timeCodeRate = 13;
                break;
            case "STCRate_Fps60":
            case 13:
                message.timeCodeRate = 13;
                break;
            case "STCR_Fps60Drop":
            case 14:
                message.timeCodeRate = 14;
                break;
            case "STCRate_Fps60Drop":
            case 14:
                message.timeCodeRate = 14;
                break;
            case "STCR_Fps100":
            case 15:
                message.timeCodeRate = 15;
                break;
            case "STCRate_Fps100":
            case 15:
                message.timeCodeRate = 15;
                break;
            case "STCR_Fps11988":
            case 16:
                message.timeCodeRate = 16;
                break;
            case "STCRate_Fps11988":
            case 16:
                message.timeCodeRate = 16;
                break;
            case "STCR_Fps11988Drop":
            case 17:
                message.timeCodeRate = 17;
                break;
            case "STCRate_Fps11988Drop":
            case 17:
                message.timeCodeRate = 17;
                break;
            case "STCR_Fps120":
            case 18:
                message.timeCodeRate = 18;
                break;
            case "STCRate_Fps120":
            case 18:
                message.timeCodeRate = 18;
                break;
            case "STCR_Fps120Drop":
            case 19:
                message.timeCodeRate = 19;
                break;
            case "STCRate_Fps120Drop":
            case 19:
                message.timeCodeRate = 19;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSessionTimeCodeRateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {ptsl.SetSessionTimeCodeRateRequestBody} message SetSessionTimeCodeRateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionTimeCodeRateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.timeCodeRate = options.enums === String ? "STCRate_Unknown" : 0;
            if (message.timeCodeRate != null && message.hasOwnProperty("timeCodeRate"))
                object.timeCodeRate = options.enums === String ? $root.ptsl.SessionTimeCodeRate[message.timeCodeRate] === undefined ? message.timeCodeRate : $root.ptsl.SessionTimeCodeRate[message.timeCodeRate] : message.timeCodeRate;
            return object;
        };

        /**
         * Converts this SetSessionTimeCodeRateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionTimeCodeRateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionTimeCodeRateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionTimeCodeRateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionTimeCodeRateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionTimeCodeRateRequestBody";
        };

        return SetSessionTimeCodeRateRequestBody;
    })();

    ptsl.SetSessionFeetFramesRateRequestBody = (function() {

        /**
         * Properties of a SetSessionFeetFramesRateRequestBody.
         * @memberof ptsl
         * @interface ISetSessionFeetFramesRateRequestBody
         * @property {ptsl.SessionFeetFramesRate|null} [feetFramesRate] SetSessionFeetFramesRateRequestBody feetFramesRate
         */

        /**
         * Constructs a new SetSessionFeetFramesRateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionFeetFramesRate request data.
         * @implements ISetSessionFeetFramesRateRequestBody
         * @constructor
         * @param {ptsl.ISetSessionFeetFramesRateRequestBody=} [properties] Properties to set
         */
        function SetSessionFeetFramesRateRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionFeetFramesRateRequestBody feetFramesRate.
         * @member {ptsl.SessionFeetFramesRate} feetFramesRate
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @instance
         */
        SetSessionFeetFramesRateRequestBody.prototype.feetFramesRate = 0;

        /**
         * Creates a new SetSessionFeetFramesRateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {ptsl.ISetSessionFeetFramesRateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionFeetFramesRateRequestBody} SetSessionFeetFramesRateRequestBody instance
         */
        SetSessionFeetFramesRateRequestBody.create = function create(properties) {
            return new SetSessionFeetFramesRateRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionFeetFramesRateRequestBody message. Does not implicitly {@link ptsl.SetSessionFeetFramesRateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {ptsl.ISetSessionFeetFramesRateRequestBody} message SetSessionFeetFramesRateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionFeetFramesRateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.feetFramesRate != null && Object.hasOwnProperty.call(message, "feetFramesRate"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feetFramesRate);
            return writer;
        };

        /**
         * Encodes the specified SetSessionFeetFramesRateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionFeetFramesRateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {ptsl.ISetSessionFeetFramesRateRequestBody} message SetSessionFeetFramesRateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionFeetFramesRateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionFeetFramesRateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionFeetFramesRateRequestBody} SetSessionFeetFramesRateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionFeetFramesRateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionFeetFramesRateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.feetFramesRate = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionFeetFramesRateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionFeetFramesRateRequestBody} SetSessionFeetFramesRateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionFeetFramesRateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionFeetFramesRateRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionFeetFramesRateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.feetFramesRate != null && message.hasOwnProperty("feetFramesRate"))
                switch (message.feetFramesRate) {
                default:
                    return "feetFramesRate: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetSessionFeetFramesRateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionFeetFramesRateRequestBody} SetSessionFeetFramesRateRequestBody
         */
        SetSessionFeetFramesRateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionFeetFramesRateRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionFeetFramesRateRequestBody();
            switch (object.feetFramesRate) {
            default:
                if (typeof object.feetFramesRate === "number") {
                    message.feetFramesRate = object.feetFramesRate;
                    break;
                }
                break;
            case "SFFRate_Unknown":
            case 0:
                message.feetFramesRate = 0;
                break;
            case "SFFR_Fps23976":
            case 1:
                message.feetFramesRate = 1;
                break;
            case "SFFRate_Fps23976":
            case 1:
                message.feetFramesRate = 1;
                break;
            case "SFFR_Fps24":
            case 2:
                message.feetFramesRate = 2;
                break;
            case "SFFRate_Fps24":
            case 2:
                message.feetFramesRate = 2;
                break;
            case "SFFR_Fps25":
            case 3:
                message.feetFramesRate = 3;
                break;
            case "SFFRate_Fps25":
            case 3:
                message.feetFramesRate = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSessionFeetFramesRateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {ptsl.SetSessionFeetFramesRateRequestBody} message SetSessionFeetFramesRateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionFeetFramesRateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.feetFramesRate = options.enums === String ? "SFFRate_Unknown" : 0;
            if (message.feetFramesRate != null && message.hasOwnProperty("feetFramesRate"))
                object.feetFramesRate = options.enums === String ? $root.ptsl.SessionFeetFramesRate[message.feetFramesRate] === undefined ? message.feetFramesRate : $root.ptsl.SessionFeetFramesRate[message.feetFramesRate] : message.feetFramesRate;
            return object;
        };

        /**
         * Converts this SetSessionFeetFramesRateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionFeetFramesRateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionFeetFramesRateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionFeetFramesRateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionFeetFramesRateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionFeetFramesRateRequestBody";
        };

        return SetSessionFeetFramesRateRequestBody;
    })();

    ptsl.SetSessionAudioRatePullSettingsRequestBody = (function() {

        /**
         * Properties of a SetSessionAudioRatePullSettingsRequestBody.
         * @memberof ptsl
         * @interface ISetSessionAudioRatePullSettingsRequestBody
         * @property {ptsl.SessionRatePull|null} [audioRatePull] SetSessionAudioRatePullSettingsRequestBody audioRatePull
         */

        /**
         * Constructs a new SetSessionAudioRatePullSettingsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionAudioRatePullSettings request data.
         * @implements ISetSessionAudioRatePullSettingsRequestBody
         * @constructor
         * @param {ptsl.ISetSessionAudioRatePullSettingsRequestBody=} [properties] Properties to set
         */
        function SetSessionAudioRatePullSettingsRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionAudioRatePullSettingsRequestBody audioRatePull.
         * @member {ptsl.SessionRatePull} audioRatePull
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @instance
         */
        SetSessionAudioRatePullSettingsRequestBody.prototype.audioRatePull = 0;

        /**
         * Creates a new SetSessionAudioRatePullSettingsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {ptsl.ISetSessionAudioRatePullSettingsRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionAudioRatePullSettingsRequestBody} SetSessionAudioRatePullSettingsRequestBody instance
         */
        SetSessionAudioRatePullSettingsRequestBody.create = function create(properties) {
            return new SetSessionAudioRatePullSettingsRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionAudioRatePullSettingsRequestBody message. Does not implicitly {@link ptsl.SetSessionAudioRatePullSettingsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {ptsl.ISetSessionAudioRatePullSettingsRequestBody} message SetSessionAudioRatePullSettingsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionAudioRatePullSettingsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audioRatePull != null && Object.hasOwnProperty.call(message, "audioRatePull"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.audioRatePull);
            return writer;
        };

        /**
         * Encodes the specified SetSessionAudioRatePullSettingsRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionAudioRatePullSettingsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {ptsl.ISetSessionAudioRatePullSettingsRequestBody} message SetSessionAudioRatePullSettingsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionAudioRatePullSettingsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionAudioRatePullSettingsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionAudioRatePullSettingsRequestBody} SetSessionAudioRatePullSettingsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionAudioRatePullSettingsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionAudioRatePullSettingsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.audioRatePull = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionAudioRatePullSettingsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionAudioRatePullSettingsRequestBody} SetSessionAudioRatePullSettingsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionAudioRatePullSettingsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionAudioRatePullSettingsRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionAudioRatePullSettingsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audioRatePull != null && message.hasOwnProperty("audioRatePull"))
                switch (message.audioRatePull) {
                default:
                    return "audioRatePull: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetSessionAudioRatePullSettingsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionAudioRatePullSettingsRequestBody} SetSessionAudioRatePullSettingsRequestBody
         */
        SetSessionAudioRatePullSettingsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionAudioRatePullSettingsRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionAudioRatePullSettingsRequestBody();
            switch (object.audioRatePull) {
            default:
                if (typeof object.audioRatePull === "number") {
                    message.audioRatePull = object.audioRatePull;
                    break;
                }
                break;
            case "SRPull_Unknown":
            case 0:
                message.audioRatePull = 0;
                break;
            case "SRP_None":
            case 1:
                message.audioRatePull = 1;
                break;
            case "SRPull_None":
            case 1:
                message.audioRatePull = 1;
                break;
            case "SRP_Up01":
            case 2:
                message.audioRatePull = 2;
                break;
            case "SRPull_Up01":
            case 2:
                message.audioRatePull = 2;
                break;
            case "SRP_Down01":
            case 3:
                message.audioRatePull = 3;
                break;
            case "SRPull_Down01":
            case 3:
                message.audioRatePull = 3;
                break;
            case "SRP_Up4":
            case 4:
                message.audioRatePull = 4;
                break;
            case "SRPull_Up4":
            case 4:
                message.audioRatePull = 4;
                break;
            case "SRP_Up4Up01":
            case 5:
                message.audioRatePull = 5;
                break;
            case "SRPull_Up4Up01":
            case 5:
                message.audioRatePull = 5;
                break;
            case "SRP_Up4Down01":
            case 6:
                message.audioRatePull = 6;
                break;
            case "SRPull_Up4Down01":
            case 6:
                message.audioRatePull = 6;
                break;
            case "SRP_Down4":
            case 7:
                message.audioRatePull = 7;
                break;
            case "SRPull_Down4":
            case 7:
                message.audioRatePull = 7;
                break;
            case "SRP_Down4Up01":
            case 8:
                message.audioRatePull = 8;
                break;
            case "SRPull_Down4Up01":
            case 8:
                message.audioRatePull = 8;
                break;
            case "SRP_Down4Down01":
            case 9:
                message.audioRatePull = 9;
                break;
            case "SRPull_Down4Down01":
            case 9:
                message.audioRatePull = 9;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSessionAudioRatePullSettingsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {ptsl.SetSessionAudioRatePullSettingsRequestBody} message SetSessionAudioRatePullSettingsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionAudioRatePullSettingsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.audioRatePull = options.enums === String ? "SRPull_Unknown" : 0;
            if (message.audioRatePull != null && message.hasOwnProperty("audioRatePull"))
                object.audioRatePull = options.enums === String ? $root.ptsl.SessionRatePull[message.audioRatePull] === undefined ? message.audioRatePull : $root.ptsl.SessionRatePull[message.audioRatePull] : message.audioRatePull;
            return object;
        };

        /**
         * Converts this SetSessionAudioRatePullSettingsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionAudioRatePullSettingsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionAudioRatePullSettingsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionAudioRatePullSettingsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionAudioRatePullSettingsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionAudioRatePullSettingsRequestBody";
        };

        return SetSessionAudioRatePullSettingsRequestBody;
    })();

    ptsl.SetSessionVideoRatePullSettingsRequestBody = (function() {

        /**
         * Properties of a SetSessionVideoRatePullSettingsRequestBody.
         * @memberof ptsl
         * @interface ISetSessionVideoRatePullSettingsRequestBody
         * @property {ptsl.SessionRatePull|null} [videoRatePull] SetSessionVideoRatePullSettingsRequestBody videoRatePull
         */

        /**
         * Constructs a new SetSessionVideoRatePullSettingsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionVideoRatePullSettings request data.
         * @implements ISetSessionVideoRatePullSettingsRequestBody
         * @constructor
         * @param {ptsl.ISetSessionVideoRatePullSettingsRequestBody=} [properties] Properties to set
         */
        function SetSessionVideoRatePullSettingsRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionVideoRatePullSettingsRequestBody videoRatePull.
         * @member {ptsl.SessionRatePull} videoRatePull
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @instance
         */
        SetSessionVideoRatePullSettingsRequestBody.prototype.videoRatePull = 0;

        /**
         * Creates a new SetSessionVideoRatePullSettingsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {ptsl.ISetSessionVideoRatePullSettingsRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionVideoRatePullSettingsRequestBody} SetSessionVideoRatePullSettingsRequestBody instance
         */
        SetSessionVideoRatePullSettingsRequestBody.create = function create(properties) {
            return new SetSessionVideoRatePullSettingsRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionVideoRatePullSettingsRequestBody message. Does not implicitly {@link ptsl.SetSessionVideoRatePullSettingsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {ptsl.ISetSessionVideoRatePullSettingsRequestBody} message SetSessionVideoRatePullSettingsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionVideoRatePullSettingsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.videoRatePull != null && Object.hasOwnProperty.call(message, "videoRatePull"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.videoRatePull);
            return writer;
        };

        /**
         * Encodes the specified SetSessionVideoRatePullSettingsRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionVideoRatePullSettingsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {ptsl.ISetSessionVideoRatePullSettingsRequestBody} message SetSessionVideoRatePullSettingsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionVideoRatePullSettingsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionVideoRatePullSettingsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionVideoRatePullSettingsRequestBody} SetSessionVideoRatePullSettingsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionVideoRatePullSettingsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionVideoRatePullSettingsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.videoRatePull = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionVideoRatePullSettingsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionVideoRatePullSettingsRequestBody} SetSessionVideoRatePullSettingsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionVideoRatePullSettingsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionVideoRatePullSettingsRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionVideoRatePullSettingsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.videoRatePull != null && message.hasOwnProperty("videoRatePull"))
                switch (message.videoRatePull) {
                default:
                    return "videoRatePull: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetSessionVideoRatePullSettingsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionVideoRatePullSettingsRequestBody} SetSessionVideoRatePullSettingsRequestBody
         */
        SetSessionVideoRatePullSettingsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionVideoRatePullSettingsRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionVideoRatePullSettingsRequestBody();
            switch (object.videoRatePull) {
            default:
                if (typeof object.videoRatePull === "number") {
                    message.videoRatePull = object.videoRatePull;
                    break;
                }
                break;
            case "SRPull_Unknown":
            case 0:
                message.videoRatePull = 0;
                break;
            case "SRP_None":
            case 1:
                message.videoRatePull = 1;
                break;
            case "SRPull_None":
            case 1:
                message.videoRatePull = 1;
                break;
            case "SRP_Up01":
            case 2:
                message.videoRatePull = 2;
                break;
            case "SRPull_Up01":
            case 2:
                message.videoRatePull = 2;
                break;
            case "SRP_Down01":
            case 3:
                message.videoRatePull = 3;
                break;
            case "SRPull_Down01":
            case 3:
                message.videoRatePull = 3;
                break;
            case "SRP_Up4":
            case 4:
                message.videoRatePull = 4;
                break;
            case "SRPull_Up4":
            case 4:
                message.videoRatePull = 4;
                break;
            case "SRP_Up4Up01":
            case 5:
                message.videoRatePull = 5;
                break;
            case "SRPull_Up4Up01":
            case 5:
                message.videoRatePull = 5;
                break;
            case "SRP_Up4Down01":
            case 6:
                message.videoRatePull = 6;
                break;
            case "SRPull_Up4Down01":
            case 6:
                message.videoRatePull = 6;
                break;
            case "SRP_Down4":
            case 7:
                message.videoRatePull = 7;
                break;
            case "SRPull_Down4":
            case 7:
                message.videoRatePull = 7;
                break;
            case "SRP_Down4Up01":
            case 8:
                message.videoRatePull = 8;
                break;
            case "SRPull_Down4Up01":
            case 8:
                message.videoRatePull = 8;
                break;
            case "SRP_Down4Down01":
            case 9:
                message.videoRatePull = 9;
                break;
            case "SRPull_Down4Down01":
            case 9:
                message.videoRatePull = 9;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSessionVideoRatePullSettingsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {ptsl.SetSessionVideoRatePullSettingsRequestBody} message SetSessionVideoRatePullSettingsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionVideoRatePullSettingsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.videoRatePull = options.enums === String ? "SRPull_Unknown" : 0;
            if (message.videoRatePull != null && message.hasOwnProperty("videoRatePull"))
                object.videoRatePull = options.enums === String ? $root.ptsl.SessionRatePull[message.videoRatePull] === undefined ? message.videoRatePull : $root.ptsl.SessionRatePull[message.videoRatePull] : message.videoRatePull;
            return object;
        };

        /**
         * Converts this SetSessionVideoRatePullSettingsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionVideoRatePullSettingsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionVideoRatePullSettingsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionVideoRatePullSettingsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionVideoRatePullSettingsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionVideoRatePullSettingsRequestBody";
        };

        return SetSessionVideoRatePullSettingsRequestBody;
    })();

    ptsl.SetSessionStartTimeRequestBody = (function() {

        /**
         * Properties of a SetSessionStartTimeRequestBody.
         * @memberof ptsl
         * @interface ISetSessionStartTimeRequestBody
         * @property {string|null} [sessionStartTime] * @deprecated since Pro Tools 2025.06, use location
         * @property {ptsl.TrackOffsetOptions|null} [trackOffsetOpts] * @deprecated since Pro Tools 2025.06, use location
         * @property {boolean|null} [maintainRelativePosition] SetSessionStartTimeRequestBody maintainRelativePosition
         * @property {ptsl.ITimelineLocation|null} [location] * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new SetSessionStartTimeRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionStartTime request data.
         * @implements ISetSessionStartTimeRequestBody
         * @constructor
         * @param {ptsl.ISetSessionStartTimeRequestBody=} [properties] Properties to set
         */
        function SetSessionStartTimeRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2025.06, use location
         * @member {string} sessionStartTime
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @instance
         */
        SetSessionStartTimeRequestBody.prototype.sessionStartTime = "";

        /**
         * * @deprecated since Pro Tools 2025.06, use location
         * @member {ptsl.TrackOffsetOptions} trackOffsetOpts
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @instance
         */
        SetSessionStartTimeRequestBody.prototype.trackOffsetOpts = 0;

        /**
         * SetSessionStartTimeRequestBody maintainRelativePosition.
         * @member {boolean} maintainRelativePosition
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @instance
         */
        SetSessionStartTimeRequestBody.prototype.maintainRelativePosition = false;

        /**
         * * @since Pro Tools 2025.06
         * @member {ptsl.ITimelineLocation|null|undefined} location
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @instance
         */
        SetSessionStartTimeRequestBody.prototype.location = null;

        /**
         * Creates a new SetSessionStartTimeRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {ptsl.ISetSessionStartTimeRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionStartTimeRequestBody} SetSessionStartTimeRequestBody instance
         */
        SetSessionStartTimeRequestBody.create = function create(properties) {
            return new SetSessionStartTimeRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionStartTimeRequestBody message. Does not implicitly {@link ptsl.SetSessionStartTimeRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {ptsl.ISetSessionStartTimeRequestBody} message SetSessionStartTimeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionStartTimeRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionStartTime != null && Object.hasOwnProperty.call(message, "sessionStartTime"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionStartTime);
            if (message.trackOffsetOpts != null && Object.hasOwnProperty.call(message, "trackOffsetOpts"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trackOffsetOpts);
            if (message.maintainRelativePosition != null && Object.hasOwnProperty.call(message, "maintainRelativePosition"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.maintainRelativePosition);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                $root.ptsl.TimelineLocation.encode(message.location, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetSessionStartTimeRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionStartTimeRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {ptsl.ISetSessionStartTimeRequestBody} message SetSessionStartTimeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionStartTimeRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionStartTimeRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionStartTimeRequestBody} SetSessionStartTimeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionStartTimeRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionStartTimeRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionStartTime = reader.string();
                        break;
                    }
                case 2: {
                        message.trackOffsetOpts = reader.int32();
                        break;
                    }
                case 3: {
                        message.maintainRelativePosition = reader.bool();
                        break;
                    }
                case 4: {
                        message.location = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionStartTimeRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionStartTimeRequestBody} SetSessionStartTimeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionStartTimeRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionStartTimeRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionStartTimeRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionStartTime != null && message.hasOwnProperty("sessionStartTime"))
                if (!$util.isString(message.sessionStartTime))
                    return "sessionStartTime: string expected";
            if (message.trackOffsetOpts != null && message.hasOwnProperty("trackOffsetOpts"))
                switch (message.trackOffsetOpts) {
                default:
                    return "trackOffsetOpts: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.maintainRelativePosition != null && message.hasOwnProperty("maintainRelativePosition"))
                if (typeof message.maintainRelativePosition !== "boolean")
                    return "maintainRelativePosition: boolean expected";
            if (message.location != null && message.hasOwnProperty("location")) {
                var error = $root.ptsl.TimelineLocation.verify(message.location);
                if (error)
                    return "location." + error;
            }
            return null;
        };

        /**
         * Creates a SetSessionStartTimeRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionStartTimeRequestBody} SetSessionStartTimeRequestBody
         */
        SetSessionStartTimeRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionStartTimeRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionStartTimeRequestBody();
            if (object.sessionStartTime != null)
                message.sessionStartTime = String(object.sessionStartTime);
            switch (object.trackOffsetOpts) {
            default:
                if (typeof object.trackOffsetOpts === "number") {
                    message.trackOffsetOpts = object.trackOffsetOpts;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.trackOffsetOpts = 0;
                break;
            case "BarsBeats":
            case 1:
                message.trackOffsetOpts = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.trackOffsetOpts = 1;
                break;
            case "MinSecs":
            case 2:
                message.trackOffsetOpts = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.trackOffsetOpts = 2;
                break;
            case "TimeCode":
            case 3:
                message.trackOffsetOpts = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.trackOffsetOpts = 3;
                break;
            case "FeetFrames":
            case 4:
                message.trackOffsetOpts = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.trackOffsetOpts = 4;
                break;
            case "Samples":
            case 5:
                message.trackOffsetOpts = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.trackOffsetOpts = 5;
                break;
            }
            if (object.maintainRelativePosition != null)
                message.maintainRelativePosition = Boolean(object.maintainRelativePosition);
            if (object.location != null) {
                if (typeof object.location !== "object")
                    throw TypeError(".ptsl.SetSessionStartTimeRequestBody.location: object expected");
                message.location = $root.ptsl.TimelineLocation.fromObject(object.location);
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSessionStartTimeRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {ptsl.SetSessionStartTimeRequestBody} message SetSessionStartTimeRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionStartTimeRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sessionStartTime = "";
                object.trackOffsetOpts = options.enums === String ? "TOOptions_Unknown" : 0;
                object.maintainRelativePosition = false;
                object.location = null;
            }
            if (message.sessionStartTime != null && message.hasOwnProperty("sessionStartTime"))
                object.sessionStartTime = message.sessionStartTime;
            if (message.trackOffsetOpts != null && message.hasOwnProperty("trackOffsetOpts"))
                object.trackOffsetOpts = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.trackOffsetOpts] === undefined ? message.trackOffsetOpts : $root.ptsl.TrackOffsetOptions[message.trackOffsetOpts] : message.trackOffsetOpts;
            if (message.maintainRelativePosition != null && message.hasOwnProperty("maintainRelativePosition"))
                object.maintainRelativePosition = message.maintainRelativePosition;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = $root.ptsl.TimelineLocation.toObject(message.location, options);
            return object;
        };

        /**
         * Converts this SetSessionStartTimeRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionStartTimeRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionStartTimeRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionStartTimeRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionStartTimeRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionStartTimeRequestBody";
        };

        return SetSessionStartTimeRequestBody;
    })();

    ptsl.SetSessionLengthRequestBody = (function() {

        /**
         * Properties of a SetSessionLengthRequestBody.
         * @memberof ptsl
         * @interface ISetSessionLengthRequestBody
         * @property {string|null} [sessionLength] SetSessionLengthRequestBody sessionLength
         */

        /**
         * Constructs a new SetSessionLengthRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSessionLength request data.
         * @implements ISetSessionLengthRequestBody
         * @constructor
         * @param {ptsl.ISetSessionLengthRequestBody=} [properties] Properties to set
         */
        function SetSessionLengthRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetSessionLengthRequestBody sessionLength.
         * @member {string} sessionLength
         * @memberof ptsl.SetSessionLengthRequestBody
         * @instance
         */
        SetSessionLengthRequestBody.prototype.sessionLength = "";

        /**
         * Creates a new SetSessionLengthRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {ptsl.ISetSessionLengthRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSessionLengthRequestBody} SetSessionLengthRequestBody instance
         */
        SetSessionLengthRequestBody.create = function create(properties) {
            return new SetSessionLengthRequestBody(properties);
        };

        /**
         * Encodes the specified SetSessionLengthRequestBody message. Does not implicitly {@link ptsl.SetSessionLengthRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {ptsl.ISetSessionLengthRequestBody} message SetSessionLengthRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionLengthRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionLength != null && Object.hasOwnProperty.call(message, "sessionLength"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionLength);
            return writer;
        };

        /**
         * Encodes the specified SetSessionLengthRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSessionLengthRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {ptsl.ISetSessionLengthRequestBody} message SetSessionLengthRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSessionLengthRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSessionLengthRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSessionLengthRequestBody} SetSessionLengthRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionLengthRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSessionLengthRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionLength = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSessionLengthRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSessionLengthRequestBody} SetSessionLengthRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSessionLengthRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSessionLengthRequestBody message.
         * @function verify
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSessionLengthRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionLength != null && message.hasOwnProperty("sessionLength"))
                if (!$util.isString(message.sessionLength))
                    return "sessionLength: string expected";
            return null;
        };

        /**
         * Creates a SetSessionLengthRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSessionLengthRequestBody} SetSessionLengthRequestBody
         */
        SetSessionLengthRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSessionLengthRequestBody)
                return object;
            var message = new $root.ptsl.SetSessionLengthRequestBody();
            if (object.sessionLength != null)
                message.sessionLength = String(object.sessionLength);
            return message;
        };

        /**
         * Creates a plain object from a SetSessionLengthRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {ptsl.SetSessionLengthRequestBody} message SetSessionLengthRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSessionLengthRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionLength = "";
            if (message.sessionLength != null && message.hasOwnProperty("sessionLength"))
                object.sessionLength = message.sessionLength;
            return object;
        };

        /**
         * Converts this SetSessionLengthRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSessionLengthRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSessionLengthRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSessionLengthRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSessionLengthRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSessionLengthRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSessionLengthRequestBody";
        };

        return SetSessionLengthRequestBody;
    })();

    ptsl.GetPTSLVersionResponseBody = (function() {

        /**
         * Properties of a GetPTSLVersionResponseBody.
         * @memberof ptsl
         * @interface IGetPTSLVersionResponseBody
         * @property {number|null} [version] * Major version of PTSL Host.
         * @property {number|null} [versionMinor] * Minor version of PTSL Host.
         * *
         * @since Pro Tools 2025.06
         * @property {number|null} [versionRevision] * Revision version of PTSL Host.
         * *
         * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new GetPTSLVersionResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetPTSLVersion response data.
         * @implements IGetPTSLVersionResponseBody
         * @constructor
         * @param {ptsl.IGetPTSLVersionResponseBody=} [properties] Properties to set
         */
        function GetPTSLVersionResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Major version of PTSL Host.
         * @member {number} version
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @instance
         */
        GetPTSLVersionResponseBody.prototype.version = 0;

        /**
         * * Minor version of PTSL Host.
         * *
         * @since Pro Tools 2025.06
         * @member {number} versionMinor
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @instance
         */
        GetPTSLVersionResponseBody.prototype.versionMinor = 0;

        /**
         * * Revision version of PTSL Host.
         * *
         * @since Pro Tools 2025.06
         * @member {number} versionRevision
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @instance
         */
        GetPTSLVersionResponseBody.prototype.versionRevision = 0;

        /**
         * Creates a new GetPTSLVersionResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {ptsl.IGetPTSLVersionResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetPTSLVersionResponseBody} GetPTSLVersionResponseBody instance
         */
        GetPTSLVersionResponseBody.create = function create(properties) {
            return new GetPTSLVersionResponseBody(properties);
        };

        /**
         * Encodes the specified GetPTSLVersionResponseBody message. Does not implicitly {@link ptsl.GetPTSLVersionResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {ptsl.IGetPTSLVersionResponseBody} message GetPTSLVersionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPTSLVersionResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
            if (message.versionMinor != null && Object.hasOwnProperty.call(message, "versionMinor"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.versionMinor);
            if (message.versionRevision != null && Object.hasOwnProperty.call(message, "versionRevision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.versionRevision);
            return writer;
        };

        /**
         * Encodes the specified GetPTSLVersionResponseBody message, length delimited. Does not implicitly {@link ptsl.GetPTSLVersionResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {ptsl.IGetPTSLVersionResponseBody} message GetPTSLVersionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPTSLVersionResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPTSLVersionResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetPTSLVersionResponseBody} GetPTSLVersionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPTSLVersionResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetPTSLVersionResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.version = reader.int32();
                        break;
                    }
                case 2: {
                        message.versionMinor = reader.int32();
                        break;
                    }
                case 3: {
                        message.versionRevision = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPTSLVersionResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetPTSLVersionResponseBody} GetPTSLVersionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPTSLVersionResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPTSLVersionResponseBody message.
         * @function verify
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPTSLVersionResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                if (!$util.isInteger(message.versionMinor))
                    return "versionMinor: integer expected";
            if (message.versionRevision != null && message.hasOwnProperty("versionRevision"))
                if (!$util.isInteger(message.versionRevision))
                    return "versionRevision: integer expected";
            return null;
        };

        /**
         * Creates a GetPTSLVersionResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetPTSLVersionResponseBody} GetPTSLVersionResponseBody
         */
        GetPTSLVersionResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetPTSLVersionResponseBody)
                return object;
            var message = new $root.ptsl.GetPTSLVersionResponseBody();
            if (object.version != null)
                message.version = object.version | 0;
            if (object.versionMinor != null)
                message.versionMinor = object.versionMinor | 0;
            if (object.versionRevision != null)
                message.versionRevision = object.versionRevision | 0;
            return message;
        };

        /**
         * Creates a plain object from a GetPTSLVersionResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {ptsl.GetPTSLVersionResponseBody} message GetPTSLVersionResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPTSLVersionResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                object.versionMinor = 0;
                object.versionRevision = 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                object.versionMinor = message.versionMinor;
            if (message.versionRevision != null && message.hasOwnProperty("versionRevision"))
                object.versionRevision = message.versionRevision;
            return object;
        };

        /**
         * Converts this GetPTSLVersionResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPTSLVersionResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetPTSLVersionResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetPTSLVersionResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetPTSLVersionResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetPTSLVersionResponseBody";
        };

        return GetPTSLVersionResponseBody;
    })();

    ptsl.GetPlaybackModeResponseBody = (function() {

        /**
         * Properties of a GetPlaybackModeResponseBody.
         * @memberof ptsl
         * @interface IGetPlaybackModeResponseBody
         * @property {Array.<ptsl.PlaybackMode>|null} [currentSettings] GetPlaybackModeResponseBody currentSettings
         * @property {Array.<ptsl.PlaybackMode>|null} [possibleSettings] GetPlaybackModeResponseBody possibleSettings
         */

        /**
         * Constructs a new GetPlaybackModeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetPlaybackMode response data.
         * @implements IGetPlaybackModeResponseBody
         * @constructor
         * @param {ptsl.IGetPlaybackModeResponseBody=} [properties] Properties to set
         */
        function GetPlaybackModeResponseBody(properties) {
            this.currentSettings = [];
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlaybackModeResponseBody currentSettings.
         * @member {Array.<ptsl.PlaybackMode>} currentSettings
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @instance
         */
        GetPlaybackModeResponseBody.prototype.currentSettings = $util.emptyArray;

        /**
         * GetPlaybackModeResponseBody possibleSettings.
         * @member {Array.<ptsl.PlaybackMode>} possibleSettings
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @instance
         */
        GetPlaybackModeResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetPlaybackModeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {ptsl.IGetPlaybackModeResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetPlaybackModeResponseBody} GetPlaybackModeResponseBody instance
         */
        GetPlaybackModeResponseBody.create = function create(properties) {
            return new GetPlaybackModeResponseBody(properties);
        };

        /**
         * Encodes the specified GetPlaybackModeResponseBody message. Does not implicitly {@link ptsl.GetPlaybackModeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {ptsl.IGetPlaybackModeResponseBody} message GetPlaybackModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlaybackModeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSettings != null && message.currentSettings.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.currentSettings.length; ++i)
                    writer.int32(message.currentSettings[i]);
                writer.ldelim();
            }
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetPlaybackModeResponseBody message, length delimited. Does not implicitly {@link ptsl.GetPlaybackModeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {ptsl.IGetPlaybackModeResponseBody} message GetPlaybackModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlaybackModeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlaybackModeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetPlaybackModeResponseBody} GetPlaybackModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlaybackModeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetPlaybackModeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.currentSettings && message.currentSettings.length))
                            message.currentSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.currentSettings.push(reader.int32());
                        } else
                            message.currentSettings.push(reader.int32());
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlaybackModeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetPlaybackModeResponseBody} GetPlaybackModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlaybackModeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlaybackModeResponseBody message.
         * @function verify
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlaybackModeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSettings != null && message.hasOwnProperty("currentSettings")) {
                if (!Array.isArray(message.currentSettings))
                    return "currentSettings: array expected";
                for (var i = 0; i < message.currentSettings.length; ++i)
                    switch (message.currentSettings[i]) {
                    default:
                        return "currentSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                        break;
                    }
            }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetPlaybackModeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetPlaybackModeResponseBody} GetPlaybackModeResponseBody
         */
        GetPlaybackModeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetPlaybackModeResponseBody)
                return object;
            var message = new $root.ptsl.GetPlaybackModeResponseBody();
            if (object.currentSettings) {
                if (!Array.isArray(object.currentSettings))
                    throw TypeError(".ptsl.GetPlaybackModeResponseBody.currentSettings: array expected");
                message.currentSettings = [];
                for (var i = 0; i < object.currentSettings.length; ++i)
                    switch (object.currentSettings[i]) {
                    default:
                        if (typeof object.currentSettings[i] === "number") {
                            message.currentSettings[i] = object.currentSettings[i];
                            break;
                        }
                    case "PMode_Unknown":
                    case 0:
                        message.currentSettings[i] = 0;
                        break;
                    case "PM_Normal":
                    case 1:
                        message.currentSettings[i] = 1;
                        break;
                    case "PMode_Normal":
                    case 1:
                        message.currentSettings[i] = 1;
                        break;
                    case "PM_Loop":
                    case 2:
                        message.currentSettings[i] = 2;
                        break;
                    case "PMode_Loop":
                    case 2:
                        message.currentSettings[i] = 2;
                        break;
                    case "PM_DynamicTransport":
                    case 3:
                        message.currentSettings[i] = 3;
                        break;
                    case "PMode_DynamicTransport":
                    case 3:
                        message.currentSettings[i] = 3;
                        break;
                    }
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetPlaybackModeResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "PMode_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "PM_Normal":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "PMode_Normal":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "PM_Loop":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "PMode_Loop":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "PM_DynamicTransport":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "PMode_DynamicTransport":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPlaybackModeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {ptsl.GetPlaybackModeResponseBody} message GetPlaybackModeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlaybackModeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.currentSettings = [];
                object.possibleSettings = [];
            }
            if (message.currentSettings && message.currentSettings.length) {
                object.currentSettings = [];
                for (var j = 0; j < message.currentSettings.length; ++j)
                    object.currentSettings[j] = options.enums === String ? $root.ptsl.PlaybackMode[message.currentSettings[j]] === undefined ? message.currentSettings[j] : $root.ptsl.PlaybackMode[message.currentSettings[j]] : message.currentSettings[j];
            }
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.PlaybackMode[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.PlaybackMode[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetPlaybackModeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlaybackModeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetPlaybackModeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetPlaybackModeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetPlaybackModeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetPlaybackModeResponseBody";
        };

        return GetPlaybackModeResponseBody;
    })();

    ptsl.GetRecordModeResponseBody = (function() {

        /**
         * Properties of a GetRecordModeResponseBody.
         * @memberof ptsl
         * @interface IGetRecordModeResponseBody
         * @property {ptsl.RecordMode|null} [currentSetting] GetRecordModeResponseBody currentSetting
         * @property {Array.<ptsl.RecordMode>|null} [possibleSettings] GetRecordModeResponseBody possibleSettings
         */

        /**
         * Constructs a new GetRecordModeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetRecordMode response data.
         * @implements IGetRecordModeResponseBody
         * @constructor
         * @param {ptsl.IGetRecordModeResponseBody=} [properties] Properties to set
         */
        function GetRecordModeResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRecordModeResponseBody currentSetting.
         * @member {ptsl.RecordMode} currentSetting
         * @memberof ptsl.GetRecordModeResponseBody
         * @instance
         */
        GetRecordModeResponseBody.prototype.currentSetting = 0;

        /**
         * GetRecordModeResponseBody possibleSettings.
         * @member {Array.<ptsl.RecordMode>} possibleSettings
         * @memberof ptsl.GetRecordModeResponseBody
         * @instance
         */
        GetRecordModeResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetRecordModeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {ptsl.IGetRecordModeResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetRecordModeResponseBody} GetRecordModeResponseBody instance
         */
        GetRecordModeResponseBody.create = function create(properties) {
            return new GetRecordModeResponseBody(properties);
        };

        /**
         * Encodes the specified GetRecordModeResponseBody message. Does not implicitly {@link ptsl.GetRecordModeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {ptsl.IGetRecordModeResponseBody} message GetRecordModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRecordModeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetRecordModeResponseBody message, length delimited. Does not implicitly {@link ptsl.GetRecordModeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {ptsl.IGetRecordModeResponseBody} message GetRecordModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRecordModeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRecordModeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetRecordModeResponseBody} GetRecordModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRecordModeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetRecordModeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRecordModeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetRecordModeResponseBody} GetRecordModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRecordModeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRecordModeResponseBody message.
         * @function verify
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRecordModeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetRecordModeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetRecordModeResponseBody} GetRecordModeResponseBody
         */
        GetRecordModeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetRecordModeResponseBody)
                return object;
            var message = new $root.ptsl.GetRecordModeResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "RMode_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "RM_Normal":
            case 0:
                message.currentSetting = 0;
                break;
            case "RMode_Normal":
            case 1:
                message.currentSetting = 1;
                break;
            case "RM_Loop":
            case 1:
                message.currentSetting = 1;
                break;
            case "RMode_Loop":
            case 2:
                message.currentSetting = 2;
                break;
            case "RM_Destructive":
            case 2:
                message.currentSetting = 2;
                break;
            case "RMode_Destructive":
            case 3:
                message.currentSetting = 3;
                break;
            case "RM_QuickPunch":
            case 3:
                message.currentSetting = 3;
                break;
            case "RMode_QuickPunch":
            case 4:
                message.currentSetting = 4;
                break;
            case "RM_TrackPunch":
            case 4:
                message.currentSetting = 4;
                break;
            case "RMode_TrackPunch":
            case 5:
                message.currentSetting = 5;
                break;
            case "RM_DestructivePunch":
            case 5:
                message.currentSetting = 5;
                break;
            case "RMode_DestructivePunch":
            case 6:
                message.currentSetting = 6;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetRecordModeResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "RMode_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "RM_Normal":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "RMode_Normal":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "RM_Loop":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "RMode_Loop":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "RM_Destructive":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "RMode_Destructive":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "RM_QuickPunch":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "RMode_QuickPunch":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "RM_TrackPunch":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "RMode_TrackPunch":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "RM_DestructivePunch":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "RMode_DestructivePunch":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRecordModeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {ptsl.GetRecordModeResponseBody} message GetRecordModeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRecordModeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "RMode_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.RecordMode[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.RecordMode[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.RecordMode[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.RecordMode[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetRecordModeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetRecordModeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRecordModeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetRecordModeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetRecordModeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetRecordModeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetRecordModeResponseBody";
        };

        return GetRecordModeResponseBody;
    })();

    /**
     * Types of the transport state.
     * Renamed to TransportState starting in Pro Tools 2025.06 (was TS_TransportState)
     * @name ptsl.TransportState
     * @enum {number}
     * @property {number} TState_Unknown=0 TState_Unknown value
     * @property {number} TS_TransportPlaying=1 * @deprecated ptsl::TransportState::TS_TransportPlaying is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportPlaying
     * @property {number} TState_TransportPlaying=1 TState_TransportPlaying value
     * @property {number} TS_TransportStopped=2 * @deprecated ptsl::TransportState::TS_TransportStopped is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportStopped
     * @property {number} TState_TransportStopped=2 TState_TransportStopped value
     * @property {number} TS_TransportRecording=3 * @deprecated ptsl::TransportState::TS_TransportRecording is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportRecording
     * @property {number} TState_TransportRecording=3 TState_TransportRecording value
     * @property {number} TS_TransportPlayingHalfSpeed=4 * @deprecated ptsl::TransportState::TS_TransportPlayingHalfSpeed is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportPlayingHalfSpeed
     * @property {number} TState_TransportPlayingHalfSpeed=4 TState_TransportPlayingHalfSpeed value
     * @property {number} TS_TransportRecordingHalfSpeed=5 * @deprecated ptsl::TransportState::TS_TransportRecordingHalfSpeed is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportRecordingHalfSpeed
     * @property {number} TState_TransportRecordingHalfSpeed=5 TState_TransportRecordingHalfSpeed value
     * @property {number} TS_TransportFastForward=6 * @deprecated ptsl::TransportState::TS_TransportFastForward is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportFastForward
     * @property {number} TState_TransportFastForward=6 TState_TransportFastForward value
     * @property {number} TS_TransportRewind=7 * @deprecated ptsl::TransportState::TS_TransportRewind is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportRewind
     * @property {number} TState_TransportRewind=7 TState_TransportRewind value
     * @property {number} TS_TransportScrub=8 * @deprecated ptsl::TransportState::TS_TransportScrub is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportScrub
     * @property {number} TState_TransportScrub=8 TState_TransportScrub value
     * @property {number} TS_TransportShuttle=9 * @deprecated ptsl::TransportState::TS_TransportShuttle is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportShuttle
     * @property {number} TState_TransportShuttle=9 TState_TransportShuttle value
     * @property {number} TS_TransportPrimed=10 * @deprecated ptsl::TransportState::TS_TransportPrimed is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportPrimed
     * @property {number} TState_TransportPrimed=10 TState_TransportPrimed value
     * @property {number} TS_TransportIsCueing=11 * @deprecated ptsl::TransportState::TS_TransportIsCueing is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportIsCueing
     * @property {number} TState_TransportIsCueing=11 TState_TransportIsCueing value
     * @property {number} TS_TransportIsCued=12 * @deprecated ptsl::TransportState::TS_TransportIsCued is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportIsCued
     * @property {number} TState_TransportIsCued=12 TState_TransportIsCued value
     * @property {number} TS_TransportIsCuedForPreview=13 * @deprecated ptsl::TransportState::TS_TransportIsCuedForPreview is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportIsCuedForPreview
     * @property {number} TState_TransportIsCuedForPreview=13 TState_TransportIsCuedForPreview value
     * @property {number} TS_TransportIsStopping=14 * @deprecated ptsl::TransportState::TS_TransportIsStopping is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportIsStopping
     * @property {number} TState_TransportIsStopping=14 TState_TransportIsStopping value
     * @property {number} TS_TransportIsPreviewing=15 * @deprecated ptsl::TransportState::TS_TransportIsPreviewing is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TransportState::TState_TransportIsPreviewing
     * @property {number} TState_TransportIsPreviewing=15 TState_TransportIsPreviewing value
     */
    ptsl.TransportState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TState_Unknown"] = 0;
        values[valuesById[1] = "TS_TransportPlaying"] = 1;
        values["TState_TransportPlaying"] = 1;
        values[valuesById[2] = "TS_TransportStopped"] = 2;
        values["TState_TransportStopped"] = 2;
        values[valuesById[3] = "TS_TransportRecording"] = 3;
        values["TState_TransportRecording"] = 3;
        values[valuesById[4] = "TS_TransportPlayingHalfSpeed"] = 4;
        values["TState_TransportPlayingHalfSpeed"] = 4;
        values[valuesById[5] = "TS_TransportRecordingHalfSpeed"] = 5;
        values["TState_TransportRecordingHalfSpeed"] = 5;
        values[valuesById[6] = "TS_TransportFastForward"] = 6;
        values["TState_TransportFastForward"] = 6;
        values[valuesById[7] = "TS_TransportRewind"] = 7;
        values["TState_TransportRewind"] = 7;
        values[valuesById[8] = "TS_TransportScrub"] = 8;
        values["TState_TransportScrub"] = 8;
        values[valuesById[9] = "TS_TransportShuttle"] = 9;
        values["TState_TransportShuttle"] = 9;
        values[valuesById[10] = "TS_TransportPrimed"] = 10;
        values["TState_TransportPrimed"] = 10;
        values[valuesById[11] = "TS_TransportIsCueing"] = 11;
        values["TState_TransportIsCueing"] = 11;
        values[valuesById[12] = "TS_TransportIsCued"] = 12;
        values["TState_TransportIsCued"] = 12;
        values[valuesById[13] = "TS_TransportIsCuedForPreview"] = 13;
        values["TState_TransportIsCuedForPreview"] = 13;
        values[valuesById[14] = "TS_TransportIsStopping"] = 14;
        values["TState_TransportIsStopping"] = 14;
        values[valuesById[15] = "TS_TransportIsPreviewing"] = 15;
        values["TState_TransportIsPreviewing"] = 15;
        return values;
    })();

    ptsl.GetTransportStateResponseBody = (function() {

        /**
         * Properties of a GetTransportStateResponseBody.
         * @memberof ptsl
         * @interface IGetTransportStateResponseBody
         * @property {ptsl.TransportState|null} [currentSetting] GetTransportStateResponseBody currentSetting
         * @property {Array.<ptsl.TransportState>|null} [possibleSettings] GetTransportStateResponseBody possibleSettings
         */

        /**
         * Constructs a new GetTransportStateResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTransportState response data.
         * @implements IGetTransportStateResponseBody
         * @constructor
         * @param {ptsl.IGetTransportStateResponseBody=} [properties] Properties to set
         */
        function GetTransportStateResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTransportStateResponseBody currentSetting.
         * @member {ptsl.TransportState} currentSetting
         * @memberof ptsl.GetTransportStateResponseBody
         * @instance
         */
        GetTransportStateResponseBody.prototype.currentSetting = 0;

        /**
         * GetTransportStateResponseBody possibleSettings.
         * @member {Array.<ptsl.TransportState>} possibleSettings
         * @memberof ptsl.GetTransportStateResponseBody
         * @instance
         */
        GetTransportStateResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetTransportStateResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {ptsl.IGetTransportStateResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetTransportStateResponseBody} GetTransportStateResponseBody instance
         */
        GetTransportStateResponseBody.create = function create(properties) {
            return new GetTransportStateResponseBody(properties);
        };

        /**
         * Encodes the specified GetTransportStateResponseBody message. Does not implicitly {@link ptsl.GetTransportStateResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {ptsl.IGetTransportStateResponseBody} message GetTransportStateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransportStateResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetTransportStateResponseBody message, length delimited. Does not implicitly {@link ptsl.GetTransportStateResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {ptsl.IGetTransportStateResponseBody} message GetTransportStateResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransportStateResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTransportStateResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTransportStateResponseBody} GetTransportStateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransportStateResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTransportStateResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTransportStateResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTransportStateResponseBody} GetTransportStateResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransportStateResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTransportStateResponseBody message.
         * @function verify
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTransportStateResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                    case 8:
                    case 9:
                    case 9:
                    case 10:
                    case 10:
                    case 11:
                    case 11:
                    case 12:
                    case 12:
                    case 13:
                    case 13:
                    case 14:
                    case 14:
                    case 15:
                    case 15:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetTransportStateResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTransportStateResponseBody} GetTransportStateResponseBody
         */
        GetTransportStateResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTransportStateResponseBody)
                return object;
            var message = new $root.ptsl.GetTransportStateResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "TState_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "TS_TransportPlaying":
            case 1:
                message.currentSetting = 1;
                break;
            case "TState_TransportPlaying":
            case 1:
                message.currentSetting = 1;
                break;
            case "TS_TransportStopped":
            case 2:
                message.currentSetting = 2;
                break;
            case "TState_TransportStopped":
            case 2:
                message.currentSetting = 2;
                break;
            case "TS_TransportRecording":
            case 3:
                message.currentSetting = 3;
                break;
            case "TState_TransportRecording":
            case 3:
                message.currentSetting = 3;
                break;
            case "TS_TransportPlayingHalfSpeed":
            case 4:
                message.currentSetting = 4;
                break;
            case "TState_TransportPlayingHalfSpeed":
            case 4:
                message.currentSetting = 4;
                break;
            case "TS_TransportRecordingHalfSpeed":
            case 5:
                message.currentSetting = 5;
                break;
            case "TState_TransportRecordingHalfSpeed":
            case 5:
                message.currentSetting = 5;
                break;
            case "TS_TransportFastForward":
            case 6:
                message.currentSetting = 6;
                break;
            case "TState_TransportFastForward":
            case 6:
                message.currentSetting = 6;
                break;
            case "TS_TransportRewind":
            case 7:
                message.currentSetting = 7;
                break;
            case "TState_TransportRewind":
            case 7:
                message.currentSetting = 7;
                break;
            case "TS_TransportScrub":
            case 8:
                message.currentSetting = 8;
                break;
            case "TState_TransportScrub":
            case 8:
                message.currentSetting = 8;
                break;
            case "TS_TransportShuttle":
            case 9:
                message.currentSetting = 9;
                break;
            case "TState_TransportShuttle":
            case 9:
                message.currentSetting = 9;
                break;
            case "TS_TransportPrimed":
            case 10:
                message.currentSetting = 10;
                break;
            case "TState_TransportPrimed":
            case 10:
                message.currentSetting = 10;
                break;
            case "TS_TransportIsCueing":
            case 11:
                message.currentSetting = 11;
                break;
            case "TState_TransportIsCueing":
            case 11:
                message.currentSetting = 11;
                break;
            case "TS_TransportIsCued":
            case 12:
                message.currentSetting = 12;
                break;
            case "TState_TransportIsCued":
            case 12:
                message.currentSetting = 12;
                break;
            case "TS_TransportIsCuedForPreview":
            case 13:
                message.currentSetting = 13;
                break;
            case "TState_TransportIsCuedForPreview":
            case 13:
                message.currentSetting = 13;
                break;
            case "TS_TransportIsStopping":
            case 14:
                message.currentSetting = 14;
                break;
            case "TState_TransportIsStopping":
            case 14:
                message.currentSetting = 14;
                break;
            case "TS_TransportIsPreviewing":
            case 15:
                message.currentSetting = 15;
                break;
            case "TState_TransportIsPreviewing":
            case 15:
                message.currentSetting = 15;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetTransportStateResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "TState_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "TS_TransportPlaying":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "TState_TransportPlaying":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "TS_TransportStopped":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "TState_TransportStopped":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "TS_TransportRecording":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "TState_TransportRecording":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "TS_TransportPlayingHalfSpeed":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "TState_TransportPlayingHalfSpeed":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "TS_TransportRecordingHalfSpeed":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "TState_TransportRecordingHalfSpeed":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "TS_TransportFastForward":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "TState_TransportFastForward":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "TS_TransportRewind":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "TState_TransportRewind":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "TS_TransportScrub":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "TState_TransportScrub":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "TS_TransportShuttle":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "TState_TransportShuttle":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "TS_TransportPrimed":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "TState_TransportPrimed":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "TS_TransportIsCueing":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    case "TState_TransportIsCueing":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    case "TS_TransportIsCued":
                    case 12:
                        message.possibleSettings[i] = 12;
                        break;
                    case "TState_TransportIsCued":
                    case 12:
                        message.possibleSettings[i] = 12;
                        break;
                    case "TS_TransportIsCuedForPreview":
                    case 13:
                        message.possibleSettings[i] = 13;
                        break;
                    case "TState_TransportIsCuedForPreview":
                    case 13:
                        message.possibleSettings[i] = 13;
                        break;
                    case "TS_TransportIsStopping":
                    case 14:
                        message.possibleSettings[i] = 14;
                        break;
                    case "TState_TransportIsStopping":
                    case 14:
                        message.possibleSettings[i] = 14;
                        break;
                    case "TS_TransportIsPreviewing":
                    case 15:
                        message.possibleSettings[i] = 15;
                        break;
                    case "TState_TransportIsPreviewing":
                    case 15:
                        message.possibleSettings[i] = 15;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTransportStateResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {ptsl.GetTransportStateResponseBody} message GetTransportStateResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTransportStateResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "TState_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.TransportState[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.TransportState[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.TransportState[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.TransportState[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetTransportStateResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTransportStateResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTransportStateResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTransportStateResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetTransportStateResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTransportStateResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTransportStateResponseBody";
        };

        return GetTransportStateResponseBody;
    })();

    ptsl.GetTransportArmedResponseBody = (function() {

        /**
         * Properties of a GetTransportArmedResponseBody.
         * @memberof ptsl
         * @interface IGetTransportArmedResponseBody
         * @property {boolean|null} [isTransportArmed] GetTransportArmedResponseBody isTransportArmed
         */

        /**
         * Constructs a new GetTransportArmedResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTransportArmed response data.
         * @implements IGetTransportArmedResponseBody
         * @constructor
         * @param {ptsl.IGetTransportArmedResponseBody=} [properties] Properties to set
         */
        function GetTransportArmedResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTransportArmedResponseBody isTransportArmed.
         * @member {boolean} isTransportArmed
         * @memberof ptsl.GetTransportArmedResponseBody
         * @instance
         */
        GetTransportArmedResponseBody.prototype.isTransportArmed = false;

        /**
         * Creates a new GetTransportArmedResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {ptsl.IGetTransportArmedResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetTransportArmedResponseBody} GetTransportArmedResponseBody instance
         */
        GetTransportArmedResponseBody.create = function create(properties) {
            return new GetTransportArmedResponseBody(properties);
        };

        /**
         * Encodes the specified GetTransportArmedResponseBody message. Does not implicitly {@link ptsl.GetTransportArmedResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {ptsl.IGetTransportArmedResponseBody} message GetTransportArmedResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransportArmedResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isTransportArmed != null && Object.hasOwnProperty.call(message, "isTransportArmed"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isTransportArmed);
            return writer;
        };

        /**
         * Encodes the specified GetTransportArmedResponseBody message, length delimited. Does not implicitly {@link ptsl.GetTransportArmedResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {ptsl.IGetTransportArmedResponseBody} message GetTransportArmedResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransportArmedResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTransportArmedResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTransportArmedResponseBody} GetTransportArmedResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransportArmedResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTransportArmedResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.isTransportArmed = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTransportArmedResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTransportArmedResponseBody} GetTransportArmedResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransportArmedResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTransportArmedResponseBody message.
         * @function verify
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTransportArmedResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isTransportArmed != null && message.hasOwnProperty("isTransportArmed"))
                if (typeof message.isTransportArmed !== "boolean")
                    return "isTransportArmed: boolean expected";
            return null;
        };

        /**
         * Creates a GetTransportArmedResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTransportArmedResponseBody} GetTransportArmedResponseBody
         */
        GetTransportArmedResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTransportArmedResponseBody)
                return object;
            var message = new $root.ptsl.GetTransportArmedResponseBody();
            if (object.isTransportArmed != null)
                message.isTransportArmed = Boolean(object.isTransportArmed);
            return message;
        };

        /**
         * Creates a plain object from a GetTransportArmedResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {ptsl.GetTransportArmedResponseBody} message GetTransportArmedResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTransportArmedResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isTransportArmed = false;
            if (message.isTransportArmed != null && message.hasOwnProperty("isTransportArmed"))
                object.isTransportArmed = message.isTransportArmed;
            return object;
        };

        /**
         * Converts this GetTransportArmedResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTransportArmedResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTransportArmedResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTransportArmedResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetTransportArmedResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTransportArmedResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTransportArmedResponseBody";
        };

        return GetTransportArmedResponseBody;
    })();

    ptsl.ClearMemoryLocationRequestBody = (function() {

        /**
         * Properties of a ClearMemoryLocationRequestBody.
         * @memberof ptsl
         * @interface IClearMemoryLocationRequestBody
         * @property {Array.<number>|null} [locationList] * List of locations that needs to be cleared.
         */

        /**
         * Constructs a new ClearMemoryLocationRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ClearMemoryLocation request data.
         * @implements IClearMemoryLocationRequestBody
         * @constructor
         * @param {ptsl.IClearMemoryLocationRequestBody=} [properties] Properties to set
         */
        function ClearMemoryLocationRequestBody(properties) {
            this.locationList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of locations that needs to be cleared.
         * @member {Array.<number>} locationList
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @instance
         */
        ClearMemoryLocationRequestBody.prototype.locationList = $util.emptyArray;

        /**
         * Creates a new ClearMemoryLocationRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {ptsl.IClearMemoryLocationRequestBody=} [properties] Properties to set
         * @returns {ptsl.ClearMemoryLocationRequestBody} ClearMemoryLocationRequestBody instance
         */
        ClearMemoryLocationRequestBody.create = function create(properties) {
            return new ClearMemoryLocationRequestBody(properties);
        };

        /**
         * Encodes the specified ClearMemoryLocationRequestBody message. Does not implicitly {@link ptsl.ClearMemoryLocationRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {ptsl.IClearMemoryLocationRequestBody} message ClearMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearMemoryLocationRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.locationList != null && message.locationList.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.locationList.length; ++i)
                    writer.int32(message.locationList[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ClearMemoryLocationRequestBody message, length delimited. Does not implicitly {@link ptsl.ClearMemoryLocationRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {ptsl.IClearMemoryLocationRequestBody} message ClearMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearMemoryLocationRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClearMemoryLocationRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ClearMemoryLocationRequestBody} ClearMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearMemoryLocationRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ClearMemoryLocationRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.locationList && message.locationList.length))
                            message.locationList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.locationList.push(reader.int32());
                        } else
                            message.locationList.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClearMemoryLocationRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ClearMemoryLocationRequestBody} ClearMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearMemoryLocationRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClearMemoryLocationRequestBody message.
         * @function verify
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearMemoryLocationRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.locationList != null && message.hasOwnProperty("locationList")) {
                if (!Array.isArray(message.locationList))
                    return "locationList: array expected";
                for (var i = 0; i < message.locationList.length; ++i)
                    if (!$util.isInteger(message.locationList[i]))
                        return "locationList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ClearMemoryLocationRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ClearMemoryLocationRequestBody} ClearMemoryLocationRequestBody
         */
        ClearMemoryLocationRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ClearMemoryLocationRequestBody)
                return object;
            var message = new $root.ptsl.ClearMemoryLocationRequestBody();
            if (object.locationList) {
                if (!Array.isArray(object.locationList))
                    throw TypeError(".ptsl.ClearMemoryLocationRequestBody.locationList: array expected");
                message.locationList = [];
                for (var i = 0; i < object.locationList.length; ++i)
                    message.locationList[i] = object.locationList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClearMemoryLocationRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {ptsl.ClearMemoryLocationRequestBody} message ClearMemoryLocationRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearMemoryLocationRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.locationList = [];
            if (message.locationList && message.locationList.length) {
                object.locationList = [];
                for (var j = 0; j < message.locationList.length; ++j)
                    object.locationList[j] = message.locationList[j];
            }
            return object;
        };

        /**
         * Converts this ClearMemoryLocationRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearMemoryLocationRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClearMemoryLocationRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ClearMemoryLocationRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClearMemoryLocationRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ClearMemoryLocationRequestBody";
        };

        return ClearMemoryLocationRequestBody;
    })();

    ptsl.ClearMemoryLocationResponseBody = (function() {

        /**
         * Properties of a ClearMemoryLocationResponseBody.
         * @memberof ptsl
         * @interface IClearMemoryLocationResponseBody
         * @property {number|null} [successCount] * Number of succeeded cleared memory locations.
         * @property {number|null} [failureCount] * Number of memory locations that were not cleared.
         * @property {Array.<number>|null} [failureList] * List of memory locations that were not cleared.
         */

        /**
         * Constructs a new ClearMemoryLocationResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes ClearMemoryLocation response data.
         * @implements IClearMemoryLocationResponseBody
         * @constructor
         * @param {ptsl.IClearMemoryLocationResponseBody=} [properties] Properties to set
         */
        function ClearMemoryLocationResponseBody(properties) {
            this.failureList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Number of succeeded cleared memory locations.
         * @member {number} successCount
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @instance
         */
        ClearMemoryLocationResponseBody.prototype.successCount = 0;

        /**
         * * Number of memory locations that were not cleared.
         * @member {number} failureCount
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @instance
         */
        ClearMemoryLocationResponseBody.prototype.failureCount = 0;

        /**
         * * List of memory locations that were not cleared.
         * @member {Array.<number>} failureList
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @instance
         */
        ClearMemoryLocationResponseBody.prototype.failureList = $util.emptyArray;

        /**
         * Creates a new ClearMemoryLocationResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {ptsl.IClearMemoryLocationResponseBody=} [properties] Properties to set
         * @returns {ptsl.ClearMemoryLocationResponseBody} ClearMemoryLocationResponseBody instance
         */
        ClearMemoryLocationResponseBody.create = function create(properties) {
            return new ClearMemoryLocationResponseBody(properties);
        };

        /**
         * Encodes the specified ClearMemoryLocationResponseBody message. Does not implicitly {@link ptsl.ClearMemoryLocationResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {ptsl.IClearMemoryLocationResponseBody} message ClearMemoryLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearMemoryLocationResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.successCount != null && Object.hasOwnProperty.call(message, "successCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.successCount);
            if (message.failureCount != null && Object.hasOwnProperty.call(message, "failureCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.failureCount);
            if (message.failureList != null && message.failureList.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.failureList.length; ++i)
                    writer.int32(message.failureList[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ClearMemoryLocationResponseBody message, length delimited. Does not implicitly {@link ptsl.ClearMemoryLocationResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {ptsl.IClearMemoryLocationResponseBody} message ClearMemoryLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearMemoryLocationResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClearMemoryLocationResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ClearMemoryLocationResponseBody} ClearMemoryLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearMemoryLocationResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ClearMemoryLocationResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.successCount = reader.int32();
                        break;
                    }
                case 2: {
                        message.failureCount = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.failureList && message.failureList.length))
                            message.failureList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.failureList.push(reader.int32());
                        } else
                            message.failureList.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClearMemoryLocationResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ClearMemoryLocationResponseBody} ClearMemoryLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearMemoryLocationResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClearMemoryLocationResponseBody message.
         * @function verify
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearMemoryLocationResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.successCount != null && message.hasOwnProperty("successCount"))
                if (!$util.isInteger(message.successCount))
                    return "successCount: integer expected";
            if (message.failureCount != null && message.hasOwnProperty("failureCount"))
                if (!$util.isInteger(message.failureCount))
                    return "failureCount: integer expected";
            if (message.failureList != null && message.hasOwnProperty("failureList")) {
                if (!Array.isArray(message.failureList))
                    return "failureList: array expected";
                for (var i = 0; i < message.failureList.length; ++i)
                    if (!$util.isInteger(message.failureList[i]))
                        return "failureList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ClearMemoryLocationResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ClearMemoryLocationResponseBody} ClearMemoryLocationResponseBody
         */
        ClearMemoryLocationResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ClearMemoryLocationResponseBody)
                return object;
            var message = new $root.ptsl.ClearMemoryLocationResponseBody();
            if (object.successCount != null)
                message.successCount = object.successCount | 0;
            if (object.failureCount != null)
                message.failureCount = object.failureCount | 0;
            if (object.failureList) {
                if (!Array.isArray(object.failureList))
                    throw TypeError(".ptsl.ClearMemoryLocationResponseBody.failureList: array expected");
                message.failureList = [];
                for (var i = 0; i < object.failureList.length; ++i)
                    message.failureList[i] = object.failureList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClearMemoryLocationResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {ptsl.ClearMemoryLocationResponseBody} message ClearMemoryLocationResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearMemoryLocationResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.failureList = [];
            if (options.defaults) {
                object.successCount = 0;
                object.failureCount = 0;
            }
            if (message.successCount != null && message.hasOwnProperty("successCount"))
                object.successCount = message.successCount;
            if (message.failureCount != null && message.hasOwnProperty("failureCount"))
                object.failureCount = message.failureCount;
            if (message.failureList && message.failureList.length) {
                object.failureList = [];
                for (var j = 0; j < message.failureList.length; ++j)
                    object.failureList[j] = message.failureList[j];
            }
            return object;
        };

        /**
         * Converts this ClearMemoryLocationResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearMemoryLocationResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClearMemoryLocationResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ClearMemoryLocationResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClearMemoryLocationResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ClearMemoryLocationResponseBody";
        };

        return ClearMemoryLocationResponseBody;
    })();

    /**
     * Clips locations.
     * Renamed to ClipLocation starting in Pro Tools 2025.06 (was CL_ClipLocation)
     * @name ptsl.ClipLocation
     * @enum {number}
     * @property {number} CLocation_Unknown=0 CLocation_Unknown value
     * @property {number} CL_ClipsList=1 * @deprecated ptsl::ClipLocation::CL_ClipsList is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ClipLocation::CLocation_ClipsList
     * @property {number} CLocation_ClipsList=1 CLocation_ClipsList value
     * @property {number} CL_Timeline=2 * @deprecated ptsl::ClipLocation::CL_Timeline is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::ClipLocation::CLocation_Timeline
     * @property {number} CLocation_Timeline=2 CLocation_Timeline value
     */
    ptsl.ClipLocation = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CLocation_Unknown"] = 0;
        values[valuesById[1] = "CL_ClipsList"] = 1;
        values["CLocation_ClipsList"] = 1;
        values[valuesById[2] = "CL_Timeline"] = 2;
        values["CLocation_Timeline"] = 2;
        return values;
    })();

    ptsl.RenameSelectedClipRequestBody = (function() {

        /**
         * Properties of a RenameSelectedClipRequestBody.
         * @memberof ptsl
         * @interface IRenameSelectedClipRequestBody
         * @property {ptsl.ClipLocation|null} [clipLocation] RenameSelectedClipRequestBody clipLocation
         * @property {string|null} [newName] RenameSelectedClipRequestBody newName
         * @property {boolean|null} [renameFile] RenameSelectedClipRequestBody renameFile
         */

        /**
         * Constructs a new RenameSelectedClipRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes RenameSelectedClip request data.
         * @implements IRenameSelectedClipRequestBody
         * @constructor
         * @param {ptsl.IRenameSelectedClipRequestBody=} [properties] Properties to set
         */
        function RenameSelectedClipRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameSelectedClipRequestBody clipLocation.
         * @member {ptsl.ClipLocation} clipLocation
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @instance
         */
        RenameSelectedClipRequestBody.prototype.clipLocation = 0;

        /**
         * RenameSelectedClipRequestBody newName.
         * @member {string} newName
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @instance
         */
        RenameSelectedClipRequestBody.prototype.newName = "";

        /**
         * RenameSelectedClipRequestBody renameFile.
         * @member {boolean} renameFile
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @instance
         */
        RenameSelectedClipRequestBody.prototype.renameFile = false;

        /**
         * Creates a new RenameSelectedClipRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {ptsl.IRenameSelectedClipRequestBody=} [properties] Properties to set
         * @returns {ptsl.RenameSelectedClipRequestBody} RenameSelectedClipRequestBody instance
         */
        RenameSelectedClipRequestBody.create = function create(properties) {
            return new RenameSelectedClipRequestBody(properties);
        };

        /**
         * Encodes the specified RenameSelectedClipRequestBody message. Does not implicitly {@link ptsl.RenameSelectedClipRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {ptsl.IRenameSelectedClipRequestBody} message RenameSelectedClipRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameSelectedClipRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clipLocation != null && Object.hasOwnProperty.call(message, "clipLocation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clipLocation);
            if (message.newName != null && Object.hasOwnProperty.call(message, "newName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.newName);
            if (message.renameFile != null && Object.hasOwnProperty.call(message, "renameFile"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.renameFile);
            return writer;
        };

        /**
         * Encodes the specified RenameSelectedClipRequestBody message, length delimited. Does not implicitly {@link ptsl.RenameSelectedClipRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {ptsl.IRenameSelectedClipRequestBody} message RenameSelectedClipRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameSelectedClipRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameSelectedClipRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RenameSelectedClipRequestBody} RenameSelectedClipRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameSelectedClipRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RenameSelectedClipRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.clipLocation = reader.int32();
                        break;
                    }
                case 2: {
                        message.newName = reader.string();
                        break;
                    }
                case 3: {
                        message.renameFile = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RenameSelectedClipRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RenameSelectedClipRequestBody} RenameSelectedClipRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameSelectedClipRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameSelectedClipRequestBody message.
         * @function verify
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameSelectedClipRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clipLocation != null && message.hasOwnProperty("clipLocation"))
                switch (message.clipLocation) {
                default:
                    return "clipLocation: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                    break;
                }
            if (message.newName != null && message.hasOwnProperty("newName"))
                if (!$util.isString(message.newName))
                    return "newName: string expected";
            if (message.renameFile != null && message.hasOwnProperty("renameFile"))
                if (typeof message.renameFile !== "boolean")
                    return "renameFile: boolean expected";
            return null;
        };

        /**
         * Creates a RenameSelectedClipRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RenameSelectedClipRequestBody} RenameSelectedClipRequestBody
         */
        RenameSelectedClipRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RenameSelectedClipRequestBody)
                return object;
            var message = new $root.ptsl.RenameSelectedClipRequestBody();
            switch (object.clipLocation) {
            default:
                if (typeof object.clipLocation === "number") {
                    message.clipLocation = object.clipLocation;
                    break;
                }
                break;
            case "CLocation_Unknown":
            case 0:
                message.clipLocation = 0;
                break;
            case "CL_ClipsList":
            case 1:
                message.clipLocation = 1;
                break;
            case "CLocation_ClipsList":
            case 1:
                message.clipLocation = 1;
                break;
            case "CL_Timeline":
            case 2:
                message.clipLocation = 2;
                break;
            case "CLocation_Timeline":
            case 2:
                message.clipLocation = 2;
                break;
            }
            if (object.newName != null)
                message.newName = String(object.newName);
            if (object.renameFile != null)
                message.renameFile = Boolean(object.renameFile);
            return message;
        };

        /**
         * Creates a plain object from a RenameSelectedClipRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {ptsl.RenameSelectedClipRequestBody} message RenameSelectedClipRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameSelectedClipRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.clipLocation = options.enums === String ? "CLocation_Unknown" : 0;
                object.newName = "";
                object.renameFile = false;
            }
            if (message.clipLocation != null && message.hasOwnProperty("clipLocation"))
                object.clipLocation = options.enums === String ? $root.ptsl.ClipLocation[message.clipLocation] === undefined ? message.clipLocation : $root.ptsl.ClipLocation[message.clipLocation] : message.clipLocation;
            if (message.newName != null && message.hasOwnProperty("newName"))
                object.newName = message.newName;
            if (message.renameFile != null && message.hasOwnProperty("renameFile"))
                object.renameFile = message.renameFile;
            return object;
        };

        /**
         * Converts this RenameSelectedClipRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameSelectedClipRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RenameSelectedClipRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RenameSelectedClipRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RenameSelectedClipRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RenameSelectedClipRequestBody";
        };

        return RenameSelectedClipRequestBody;
    })();

    ptsl.RenameTargetClipRequestBody = (function() {

        /**
         * Properties of a RenameTargetClipRequestBody.
         * @memberof ptsl
         * @interface IRenameTargetClipRequestBody
         * @property {string|null} [clipName] RenameTargetClipRequestBody clipName
         * @property {string|null} [newName] RenameTargetClipRequestBody newName
         * @property {boolean|null} [renameFile] RenameTargetClipRequestBody renameFile
         */

        /**
         * Constructs a new RenameTargetClipRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes RenameTargetClip request data.
         * @implements IRenameTargetClipRequestBody
         * @constructor
         * @param {ptsl.IRenameTargetClipRequestBody=} [properties] Properties to set
         */
        function RenameTargetClipRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameTargetClipRequestBody clipName.
         * @member {string} clipName
         * @memberof ptsl.RenameTargetClipRequestBody
         * @instance
         */
        RenameTargetClipRequestBody.prototype.clipName = "";

        /**
         * RenameTargetClipRequestBody newName.
         * @member {string} newName
         * @memberof ptsl.RenameTargetClipRequestBody
         * @instance
         */
        RenameTargetClipRequestBody.prototype.newName = "";

        /**
         * RenameTargetClipRequestBody renameFile.
         * @member {boolean} renameFile
         * @memberof ptsl.RenameTargetClipRequestBody
         * @instance
         */
        RenameTargetClipRequestBody.prototype.renameFile = false;

        /**
         * Creates a new RenameTargetClipRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {ptsl.IRenameTargetClipRequestBody=} [properties] Properties to set
         * @returns {ptsl.RenameTargetClipRequestBody} RenameTargetClipRequestBody instance
         */
        RenameTargetClipRequestBody.create = function create(properties) {
            return new RenameTargetClipRequestBody(properties);
        };

        /**
         * Encodes the specified RenameTargetClipRequestBody message. Does not implicitly {@link ptsl.RenameTargetClipRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {ptsl.IRenameTargetClipRequestBody} message RenameTargetClipRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameTargetClipRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clipName != null && Object.hasOwnProperty.call(message, "clipName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clipName);
            if (message.newName != null && Object.hasOwnProperty.call(message, "newName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.newName);
            if (message.renameFile != null && Object.hasOwnProperty.call(message, "renameFile"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.renameFile);
            return writer;
        };

        /**
         * Encodes the specified RenameTargetClipRequestBody message, length delimited. Does not implicitly {@link ptsl.RenameTargetClipRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {ptsl.IRenameTargetClipRequestBody} message RenameTargetClipRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameTargetClipRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameTargetClipRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RenameTargetClipRequestBody} RenameTargetClipRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameTargetClipRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RenameTargetClipRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.clipName = reader.string();
                        break;
                    }
                case 2: {
                        message.newName = reader.string();
                        break;
                    }
                case 3: {
                        message.renameFile = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RenameTargetClipRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RenameTargetClipRequestBody} RenameTargetClipRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameTargetClipRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameTargetClipRequestBody message.
         * @function verify
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameTargetClipRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clipName != null && message.hasOwnProperty("clipName"))
                if (!$util.isString(message.clipName))
                    return "clipName: string expected";
            if (message.newName != null && message.hasOwnProperty("newName"))
                if (!$util.isString(message.newName))
                    return "newName: string expected";
            if (message.renameFile != null && message.hasOwnProperty("renameFile"))
                if (typeof message.renameFile !== "boolean")
                    return "renameFile: boolean expected";
            return null;
        };

        /**
         * Creates a RenameTargetClipRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RenameTargetClipRequestBody} RenameTargetClipRequestBody
         */
        RenameTargetClipRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RenameTargetClipRequestBody)
                return object;
            var message = new $root.ptsl.RenameTargetClipRequestBody();
            if (object.clipName != null)
                message.clipName = String(object.clipName);
            if (object.newName != null)
                message.newName = String(object.newName);
            if (object.renameFile != null)
                message.renameFile = Boolean(object.renameFile);
            return message;
        };

        /**
         * Creates a plain object from a RenameTargetClipRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {ptsl.RenameTargetClipRequestBody} message RenameTargetClipRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameTargetClipRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.clipName = "";
                object.newName = "";
                object.renameFile = false;
            }
            if (message.clipName != null && message.hasOwnProperty("clipName"))
                object.clipName = message.clipName;
            if (message.newName != null && message.hasOwnProperty("newName"))
                object.newName = message.newName;
            if (message.renameFile != null && message.hasOwnProperty("renameFile"))
                object.renameFile = message.renameFile;
            return object;
        };

        /**
         * Converts this RenameTargetClipRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RenameTargetClipRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameTargetClipRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RenameTargetClipRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RenameTargetClipRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RenameTargetClipRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RenameTargetClipRequestBody";
        };

        return RenameTargetClipRequestBody;
    })();

    /**
     * Type of time properties.
     * @name ptsl.TimeProperties
     * @enum {number}
     * @property {number} TProperties_Unknown=0 TProperties_Unknown value
     * @property {number} TP_Marker=1 * @deprecated ptsl::TimeProperties::TP_Marker is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimeProperties::TProperties_Marker
     * @property {number} TProperties_Marker=1 TProperties_Marker value
     * @property {number} TP_Selection=2 * @deprecated ptsl::TimeProperties::TP_Selection is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimeProperties::TProperties_Selection
     * @property {number} TProperties_Selection=2 TProperties_Selection value
     * @property {number} TP_None=3 * @deprecated ptsl::TimeProperties::TP_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimeProperties::TProperties_None
     * @property {number} TProperties_None=3 TProperties_None value
     */
    ptsl.TimeProperties = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TProperties_Unknown"] = 0;
        values[valuesById[1] = "TP_Marker"] = 1;
        values["TProperties_Marker"] = 1;
        values[valuesById[2] = "TP_Selection"] = 2;
        values["TProperties_Selection"] = 2;
        values[valuesById[3] = "TP_None"] = 3;
        values["TProperties_None"] = 3;
        return values;
    })();

    /**
     * Type of memory location reference.
     * @name ptsl.MemoryLocationReference
     * @enum {number}
     * @property {number} MLReference_Unknown=0 MLReference_Unknown value
     * @property {number} MLR_BarBeat=1 * @deprecated ptsl::MemoryLocationReference::MLR_BarBeat is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MemoryLocationReference::MLReference_BarBeat
     * @property {number} MLReference_BarBeat=1 MLReference_BarBeat value
     * @property {number} MLR_Absolute=2 * @deprecated ptsl::MemoryLocationReference::MLR_Absolute is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MemoryLocationReference::MLReference_Absolute
     * @property {number} MLReference_Absolute=2 MLReference_Absolute value
     * @property {number} MLR_FollowTrackTimebase=3 * @deprecated ptsl::MemoryLocationReference::MLR_FollowTrackTimebase is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MemoryLocationReference::MLReference_FollowTrackTimebase
     * @property {number} MLReference_FollowTrackTimebase=3 MLReference_FollowTrackTimebase value
     */
    ptsl.MemoryLocationReference = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MLReference_Unknown"] = 0;
        values[valuesById[1] = "MLR_BarBeat"] = 1;
        values["MLReference_BarBeat"] = 1;
        values[valuesById[2] = "MLR_Absolute"] = 2;
        values["MLReference_Absolute"] = 2;
        values[valuesById[3] = "MLR_FollowTrackTimebase"] = 3;
        values["MLReference_FollowTrackTimebase"] = 3;
        return values;
    })();

    /**
     * Type of marker location.
     * @name ptsl.MarkerLocation
     * @enum {number}
     * @property {number} MLC_Unknown=0 * @deprecated ptsl::MarkerLocation::MLC_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MarkerLocation::MarkerLocation_Unknown
     * @property {number} MarkerLocation_Unknown=0 MarkerLocation_Unknown value
     * @property {number} MLC_MainRuler=1 * @deprecated ptsl::MarkerLocation::MLC_MainRuler is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MarkerLocation::MarkerLocation_MainRuler
     * @property {number} MarkerLocation_MainRuler=1 MarkerLocation_MainRuler value
     * @property {number} MLC_Track=2 * @deprecated ptsl::MarkerLocation::MLC_Track is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MarkerLocation::MarkerLocation_Track
     * @property {number} MarkerLocation_Track=2 MarkerLocation_Track value
     * @property {number} MarkerLocation_NamedRuler=3 * @since Pro Tools 2025.06
     */
    ptsl.MarkerLocation = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MLC_Unknown"] = 0;
        values["MarkerLocation_Unknown"] = 0;
        values[valuesById[1] = "MLC_MainRuler"] = 1;
        values["MarkerLocation_MainRuler"] = 1;
        values[valuesById[2] = "MLC_Track"] = 2;
        values["MarkerLocation_Track"] = 2;
        values[valuesById[3] = "MarkerLocation_NamedRuler"] = 3;
        return values;
    })();

    ptsl.MemoryLocation = (function() {

        /**
         * Properties of a MemoryLocation.
         * @memberof ptsl
         * @interface IMemoryLocation
         * @property {number|null} [number] MemoryLocation number
         * @property {string|null} [name] MemoryLocation name
         * @property {string|null} [startTime] MemoryLocation startTime
         * @property {string|null} [endTime] MemoryLocation endTime
         * @property {ptsl.TimeProperties|null} [timeProperties] MemoryLocation timeProperties
         * @property {ptsl.MemoryLocationReference|null} [reference] MemoryLocation reference
         * @property {ptsl.IMemoryLocationProperties|null} [generalProperties] MemoryLocation generalProperties
         * @property {string|null} [comments] MemoryLocation comments
         * @property {ptsl.MarkerLocation|null} [location] MemoryLocation location
         * @property {string|null} [trackName] MemoryLocation trackName
         * @property {number|null} [colorIndex] MemoryLocation colorIndex
         */

        /**
         * Constructs a new MemoryLocation.
         * @memberof ptsl
         * @classdesc Structure that describes memory location.
         * @implements IMemoryLocation
         * @constructor
         * @param {ptsl.IMemoryLocation=} [properties] Properties to set
         */
        function MemoryLocation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemoryLocation number.
         * @member {number} number
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.number = 0;

        /**
         * MemoryLocation name.
         * @member {string} name
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.name = "";

        /**
         * MemoryLocation startTime.
         * @member {string} startTime
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.startTime = "";

        /**
         * MemoryLocation endTime.
         * @member {string} endTime
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.endTime = "";

        /**
         * MemoryLocation timeProperties.
         * @member {ptsl.TimeProperties} timeProperties
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.timeProperties = 0;

        /**
         * MemoryLocation reference.
         * @member {ptsl.MemoryLocationReference} reference
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.reference = 0;

        /**
         * MemoryLocation generalProperties.
         * @member {ptsl.IMemoryLocationProperties|null|undefined} generalProperties
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.generalProperties = null;

        /**
         * MemoryLocation comments.
         * @member {string} comments
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.comments = "";

        /**
         * MemoryLocation location.
         * @member {ptsl.MarkerLocation} location
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.location = 0;

        /**
         * MemoryLocation trackName.
         * @member {string} trackName
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.trackName = "";

        /**
         * MemoryLocation colorIndex.
         * @member {number} colorIndex
         * @memberof ptsl.MemoryLocation
         * @instance
         */
        MemoryLocation.prototype.colorIndex = 0;

        /**
         * Creates a new MemoryLocation instance using the specified properties.
         * @function create
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {ptsl.IMemoryLocation=} [properties] Properties to set
         * @returns {ptsl.MemoryLocation} MemoryLocation instance
         */
        MemoryLocation.create = function create(properties) {
            return new MemoryLocation(properties);
        };

        /**
         * Encodes the specified MemoryLocation message. Does not implicitly {@link ptsl.MemoryLocation.verify|verify} messages.
         * @function encode
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {ptsl.IMemoryLocation} message MemoryLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemoryLocation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.number);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.startTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            if (message.timeProperties != null && Object.hasOwnProperty.call(message, "timeProperties"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.timeProperties);
            if (message.reference != null && Object.hasOwnProperty.call(message, "reference"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.reference);
            if (message.generalProperties != null && Object.hasOwnProperty.call(message, "generalProperties"))
                $root.ptsl.MemoryLocationProperties.encode(message.generalProperties, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.comments != null && Object.hasOwnProperty.call(message, "comments"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.comments);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.location);
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.trackName);
            if (message.colorIndex != null && Object.hasOwnProperty.call(message, "colorIndex"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.colorIndex);
            return writer;
        };

        /**
         * Encodes the specified MemoryLocation message, length delimited. Does not implicitly {@link ptsl.MemoryLocation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {ptsl.IMemoryLocation} message MemoryLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemoryLocation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemoryLocation message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.MemoryLocation} MemoryLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemoryLocation.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.MemoryLocation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.number = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.startTime = reader.string();
                        break;
                    }
                case 4: {
                        message.endTime = reader.string();
                        break;
                    }
                case 5: {
                        message.timeProperties = reader.int32();
                        break;
                    }
                case 6: {
                        message.reference = reader.int32();
                        break;
                    }
                case 7: {
                        message.generalProperties = $root.ptsl.MemoryLocationProperties.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.comments = reader.string();
                        break;
                    }
                case 9: {
                        message.location = reader.int32();
                        break;
                    }
                case 10: {
                        message.trackName = reader.string();
                        break;
                    }
                case 11: {
                        message.colorIndex = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemoryLocation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.MemoryLocation} MemoryLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemoryLocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MemoryLocation message.
         * @function verify
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MemoryLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isString(message.startTime))
                    return "startTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            if (message.timeProperties != null && message.hasOwnProperty("timeProperties"))
                switch (message.timeProperties) {
                default:
                    return "timeProperties: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.reference != null && message.hasOwnProperty("reference"))
                switch (message.reference) {
                default:
                    return "reference: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.generalProperties != null && message.hasOwnProperty("generalProperties")) {
                var error = $root.ptsl.MemoryLocationProperties.verify(message.generalProperties);
                if (error)
                    return "generalProperties." + error;
            }
            if (message.comments != null && message.hasOwnProperty("comments"))
                if (!$util.isString(message.comments))
                    return "comments: string expected";
            if (message.location != null && message.hasOwnProperty("location"))
                switch (message.location) {
                default:
                    return "location: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                    break;
                }
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                if (!$util.isInteger(message.colorIndex))
                    return "colorIndex: integer expected";
            return null;
        };

        /**
         * Creates a MemoryLocation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.MemoryLocation} MemoryLocation
         */
        MemoryLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.MemoryLocation)
                return object;
            var message = new $root.ptsl.MemoryLocation();
            if (object.number != null)
                message.number = object.number | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.startTime != null)
                message.startTime = String(object.startTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            switch (object.timeProperties) {
            default:
                if (typeof object.timeProperties === "number") {
                    message.timeProperties = object.timeProperties;
                    break;
                }
                break;
            case "TProperties_Unknown":
            case 0:
                message.timeProperties = 0;
                break;
            case "TP_Marker":
            case 1:
                message.timeProperties = 1;
                break;
            case "TProperties_Marker":
            case 1:
                message.timeProperties = 1;
                break;
            case "TP_Selection":
            case 2:
                message.timeProperties = 2;
                break;
            case "TProperties_Selection":
            case 2:
                message.timeProperties = 2;
                break;
            case "TP_None":
            case 3:
                message.timeProperties = 3;
                break;
            case "TProperties_None":
            case 3:
                message.timeProperties = 3;
                break;
            }
            switch (object.reference) {
            default:
                if (typeof object.reference === "number") {
                    message.reference = object.reference;
                    break;
                }
                break;
            case "MLReference_Unknown":
            case 0:
                message.reference = 0;
                break;
            case "MLR_BarBeat":
            case 1:
                message.reference = 1;
                break;
            case "MLReference_BarBeat":
            case 1:
                message.reference = 1;
                break;
            case "MLR_Absolute":
            case 2:
                message.reference = 2;
                break;
            case "MLReference_Absolute":
            case 2:
                message.reference = 2;
                break;
            case "MLR_FollowTrackTimebase":
            case 3:
                message.reference = 3;
                break;
            case "MLReference_FollowTrackTimebase":
            case 3:
                message.reference = 3;
                break;
            }
            if (object.generalProperties != null) {
                if (typeof object.generalProperties !== "object")
                    throw TypeError(".ptsl.MemoryLocation.generalProperties: object expected");
                message.generalProperties = $root.ptsl.MemoryLocationProperties.fromObject(object.generalProperties);
            }
            if (object.comments != null)
                message.comments = String(object.comments);
            switch (object.location) {
            default:
                if (typeof object.location === "number") {
                    message.location = object.location;
                    break;
                }
                break;
            case "MLC_Unknown":
            case 0:
                message.location = 0;
                break;
            case "MarkerLocation_Unknown":
            case 0:
                message.location = 0;
                break;
            case "MLC_MainRuler":
            case 1:
                message.location = 1;
                break;
            case "MarkerLocation_MainRuler":
            case 1:
                message.location = 1;
                break;
            case "MLC_Track":
            case 2:
                message.location = 2;
                break;
            case "MarkerLocation_Track":
            case 2:
                message.location = 2;
                break;
            case "MarkerLocation_NamedRuler":
            case 3:
                message.location = 3;
                break;
            }
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            if (object.colorIndex != null)
                message.colorIndex = object.colorIndex | 0;
            return message;
        };

        /**
         * Creates a plain object from a MemoryLocation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {ptsl.MemoryLocation} message MemoryLocation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemoryLocation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.number = 0;
                object.name = "";
                object.startTime = "";
                object.endTime = "";
                object.timeProperties = options.enums === String ? "TProperties_Unknown" : 0;
                object.reference = options.enums === String ? "MLReference_Unknown" : 0;
                object.generalProperties = null;
                object.comments = "";
                object.location = options.enums === String ? "MLC_Unknown" : 0;
                object.trackName = "";
                object.colorIndex = 0;
            }
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                object.startTime = message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.timeProperties != null && message.hasOwnProperty("timeProperties"))
                object.timeProperties = options.enums === String ? $root.ptsl.TimeProperties[message.timeProperties] === undefined ? message.timeProperties : $root.ptsl.TimeProperties[message.timeProperties] : message.timeProperties;
            if (message.reference != null && message.hasOwnProperty("reference"))
                object.reference = options.enums === String ? $root.ptsl.MemoryLocationReference[message.reference] === undefined ? message.reference : $root.ptsl.MemoryLocationReference[message.reference] : message.reference;
            if (message.generalProperties != null && message.hasOwnProperty("generalProperties"))
                object.generalProperties = $root.ptsl.MemoryLocationProperties.toObject(message.generalProperties, options);
            if (message.comments != null && message.hasOwnProperty("comments"))
                object.comments = message.comments;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = options.enums === String ? $root.ptsl.MarkerLocation[message.location] === undefined ? message.location : $root.ptsl.MarkerLocation[message.location] : message.location;
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                object.colorIndex = message.colorIndex;
            return object;
        };

        /**
         * Converts this MemoryLocation to JSON.
         * @function toJSON
         * @memberof ptsl.MemoryLocation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemoryLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MemoryLocation
         * @function getTypeUrl
         * @memberof ptsl.MemoryLocation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MemoryLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.MemoryLocation";
        };

        return MemoryLocation;
    })();

    ptsl.MemoryLocationProperties = (function() {

        /**
         * Properties of a MemoryLocationProperties.
         * @memberof ptsl
         * @interface IMemoryLocationProperties
         * @property {boolean|null} [zoomSettings] MemoryLocationProperties zoomSettings
         * @property {boolean|null} [prePostRollTimes] MemoryLocationProperties prePostRollTimes
         * @property {boolean|null} [trackVisibility] MemoryLocationProperties trackVisibility
         * @property {boolean|null} [trackHeights] MemoryLocationProperties trackHeights
         * @property {boolean|null} [groupEnables] MemoryLocationProperties groupEnables
         * @property {boolean|null} [windowConfiguration] MemoryLocationProperties windowConfiguration
         * @property {number|null} [windowConfigurationIndex] MemoryLocationProperties windowConfigurationIndex
         * @property {string|null} [windowConfigurationName] MemoryLocationProperties windowConfigurationName
         * @property {number|null} [venueSnapshotIndex] MemoryLocationProperties venueSnapshotIndex
         * @property {string|null} [venueSnapshotName] MemoryLocationProperties venueSnapshotName
         */

        /**
         * Constructs a new MemoryLocationProperties.
         * @memberof ptsl
         * @classdesc Structure that describes memory location properties (flags).
         * @implements IMemoryLocationProperties
         * @constructor
         * @param {ptsl.IMemoryLocationProperties=} [properties] Properties to set
         */
        function MemoryLocationProperties(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemoryLocationProperties zoomSettings.
         * @member {boolean} zoomSettings
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.zoomSettings = false;

        /**
         * MemoryLocationProperties prePostRollTimes.
         * @member {boolean} prePostRollTimes
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.prePostRollTimes = false;

        /**
         * MemoryLocationProperties trackVisibility.
         * @member {boolean} trackVisibility
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.trackVisibility = false;

        /**
         * MemoryLocationProperties trackHeights.
         * @member {boolean} trackHeights
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.trackHeights = false;

        /**
         * MemoryLocationProperties groupEnables.
         * @member {boolean} groupEnables
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.groupEnables = false;

        /**
         * MemoryLocationProperties windowConfiguration.
         * @member {boolean} windowConfiguration
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.windowConfiguration = false;

        /**
         * MemoryLocationProperties windowConfigurationIndex.
         * @member {number} windowConfigurationIndex
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.windowConfigurationIndex = 0;

        /**
         * MemoryLocationProperties windowConfigurationName.
         * @member {string} windowConfigurationName
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.windowConfigurationName = "";

        /**
         * MemoryLocationProperties venueSnapshotIndex.
         * @member {number} venueSnapshotIndex
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.venueSnapshotIndex = 0;

        /**
         * MemoryLocationProperties venueSnapshotName.
         * @member {string} venueSnapshotName
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         */
        MemoryLocationProperties.prototype.venueSnapshotName = "";

        /**
         * Creates a new MemoryLocationProperties instance using the specified properties.
         * @function create
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {ptsl.IMemoryLocationProperties=} [properties] Properties to set
         * @returns {ptsl.MemoryLocationProperties} MemoryLocationProperties instance
         */
        MemoryLocationProperties.create = function create(properties) {
            return new MemoryLocationProperties(properties);
        };

        /**
         * Encodes the specified MemoryLocationProperties message. Does not implicitly {@link ptsl.MemoryLocationProperties.verify|verify} messages.
         * @function encode
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {ptsl.IMemoryLocationProperties} message MemoryLocationProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemoryLocationProperties.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.zoomSettings != null && Object.hasOwnProperty.call(message, "zoomSettings"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.zoomSettings);
            if (message.prePostRollTimes != null && Object.hasOwnProperty.call(message, "prePostRollTimes"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.prePostRollTimes);
            if (message.trackVisibility != null && Object.hasOwnProperty.call(message, "trackVisibility"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.trackVisibility);
            if (message.trackHeights != null && Object.hasOwnProperty.call(message, "trackHeights"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.trackHeights);
            if (message.groupEnables != null && Object.hasOwnProperty.call(message, "groupEnables"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.groupEnables);
            if (message.windowConfiguration != null && Object.hasOwnProperty.call(message, "windowConfiguration"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.windowConfiguration);
            if (message.windowConfigurationIndex != null && Object.hasOwnProperty.call(message, "windowConfigurationIndex"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.windowConfigurationIndex);
            if (message.windowConfigurationName != null && Object.hasOwnProperty.call(message, "windowConfigurationName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.windowConfigurationName);
            if (message.venueSnapshotIndex != null && Object.hasOwnProperty.call(message, "venueSnapshotIndex"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.venueSnapshotIndex);
            if (message.venueSnapshotName != null && Object.hasOwnProperty.call(message, "venueSnapshotName"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.venueSnapshotName);
            return writer;
        };

        /**
         * Encodes the specified MemoryLocationProperties message, length delimited. Does not implicitly {@link ptsl.MemoryLocationProperties.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {ptsl.IMemoryLocationProperties} message MemoryLocationProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemoryLocationProperties.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemoryLocationProperties message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.MemoryLocationProperties} MemoryLocationProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemoryLocationProperties.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.MemoryLocationProperties();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.zoomSettings = reader.bool();
                        break;
                    }
                case 2: {
                        message.prePostRollTimes = reader.bool();
                        break;
                    }
                case 3: {
                        message.trackVisibility = reader.bool();
                        break;
                    }
                case 4: {
                        message.trackHeights = reader.bool();
                        break;
                    }
                case 5: {
                        message.groupEnables = reader.bool();
                        break;
                    }
                case 6: {
                        message.windowConfiguration = reader.bool();
                        break;
                    }
                case 7: {
                        message.windowConfigurationIndex = reader.int32();
                        break;
                    }
                case 8: {
                        message.windowConfigurationName = reader.string();
                        break;
                    }
                case 9: {
                        message.venueSnapshotIndex = reader.int32();
                        break;
                    }
                case 10: {
                        message.venueSnapshotName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemoryLocationProperties message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.MemoryLocationProperties} MemoryLocationProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemoryLocationProperties.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MemoryLocationProperties message.
         * @function verify
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MemoryLocationProperties.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.zoomSettings != null && message.hasOwnProperty("zoomSettings"))
                if (typeof message.zoomSettings !== "boolean")
                    return "zoomSettings: boolean expected";
            if (message.prePostRollTimes != null && message.hasOwnProperty("prePostRollTimes"))
                if (typeof message.prePostRollTimes !== "boolean")
                    return "prePostRollTimes: boolean expected";
            if (message.trackVisibility != null && message.hasOwnProperty("trackVisibility"))
                if (typeof message.trackVisibility !== "boolean")
                    return "trackVisibility: boolean expected";
            if (message.trackHeights != null && message.hasOwnProperty("trackHeights"))
                if (typeof message.trackHeights !== "boolean")
                    return "trackHeights: boolean expected";
            if (message.groupEnables != null && message.hasOwnProperty("groupEnables"))
                if (typeof message.groupEnables !== "boolean")
                    return "groupEnables: boolean expected";
            if (message.windowConfiguration != null && message.hasOwnProperty("windowConfiguration"))
                if (typeof message.windowConfiguration !== "boolean")
                    return "windowConfiguration: boolean expected";
            if (message.windowConfigurationIndex != null && message.hasOwnProperty("windowConfigurationIndex"))
                if (!$util.isInteger(message.windowConfigurationIndex))
                    return "windowConfigurationIndex: integer expected";
            if (message.windowConfigurationName != null && message.hasOwnProperty("windowConfigurationName"))
                if (!$util.isString(message.windowConfigurationName))
                    return "windowConfigurationName: string expected";
            if (message.venueSnapshotIndex != null && message.hasOwnProperty("venueSnapshotIndex"))
                if (!$util.isInteger(message.venueSnapshotIndex))
                    return "venueSnapshotIndex: integer expected";
            if (message.venueSnapshotName != null && message.hasOwnProperty("venueSnapshotName"))
                if (!$util.isString(message.venueSnapshotName))
                    return "venueSnapshotName: string expected";
            return null;
        };

        /**
         * Creates a MemoryLocationProperties message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.MemoryLocationProperties} MemoryLocationProperties
         */
        MemoryLocationProperties.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.MemoryLocationProperties)
                return object;
            var message = new $root.ptsl.MemoryLocationProperties();
            if (object.zoomSettings != null)
                message.zoomSettings = Boolean(object.zoomSettings);
            if (object.prePostRollTimes != null)
                message.prePostRollTimes = Boolean(object.prePostRollTimes);
            if (object.trackVisibility != null)
                message.trackVisibility = Boolean(object.trackVisibility);
            if (object.trackHeights != null)
                message.trackHeights = Boolean(object.trackHeights);
            if (object.groupEnables != null)
                message.groupEnables = Boolean(object.groupEnables);
            if (object.windowConfiguration != null)
                message.windowConfiguration = Boolean(object.windowConfiguration);
            if (object.windowConfigurationIndex != null)
                message.windowConfigurationIndex = object.windowConfigurationIndex | 0;
            if (object.windowConfigurationName != null)
                message.windowConfigurationName = String(object.windowConfigurationName);
            if (object.venueSnapshotIndex != null)
                message.venueSnapshotIndex = object.venueSnapshotIndex | 0;
            if (object.venueSnapshotName != null)
                message.venueSnapshotName = String(object.venueSnapshotName);
            return message;
        };

        /**
         * Creates a plain object from a MemoryLocationProperties message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {ptsl.MemoryLocationProperties} message MemoryLocationProperties
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemoryLocationProperties.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.zoomSettings = false;
                object.prePostRollTimes = false;
                object.trackVisibility = false;
                object.trackHeights = false;
                object.groupEnables = false;
                object.windowConfiguration = false;
                object.windowConfigurationIndex = 0;
                object.windowConfigurationName = "";
                object.venueSnapshotIndex = 0;
                object.venueSnapshotName = "";
            }
            if (message.zoomSettings != null && message.hasOwnProperty("zoomSettings"))
                object.zoomSettings = message.zoomSettings;
            if (message.prePostRollTimes != null && message.hasOwnProperty("prePostRollTimes"))
                object.prePostRollTimes = message.prePostRollTimes;
            if (message.trackVisibility != null && message.hasOwnProperty("trackVisibility"))
                object.trackVisibility = message.trackVisibility;
            if (message.trackHeights != null && message.hasOwnProperty("trackHeights"))
                object.trackHeights = message.trackHeights;
            if (message.groupEnables != null && message.hasOwnProperty("groupEnables"))
                object.groupEnables = message.groupEnables;
            if (message.windowConfiguration != null && message.hasOwnProperty("windowConfiguration"))
                object.windowConfiguration = message.windowConfiguration;
            if (message.windowConfigurationIndex != null && message.hasOwnProperty("windowConfigurationIndex"))
                object.windowConfigurationIndex = message.windowConfigurationIndex;
            if (message.windowConfigurationName != null && message.hasOwnProperty("windowConfigurationName"))
                object.windowConfigurationName = message.windowConfigurationName;
            if (message.venueSnapshotIndex != null && message.hasOwnProperty("venueSnapshotIndex"))
                object.venueSnapshotIndex = message.venueSnapshotIndex;
            if (message.venueSnapshotName != null && message.hasOwnProperty("venueSnapshotName"))
                object.venueSnapshotName = message.venueSnapshotName;
            return object;
        };

        /**
         * Converts this MemoryLocationProperties to JSON.
         * @function toJSON
         * @memberof ptsl.MemoryLocationProperties
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemoryLocationProperties.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MemoryLocationProperties
         * @function getTypeUrl
         * @memberof ptsl.MemoryLocationProperties
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MemoryLocationProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.MemoryLocationProperties";
        };

        return MemoryLocationProperties;
    })();

    ptsl.EditMemoryLocationRequestBody = (function() {

        /**
         * Properties of an EditMemoryLocationRequestBody.
         * @memberof ptsl
         * @interface IEditMemoryLocationRequestBody
         * @property {number|null} [number] EditMemoryLocationRequestBody number
         * @property {string|null} [name] EditMemoryLocationRequestBody name
         * @property {string|null} [startTime] EditMemoryLocationRequestBody startTime
         * @property {string|null} [endTime] EditMemoryLocationRequestBody endTime
         * @property {ptsl.TimeProperties|null} [timeProperties] EditMemoryLocationRequestBody timeProperties
         * @property {ptsl.MemoryLocationReference|null} [reference] * Only MLR_FollowTrackTimebase option is supported. All other options are ignored when set.
         * * Reference type is determined based on the start_time format instead.
         * @property {ptsl.IMemoryLocationProperties|null} [generalProperties] EditMemoryLocationRequestBody generalProperties
         * @property {string|null} [comments] EditMemoryLocationRequestBody comments
         * @property {number|null} [colorIndex] EditMemoryLocationRequestBody colorIndex
         * @property {ptsl.MarkerLocation|null} [location] EditMemoryLocationRequestBody location
         * @property {string|null} [trackName] EditMemoryLocationRequestBody trackName
         */

        /**
         * Constructs a new EditMemoryLocationRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes EditMemoryLocation request data.
         * @implements IEditMemoryLocationRequestBody
         * @constructor
         * @param {ptsl.IEditMemoryLocationRequestBody=} [properties] Properties to set
         */
        function EditMemoryLocationRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EditMemoryLocationRequestBody number.
         * @member {number} number
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.number = 0;

        /**
         * EditMemoryLocationRequestBody name.
         * @member {string} name
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.name = "";

        /**
         * EditMemoryLocationRequestBody startTime.
         * @member {string} startTime
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.startTime = "";

        /**
         * EditMemoryLocationRequestBody endTime.
         * @member {string} endTime
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.endTime = "";

        /**
         * EditMemoryLocationRequestBody timeProperties.
         * @member {ptsl.TimeProperties} timeProperties
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.timeProperties = 0;

        /**
         * * Only MLR_FollowTrackTimebase option is supported. All other options are ignored when set.
         * * Reference type is determined based on the start_time format instead.
         * @member {ptsl.MemoryLocationReference} reference
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.reference = 0;

        /**
         * EditMemoryLocationRequestBody generalProperties.
         * @member {ptsl.IMemoryLocationProperties|null|undefined} generalProperties
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.generalProperties = null;

        /**
         * EditMemoryLocationRequestBody comments.
         * @member {string} comments
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.comments = "";

        /**
         * EditMemoryLocationRequestBody colorIndex.
         * @member {number} colorIndex
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.colorIndex = 0;

        /**
         * EditMemoryLocationRequestBody location.
         * @member {ptsl.MarkerLocation} location
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.location = 0;

        /**
         * EditMemoryLocationRequestBody trackName.
         * @member {string} trackName
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         */
        EditMemoryLocationRequestBody.prototype.trackName = "";

        /**
         * Creates a new EditMemoryLocationRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {ptsl.IEditMemoryLocationRequestBody=} [properties] Properties to set
         * @returns {ptsl.EditMemoryLocationRequestBody} EditMemoryLocationRequestBody instance
         */
        EditMemoryLocationRequestBody.create = function create(properties) {
            return new EditMemoryLocationRequestBody(properties);
        };

        /**
         * Encodes the specified EditMemoryLocationRequestBody message. Does not implicitly {@link ptsl.EditMemoryLocationRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {ptsl.IEditMemoryLocationRequestBody} message EditMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditMemoryLocationRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.number);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.startTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            if (message.timeProperties != null && Object.hasOwnProperty.call(message, "timeProperties"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.timeProperties);
            if (message.reference != null && Object.hasOwnProperty.call(message, "reference"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.reference);
            if (message.generalProperties != null && Object.hasOwnProperty.call(message, "generalProperties"))
                $root.ptsl.MemoryLocationProperties.encode(message.generalProperties, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.comments != null && Object.hasOwnProperty.call(message, "comments"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.comments);
            if (message.colorIndex != null && Object.hasOwnProperty.call(message, "colorIndex"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.colorIndex);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.location);
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.trackName);
            return writer;
        };

        /**
         * Encodes the specified EditMemoryLocationRequestBody message, length delimited. Does not implicitly {@link ptsl.EditMemoryLocationRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {ptsl.IEditMemoryLocationRequestBody} message EditMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditMemoryLocationRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EditMemoryLocationRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EditMemoryLocationRequestBody} EditMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditMemoryLocationRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EditMemoryLocationRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.number = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.startTime = reader.string();
                        break;
                    }
                case 4: {
                        message.endTime = reader.string();
                        break;
                    }
                case 5: {
                        message.timeProperties = reader.int32();
                        break;
                    }
                case 6: {
                        message.reference = reader.int32();
                        break;
                    }
                case 7: {
                        message.generalProperties = $root.ptsl.MemoryLocationProperties.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.comments = reader.string();
                        break;
                    }
                case 9: {
                        message.colorIndex = reader.int32();
                        break;
                    }
                case 10: {
                        message.location = reader.int32();
                        break;
                    }
                case 11: {
                        message.trackName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EditMemoryLocationRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EditMemoryLocationRequestBody} EditMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditMemoryLocationRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EditMemoryLocationRequestBody message.
         * @function verify
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EditMemoryLocationRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isString(message.startTime))
                    return "startTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            if (message.timeProperties != null && message.hasOwnProperty("timeProperties"))
                switch (message.timeProperties) {
                default:
                    return "timeProperties: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.reference != null && message.hasOwnProperty("reference"))
                switch (message.reference) {
                default:
                    return "reference: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.generalProperties != null && message.hasOwnProperty("generalProperties")) {
                var error = $root.ptsl.MemoryLocationProperties.verify(message.generalProperties);
                if (error)
                    return "generalProperties." + error;
            }
            if (message.comments != null && message.hasOwnProperty("comments"))
                if (!$util.isString(message.comments))
                    return "comments: string expected";
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                if (!$util.isInteger(message.colorIndex))
                    return "colorIndex: integer expected";
            if (message.location != null && message.hasOwnProperty("location"))
                switch (message.location) {
                default:
                    return "location: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                    break;
                }
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            return null;
        };

        /**
         * Creates an EditMemoryLocationRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EditMemoryLocationRequestBody} EditMemoryLocationRequestBody
         */
        EditMemoryLocationRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EditMemoryLocationRequestBody)
                return object;
            var message = new $root.ptsl.EditMemoryLocationRequestBody();
            if (object.number != null)
                message.number = object.number | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.startTime != null)
                message.startTime = String(object.startTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            switch (object.timeProperties) {
            default:
                if (typeof object.timeProperties === "number") {
                    message.timeProperties = object.timeProperties;
                    break;
                }
                break;
            case "TProperties_Unknown":
            case 0:
                message.timeProperties = 0;
                break;
            case "TP_Marker":
            case 1:
                message.timeProperties = 1;
                break;
            case "TProperties_Marker":
            case 1:
                message.timeProperties = 1;
                break;
            case "TP_Selection":
            case 2:
                message.timeProperties = 2;
                break;
            case "TProperties_Selection":
            case 2:
                message.timeProperties = 2;
                break;
            case "TP_None":
            case 3:
                message.timeProperties = 3;
                break;
            case "TProperties_None":
            case 3:
                message.timeProperties = 3;
                break;
            }
            switch (object.reference) {
            default:
                if (typeof object.reference === "number") {
                    message.reference = object.reference;
                    break;
                }
                break;
            case "MLReference_Unknown":
            case 0:
                message.reference = 0;
                break;
            case "MLR_BarBeat":
            case 1:
                message.reference = 1;
                break;
            case "MLReference_BarBeat":
            case 1:
                message.reference = 1;
                break;
            case "MLR_Absolute":
            case 2:
                message.reference = 2;
                break;
            case "MLReference_Absolute":
            case 2:
                message.reference = 2;
                break;
            case "MLR_FollowTrackTimebase":
            case 3:
                message.reference = 3;
                break;
            case "MLReference_FollowTrackTimebase":
            case 3:
                message.reference = 3;
                break;
            }
            if (object.generalProperties != null) {
                if (typeof object.generalProperties !== "object")
                    throw TypeError(".ptsl.EditMemoryLocationRequestBody.generalProperties: object expected");
                message.generalProperties = $root.ptsl.MemoryLocationProperties.fromObject(object.generalProperties);
            }
            if (object.comments != null)
                message.comments = String(object.comments);
            if (object.colorIndex != null)
                message.colorIndex = object.colorIndex | 0;
            switch (object.location) {
            default:
                if (typeof object.location === "number") {
                    message.location = object.location;
                    break;
                }
                break;
            case "MLC_Unknown":
            case 0:
                message.location = 0;
                break;
            case "MarkerLocation_Unknown":
            case 0:
                message.location = 0;
                break;
            case "MLC_MainRuler":
            case 1:
                message.location = 1;
                break;
            case "MarkerLocation_MainRuler":
            case 1:
                message.location = 1;
                break;
            case "MLC_Track":
            case 2:
                message.location = 2;
                break;
            case "MarkerLocation_Track":
            case 2:
                message.location = 2;
                break;
            case "MarkerLocation_NamedRuler":
            case 3:
                message.location = 3;
                break;
            }
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            return message;
        };

        /**
         * Creates a plain object from an EditMemoryLocationRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {ptsl.EditMemoryLocationRequestBody} message EditMemoryLocationRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EditMemoryLocationRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.number = 0;
                object.name = "";
                object.startTime = "";
                object.endTime = "";
                object.timeProperties = options.enums === String ? "TProperties_Unknown" : 0;
                object.reference = options.enums === String ? "MLReference_Unknown" : 0;
                object.generalProperties = null;
                object.comments = "";
                object.colorIndex = 0;
                object.location = options.enums === String ? "MLC_Unknown" : 0;
                object.trackName = "";
            }
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                object.startTime = message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.timeProperties != null && message.hasOwnProperty("timeProperties"))
                object.timeProperties = options.enums === String ? $root.ptsl.TimeProperties[message.timeProperties] === undefined ? message.timeProperties : $root.ptsl.TimeProperties[message.timeProperties] : message.timeProperties;
            if (message.reference != null && message.hasOwnProperty("reference"))
                object.reference = options.enums === String ? $root.ptsl.MemoryLocationReference[message.reference] === undefined ? message.reference : $root.ptsl.MemoryLocationReference[message.reference] : message.reference;
            if (message.generalProperties != null && message.hasOwnProperty("generalProperties"))
                object.generalProperties = $root.ptsl.MemoryLocationProperties.toObject(message.generalProperties, options);
            if (message.comments != null && message.hasOwnProperty("comments"))
                object.comments = message.comments;
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                object.colorIndex = message.colorIndex;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = options.enums === String ? $root.ptsl.MarkerLocation[message.location] === undefined ? message.location : $root.ptsl.MarkerLocation[message.location] : message.location;
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            return object;
        };

        /**
         * Converts this EditMemoryLocationRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EditMemoryLocationRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EditMemoryLocationRequestBody
         * @function getTypeUrl
         * @memberof ptsl.EditMemoryLocationRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EditMemoryLocationRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EditMemoryLocationRequestBody";
        };

        return EditMemoryLocationRequestBody;
    })();

    ptsl.EditMemoryLocationResponseBody = (function() {

        /**
         * Properties of an EditMemoryLocationResponseBody.
         * @memberof ptsl
         * @interface IEditMemoryLocationResponseBody
         */

        /**
         * Constructs a new EditMemoryLocationResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes EditMemoryLocation response data.
         * @implements IEditMemoryLocationResponseBody
         * @constructor
         * @param {ptsl.IEditMemoryLocationResponseBody=} [properties] Properties to set
         */
        function EditMemoryLocationResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new EditMemoryLocationResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {ptsl.IEditMemoryLocationResponseBody=} [properties] Properties to set
         * @returns {ptsl.EditMemoryLocationResponseBody} EditMemoryLocationResponseBody instance
         */
        EditMemoryLocationResponseBody.create = function create(properties) {
            return new EditMemoryLocationResponseBody(properties);
        };

        /**
         * Encodes the specified EditMemoryLocationResponseBody message. Does not implicitly {@link ptsl.EditMemoryLocationResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {ptsl.IEditMemoryLocationResponseBody} message EditMemoryLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditMemoryLocationResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified EditMemoryLocationResponseBody message, length delimited. Does not implicitly {@link ptsl.EditMemoryLocationResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {ptsl.IEditMemoryLocationResponseBody} message EditMemoryLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditMemoryLocationResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EditMemoryLocationResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EditMemoryLocationResponseBody} EditMemoryLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditMemoryLocationResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EditMemoryLocationResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EditMemoryLocationResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EditMemoryLocationResponseBody} EditMemoryLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditMemoryLocationResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EditMemoryLocationResponseBody message.
         * @function verify
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EditMemoryLocationResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an EditMemoryLocationResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EditMemoryLocationResponseBody} EditMemoryLocationResponseBody
         */
        EditMemoryLocationResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EditMemoryLocationResponseBody)
                return object;
            return new $root.ptsl.EditMemoryLocationResponseBody();
        };

        /**
         * Creates a plain object from an EditMemoryLocationResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {ptsl.EditMemoryLocationResponseBody} message EditMemoryLocationResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EditMemoryLocationResponseBody.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this EditMemoryLocationResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EditMemoryLocationResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EditMemoryLocationResponseBody
         * @function getTypeUrl
         * @memberof ptsl.EditMemoryLocationResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EditMemoryLocationResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EditMemoryLocationResponseBody";
        };

        return EditMemoryLocationResponseBody;
    })();

    ptsl.CreateMemoryLocationRequestBody = (function() {

        /**
         * Properties of a CreateMemoryLocationRequestBody.
         * @memberof ptsl
         * @interface ICreateMemoryLocationRequestBody
         * @property {number|null} [number] CreateMemoryLocationRequestBody number
         * @property {string|null} [name] CreateMemoryLocationRequestBody name
         * @property {string|null} [startTime] CreateMemoryLocationRequestBody startTime
         * @property {string|null} [endTime] CreateMemoryLocationRequestBody endTime
         * @property {ptsl.TimeProperties|null} [timeProperties] CreateMemoryLocationRequestBody timeProperties
         * @property {ptsl.MemoryLocationReference|null} [reference] * Only MLR_FollowTrackTimebase option is supported. All other options are ignored when set.
         * * Reference type is determined based on the start_time format instead.
         * @property {ptsl.IMemoryLocationProperties|null} [generalProperties] CreateMemoryLocationRequestBody generalProperties
         * @property {string|null} [comments] CreateMemoryLocationRequestBody comments
         * @property {number|null} [colorIndex] CreateMemoryLocationRequestBody colorIndex
         * @property {ptsl.MarkerLocation|null} [location] CreateMemoryLocationRequestBody location
         * @property {string|null} [trackName] CreateMemoryLocationRequestBody trackName
         */

        /**
         * Constructs a new CreateMemoryLocationRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateMemoryLocation request data.
         * @implements ICreateMemoryLocationRequestBody
         * @constructor
         * @param {ptsl.ICreateMemoryLocationRequestBody=} [properties] Properties to set
         */
        function CreateMemoryLocationRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMemoryLocationRequestBody number.
         * @member {number} number
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.number = 0;

        /**
         * CreateMemoryLocationRequestBody name.
         * @member {string} name
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.name = "";

        /**
         * CreateMemoryLocationRequestBody startTime.
         * @member {string} startTime
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.startTime = "";

        /**
         * CreateMemoryLocationRequestBody endTime.
         * @member {string} endTime
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.endTime = "";

        /**
         * CreateMemoryLocationRequestBody timeProperties.
         * @member {ptsl.TimeProperties} timeProperties
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.timeProperties = 0;

        /**
         * * Only MLR_FollowTrackTimebase option is supported. All other options are ignored when set.
         * * Reference type is determined based on the start_time format instead.
         * @member {ptsl.MemoryLocationReference} reference
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.reference = 0;

        /**
         * CreateMemoryLocationRequestBody generalProperties.
         * @member {ptsl.IMemoryLocationProperties|null|undefined} generalProperties
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.generalProperties = null;

        /**
         * CreateMemoryLocationRequestBody comments.
         * @member {string} comments
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.comments = "";

        /**
         * CreateMemoryLocationRequestBody colorIndex.
         * @member {number} colorIndex
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.colorIndex = 0;

        /**
         * CreateMemoryLocationRequestBody location.
         * @member {ptsl.MarkerLocation} location
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.location = 0;

        /**
         * CreateMemoryLocationRequestBody trackName.
         * @member {string} trackName
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         */
        CreateMemoryLocationRequestBody.prototype.trackName = "";

        /**
         * Creates a new CreateMemoryLocationRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {ptsl.ICreateMemoryLocationRequestBody=} [properties] Properties to set
         * @returns {ptsl.CreateMemoryLocationRequestBody} CreateMemoryLocationRequestBody instance
         */
        CreateMemoryLocationRequestBody.create = function create(properties) {
            return new CreateMemoryLocationRequestBody(properties);
        };

        /**
         * Encodes the specified CreateMemoryLocationRequestBody message. Does not implicitly {@link ptsl.CreateMemoryLocationRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {ptsl.ICreateMemoryLocationRequestBody} message CreateMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMemoryLocationRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.number);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.startTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            if (message.timeProperties != null && Object.hasOwnProperty.call(message, "timeProperties"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.timeProperties);
            if (message.reference != null && Object.hasOwnProperty.call(message, "reference"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.reference);
            if (message.generalProperties != null && Object.hasOwnProperty.call(message, "generalProperties"))
                $root.ptsl.MemoryLocationProperties.encode(message.generalProperties, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.comments != null && Object.hasOwnProperty.call(message, "comments"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.comments);
            if (message.colorIndex != null && Object.hasOwnProperty.call(message, "colorIndex"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.colorIndex);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.location);
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.trackName);
            return writer;
        };

        /**
         * Encodes the specified CreateMemoryLocationRequestBody message, length delimited. Does not implicitly {@link ptsl.CreateMemoryLocationRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {ptsl.ICreateMemoryLocationRequestBody} message CreateMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMemoryLocationRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMemoryLocationRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateMemoryLocationRequestBody} CreateMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMemoryLocationRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateMemoryLocationRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.number = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.startTime = reader.string();
                        break;
                    }
                case 4: {
                        message.endTime = reader.string();
                        break;
                    }
                case 5: {
                        message.timeProperties = reader.int32();
                        break;
                    }
                case 6: {
                        message.reference = reader.int32();
                        break;
                    }
                case 7: {
                        message.generalProperties = $root.ptsl.MemoryLocationProperties.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.comments = reader.string();
                        break;
                    }
                case 9: {
                        message.colorIndex = reader.int32();
                        break;
                    }
                case 10: {
                        message.location = reader.int32();
                        break;
                    }
                case 11: {
                        message.trackName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMemoryLocationRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateMemoryLocationRequestBody} CreateMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMemoryLocationRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMemoryLocationRequestBody message.
         * @function verify
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMemoryLocationRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isString(message.startTime))
                    return "startTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            if (message.timeProperties != null && message.hasOwnProperty("timeProperties"))
                switch (message.timeProperties) {
                default:
                    return "timeProperties: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.reference != null && message.hasOwnProperty("reference"))
                switch (message.reference) {
                default:
                    return "reference: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.generalProperties != null && message.hasOwnProperty("generalProperties")) {
                var error = $root.ptsl.MemoryLocationProperties.verify(message.generalProperties);
                if (error)
                    return "generalProperties." + error;
            }
            if (message.comments != null && message.hasOwnProperty("comments"))
                if (!$util.isString(message.comments))
                    return "comments: string expected";
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                if (!$util.isInteger(message.colorIndex))
                    return "colorIndex: integer expected";
            if (message.location != null && message.hasOwnProperty("location"))
                switch (message.location) {
                default:
                    return "location: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                    break;
                }
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            return null;
        };

        /**
         * Creates a CreateMemoryLocationRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateMemoryLocationRequestBody} CreateMemoryLocationRequestBody
         */
        CreateMemoryLocationRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateMemoryLocationRequestBody)
                return object;
            var message = new $root.ptsl.CreateMemoryLocationRequestBody();
            if (object.number != null)
                message.number = object.number | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.startTime != null)
                message.startTime = String(object.startTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            switch (object.timeProperties) {
            default:
                if (typeof object.timeProperties === "number") {
                    message.timeProperties = object.timeProperties;
                    break;
                }
                break;
            case "TProperties_Unknown":
            case 0:
                message.timeProperties = 0;
                break;
            case "TP_Marker":
            case 1:
                message.timeProperties = 1;
                break;
            case "TProperties_Marker":
            case 1:
                message.timeProperties = 1;
                break;
            case "TP_Selection":
            case 2:
                message.timeProperties = 2;
                break;
            case "TProperties_Selection":
            case 2:
                message.timeProperties = 2;
                break;
            case "TP_None":
            case 3:
                message.timeProperties = 3;
                break;
            case "TProperties_None":
            case 3:
                message.timeProperties = 3;
                break;
            }
            switch (object.reference) {
            default:
                if (typeof object.reference === "number") {
                    message.reference = object.reference;
                    break;
                }
                break;
            case "MLReference_Unknown":
            case 0:
                message.reference = 0;
                break;
            case "MLR_BarBeat":
            case 1:
                message.reference = 1;
                break;
            case "MLReference_BarBeat":
            case 1:
                message.reference = 1;
                break;
            case "MLR_Absolute":
            case 2:
                message.reference = 2;
                break;
            case "MLReference_Absolute":
            case 2:
                message.reference = 2;
                break;
            case "MLR_FollowTrackTimebase":
            case 3:
                message.reference = 3;
                break;
            case "MLReference_FollowTrackTimebase":
            case 3:
                message.reference = 3;
                break;
            }
            if (object.generalProperties != null) {
                if (typeof object.generalProperties !== "object")
                    throw TypeError(".ptsl.CreateMemoryLocationRequestBody.generalProperties: object expected");
                message.generalProperties = $root.ptsl.MemoryLocationProperties.fromObject(object.generalProperties);
            }
            if (object.comments != null)
                message.comments = String(object.comments);
            if (object.colorIndex != null)
                message.colorIndex = object.colorIndex | 0;
            switch (object.location) {
            default:
                if (typeof object.location === "number") {
                    message.location = object.location;
                    break;
                }
                break;
            case "MLC_Unknown":
            case 0:
                message.location = 0;
                break;
            case "MarkerLocation_Unknown":
            case 0:
                message.location = 0;
                break;
            case "MLC_MainRuler":
            case 1:
                message.location = 1;
                break;
            case "MarkerLocation_MainRuler":
            case 1:
                message.location = 1;
                break;
            case "MLC_Track":
            case 2:
                message.location = 2;
                break;
            case "MarkerLocation_Track":
            case 2:
                message.location = 2;
                break;
            case "MarkerLocation_NamedRuler":
            case 3:
                message.location = 3;
                break;
            }
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            return message;
        };

        /**
         * Creates a plain object from a CreateMemoryLocationRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {ptsl.CreateMemoryLocationRequestBody} message CreateMemoryLocationRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMemoryLocationRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.number = 0;
                object.name = "";
                object.startTime = "";
                object.endTime = "";
                object.timeProperties = options.enums === String ? "TProperties_Unknown" : 0;
                object.reference = options.enums === String ? "MLReference_Unknown" : 0;
                object.generalProperties = null;
                object.comments = "";
                object.colorIndex = 0;
                object.location = options.enums === String ? "MLC_Unknown" : 0;
                object.trackName = "";
            }
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                object.startTime = message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.timeProperties != null && message.hasOwnProperty("timeProperties"))
                object.timeProperties = options.enums === String ? $root.ptsl.TimeProperties[message.timeProperties] === undefined ? message.timeProperties : $root.ptsl.TimeProperties[message.timeProperties] : message.timeProperties;
            if (message.reference != null && message.hasOwnProperty("reference"))
                object.reference = options.enums === String ? $root.ptsl.MemoryLocationReference[message.reference] === undefined ? message.reference : $root.ptsl.MemoryLocationReference[message.reference] : message.reference;
            if (message.generalProperties != null && message.hasOwnProperty("generalProperties"))
                object.generalProperties = $root.ptsl.MemoryLocationProperties.toObject(message.generalProperties, options);
            if (message.comments != null && message.hasOwnProperty("comments"))
                object.comments = message.comments;
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                object.colorIndex = message.colorIndex;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = options.enums === String ? $root.ptsl.MarkerLocation[message.location] === undefined ? message.location : $root.ptsl.MarkerLocation[message.location] : message.location;
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            return object;
        };

        /**
         * Converts this CreateMemoryLocationRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMemoryLocationRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateMemoryLocationRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CreateMemoryLocationRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateMemoryLocationRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateMemoryLocationRequestBody";
        };

        return CreateMemoryLocationRequestBody;
    })();

    ptsl.CreateMemoryLocationResponseBody = (function() {

        /**
         * Properties of a CreateMemoryLocationResponseBody.
         * @memberof ptsl
         * @interface ICreateMemoryLocationResponseBody
         */

        /**
         * Constructs a new CreateMemoryLocationResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateMemoryLocation response data.
         * @implements ICreateMemoryLocationResponseBody
         * @constructor
         * @param {ptsl.ICreateMemoryLocationResponseBody=} [properties] Properties to set
         */
        function CreateMemoryLocationResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CreateMemoryLocationResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {ptsl.ICreateMemoryLocationResponseBody=} [properties] Properties to set
         * @returns {ptsl.CreateMemoryLocationResponseBody} CreateMemoryLocationResponseBody instance
         */
        CreateMemoryLocationResponseBody.create = function create(properties) {
            return new CreateMemoryLocationResponseBody(properties);
        };

        /**
         * Encodes the specified CreateMemoryLocationResponseBody message. Does not implicitly {@link ptsl.CreateMemoryLocationResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {ptsl.ICreateMemoryLocationResponseBody} message CreateMemoryLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMemoryLocationResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CreateMemoryLocationResponseBody message, length delimited. Does not implicitly {@link ptsl.CreateMemoryLocationResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {ptsl.ICreateMemoryLocationResponseBody} message CreateMemoryLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMemoryLocationResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMemoryLocationResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateMemoryLocationResponseBody} CreateMemoryLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMemoryLocationResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateMemoryLocationResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMemoryLocationResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateMemoryLocationResponseBody} CreateMemoryLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMemoryLocationResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMemoryLocationResponseBody message.
         * @function verify
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMemoryLocationResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a CreateMemoryLocationResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateMemoryLocationResponseBody} CreateMemoryLocationResponseBody
         */
        CreateMemoryLocationResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateMemoryLocationResponseBody)
                return object;
            return new $root.ptsl.CreateMemoryLocationResponseBody();
        };

        /**
         * Creates a plain object from a CreateMemoryLocationResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {ptsl.CreateMemoryLocationResponseBody} message CreateMemoryLocationResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMemoryLocationResponseBody.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CreateMemoryLocationResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMemoryLocationResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateMemoryLocationResponseBody
         * @function getTypeUrl
         * @memberof ptsl.CreateMemoryLocationResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateMemoryLocationResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateMemoryLocationResponseBody";
        };

        return CreateMemoryLocationResponseBody;
    })();

    ptsl.GetMemoryLocationsRequestBody = (function() {

        /**
         * Properties of a GetMemoryLocationsRequestBody.
         * @memberof ptsl
         * @interface IGetMemoryLocationsRequestBody
         * @property {ptsl.IPaginationRequest|null} [paginationRequest] * Enable pagination and control limit and offset
         * * @since Pro Tools 2023.12
         */

        /**
         * Constructs a new GetMemoryLocationsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetMemoryLocations request data.
         * @implements IGetMemoryLocationsRequestBody
         * @constructor
         * @param {ptsl.IGetMemoryLocationsRequestBody=} [properties] Properties to set
         */
        function GetMemoryLocationsRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Enable pagination and control limit and offset
         * * @since Pro Tools 2023.12
         * @member {ptsl.IPaginationRequest|null|undefined} paginationRequest
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @instance
         */
        GetMemoryLocationsRequestBody.prototype.paginationRequest = null;

        /**
         * Creates a new GetMemoryLocationsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {ptsl.IGetMemoryLocationsRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetMemoryLocationsRequestBody} GetMemoryLocationsRequestBody instance
         */
        GetMemoryLocationsRequestBody.create = function create(properties) {
            return new GetMemoryLocationsRequestBody(properties);
        };

        /**
         * Encodes the specified GetMemoryLocationsRequestBody message. Does not implicitly {@link ptsl.GetMemoryLocationsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {ptsl.IGetMemoryLocationsRequestBody} message GetMemoryLocationsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMemoryLocationsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paginationRequest != null && Object.hasOwnProperty.call(message, "paginationRequest"))
                $root.ptsl.PaginationRequest.encode(message.paginationRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetMemoryLocationsRequestBody message, length delimited. Does not implicitly {@link ptsl.GetMemoryLocationsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {ptsl.IGetMemoryLocationsRequestBody} message GetMemoryLocationsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMemoryLocationsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMemoryLocationsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetMemoryLocationsRequestBody} GetMemoryLocationsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMemoryLocationsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetMemoryLocationsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.paginationRequest = $root.ptsl.PaginationRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMemoryLocationsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetMemoryLocationsRequestBody} GetMemoryLocationsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMemoryLocationsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMemoryLocationsRequestBody message.
         * @function verify
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMemoryLocationsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest")) {
                var error = $root.ptsl.PaginationRequest.verify(message.paginationRequest);
                if (error)
                    return "paginationRequest." + error;
            }
            return null;
        };

        /**
         * Creates a GetMemoryLocationsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetMemoryLocationsRequestBody} GetMemoryLocationsRequestBody
         */
        GetMemoryLocationsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetMemoryLocationsRequestBody)
                return object;
            var message = new $root.ptsl.GetMemoryLocationsRequestBody();
            if (object.paginationRequest != null) {
                if (typeof object.paginationRequest !== "object")
                    throw TypeError(".ptsl.GetMemoryLocationsRequestBody.paginationRequest: object expected");
                message.paginationRequest = $root.ptsl.PaginationRequest.fromObject(object.paginationRequest);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetMemoryLocationsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {ptsl.GetMemoryLocationsRequestBody} message GetMemoryLocationsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMemoryLocationsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.paginationRequest = null;
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest"))
                object.paginationRequest = $root.ptsl.PaginationRequest.toObject(message.paginationRequest, options);
            return object;
        };

        /**
         * Converts this GetMemoryLocationsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMemoryLocationsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetMemoryLocationsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetMemoryLocationsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMemoryLocationsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetMemoryLocationsRequestBody";
        };

        return GetMemoryLocationsRequestBody;
    })();

    ptsl.GetMemoryLocationsResponseBody = (function() {

        /**
         * Properties of a GetMemoryLocationsResponseBody.
         * @memberof ptsl
         * @interface IGetMemoryLocationsResponseBody
         * @property {Array.<ptsl.IMemoryLocation>|null} [memoryLocations] GetMemoryLocationsResponseBody memoryLocations
         * @property {ptsl.IPagination|null} [stats] * @deprecated since Pro Tools 2023.09, use pagination_response
         * @property {ptsl.IPaginationResponse|null} [paginationResponse] * @since Pro Tools 2023.12
         */

        /**
         * Constructs a new GetMemoryLocationsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetMemoryLocations response data.
         * @implements IGetMemoryLocationsResponseBody
         * @constructor
         * @param {ptsl.IGetMemoryLocationsResponseBody=} [properties] Properties to set
         */
        function GetMemoryLocationsResponseBody(properties) {
            this.memoryLocations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMemoryLocationsResponseBody memoryLocations.
         * @member {Array.<ptsl.IMemoryLocation>} memoryLocations
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @instance
         */
        GetMemoryLocationsResponseBody.prototype.memoryLocations = $util.emptyArray;

        /**
         * * @deprecated since Pro Tools 2023.09, use pagination_response
         * @member {ptsl.IPagination|null|undefined} stats
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @instance
         */
        GetMemoryLocationsResponseBody.prototype.stats = null;

        /**
         * * @since Pro Tools 2023.12
         * @member {ptsl.IPaginationResponse|null|undefined} paginationResponse
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @instance
         */
        GetMemoryLocationsResponseBody.prototype.paginationResponse = null;

        /**
         * Creates a new GetMemoryLocationsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {ptsl.IGetMemoryLocationsResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetMemoryLocationsResponseBody} GetMemoryLocationsResponseBody instance
         */
        GetMemoryLocationsResponseBody.create = function create(properties) {
            return new GetMemoryLocationsResponseBody(properties);
        };

        /**
         * Encodes the specified GetMemoryLocationsResponseBody message. Does not implicitly {@link ptsl.GetMemoryLocationsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {ptsl.IGetMemoryLocationsResponseBody} message GetMemoryLocationsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMemoryLocationsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memoryLocations != null && message.memoryLocations.length)
                for (var i = 0; i < message.memoryLocations.length; ++i)
                    $root.ptsl.MemoryLocation.encode(message.memoryLocations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stats != null && Object.hasOwnProperty.call(message, "stats"))
                $root.ptsl.Pagination.encode(message.stats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.paginationResponse != null && Object.hasOwnProperty.call(message, "paginationResponse"))
                $root.ptsl.PaginationResponse.encode(message.paginationResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetMemoryLocationsResponseBody message, length delimited. Does not implicitly {@link ptsl.GetMemoryLocationsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {ptsl.IGetMemoryLocationsResponseBody} message GetMemoryLocationsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMemoryLocationsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMemoryLocationsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetMemoryLocationsResponseBody} GetMemoryLocationsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMemoryLocationsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetMemoryLocationsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.memoryLocations && message.memoryLocations.length))
                            message.memoryLocations = [];
                        message.memoryLocations.push($root.ptsl.MemoryLocation.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.stats = $root.ptsl.Pagination.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.paginationResponse = $root.ptsl.PaginationResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMemoryLocationsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetMemoryLocationsResponseBody} GetMemoryLocationsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMemoryLocationsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMemoryLocationsResponseBody message.
         * @function verify
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMemoryLocationsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.memoryLocations != null && message.hasOwnProperty("memoryLocations")) {
                if (!Array.isArray(message.memoryLocations))
                    return "memoryLocations: array expected";
                for (var i = 0; i < message.memoryLocations.length; ++i) {
                    var error = $root.ptsl.MemoryLocation.verify(message.memoryLocations[i]);
                    if (error)
                        return "memoryLocations." + error;
                }
            }
            if (message.stats != null && message.hasOwnProperty("stats")) {
                var error = $root.ptsl.Pagination.verify(message.stats);
                if (error)
                    return "stats." + error;
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse")) {
                var error = $root.ptsl.PaginationResponse.verify(message.paginationResponse);
                if (error)
                    return "paginationResponse." + error;
            }
            return null;
        };

        /**
         * Creates a GetMemoryLocationsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetMemoryLocationsResponseBody} GetMemoryLocationsResponseBody
         */
        GetMemoryLocationsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetMemoryLocationsResponseBody)
                return object;
            var message = new $root.ptsl.GetMemoryLocationsResponseBody();
            if (object.memoryLocations) {
                if (!Array.isArray(object.memoryLocations))
                    throw TypeError(".ptsl.GetMemoryLocationsResponseBody.memoryLocations: array expected");
                message.memoryLocations = [];
                for (var i = 0; i < object.memoryLocations.length; ++i) {
                    if (typeof object.memoryLocations[i] !== "object")
                        throw TypeError(".ptsl.GetMemoryLocationsResponseBody.memoryLocations: object expected");
                    message.memoryLocations[i] = $root.ptsl.MemoryLocation.fromObject(object.memoryLocations[i]);
                }
            }
            if (object.stats != null) {
                if (typeof object.stats !== "object")
                    throw TypeError(".ptsl.GetMemoryLocationsResponseBody.stats: object expected");
                message.stats = $root.ptsl.Pagination.fromObject(object.stats);
            }
            if (object.paginationResponse != null) {
                if (typeof object.paginationResponse !== "object")
                    throw TypeError(".ptsl.GetMemoryLocationsResponseBody.paginationResponse: object expected");
                message.paginationResponse = $root.ptsl.PaginationResponse.fromObject(object.paginationResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetMemoryLocationsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {ptsl.GetMemoryLocationsResponseBody} message GetMemoryLocationsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMemoryLocationsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.memoryLocations = [];
            if (options.defaults) {
                object.stats = null;
                object.paginationResponse = null;
            }
            if (message.memoryLocations && message.memoryLocations.length) {
                object.memoryLocations = [];
                for (var j = 0; j < message.memoryLocations.length; ++j)
                    object.memoryLocations[j] = $root.ptsl.MemoryLocation.toObject(message.memoryLocations[j], options);
            }
            if (message.stats != null && message.hasOwnProperty("stats"))
                object.stats = $root.ptsl.Pagination.toObject(message.stats, options);
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse"))
                object.paginationResponse = $root.ptsl.PaginationResponse.toObject(message.paginationResponse, options);
            return object;
        };

        /**
         * Converts this GetMemoryLocationsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMemoryLocationsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetMemoryLocationsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetMemoryLocationsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMemoryLocationsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetMemoryLocationsResponseBody";
        };

        return GetMemoryLocationsResponseBody;
    })();

    ptsl.RegisterConnectionRequestBody = (function() {

        /**
         * Properties of a RegisterConnectionRequestBody.
         * @memberof ptsl
         * @interface IRegisterConnectionRequestBody
         * @property {string|null} [companyName] * The name of the company to which the application belongs.
         * @property {string|null} [applicationName] * The name of the application that is registering the connection.
         */

        /**
         * Constructs a new RegisterConnectionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes RegisterConnection request data.
         * @implements IRegisterConnectionRequestBody
         * @constructor
         * @param {ptsl.IRegisterConnectionRequestBody=} [properties] Properties to set
         */
        function RegisterConnectionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The name of the company to which the application belongs.
         * @member {string} companyName
         * @memberof ptsl.RegisterConnectionRequestBody
         * @instance
         */
        RegisterConnectionRequestBody.prototype.companyName = "";

        /**
         * * The name of the application that is registering the connection.
         * @member {string} applicationName
         * @memberof ptsl.RegisterConnectionRequestBody
         * @instance
         */
        RegisterConnectionRequestBody.prototype.applicationName = "";

        /**
         * Creates a new RegisterConnectionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {ptsl.IRegisterConnectionRequestBody=} [properties] Properties to set
         * @returns {ptsl.RegisterConnectionRequestBody} RegisterConnectionRequestBody instance
         */
        RegisterConnectionRequestBody.create = function create(properties) {
            return new RegisterConnectionRequestBody(properties);
        };

        /**
         * Encodes the specified RegisterConnectionRequestBody message. Does not implicitly {@link ptsl.RegisterConnectionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {ptsl.IRegisterConnectionRequestBody} message RegisterConnectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterConnectionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.companyName != null && Object.hasOwnProperty.call(message, "companyName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.companyName);
            if (message.applicationName != null && Object.hasOwnProperty.call(message, "applicationName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.applicationName);
            return writer;
        };

        /**
         * Encodes the specified RegisterConnectionRequestBody message, length delimited. Does not implicitly {@link ptsl.RegisterConnectionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {ptsl.IRegisterConnectionRequestBody} message RegisterConnectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterConnectionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterConnectionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RegisterConnectionRequestBody} RegisterConnectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterConnectionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RegisterConnectionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.companyName = reader.string();
                        break;
                    }
                case 2: {
                        message.applicationName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterConnectionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RegisterConnectionRequestBody} RegisterConnectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterConnectionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterConnectionRequestBody message.
         * @function verify
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterConnectionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                if (!$util.isString(message.companyName))
                    return "companyName: string expected";
            if (message.applicationName != null && message.hasOwnProperty("applicationName"))
                if (!$util.isString(message.applicationName))
                    return "applicationName: string expected";
            return null;
        };

        /**
         * Creates a RegisterConnectionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RegisterConnectionRequestBody} RegisterConnectionRequestBody
         */
        RegisterConnectionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RegisterConnectionRequestBody)
                return object;
            var message = new $root.ptsl.RegisterConnectionRequestBody();
            if (object.companyName != null)
                message.companyName = String(object.companyName);
            if (object.applicationName != null)
                message.applicationName = String(object.applicationName);
            return message;
        };

        /**
         * Creates a plain object from a RegisterConnectionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {ptsl.RegisterConnectionRequestBody} message RegisterConnectionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterConnectionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.companyName = "";
                object.applicationName = "";
            }
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                object.companyName = message.companyName;
            if (message.applicationName != null && message.hasOwnProperty("applicationName"))
                object.applicationName = message.applicationName;
            return object;
        };

        /**
         * Converts this RegisterConnectionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RegisterConnectionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterConnectionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RegisterConnectionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RegisterConnectionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RegisterConnectionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RegisterConnectionRequestBody";
        };

        return RegisterConnectionRequestBody;
    })();

    ptsl.RegisterConnectionResponseBody = (function() {

        /**
         * Properties of a RegisterConnectionResponseBody.
         * @memberof ptsl
         * @interface IRegisterConnectionResponseBody
         * @property {string|null} [sessionId] * The unique identifier for the PTSL connection. Please don't confuse it with Pro Tools sessions.
         */

        /**
         * Constructs a new RegisterConnectionResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes RegisterConnection response data.
         * @implements IRegisterConnectionResponseBody
         * @constructor
         * @param {ptsl.IRegisterConnectionResponseBody=} [properties] Properties to set
         */
        function RegisterConnectionResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The unique identifier for the PTSL connection. Please don't confuse it with Pro Tools sessions.
         * @member {string} sessionId
         * @memberof ptsl.RegisterConnectionResponseBody
         * @instance
         */
        RegisterConnectionResponseBody.prototype.sessionId = "";

        /**
         * Creates a new RegisterConnectionResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {ptsl.IRegisterConnectionResponseBody=} [properties] Properties to set
         * @returns {ptsl.RegisterConnectionResponseBody} RegisterConnectionResponseBody instance
         */
        RegisterConnectionResponseBody.create = function create(properties) {
            return new RegisterConnectionResponseBody(properties);
        };

        /**
         * Encodes the specified RegisterConnectionResponseBody message. Does not implicitly {@link ptsl.RegisterConnectionResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {ptsl.IRegisterConnectionResponseBody} message RegisterConnectionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterConnectionResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
            return writer;
        };

        /**
         * Encodes the specified RegisterConnectionResponseBody message, length delimited. Does not implicitly {@link ptsl.RegisterConnectionResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {ptsl.IRegisterConnectionResponseBody} message RegisterConnectionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterConnectionResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterConnectionResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RegisterConnectionResponseBody} RegisterConnectionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterConnectionResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RegisterConnectionResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sessionId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterConnectionResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RegisterConnectionResponseBody} RegisterConnectionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterConnectionResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterConnectionResponseBody message.
         * @function verify
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterConnectionResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                if (!$util.isString(message.sessionId))
                    return "sessionId: string expected";
            return null;
        };

        /**
         * Creates a RegisterConnectionResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RegisterConnectionResponseBody} RegisterConnectionResponseBody
         */
        RegisterConnectionResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RegisterConnectionResponseBody)
                return object;
            var message = new $root.ptsl.RegisterConnectionResponseBody();
            if (object.sessionId != null)
                message.sessionId = String(object.sessionId);
            return message;
        };

        /**
         * Creates a plain object from a RegisterConnectionResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {ptsl.RegisterConnectionResponseBody} message RegisterConnectionResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterConnectionResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionId = "";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                object.sessionId = message.sessionId;
            return object;
        };

        /**
         * Converts this RegisterConnectionResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.RegisterConnectionResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterConnectionResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RegisterConnectionResponseBody
         * @function getTypeUrl
         * @memberof ptsl.RegisterConnectionResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RegisterConnectionResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RegisterConnectionResponseBody";
        };

        return RegisterConnectionResponseBody;
    })();

    /**
     * Enumeration that describes the position of the insertion point for a track.
     * 
     * @since Pro Tools 2024.06
     * @name ptsl.TrackInsertionPoint
     * @enum {number}
     * @property {number} TIPoint_Unknown=0 * Default value, the insertion point is determined by Pro Tools.
     * @property {number} TIPoint_Before=1 * The insertion point is before the specified track.
     * @property {number} TIPoint_After=2 * The insertion point is after the specified track.
     * @property {number} TIPoint_First=3 * The insertion point is either the first track in the session or the first member track of the specified folder track.
     * @property {number} TIPoint_Last=4 * The insertion point is either the last track in the session or the last member track of the specified folder track.
     */
    ptsl.TrackInsertionPoint = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TIPoint_Unknown"] = 0;
        values[valuesById[1] = "TIPoint_Before"] = 1;
        values[valuesById[2] = "TIPoint_After"] = 2;
        values[valuesById[3] = "TIPoint_First"] = 3;
        values[valuesById[4] = "TIPoint_Last"] = 4;
        return values;
    })();

    ptsl.CreateNewTracksRequestBody = (function() {

        /**
         * Properties of a CreateNewTracksRequestBody.
         * @memberof ptsl
         * @interface ICreateNewTracksRequestBody
         * @property {number|null} [numberOfTracks] CreateNewTracksRequestBody numberOfTracks
         * @property {string|null} [trackName] CreateNewTracksRequestBody trackName
         * @property {ptsl.TrackFormat|null} [trackFormat] CreateNewTracksRequestBody trackFormat
         * @property {ptsl.TrackType|null} [trackType] CreateNewTracksRequestBody trackType
         * @property {ptsl.TrackTimebase|null} [trackTimebase] CreateNewTracksRequestBody trackTimebase
         * @property {ptsl.IPaginationRequest|null} [paginationRequest] * Non-default pagination_request values can be used to limit the response (CreateNewTracksResponseBody.created_track_names)
         * *
         * * @since Pro Tools 2024.06
         * @property {ptsl.TrackInsertionPoint|null} [insertionPointPosition] * @since Pro Tools 2024.06
         * @property {string|null} [insertionPointTrackName] * @since Pro Tools 2024.06
         */

        /**
         * Constructs a new CreateNewTracksRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateNewTracks request data.
         * @implements ICreateNewTracksRequestBody
         * @constructor
         * @param {ptsl.ICreateNewTracksRequestBody=} [properties] Properties to set
         */
        function CreateNewTracksRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateNewTracksRequestBody numberOfTracks.
         * @member {number} numberOfTracks
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.numberOfTracks = 0;

        /**
         * CreateNewTracksRequestBody trackName.
         * @member {string} trackName
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.trackName = "";

        /**
         * CreateNewTracksRequestBody trackFormat.
         * @member {ptsl.TrackFormat} trackFormat
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.trackFormat = 0;

        /**
         * CreateNewTracksRequestBody trackType.
         * @member {ptsl.TrackType} trackType
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.trackType = 0;

        /**
         * CreateNewTracksRequestBody trackTimebase.
         * @member {ptsl.TrackTimebase} trackTimebase
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.trackTimebase = 0;

        /**
         * * Non-default pagination_request values can be used to limit the response (CreateNewTracksResponseBody.created_track_names)
         * *
         * * @since Pro Tools 2024.06
         * @member {ptsl.IPaginationRequest|null|undefined} paginationRequest
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.paginationRequest = null;

        /**
         * * @since Pro Tools 2024.06
         * @member {ptsl.TrackInsertionPoint} insertionPointPosition
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.insertionPointPosition = 0;

        /**
         * * @since Pro Tools 2024.06
         * @member {string} insertionPointTrackName
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         */
        CreateNewTracksRequestBody.prototype.insertionPointTrackName = "";

        /**
         * Creates a new CreateNewTracksRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {ptsl.ICreateNewTracksRequestBody=} [properties] Properties to set
         * @returns {ptsl.CreateNewTracksRequestBody} CreateNewTracksRequestBody instance
         */
        CreateNewTracksRequestBody.create = function create(properties) {
            return new CreateNewTracksRequestBody(properties);
        };

        /**
         * Encodes the specified CreateNewTracksRequestBody message. Does not implicitly {@link ptsl.CreateNewTracksRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {ptsl.ICreateNewTracksRequestBody} message CreateNewTracksRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateNewTracksRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numberOfTracks != null && Object.hasOwnProperty.call(message, "numberOfTracks"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.numberOfTracks);
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.trackName);
            if (message.trackFormat != null && Object.hasOwnProperty.call(message, "trackFormat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trackFormat);
            if (message.trackType != null && Object.hasOwnProperty.call(message, "trackType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.trackType);
            if (message.trackTimebase != null && Object.hasOwnProperty.call(message, "trackTimebase"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.trackTimebase);
            if (message.paginationRequest != null && Object.hasOwnProperty.call(message, "paginationRequest"))
                $root.ptsl.PaginationRequest.encode(message.paginationRequest, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.insertionPointPosition != null && Object.hasOwnProperty.call(message, "insertionPointPosition"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.insertionPointPosition);
            if (message.insertionPointTrackName != null && Object.hasOwnProperty.call(message, "insertionPointTrackName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.insertionPointTrackName);
            return writer;
        };

        /**
         * Encodes the specified CreateNewTracksRequestBody message, length delimited. Does not implicitly {@link ptsl.CreateNewTracksRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {ptsl.ICreateNewTracksRequestBody} message CreateNewTracksRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateNewTracksRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateNewTracksRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateNewTracksRequestBody} CreateNewTracksRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateNewTracksRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateNewTracksRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.numberOfTracks = reader.int32();
                        break;
                    }
                case 2: {
                        message.trackName = reader.string();
                        break;
                    }
                case 3: {
                        message.trackFormat = reader.int32();
                        break;
                    }
                case 4: {
                        message.trackType = reader.int32();
                        break;
                    }
                case 5: {
                        message.trackTimebase = reader.int32();
                        break;
                    }
                case 6: {
                        message.paginationRequest = $root.ptsl.PaginationRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.insertionPointPosition = reader.int32();
                        break;
                    }
                case 8: {
                        message.insertionPointTrackName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateNewTracksRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateNewTracksRequestBody} CreateNewTracksRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateNewTracksRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateNewTracksRequestBody message.
         * @function verify
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateNewTracksRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numberOfTracks != null && message.hasOwnProperty("numberOfTracks"))
                if (!$util.isInteger(message.numberOfTracks))
                    return "numberOfTracks: integer expected";
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            if (message.trackFormat != null && message.hasOwnProperty("trackFormat"))
                switch (message.trackFormat) {
                default:
                    return "trackFormat: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                case 20:
                case 20:
                case 21:
                case 21:
                case 22:
                case 22:
                case 23:
                case 23:
                case 24:
                case 24:
                case 25:
                case 25:
                case 26:
                case 26:
                case 27:
                case 27:
                case 28:
                case 28:
                case 29:
                case 29:
                case 30:
                case 30:
                case 31:
                case 31:
                case 32:
                case 32:
                case 33:
                case 33:
                case 34:
                case 34:
                case 35:
                case 35:
                case 36:
                case 36:
                case 37:
                case 37:
                    break;
                }
            if (message.trackType != null && message.hasOwnProperty("trackType"))
                switch (message.trackType) {
                default:
                    return "trackType: enum value expected";
                case 0:
                case 0:
                case 0:
                case 1:
                case 1:
                case 1:
                case 2:
                case 2:
                case 2:
                case 3:
                case 3:
                case 3:
                case 4:
                case 4:
                case 4:
                case 5:
                case 5:
                case 5:
                case 6:
                case 6:
                case 6:
                case 7:
                case 7:
                case 7:
                case 8:
                case 8:
                case 8:
                case 9:
                case 9:
                case 9:
                case 10:
                case 10:
                case 10:
                case 11:
                case 11:
                case 11:
                case 12:
                case 12:
                case 12:
                case 13:
                case 13:
                case 13:
                case 14:
                case 14:
                case 14:
                case 15:
                case 15:
                case 15:
                case 16:
                case 16:
                case 16:
                    break;
                }
            if (message.trackTimebase != null && message.hasOwnProperty("trackTimebase"))
                switch (message.trackTimebase) {
                default:
                    return "trackTimebase: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest")) {
                var error = $root.ptsl.PaginationRequest.verify(message.paginationRequest);
                if (error)
                    return "paginationRequest." + error;
            }
            if (message.insertionPointPosition != null && message.hasOwnProperty("insertionPointPosition"))
                switch (message.insertionPointPosition) {
                default:
                    return "insertionPointPosition: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.insertionPointTrackName != null && message.hasOwnProperty("insertionPointTrackName"))
                if (!$util.isString(message.insertionPointTrackName))
                    return "insertionPointTrackName: string expected";
            return null;
        };

        /**
         * Creates a CreateNewTracksRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateNewTracksRequestBody} CreateNewTracksRequestBody
         */
        CreateNewTracksRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateNewTracksRequestBody)
                return object;
            var message = new $root.ptsl.CreateNewTracksRequestBody();
            if (object.numberOfTracks != null)
                message.numberOfTracks = object.numberOfTracks | 0;
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            switch (object.trackFormat) {
            default:
                if (typeof object.trackFormat === "number") {
                    message.trackFormat = object.trackFormat;
                    break;
                }
                break;
            case "TF_Unknown":
            case 0:
                message.trackFormat = 0;
                break;
            case "TFormat_Unknown":
            case 0:
                message.trackFormat = 0;
                break;
            case "TF_Mono":
            case 1:
                message.trackFormat = 1;
                break;
            case "TFormat_Mono":
            case 1:
                message.trackFormat = 1;
                break;
            case "TF_Stereo":
            case 2:
                message.trackFormat = 2;
                break;
            case "TFormat_Stereo":
            case 2:
                message.trackFormat = 2;
                break;
            case "TF_LCR":
            case 3:
                message.trackFormat = 3;
                break;
            case "TFormat_LCR":
            case 3:
                message.trackFormat = 3;
                break;
            case "TF_LCRS":
            case 4:
                message.trackFormat = 4;
                break;
            case "TFormat_LCRS":
            case 4:
                message.trackFormat = 4;
                break;
            case "TF_Quad":
            case 5:
                message.trackFormat = 5;
                break;
            case "TFormat_Quad":
            case 5:
                message.trackFormat = 5;
                break;
            case "TF_5_0":
            case 6:
                message.trackFormat = 6;
                break;
            case "TFormat_5_0":
            case 6:
                message.trackFormat = 6;
                break;
            case "TF_5_1":
            case 7:
                message.trackFormat = 7;
                break;
            case "TFormat_5_1":
            case 7:
                message.trackFormat = 7;
                break;
            case "TF_5_0_2":
            case 8:
                message.trackFormat = 8;
                break;
            case "TFormat_5_0_2":
            case 8:
                message.trackFormat = 8;
                break;
            case "TF_5_1_2":
            case 9:
                message.trackFormat = 9;
                break;
            case "TFormat_5_1_2":
            case 9:
                message.trackFormat = 9;
                break;
            case "TF_5_0_4":
            case 10:
                message.trackFormat = 10;
                break;
            case "TFormat_5_0_4":
            case 10:
                message.trackFormat = 10;
                break;
            case "TF_5_1_4":
            case 11:
                message.trackFormat = 11;
                break;
            case "TFormat_5_1_4":
            case 11:
                message.trackFormat = 11;
                break;
            case "TF_6_0":
            case 12:
                message.trackFormat = 12;
                break;
            case "TFormat_6_0":
            case 12:
                message.trackFormat = 12;
                break;
            case "TF_6_1":
            case 13:
                message.trackFormat = 13;
                break;
            case "TFormat_6_1":
            case 13:
                message.trackFormat = 13;
                break;
            case "TF_7_0":
            case 14:
                message.trackFormat = 14;
                break;
            case "TFormat_7_0":
            case 14:
                message.trackFormat = 14;
                break;
            case "TF_7_1":
            case 15:
                message.trackFormat = 15;
                break;
            case "TFormat_7_1":
            case 15:
                message.trackFormat = 15;
                break;
            case "TF_7_0_SDDS":
            case 16:
                message.trackFormat = 16;
                break;
            case "TFormat_7_0_SDDS":
            case 16:
                message.trackFormat = 16;
                break;
            case "TF_7_1_SDDS":
            case 17:
                message.trackFormat = 17;
                break;
            case "TFormat_7_1_SDDS":
            case 17:
                message.trackFormat = 17;
                break;
            case "TF_7_0_2":
            case 18:
                message.trackFormat = 18;
                break;
            case "TFormat_7_0_2":
            case 18:
                message.trackFormat = 18;
                break;
            case "TF_7_1_2":
            case 19:
                message.trackFormat = 19;
                break;
            case "TFormat_7_1_2":
            case 19:
                message.trackFormat = 19;
                break;
            case "TF_7_0_4":
            case 20:
                message.trackFormat = 20;
                break;
            case "TFormat_7_0_4":
            case 20:
                message.trackFormat = 20;
                break;
            case "TF_7_1_4":
            case 21:
                message.trackFormat = 21;
                break;
            case "TFormat_7_1_4":
            case 21:
                message.trackFormat = 21;
                break;
            case "TF_7_0_6":
            case 22:
                message.trackFormat = 22;
                break;
            case "TFormat_7_0_6":
            case 22:
                message.trackFormat = 22;
                break;
            case "TF_7_1_6":
            case 23:
                message.trackFormat = 23;
                break;
            case "TFormat_7_1_6":
            case 23:
                message.trackFormat = 23;
                break;
            case "TF_9_0_4":
            case 24:
                message.trackFormat = 24;
                break;
            case "TFormat_9_0_4":
            case 24:
                message.trackFormat = 24;
                break;
            case "TF_9_1_4":
            case 25:
                message.trackFormat = 25;
                break;
            case "TFormat_9_1_4":
            case 25:
                message.trackFormat = 25;
                break;
            case "TF_9_0_6":
            case 26:
                message.trackFormat = 26;
                break;
            case "TFormat_9_0_6":
            case 26:
                message.trackFormat = 26;
                break;
            case "TF_9_1_6":
            case 27:
                message.trackFormat = 27;
                break;
            case "TFormat_9_1_6":
            case 27:
                message.trackFormat = 27;
                break;
            case "TF_1stOrderAmbisonics":
            case 28:
                message.trackFormat = 28;
                break;
            case "TFormat_1stOrderAmbisonics":
            case 28:
                message.trackFormat = 28;
                break;
            case "TF_2ndOrderAmbisonics":
            case 29:
                message.trackFormat = 29;
                break;
            case "TFormat_2ndOrderAmbisonics":
            case 29:
                message.trackFormat = 29;
                break;
            case "TF_3rdOrderAmbisonics":
            case 30:
                message.trackFormat = 30;
                break;
            case "TFormat_3rdOrderAmbisonics":
            case 30:
                message.trackFormat = 30;
                break;
            case "TF_4thOrderAmbisonics":
            case 31:
                message.trackFormat = 31;
                break;
            case "TFormat_4thOrderAmbisonics":
            case 31:
                message.trackFormat = 31;
                break;
            case "TF_5thOrderAmbisonics":
            case 32:
                message.trackFormat = 32;
                break;
            case "TFormat_5thOrderAmbisonics":
            case 32:
                message.trackFormat = 32;
                break;
            case "TF_6thOrderAmbisonics":
            case 33:
                message.trackFormat = 33;
                break;
            case "TFormat_6thOrderAmbisonics":
            case 33:
                message.trackFormat = 33;
                break;
            case "TF_7thOrderAmbisonics":
            case 34:
                message.trackFormat = 34;
                break;
            case "TFormat_7thOrderAmbisonics":
            case 34:
                message.trackFormat = 34;
                break;
            case "TF_None":
            case 35:
                message.trackFormat = 35;
                break;
            case "TFormat_None":
            case 35:
                message.trackFormat = 35;
                break;
            case "TF_2_1":
            case 36:
                message.trackFormat = 36;
                break;
            case "TFormat_2_1":
            case 36:
                message.trackFormat = 36;
                break;
            case "TF_Overhead":
            case 37:
                message.trackFormat = 37;
                break;
            case "TFormat_Overhead":
            case 37:
                message.trackFormat = 37;
                break;
            }
            switch (object.trackType) {
            default:
                if (typeof object.trackType === "number") {
                    message.trackType = object.trackType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.trackType = 0;
                break;
            case "TT_Unknown":
            case 0:
                message.trackType = 0;
                break;
            case "TType_Unknown":
            case 0:
                message.trackType = 0;
                break;
            case "Midi":
            case 1:
                message.trackType = 1;
                break;
            case "TT_Midi":
            case 1:
                message.trackType = 1;
                break;
            case "TType_Midi":
            case 1:
                message.trackType = 1;
                break;
            case "AudioTrack":
            case 2:
                message.trackType = 2;
                break;
            case "TT_Audio":
            case 2:
                message.trackType = 2;
                break;
            case "TType_Audio":
            case 2:
                message.trackType = 2;
                break;
            case "Aux":
            case 3:
                message.trackType = 3;
                break;
            case "TT_Aux":
            case 3:
                message.trackType = 3;
                break;
            case "TType_Aux":
            case 3:
                message.trackType = 3;
                break;
            case "VideoTrack":
            case 4:
                message.trackType = 4;
                break;
            case "TT_Video":
            case 4:
                message.trackType = 4;
                break;
            case "TType_Video":
            case 4:
                message.trackType = 4;
                break;
            case "Vca":
            case 5:
                message.trackType = 5;
                break;
            case "TT_Vca":
            case 5:
                message.trackType = 5;
                break;
            case "TType_Vca":
            case 5:
                message.trackType = 5;
                break;
            case "Tempo":
            case 6:
                message.trackType = 6;
                break;
            case "TT_Tempo":
            case 6:
                message.trackType = 6;
                break;
            case "TType_Tempo":
            case 6:
                message.trackType = 6;
                break;
            case "Markers":
            case 7:
                message.trackType = 7;
                break;
            case "TT_Markers":
            case 7:
                message.trackType = 7;
                break;
            case "TType_Markers":
            case 7:
                message.trackType = 7;
                break;
            case "Meter":
            case 8:
                message.trackType = 8;
                break;
            case "TT_Meter":
            case 8:
                message.trackType = 8;
                break;
            case "TType_Meter":
            case 8:
                message.trackType = 8;
                break;
            case "KeySignature":
            case 9:
                message.trackType = 9;
                break;
            case "TT_KeySignature":
            case 9:
                message.trackType = 9;
                break;
            case "TType_KeySignature":
            case 9:
                message.trackType = 9;
                break;
            case "ChordSymbols":
            case 10:
                message.trackType = 10;
                break;
            case "TT_ChordSymbols":
            case 10:
                message.trackType = 10;
                break;
            case "TType_ChordSymbols":
            case 10:
                message.trackType = 10;
                break;
            case "Instrument":
            case 11:
                message.trackType = 11;
                break;
            case "TT_Instrument":
            case 11:
                message.trackType = 11;
                break;
            case "TType_Instrument":
            case 11:
                message.trackType = 11;
                break;
            case "Master":
            case 12:
                message.trackType = 12;
                break;
            case "TT_Master":
            case 12:
                message.trackType = 12;
                break;
            case "TType_Master":
            case 12:
                message.trackType = 12;
                break;
            case "Heat":
            case 13:
                message.trackType = 13;
                break;
            case "TT_Heat":
            case 13:
                message.trackType = 13;
                break;
            case "TType_Heat":
            case 13:
                message.trackType = 13;
                break;
            case "BasicFolder":
            case 14:
                message.trackType = 14;
                break;
            case "TT_BasicFolder":
            case 14:
                message.trackType = 14;
                break;
            case "TType_BasicFolder":
            case 14:
                message.trackType = 14;
                break;
            case "RoutingFolder":
            case 15:
                message.trackType = 15;
                break;
            case "TT_RoutingFolder":
            case 15:
                message.trackType = 15;
                break;
            case "TType_RoutingFolder":
            case 15:
                message.trackType = 15;
                break;
            case "CompLane":
            case 16:
                message.trackType = 16;
                break;
            case "TT_CompLane":
            case 16:
                message.trackType = 16;
                break;
            case "TType_CompLane":
            case 16:
                message.trackType = 16;
                break;
            }
            switch (object.trackTimebase) {
            default:
                if (typeof object.trackTimebase === "number") {
                    message.trackTimebase = object.trackTimebase;
                    break;
                }
                break;
            case "TTB_Unknown":
            case 0:
                message.trackTimebase = 0;
                break;
            case "TTimebase_Unknown":
            case 0:
                message.trackTimebase = 0;
                break;
            case "TTB_Samples":
            case 1:
                message.trackTimebase = 1;
                break;
            case "TTimebase_Samples":
            case 1:
                message.trackTimebase = 1;
                break;
            case "TTB_Ticks":
            case 2:
                message.trackTimebase = 2;
                break;
            case "TTimebase_Ticks":
            case 2:
                message.trackTimebase = 2;
                break;
            case "TTB_None":
            case 3:
                message.trackTimebase = 3;
                break;
            case "TTimebase_None":
            case 3:
                message.trackTimebase = 3;
                break;
            }
            if (object.paginationRequest != null) {
                if (typeof object.paginationRequest !== "object")
                    throw TypeError(".ptsl.CreateNewTracksRequestBody.paginationRequest: object expected");
                message.paginationRequest = $root.ptsl.PaginationRequest.fromObject(object.paginationRequest);
            }
            switch (object.insertionPointPosition) {
            default:
                if (typeof object.insertionPointPosition === "number") {
                    message.insertionPointPosition = object.insertionPointPosition;
                    break;
                }
                break;
            case "TIPoint_Unknown":
            case 0:
                message.insertionPointPosition = 0;
                break;
            case "TIPoint_Before":
            case 1:
                message.insertionPointPosition = 1;
                break;
            case "TIPoint_After":
            case 2:
                message.insertionPointPosition = 2;
                break;
            case "TIPoint_First":
            case 3:
                message.insertionPointPosition = 3;
                break;
            case "TIPoint_Last":
            case 4:
                message.insertionPointPosition = 4;
                break;
            }
            if (object.insertionPointTrackName != null)
                message.insertionPointTrackName = String(object.insertionPointTrackName);
            return message;
        };

        /**
         * Creates a plain object from a CreateNewTracksRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {ptsl.CreateNewTracksRequestBody} message CreateNewTracksRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateNewTracksRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.numberOfTracks = 0;
                object.trackName = "";
                object.trackFormat = options.enums === String ? "TF_Unknown" : 0;
                object.trackType = options.enums === String ? "Unknown" : 0;
                object.trackTimebase = options.enums === String ? "TTB_Unknown" : 0;
                object.paginationRequest = null;
                object.insertionPointPosition = options.enums === String ? "TIPoint_Unknown" : 0;
                object.insertionPointTrackName = "";
            }
            if (message.numberOfTracks != null && message.hasOwnProperty("numberOfTracks"))
                object.numberOfTracks = message.numberOfTracks;
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            if (message.trackFormat != null && message.hasOwnProperty("trackFormat"))
                object.trackFormat = options.enums === String ? $root.ptsl.TrackFormat[message.trackFormat] === undefined ? message.trackFormat : $root.ptsl.TrackFormat[message.trackFormat] : message.trackFormat;
            if (message.trackType != null && message.hasOwnProperty("trackType"))
                object.trackType = options.enums === String ? $root.ptsl.TrackType[message.trackType] === undefined ? message.trackType : $root.ptsl.TrackType[message.trackType] : message.trackType;
            if (message.trackTimebase != null && message.hasOwnProperty("trackTimebase"))
                object.trackTimebase = options.enums === String ? $root.ptsl.TrackTimebase[message.trackTimebase] === undefined ? message.trackTimebase : $root.ptsl.TrackTimebase[message.trackTimebase] : message.trackTimebase;
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest"))
                object.paginationRequest = $root.ptsl.PaginationRequest.toObject(message.paginationRequest, options);
            if (message.insertionPointPosition != null && message.hasOwnProperty("insertionPointPosition"))
                object.insertionPointPosition = options.enums === String ? $root.ptsl.TrackInsertionPoint[message.insertionPointPosition] === undefined ? message.insertionPointPosition : $root.ptsl.TrackInsertionPoint[message.insertionPointPosition] : message.insertionPointPosition;
            if (message.insertionPointTrackName != null && message.hasOwnProperty("insertionPointTrackName"))
                object.insertionPointTrackName = message.insertionPointTrackName;
            return object;
        };

        /**
         * Converts this CreateNewTracksRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateNewTracksRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateNewTracksRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateNewTracksRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CreateNewTracksRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateNewTracksRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateNewTracksRequestBody";
        };

        return CreateNewTracksRequestBody;
    })();

    ptsl.CreateNewTracksResponseBody = (function() {

        /**
         * Properties of a CreateNewTracksResponseBody.
         * @memberof ptsl
         * @interface ICreateNewTracksResponseBody
         * @property {number|null} [numberOfTracks] * @deprecated since Pro Tools 2024.06, use created_track_names/pagination_response
         * @property {Array.<string>|null} [createdTrackNames] * @since Pro Tools 2024.06
         * @property {ptsl.IPaginationResponse|null} [paginationResponse] * @since Pro Tools 2024.06
         * @property {Array.<string>|null} [createdTrackIds] * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new CreateNewTracksResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateNewTracks response data.
         * @implements ICreateNewTracksResponseBody
         * @constructor
         * @param {ptsl.ICreateNewTracksResponseBody=} [properties] Properties to set
         */
        function CreateNewTracksResponseBody(properties) {
            this.createdTrackNames = [];
            this.createdTrackIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2024.06, use created_track_names/pagination_response
         * @member {number} numberOfTracks
         * @memberof ptsl.CreateNewTracksResponseBody
         * @instance
         */
        CreateNewTracksResponseBody.prototype.numberOfTracks = 0;

        /**
         * * @since Pro Tools 2024.06
         * @member {Array.<string>} createdTrackNames
         * @memberof ptsl.CreateNewTracksResponseBody
         * @instance
         */
        CreateNewTracksResponseBody.prototype.createdTrackNames = $util.emptyArray;

        /**
         * * @since Pro Tools 2024.06
         * @member {ptsl.IPaginationResponse|null|undefined} paginationResponse
         * @memberof ptsl.CreateNewTracksResponseBody
         * @instance
         */
        CreateNewTracksResponseBody.prototype.paginationResponse = null;

        /**
         * * @since Pro Tools 2025.06
         * @member {Array.<string>} createdTrackIds
         * @memberof ptsl.CreateNewTracksResponseBody
         * @instance
         */
        CreateNewTracksResponseBody.prototype.createdTrackIds = $util.emptyArray;

        /**
         * Creates a new CreateNewTracksResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {ptsl.ICreateNewTracksResponseBody=} [properties] Properties to set
         * @returns {ptsl.CreateNewTracksResponseBody} CreateNewTracksResponseBody instance
         */
        CreateNewTracksResponseBody.create = function create(properties) {
            return new CreateNewTracksResponseBody(properties);
        };

        /**
         * Encodes the specified CreateNewTracksResponseBody message. Does not implicitly {@link ptsl.CreateNewTracksResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {ptsl.ICreateNewTracksResponseBody} message CreateNewTracksResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateNewTracksResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numberOfTracks != null && Object.hasOwnProperty.call(message, "numberOfTracks"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.numberOfTracks);
            if (message.createdTrackNames != null && message.createdTrackNames.length)
                for (var i = 0; i < message.createdTrackNames.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.createdTrackNames[i]);
            if (message.paginationResponse != null && Object.hasOwnProperty.call(message, "paginationResponse"))
                $root.ptsl.PaginationResponse.encode(message.paginationResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.createdTrackIds != null && message.createdTrackIds.length)
                for (var i = 0; i < message.createdTrackIds.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.createdTrackIds[i]);
            return writer;
        };

        /**
         * Encodes the specified CreateNewTracksResponseBody message, length delimited. Does not implicitly {@link ptsl.CreateNewTracksResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {ptsl.ICreateNewTracksResponseBody} message CreateNewTracksResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateNewTracksResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateNewTracksResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateNewTracksResponseBody} CreateNewTracksResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateNewTracksResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateNewTracksResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.numberOfTracks = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.createdTrackNames && message.createdTrackNames.length))
                            message.createdTrackNames = [];
                        message.createdTrackNames.push(reader.string());
                        break;
                    }
                case 3: {
                        message.paginationResponse = $root.ptsl.PaginationResponse.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.createdTrackIds && message.createdTrackIds.length))
                            message.createdTrackIds = [];
                        message.createdTrackIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateNewTracksResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateNewTracksResponseBody} CreateNewTracksResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateNewTracksResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateNewTracksResponseBody message.
         * @function verify
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateNewTracksResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numberOfTracks != null && message.hasOwnProperty("numberOfTracks"))
                if (!$util.isInteger(message.numberOfTracks))
                    return "numberOfTracks: integer expected";
            if (message.createdTrackNames != null && message.hasOwnProperty("createdTrackNames")) {
                if (!Array.isArray(message.createdTrackNames))
                    return "createdTrackNames: array expected";
                for (var i = 0; i < message.createdTrackNames.length; ++i)
                    if (!$util.isString(message.createdTrackNames[i]))
                        return "createdTrackNames: string[] expected";
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse")) {
                var error = $root.ptsl.PaginationResponse.verify(message.paginationResponse);
                if (error)
                    return "paginationResponse." + error;
            }
            if (message.createdTrackIds != null && message.hasOwnProperty("createdTrackIds")) {
                if (!Array.isArray(message.createdTrackIds))
                    return "createdTrackIds: array expected";
                for (var i = 0; i < message.createdTrackIds.length; ++i)
                    if (!$util.isString(message.createdTrackIds[i]))
                        return "createdTrackIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a CreateNewTracksResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateNewTracksResponseBody} CreateNewTracksResponseBody
         */
        CreateNewTracksResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateNewTracksResponseBody)
                return object;
            var message = new $root.ptsl.CreateNewTracksResponseBody();
            if (object.numberOfTracks != null)
                message.numberOfTracks = object.numberOfTracks | 0;
            if (object.createdTrackNames) {
                if (!Array.isArray(object.createdTrackNames))
                    throw TypeError(".ptsl.CreateNewTracksResponseBody.createdTrackNames: array expected");
                message.createdTrackNames = [];
                for (var i = 0; i < object.createdTrackNames.length; ++i)
                    message.createdTrackNames[i] = String(object.createdTrackNames[i]);
            }
            if (object.paginationResponse != null) {
                if (typeof object.paginationResponse !== "object")
                    throw TypeError(".ptsl.CreateNewTracksResponseBody.paginationResponse: object expected");
                message.paginationResponse = $root.ptsl.PaginationResponse.fromObject(object.paginationResponse);
            }
            if (object.createdTrackIds) {
                if (!Array.isArray(object.createdTrackIds))
                    throw TypeError(".ptsl.CreateNewTracksResponseBody.createdTrackIds: array expected");
                message.createdTrackIds = [];
                for (var i = 0; i < object.createdTrackIds.length; ++i)
                    message.createdTrackIds[i] = String(object.createdTrackIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateNewTracksResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {ptsl.CreateNewTracksResponseBody} message CreateNewTracksResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateNewTracksResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.createdTrackNames = [];
                object.createdTrackIds = [];
            }
            if (options.defaults) {
                object.numberOfTracks = 0;
                object.paginationResponse = null;
            }
            if (message.numberOfTracks != null && message.hasOwnProperty("numberOfTracks"))
                object.numberOfTracks = message.numberOfTracks;
            if (message.createdTrackNames && message.createdTrackNames.length) {
                object.createdTrackNames = [];
                for (var j = 0; j < message.createdTrackNames.length; ++j)
                    object.createdTrackNames[j] = message.createdTrackNames[j];
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse"))
                object.paginationResponse = $root.ptsl.PaginationResponse.toObject(message.paginationResponse, options);
            if (message.createdTrackIds && message.createdTrackIds.length) {
                object.createdTrackIds = [];
                for (var j = 0; j < message.createdTrackIds.length; ++j)
                    object.createdTrackIds[j] = message.createdTrackIds[j];
            }
            return object;
        };

        /**
         * Converts this CreateNewTracksResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateNewTracksResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateNewTracksResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateNewTracksResponseBody
         * @function getTypeUrl
         * @memberof ptsl.CreateNewTracksResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateNewTracksResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateNewTracksResponseBody";
        };

        return CreateNewTracksResponseBody;
    })();

    /**
     * Type of edit mode.
     * @name ptsl.EditMode
     * @enum {number}
     * @property {number} EMO_Unknown=0 * @deprecated ptsl::EditMode::EMO_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_Unknown
     * @property {number} EMode_Unknown=0 EMode_Unknown value
     * @property {number} EMO_Shuffle=1 * @deprecated ptsl::EditMode::EMO_Shuffle is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::MemoryLocationReference::EMode_Shuffle
     * @property {number} EMode_Shuffle=1 EMode_Shuffle value
     * @property {number} EMO_Slip=2 * @deprecated ptsl::EditMode::EMO_Slip is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_Slip
     * @property {number} EMode_Slip=2 EMode_Slip value
     * @property {number} EMO_Spot=3 * @deprecated ptsl::EditMode::EMO_Spot is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_Spot
     * @property {number} EMode_Spot=3 EMode_Spot value
     * @property {number} EMO_GridAbsolute=4 * @deprecated ptsl::EditMode::EMO_GridAbsolute is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_GridAbsolute
     * @property {number} EMode_GridAbsolute=4 EMode_GridAbsolute value
     * @property {number} EMO_GridRelative=5 * @deprecated ptsl::EditMode::EMO_GridRelative is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_GridRelative
     * @property {number} EMode_GridRelative=5 EMode_GridRelative value
     * @property {number} EMO_ShuffleSnapToGridAbsolute=6 * @deprecated ptsl::EditMode::EMO_ShuffleSnapToGridAbsolute is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_ShuffleSnapToGridAbsolute
     * @property {number} EMode_ShuffleSnapToGridAbsolute=6 EMode_ShuffleSnapToGridAbsolute value
     * @property {number} EMO_SlipSnapToGridAbsolute=7 * @deprecated ptsl::EditMode::EMO_SlipSnapToGridAbsolute is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_SlipSnapToGridAbsolute
     * @property {number} EMode_SlipSnapToGridAbsolute=7 EMode_SlipSnapToGridAbsolute value
     * @property {number} EMO_SpotSnapToGridAbsolute=8 * @deprecated ptsl::EditMode::EMO_SpotSnapToGridAbsolute is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_SpotSnapToGridAbsolute
     * @property {number} EMode_SpotSnapToGridAbsolute=8 EMode_SpotSnapToGridAbsolute value
     * @property {number} EMO_ShuffleSnapToGridRelative=9 * @deprecated ptsl::EditMode::EMO_ShuffleSnapToGridRelative is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_ShuffleSnapToGridRelative
     * @property {number} EMode_ShuffleSnapToGridRelative=9 EMode_ShuffleSnapToGridRelative value
     * @property {number} EMO_SlipSnapToGridRelative=10 * @deprecated ptsl::EditMode::EMO_SlipSnapToGridRelative is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_SlipSnapToGridRelative
     * @property {number} EMode_SlipSnapToGridRelative=10 EMode_SlipSnapToGridRelative value
     * @property {number} EMO_SpotSnapToGridRelative=11 * @deprecated ptsl::EditMode::EMO_SpotSnapToGridRelative is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditMode::EMode_SpotSnapToGridRelative
     * @property {number} EMode_SpotSnapToGridRelative=11 EMode_SpotSnapToGridRelative value
     */
    ptsl.EditMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EMO_Unknown"] = 0;
        values["EMode_Unknown"] = 0;
        values[valuesById[1] = "EMO_Shuffle"] = 1;
        values["EMode_Shuffle"] = 1;
        values[valuesById[2] = "EMO_Slip"] = 2;
        values["EMode_Slip"] = 2;
        values[valuesById[3] = "EMO_Spot"] = 3;
        values["EMode_Spot"] = 3;
        values[valuesById[4] = "EMO_GridAbsolute"] = 4;
        values["EMode_GridAbsolute"] = 4;
        values[valuesById[5] = "EMO_GridRelative"] = 5;
        values["EMode_GridRelative"] = 5;
        values[valuesById[6] = "EMO_ShuffleSnapToGridAbsolute"] = 6;
        values["EMode_ShuffleSnapToGridAbsolute"] = 6;
        values[valuesById[7] = "EMO_SlipSnapToGridAbsolute"] = 7;
        values["EMode_SlipSnapToGridAbsolute"] = 7;
        values[valuesById[8] = "EMO_SpotSnapToGridAbsolute"] = 8;
        values["EMode_SpotSnapToGridAbsolute"] = 8;
        values[valuesById[9] = "EMO_ShuffleSnapToGridRelative"] = 9;
        values["EMode_ShuffleSnapToGridRelative"] = 9;
        values[valuesById[10] = "EMO_SlipSnapToGridRelative"] = 10;
        values["EMode_SlipSnapToGridRelative"] = 10;
        values[valuesById[11] = "EMO_SpotSnapToGridRelative"] = 11;
        values["EMode_SpotSnapToGridRelative"] = 11;
        return values;
    })();

    /**
     * Type of edit tool.
     * @name ptsl.EditTool
     * @enum {number}
     * @property {number} ET_Unknown=0 * @deprecated ptsl::EditTool::ET_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_Unknown
     * @property {number} ETool_Unknown=0 ETool_Unknown value
     * @property {number} ET_ZoomNormal=1 * @deprecated ptsl::EditTool::ET_ZoomNormal is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_ZoomNormal
     * @property {number} ETool_ZoomNormal=1 ETool_ZoomNormal value
     * @property {number} ET_ZoomSingle=2 * @deprecated ptsl::EditTool::ET_ZoomSingle is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_ZoomSingle
     * @property {number} ETool_ZoomSingle=2 ETool_ZoomSingle value
     * @property {number} ET_TrimStandard=3 * @deprecated ptsl::EditTool::ET_TrimStandard is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_TrimStandard
     * @property {number} ETool_TrimStandard=3 ETool_TrimStandard value
     * @property {number} ET_TrimTce=4 * @deprecated ptsl::EditTool::ET_TrimTce is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_TrimTce
     * @property {number} ETool_TrimTce=4 ETool_TrimTce value
     * @property {number} ET_TrimScrub=5 * @deprecated ptsl::EditTool::ET_TrimScrub is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_TrimScrub
     * @property {number} ETool_TrimScrub=5 ETool_TrimScrub value
     * @property {number} ET_TrimLoop=6 * @deprecated ptsl::EditTool::ET_TrimLoop is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_TrimLoop
     * @property {number} ETool_TrimLoop=6 ETool_TrimLoop value
     * @property {number} ET_Selector=7 * @deprecated ptsl::EditTool::ET_Selector is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_Selector
     * @property {number} ETool_Selector=7 ETool_Selector value
     * @property {number} ET_GrabberTime=8 * @deprecated ptsl::EditTool::ET_GrabberTime is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_GrabberTime
     * @property {number} ETool_GrabberTime=8 ETool_GrabberTime value
     * @property {number} ET_GrabberSeparation=9 * @deprecated ptsl::EditTool::ET_GrabberSeparation is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_GrabberSeparation
     * @property {number} ETool_GrabberSeparation=9 ETool_GrabberSeparation value
     * @property {number} ET_GrabberObject=10 * @deprecated ptsl::EditTool::ET_GrabberObject is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_GrabberObject
     * @property {number} ETool_GrabberObject=10 ETool_GrabberObject value
     * @property {number} ET_SmartTool=11 * @deprecated ptsl::EditTool::ET_SmartTool is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_SmartTool
     * @property {number} ETool_SmartTool=11 ETool_SmartTool value
     * @property {number} ET_Scrubber=12 * @deprecated ptsl::EditTool::ET_Scrubber is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_Scrubber
     * @property {number} ETool_Scrubber=12 ETool_Scrubber value
     * @property {number} ET_PencilFreeHand=13 * @deprecated ptsl::EditTool::ET_PencilFreeHand is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_PencilFreeHand
     * @property {number} ETool_PencilFreeHand=13 ETool_PencilFreeHand value
     * @property {number} ET_PencilLine=14 * @deprecated ptsl::EditTool::ET_PencilLine is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_PencilLine
     * @property {number} ETool_PencilLine=14 ETool_PencilLine value
     * @property {number} ET_PencilTriangle=15 * @deprecated ptsl::EditTool::ET_PencilTriangle is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_PencilTriangle
     * @property {number} ETool_PencilTriangle=15 ETool_PencilTriangle value
     * @property {number} ET_PencilSquare=16 * @deprecated ptsl::EditTool::ET_PencilSquare is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_PencilSquare
     * @property {number} ETool_PencilSquare=16 ETool_PencilSquare value
     * @property {number} ET_PencilRandom=17 * @deprecated ptsl::EditTool::ET_PencilRandom is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_PencilRandom
     * @property {number} ETool_PencilRandom=17 ETool_PencilRandom value
     * @property {number} ET_PencilParabolic=18 * @deprecated ptsl::EditTool::ET_PencilParabolic is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_PencilParabolic
     * @property {number} ETool_PencilParabolic=18 ETool_PencilParabolic value
     * @property {number} ET_PencilSCurve=19 * @deprecated ptsl::EditTool::ET_PencilSCurve is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::EditTool::ETool_PencilSCurve
     * @property {number} ETool_PencilSCurve=19 ETool_PencilSCurve value
     */
    ptsl.EditTool = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ET_Unknown"] = 0;
        values["ETool_Unknown"] = 0;
        values[valuesById[1] = "ET_ZoomNormal"] = 1;
        values["ETool_ZoomNormal"] = 1;
        values[valuesById[2] = "ET_ZoomSingle"] = 2;
        values["ETool_ZoomSingle"] = 2;
        values[valuesById[3] = "ET_TrimStandard"] = 3;
        values["ETool_TrimStandard"] = 3;
        values[valuesById[4] = "ET_TrimTce"] = 4;
        values["ETool_TrimTce"] = 4;
        values[valuesById[5] = "ET_TrimScrub"] = 5;
        values["ETool_TrimScrub"] = 5;
        values[valuesById[6] = "ET_TrimLoop"] = 6;
        values["ETool_TrimLoop"] = 6;
        values[valuesById[7] = "ET_Selector"] = 7;
        values["ETool_Selector"] = 7;
        values[valuesById[8] = "ET_GrabberTime"] = 8;
        values["ETool_GrabberTime"] = 8;
        values[valuesById[9] = "ET_GrabberSeparation"] = 9;
        values["ETool_GrabberSeparation"] = 9;
        values[valuesById[10] = "ET_GrabberObject"] = 10;
        values["ETool_GrabberObject"] = 10;
        values[valuesById[11] = "ET_SmartTool"] = 11;
        values["ETool_SmartTool"] = 11;
        values[valuesById[12] = "ET_Scrubber"] = 12;
        values["ETool_Scrubber"] = 12;
        values[valuesById[13] = "ET_PencilFreeHand"] = 13;
        values["ETool_PencilFreeHand"] = 13;
        values[valuesById[14] = "ET_PencilLine"] = 14;
        values["ETool_PencilLine"] = 14;
        values[valuesById[15] = "ET_PencilTriangle"] = 15;
        values["ETool_PencilTriangle"] = 15;
        values[valuesById[16] = "ET_PencilSquare"] = 16;
        values["ETool_PencilSquare"] = 16;
        values[valuesById[17] = "ET_PencilRandom"] = 17;
        values["ETool_PencilRandom"] = 17;
        values[valuesById[18] = "ET_PencilParabolic"] = 18;
        values["ETool_PencilParabolic"] = 18;
        values[valuesById[19] = "ET_PencilSCurve"] = 19;
        values["ETool_PencilSCurve"] = 19;
        return values;
    })();

    ptsl.EditModeOptions = (function() {

        /**
         * Properties of an EditModeOptions.
         * @memberof ptsl
         * @interface IEditModeOptions
         * @property {boolean|null} [tabToTransients] EditModeOptions tabToTransients
         * @property {boolean|null} [linkTimelineAndEditSelection] EditModeOptions linkTimelineAndEditSelection
         * @property {boolean|null} [linkTrackAndEditSelection] EditModeOptions linkTrackAndEditSelection
         * @property {boolean|null} [insertionFollowsPlayback] EditModeOptions insertionFollowsPlayback
         * @property {boolean|null} [automationFollowsEdit] EditModeOptions automationFollowsEdit
         * @property {boolean|null} [markersFollowEdit] EditModeOptions markersFollowEdit
         * @property {boolean|null} [mirroredMidiEditing] EditModeOptions mirroredMidiEditing
         * @property {boolean|null} [layeredEditing] EditModeOptions layeredEditing
         */

        /**
         * Constructs a new EditModeOptions.
         * @memberof ptsl
         * @classdesc Structure that describes edit mode options.
         * @implements IEditModeOptions
         * @constructor
         * @param {ptsl.IEditModeOptions=} [properties] Properties to set
         */
        function EditModeOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EditModeOptions tabToTransients.
         * @member {boolean} tabToTransients
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.tabToTransients = false;

        /**
         * EditModeOptions linkTimelineAndEditSelection.
         * @member {boolean} linkTimelineAndEditSelection
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.linkTimelineAndEditSelection = false;

        /**
         * EditModeOptions linkTrackAndEditSelection.
         * @member {boolean} linkTrackAndEditSelection
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.linkTrackAndEditSelection = false;

        /**
         * EditModeOptions insertionFollowsPlayback.
         * @member {boolean} insertionFollowsPlayback
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.insertionFollowsPlayback = false;

        /**
         * EditModeOptions automationFollowsEdit.
         * @member {boolean} automationFollowsEdit
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.automationFollowsEdit = false;

        /**
         * EditModeOptions markersFollowEdit.
         * @member {boolean} markersFollowEdit
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.markersFollowEdit = false;

        /**
         * EditModeOptions mirroredMidiEditing.
         * @member {boolean} mirroredMidiEditing
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.mirroredMidiEditing = false;

        /**
         * EditModeOptions layeredEditing.
         * @member {boolean} layeredEditing
         * @memberof ptsl.EditModeOptions
         * @instance
         */
        EditModeOptions.prototype.layeredEditing = false;

        /**
         * Creates a new EditModeOptions instance using the specified properties.
         * @function create
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {ptsl.IEditModeOptions=} [properties] Properties to set
         * @returns {ptsl.EditModeOptions} EditModeOptions instance
         */
        EditModeOptions.create = function create(properties) {
            return new EditModeOptions(properties);
        };

        /**
         * Encodes the specified EditModeOptions message. Does not implicitly {@link ptsl.EditModeOptions.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {ptsl.IEditModeOptions} message EditModeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditModeOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tabToTransients != null && Object.hasOwnProperty.call(message, "tabToTransients"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.tabToTransients);
            if (message.linkTimelineAndEditSelection != null && Object.hasOwnProperty.call(message, "linkTimelineAndEditSelection"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.linkTimelineAndEditSelection);
            if (message.linkTrackAndEditSelection != null && Object.hasOwnProperty.call(message, "linkTrackAndEditSelection"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.linkTrackAndEditSelection);
            if (message.insertionFollowsPlayback != null && Object.hasOwnProperty.call(message, "insertionFollowsPlayback"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.insertionFollowsPlayback);
            if (message.automationFollowsEdit != null && Object.hasOwnProperty.call(message, "automationFollowsEdit"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.automationFollowsEdit);
            if (message.markersFollowEdit != null && Object.hasOwnProperty.call(message, "markersFollowEdit"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.markersFollowEdit);
            if (message.mirroredMidiEditing != null && Object.hasOwnProperty.call(message, "mirroredMidiEditing"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mirroredMidiEditing);
            if (message.layeredEditing != null && Object.hasOwnProperty.call(message, "layeredEditing"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.layeredEditing);
            return writer;
        };

        /**
         * Encodes the specified EditModeOptions message, length delimited. Does not implicitly {@link ptsl.EditModeOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {ptsl.IEditModeOptions} message EditModeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EditModeOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EditModeOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EditModeOptions} EditModeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditModeOptions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EditModeOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.tabToTransients = reader.bool();
                        break;
                    }
                case 2: {
                        message.linkTimelineAndEditSelection = reader.bool();
                        break;
                    }
                case 3: {
                        message.linkTrackAndEditSelection = reader.bool();
                        break;
                    }
                case 4: {
                        message.insertionFollowsPlayback = reader.bool();
                        break;
                    }
                case 5: {
                        message.automationFollowsEdit = reader.bool();
                        break;
                    }
                case 6: {
                        message.markersFollowEdit = reader.bool();
                        break;
                    }
                case 7: {
                        message.mirroredMidiEditing = reader.bool();
                        break;
                    }
                case 8: {
                        message.layeredEditing = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EditModeOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EditModeOptions} EditModeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EditModeOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EditModeOptions message.
         * @function verify
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EditModeOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tabToTransients != null && message.hasOwnProperty("tabToTransients"))
                if (typeof message.tabToTransients !== "boolean")
                    return "tabToTransients: boolean expected";
            if (message.linkTimelineAndEditSelection != null && message.hasOwnProperty("linkTimelineAndEditSelection"))
                if (typeof message.linkTimelineAndEditSelection !== "boolean")
                    return "linkTimelineAndEditSelection: boolean expected";
            if (message.linkTrackAndEditSelection != null && message.hasOwnProperty("linkTrackAndEditSelection"))
                if (typeof message.linkTrackAndEditSelection !== "boolean")
                    return "linkTrackAndEditSelection: boolean expected";
            if (message.insertionFollowsPlayback != null && message.hasOwnProperty("insertionFollowsPlayback"))
                if (typeof message.insertionFollowsPlayback !== "boolean")
                    return "insertionFollowsPlayback: boolean expected";
            if (message.automationFollowsEdit != null && message.hasOwnProperty("automationFollowsEdit"))
                if (typeof message.automationFollowsEdit !== "boolean")
                    return "automationFollowsEdit: boolean expected";
            if (message.markersFollowEdit != null && message.hasOwnProperty("markersFollowEdit"))
                if (typeof message.markersFollowEdit !== "boolean")
                    return "markersFollowEdit: boolean expected";
            if (message.mirroredMidiEditing != null && message.hasOwnProperty("mirroredMidiEditing"))
                if (typeof message.mirroredMidiEditing !== "boolean")
                    return "mirroredMidiEditing: boolean expected";
            if (message.layeredEditing != null && message.hasOwnProperty("layeredEditing"))
                if (typeof message.layeredEditing !== "boolean")
                    return "layeredEditing: boolean expected";
            return null;
        };

        /**
         * Creates an EditModeOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EditModeOptions} EditModeOptions
         */
        EditModeOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EditModeOptions)
                return object;
            var message = new $root.ptsl.EditModeOptions();
            if (object.tabToTransients != null)
                message.tabToTransients = Boolean(object.tabToTransients);
            if (object.linkTimelineAndEditSelection != null)
                message.linkTimelineAndEditSelection = Boolean(object.linkTimelineAndEditSelection);
            if (object.linkTrackAndEditSelection != null)
                message.linkTrackAndEditSelection = Boolean(object.linkTrackAndEditSelection);
            if (object.insertionFollowsPlayback != null)
                message.insertionFollowsPlayback = Boolean(object.insertionFollowsPlayback);
            if (object.automationFollowsEdit != null)
                message.automationFollowsEdit = Boolean(object.automationFollowsEdit);
            if (object.markersFollowEdit != null)
                message.markersFollowEdit = Boolean(object.markersFollowEdit);
            if (object.mirroredMidiEditing != null)
                message.mirroredMidiEditing = Boolean(object.mirroredMidiEditing);
            if (object.layeredEditing != null)
                message.layeredEditing = Boolean(object.layeredEditing);
            return message;
        };

        /**
         * Creates a plain object from an EditModeOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {ptsl.EditModeOptions} message EditModeOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EditModeOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tabToTransients = false;
                object.linkTimelineAndEditSelection = false;
                object.linkTrackAndEditSelection = false;
                object.insertionFollowsPlayback = false;
                object.automationFollowsEdit = false;
                object.markersFollowEdit = false;
                object.mirroredMidiEditing = false;
                object.layeredEditing = false;
            }
            if (message.tabToTransients != null && message.hasOwnProperty("tabToTransients"))
                object.tabToTransients = message.tabToTransients;
            if (message.linkTimelineAndEditSelection != null && message.hasOwnProperty("linkTimelineAndEditSelection"))
                object.linkTimelineAndEditSelection = message.linkTimelineAndEditSelection;
            if (message.linkTrackAndEditSelection != null && message.hasOwnProperty("linkTrackAndEditSelection"))
                object.linkTrackAndEditSelection = message.linkTrackAndEditSelection;
            if (message.insertionFollowsPlayback != null && message.hasOwnProperty("insertionFollowsPlayback"))
                object.insertionFollowsPlayback = message.insertionFollowsPlayback;
            if (message.automationFollowsEdit != null && message.hasOwnProperty("automationFollowsEdit"))
                object.automationFollowsEdit = message.automationFollowsEdit;
            if (message.markersFollowEdit != null && message.hasOwnProperty("markersFollowEdit"))
                object.markersFollowEdit = message.markersFollowEdit;
            if (message.mirroredMidiEditing != null && message.hasOwnProperty("mirroredMidiEditing"))
                object.mirroredMidiEditing = message.mirroredMidiEditing;
            if (message.layeredEditing != null && message.hasOwnProperty("layeredEditing"))
                object.layeredEditing = message.layeredEditing;
            return object;
        };

        /**
         * Converts this EditModeOptions to JSON.
         * @function toJSON
         * @memberof ptsl.EditModeOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EditModeOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EditModeOptions
         * @function getTypeUrl
         * @memberof ptsl.EditModeOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EditModeOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EditModeOptions";
        };

        return EditModeOptions;
    })();

    ptsl.GetEditModeResponseBody = (function() {

        /**
         * Properties of a GetEditModeResponseBody.
         * @memberof ptsl
         * @interface IGetEditModeResponseBody
         * @property {ptsl.EditMode|null} [currentSetting] GetEditModeResponseBody currentSetting
         * @property {Array.<ptsl.EditMode>|null} [possibleSettings] GetEditModeResponseBody possibleSettings
         */

        /**
         * Constructs a new GetEditModeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetEditMode response data.
         * @implements IGetEditModeResponseBody
         * @constructor
         * @param {ptsl.IGetEditModeResponseBody=} [properties] Properties to set
         */
        function GetEditModeResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetEditModeResponseBody currentSetting.
         * @member {ptsl.EditMode} currentSetting
         * @memberof ptsl.GetEditModeResponseBody
         * @instance
         */
        GetEditModeResponseBody.prototype.currentSetting = 0;

        /**
         * GetEditModeResponseBody possibleSettings.
         * @member {Array.<ptsl.EditMode>} possibleSettings
         * @memberof ptsl.GetEditModeResponseBody
         * @instance
         */
        GetEditModeResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetEditModeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {ptsl.IGetEditModeResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetEditModeResponseBody} GetEditModeResponseBody instance
         */
        GetEditModeResponseBody.create = function create(properties) {
            return new GetEditModeResponseBody(properties);
        };

        /**
         * Encodes the specified GetEditModeResponseBody message. Does not implicitly {@link ptsl.GetEditModeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {ptsl.IGetEditModeResponseBody} message GetEditModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditModeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetEditModeResponseBody message, length delimited. Does not implicitly {@link ptsl.GetEditModeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {ptsl.IGetEditModeResponseBody} message GetEditModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditModeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEditModeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetEditModeResponseBody} GetEditModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditModeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetEditModeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEditModeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetEditModeResponseBody} GetEditModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditModeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEditModeResponseBody message.
         * @function verify
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEditModeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                    case 8:
                    case 9:
                    case 9:
                    case 10:
                    case 10:
                    case 11:
                    case 11:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetEditModeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetEditModeResponseBody} GetEditModeResponseBody
         */
        GetEditModeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetEditModeResponseBody)
                return object;
            var message = new $root.ptsl.GetEditModeResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "EMO_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "EMode_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "EMO_Shuffle":
            case 1:
                message.currentSetting = 1;
                break;
            case "EMode_Shuffle":
            case 1:
                message.currentSetting = 1;
                break;
            case "EMO_Slip":
            case 2:
                message.currentSetting = 2;
                break;
            case "EMode_Slip":
            case 2:
                message.currentSetting = 2;
                break;
            case "EMO_Spot":
            case 3:
                message.currentSetting = 3;
                break;
            case "EMode_Spot":
            case 3:
                message.currentSetting = 3;
                break;
            case "EMO_GridAbsolute":
            case 4:
                message.currentSetting = 4;
                break;
            case "EMode_GridAbsolute":
            case 4:
                message.currentSetting = 4;
                break;
            case "EMO_GridRelative":
            case 5:
                message.currentSetting = 5;
                break;
            case "EMode_GridRelative":
            case 5:
                message.currentSetting = 5;
                break;
            case "EMO_ShuffleSnapToGridAbsolute":
            case 6:
                message.currentSetting = 6;
                break;
            case "EMode_ShuffleSnapToGridAbsolute":
            case 6:
                message.currentSetting = 6;
                break;
            case "EMO_SlipSnapToGridAbsolute":
            case 7:
                message.currentSetting = 7;
                break;
            case "EMode_SlipSnapToGridAbsolute":
            case 7:
                message.currentSetting = 7;
                break;
            case "EMO_SpotSnapToGridAbsolute":
            case 8:
                message.currentSetting = 8;
                break;
            case "EMode_SpotSnapToGridAbsolute":
            case 8:
                message.currentSetting = 8;
                break;
            case "EMO_ShuffleSnapToGridRelative":
            case 9:
                message.currentSetting = 9;
                break;
            case "EMode_ShuffleSnapToGridRelative":
            case 9:
                message.currentSetting = 9;
                break;
            case "EMO_SlipSnapToGridRelative":
            case 10:
                message.currentSetting = 10;
                break;
            case "EMode_SlipSnapToGridRelative":
            case 10:
                message.currentSetting = 10;
                break;
            case "EMO_SpotSnapToGridRelative":
            case 11:
                message.currentSetting = 11;
                break;
            case "EMode_SpotSnapToGridRelative":
            case 11:
                message.currentSetting = 11;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetEditModeResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "EMO_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "EMode_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "EMO_Shuffle":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "EMode_Shuffle":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "EMO_Slip":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "EMode_Slip":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "EMO_Spot":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "EMode_Spot":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "EMO_GridAbsolute":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "EMode_GridAbsolute":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "EMO_GridRelative":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "EMode_GridRelative":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "EMO_ShuffleSnapToGridAbsolute":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "EMode_ShuffleSnapToGridAbsolute":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "EMO_SlipSnapToGridAbsolute":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "EMode_SlipSnapToGridAbsolute":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "EMO_SpotSnapToGridAbsolute":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "EMode_SpotSnapToGridAbsolute":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "EMO_ShuffleSnapToGridRelative":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "EMode_ShuffleSnapToGridRelative":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "EMO_SlipSnapToGridRelative":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "EMode_SlipSnapToGridRelative":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "EMO_SpotSnapToGridRelative":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    case "EMode_SpotSnapToGridRelative":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEditModeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {ptsl.GetEditModeResponseBody} message GetEditModeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEditModeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "EMO_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.EditMode[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.EditMode[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.EditMode[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.EditMode[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetEditModeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetEditModeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEditModeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetEditModeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetEditModeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetEditModeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetEditModeResponseBody";
        };

        return GetEditModeResponseBody;
    })();

    ptsl.SetEditModeRequestBody = (function() {

        /**
         * Properties of a SetEditModeRequestBody.
         * @memberof ptsl
         * @interface ISetEditModeRequestBody
         * @property {ptsl.EditMode|null} [editMode] SetEditModeRequestBody editMode
         */

        /**
         * Constructs a new SetEditModeRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetEditMode request data.
         * @implements ISetEditModeRequestBody
         * @constructor
         * @param {ptsl.ISetEditModeRequestBody=} [properties] Properties to set
         */
        function SetEditModeRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetEditModeRequestBody editMode.
         * @member {ptsl.EditMode} editMode
         * @memberof ptsl.SetEditModeRequestBody
         * @instance
         */
        SetEditModeRequestBody.prototype.editMode = 0;

        /**
         * Creates a new SetEditModeRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {ptsl.ISetEditModeRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetEditModeRequestBody} SetEditModeRequestBody instance
         */
        SetEditModeRequestBody.create = function create(properties) {
            return new SetEditModeRequestBody(properties);
        };

        /**
         * Encodes the specified SetEditModeRequestBody message. Does not implicitly {@link ptsl.SetEditModeRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {ptsl.ISetEditModeRequestBody} message SetEditModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetEditModeRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.editMode != null && Object.hasOwnProperty.call(message, "editMode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.editMode);
            return writer;
        };

        /**
         * Encodes the specified SetEditModeRequestBody message, length delimited. Does not implicitly {@link ptsl.SetEditModeRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {ptsl.ISetEditModeRequestBody} message SetEditModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetEditModeRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetEditModeRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetEditModeRequestBody} SetEditModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetEditModeRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetEditModeRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.editMode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetEditModeRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetEditModeRequestBody} SetEditModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetEditModeRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetEditModeRequestBody message.
         * @function verify
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetEditModeRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.editMode != null && message.hasOwnProperty("editMode"))
                switch (message.editMode) {
                default:
                    return "editMode: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetEditModeRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetEditModeRequestBody} SetEditModeRequestBody
         */
        SetEditModeRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetEditModeRequestBody)
                return object;
            var message = new $root.ptsl.SetEditModeRequestBody();
            switch (object.editMode) {
            default:
                if (typeof object.editMode === "number") {
                    message.editMode = object.editMode;
                    break;
                }
                break;
            case "EMO_Unknown":
            case 0:
                message.editMode = 0;
                break;
            case "EMode_Unknown":
            case 0:
                message.editMode = 0;
                break;
            case "EMO_Shuffle":
            case 1:
                message.editMode = 1;
                break;
            case "EMode_Shuffle":
            case 1:
                message.editMode = 1;
                break;
            case "EMO_Slip":
            case 2:
                message.editMode = 2;
                break;
            case "EMode_Slip":
            case 2:
                message.editMode = 2;
                break;
            case "EMO_Spot":
            case 3:
                message.editMode = 3;
                break;
            case "EMode_Spot":
            case 3:
                message.editMode = 3;
                break;
            case "EMO_GridAbsolute":
            case 4:
                message.editMode = 4;
                break;
            case "EMode_GridAbsolute":
            case 4:
                message.editMode = 4;
                break;
            case "EMO_GridRelative":
            case 5:
                message.editMode = 5;
                break;
            case "EMode_GridRelative":
            case 5:
                message.editMode = 5;
                break;
            case "EMO_ShuffleSnapToGridAbsolute":
            case 6:
                message.editMode = 6;
                break;
            case "EMode_ShuffleSnapToGridAbsolute":
            case 6:
                message.editMode = 6;
                break;
            case "EMO_SlipSnapToGridAbsolute":
            case 7:
                message.editMode = 7;
                break;
            case "EMode_SlipSnapToGridAbsolute":
            case 7:
                message.editMode = 7;
                break;
            case "EMO_SpotSnapToGridAbsolute":
            case 8:
                message.editMode = 8;
                break;
            case "EMode_SpotSnapToGridAbsolute":
            case 8:
                message.editMode = 8;
                break;
            case "EMO_ShuffleSnapToGridRelative":
            case 9:
                message.editMode = 9;
                break;
            case "EMode_ShuffleSnapToGridRelative":
            case 9:
                message.editMode = 9;
                break;
            case "EMO_SlipSnapToGridRelative":
            case 10:
                message.editMode = 10;
                break;
            case "EMode_SlipSnapToGridRelative":
            case 10:
                message.editMode = 10;
                break;
            case "EMO_SpotSnapToGridRelative":
            case 11:
                message.editMode = 11;
                break;
            case "EMode_SpotSnapToGridRelative":
            case 11:
                message.editMode = 11;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetEditModeRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {ptsl.SetEditModeRequestBody} message SetEditModeRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetEditModeRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.editMode = options.enums === String ? "EMO_Unknown" : 0;
            if (message.editMode != null && message.hasOwnProperty("editMode"))
                object.editMode = options.enums === String ? $root.ptsl.EditMode[message.editMode] === undefined ? message.editMode : $root.ptsl.EditMode[message.editMode] : message.editMode;
            return object;
        };

        /**
         * Converts this SetEditModeRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetEditModeRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetEditModeRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetEditModeRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetEditModeRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetEditModeRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetEditModeRequestBody";
        };

        return SetEditModeRequestBody;
    })();

    ptsl.GetEditToolResponseBody = (function() {

        /**
         * Properties of a GetEditToolResponseBody.
         * @memberof ptsl
         * @interface IGetEditToolResponseBody
         * @property {ptsl.EditTool|null} [currentSetting] GetEditToolResponseBody currentSetting
         * @property {Array.<ptsl.EditTool>|null} [possibleSettings] GetEditToolResponseBody possibleSettings
         */

        /**
         * Constructs a new GetEditToolResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetEditTool response data.
         * @implements IGetEditToolResponseBody
         * @constructor
         * @param {ptsl.IGetEditToolResponseBody=} [properties] Properties to set
         */
        function GetEditToolResponseBody(properties) {
            this.possibleSettings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetEditToolResponseBody currentSetting.
         * @member {ptsl.EditTool} currentSetting
         * @memberof ptsl.GetEditToolResponseBody
         * @instance
         */
        GetEditToolResponseBody.prototype.currentSetting = 0;

        /**
         * GetEditToolResponseBody possibleSettings.
         * @member {Array.<ptsl.EditTool>} possibleSettings
         * @memberof ptsl.GetEditToolResponseBody
         * @instance
         */
        GetEditToolResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * Creates a new GetEditToolResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {ptsl.IGetEditToolResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetEditToolResponseBody} GetEditToolResponseBody instance
         */
        GetEditToolResponseBody.create = function create(properties) {
            return new GetEditToolResponseBody(properties);
        };

        /**
         * Encodes the specified GetEditToolResponseBody message. Does not implicitly {@link ptsl.GetEditToolResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {ptsl.IGetEditToolResponseBody} message GetEditToolResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditToolResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetEditToolResponseBody message, length delimited. Does not implicitly {@link ptsl.GetEditToolResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {ptsl.IGetEditToolResponseBody} message GetEditToolResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditToolResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEditToolResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetEditToolResponseBody} GetEditToolResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditToolResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetEditToolResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEditToolResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetEditToolResponseBody} GetEditToolResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditToolResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEditToolResponseBody message.
         * @function verify
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEditToolResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                    case 6:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                    case 8:
                    case 9:
                    case 9:
                    case 10:
                    case 10:
                    case 11:
                    case 11:
                    case 12:
                    case 12:
                    case 13:
                    case 13:
                    case 14:
                    case 14:
                    case 15:
                    case 15:
                    case 16:
                    case 16:
                    case 17:
                    case 17:
                    case 18:
                    case 18:
                    case 19:
                    case 19:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetEditToolResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetEditToolResponseBody} GetEditToolResponseBody
         */
        GetEditToolResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetEditToolResponseBody)
                return object;
            var message = new $root.ptsl.GetEditToolResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "ET_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "ETool_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "ET_ZoomNormal":
            case 1:
                message.currentSetting = 1;
                break;
            case "ETool_ZoomNormal":
            case 1:
                message.currentSetting = 1;
                break;
            case "ET_ZoomSingle":
            case 2:
                message.currentSetting = 2;
                break;
            case "ETool_ZoomSingle":
            case 2:
                message.currentSetting = 2;
                break;
            case "ET_TrimStandard":
            case 3:
                message.currentSetting = 3;
                break;
            case "ETool_TrimStandard":
            case 3:
                message.currentSetting = 3;
                break;
            case "ET_TrimTce":
            case 4:
                message.currentSetting = 4;
                break;
            case "ETool_TrimTce":
            case 4:
                message.currentSetting = 4;
                break;
            case "ET_TrimScrub":
            case 5:
                message.currentSetting = 5;
                break;
            case "ETool_TrimScrub":
            case 5:
                message.currentSetting = 5;
                break;
            case "ET_TrimLoop":
            case 6:
                message.currentSetting = 6;
                break;
            case "ETool_TrimLoop":
            case 6:
                message.currentSetting = 6;
                break;
            case "ET_Selector":
            case 7:
                message.currentSetting = 7;
                break;
            case "ETool_Selector":
            case 7:
                message.currentSetting = 7;
                break;
            case "ET_GrabberTime":
            case 8:
                message.currentSetting = 8;
                break;
            case "ETool_GrabberTime":
            case 8:
                message.currentSetting = 8;
                break;
            case "ET_GrabberSeparation":
            case 9:
                message.currentSetting = 9;
                break;
            case "ETool_GrabberSeparation":
            case 9:
                message.currentSetting = 9;
                break;
            case "ET_GrabberObject":
            case 10:
                message.currentSetting = 10;
                break;
            case "ETool_GrabberObject":
            case 10:
                message.currentSetting = 10;
                break;
            case "ET_SmartTool":
            case 11:
                message.currentSetting = 11;
                break;
            case "ETool_SmartTool":
            case 11:
                message.currentSetting = 11;
                break;
            case "ET_Scrubber":
            case 12:
                message.currentSetting = 12;
                break;
            case "ETool_Scrubber":
            case 12:
                message.currentSetting = 12;
                break;
            case "ET_PencilFreeHand":
            case 13:
                message.currentSetting = 13;
                break;
            case "ETool_PencilFreeHand":
            case 13:
                message.currentSetting = 13;
                break;
            case "ET_PencilLine":
            case 14:
                message.currentSetting = 14;
                break;
            case "ETool_PencilLine":
            case 14:
                message.currentSetting = 14;
                break;
            case "ET_PencilTriangle":
            case 15:
                message.currentSetting = 15;
                break;
            case "ETool_PencilTriangle":
            case 15:
                message.currentSetting = 15;
                break;
            case "ET_PencilSquare":
            case 16:
                message.currentSetting = 16;
                break;
            case "ETool_PencilSquare":
            case 16:
                message.currentSetting = 16;
                break;
            case "ET_PencilRandom":
            case 17:
                message.currentSetting = 17;
                break;
            case "ETool_PencilRandom":
            case 17:
                message.currentSetting = 17;
                break;
            case "ET_PencilParabolic":
            case 18:
                message.currentSetting = 18;
                break;
            case "ETool_PencilParabolic":
            case 18:
                message.currentSetting = 18;
                break;
            case "ET_PencilSCurve":
            case 19:
                message.currentSetting = 19;
                break;
            case "ETool_PencilSCurve":
            case 19:
                message.currentSetting = 19;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetEditToolResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "ET_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "ETool_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "ET_ZoomNormal":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "ETool_ZoomNormal":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "ET_ZoomSingle":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "ETool_ZoomSingle":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "ET_TrimStandard":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "ETool_TrimStandard":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "ET_TrimTce":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "ETool_TrimTce":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "ET_TrimScrub":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "ETool_TrimScrub":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "ET_TrimLoop":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "ETool_TrimLoop":
                    case 6:
                        message.possibleSettings[i] = 6;
                        break;
                    case "ET_Selector":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "ETool_Selector":
                    case 7:
                        message.possibleSettings[i] = 7;
                        break;
                    case "ET_GrabberTime":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "ETool_GrabberTime":
                    case 8:
                        message.possibleSettings[i] = 8;
                        break;
                    case "ET_GrabberSeparation":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "ETool_GrabberSeparation":
                    case 9:
                        message.possibleSettings[i] = 9;
                        break;
                    case "ET_GrabberObject":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "ETool_GrabberObject":
                    case 10:
                        message.possibleSettings[i] = 10;
                        break;
                    case "ET_SmartTool":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    case "ETool_SmartTool":
                    case 11:
                        message.possibleSettings[i] = 11;
                        break;
                    case "ET_Scrubber":
                    case 12:
                        message.possibleSettings[i] = 12;
                        break;
                    case "ETool_Scrubber":
                    case 12:
                        message.possibleSettings[i] = 12;
                        break;
                    case "ET_PencilFreeHand":
                    case 13:
                        message.possibleSettings[i] = 13;
                        break;
                    case "ETool_PencilFreeHand":
                    case 13:
                        message.possibleSettings[i] = 13;
                        break;
                    case "ET_PencilLine":
                    case 14:
                        message.possibleSettings[i] = 14;
                        break;
                    case "ETool_PencilLine":
                    case 14:
                        message.possibleSettings[i] = 14;
                        break;
                    case "ET_PencilTriangle":
                    case 15:
                        message.possibleSettings[i] = 15;
                        break;
                    case "ETool_PencilTriangle":
                    case 15:
                        message.possibleSettings[i] = 15;
                        break;
                    case "ET_PencilSquare":
                    case 16:
                        message.possibleSettings[i] = 16;
                        break;
                    case "ETool_PencilSquare":
                    case 16:
                        message.possibleSettings[i] = 16;
                        break;
                    case "ET_PencilRandom":
                    case 17:
                        message.possibleSettings[i] = 17;
                        break;
                    case "ETool_PencilRandom":
                    case 17:
                        message.possibleSettings[i] = 17;
                        break;
                    case "ET_PencilParabolic":
                    case 18:
                        message.possibleSettings[i] = 18;
                        break;
                    case "ETool_PencilParabolic":
                    case 18:
                        message.possibleSettings[i] = 18;
                        break;
                    case "ET_PencilSCurve":
                    case 19:
                        message.possibleSettings[i] = 19;
                        break;
                    case "ETool_PencilSCurve":
                    case 19:
                        message.possibleSettings[i] = 19;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEditToolResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {ptsl.GetEditToolResponseBody} message GetEditToolResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEditToolResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.possibleSettings = [];
            if (options.defaults)
                object.currentSetting = options.enums === String ? "ET_Unknown" : 0;
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.EditTool[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.EditTool[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.EditTool[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.EditTool[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            return object;
        };

        /**
         * Converts this GetEditToolResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetEditToolResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEditToolResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetEditToolResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetEditToolResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetEditToolResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetEditToolResponseBody";
        };

        return GetEditToolResponseBody;
    })();

    ptsl.SetEditToolRequestBody = (function() {

        /**
         * Properties of a SetEditToolRequestBody.
         * @memberof ptsl
         * @interface ISetEditToolRequestBody
         * @property {ptsl.EditTool|null} [editTool] SetEditToolRequestBody editTool
         */

        /**
         * Constructs a new SetEditToolRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetEditTool request data.
         * @implements ISetEditToolRequestBody
         * @constructor
         * @param {ptsl.ISetEditToolRequestBody=} [properties] Properties to set
         */
        function SetEditToolRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetEditToolRequestBody editTool.
         * @member {ptsl.EditTool} editTool
         * @memberof ptsl.SetEditToolRequestBody
         * @instance
         */
        SetEditToolRequestBody.prototype.editTool = 0;

        /**
         * Creates a new SetEditToolRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {ptsl.ISetEditToolRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetEditToolRequestBody} SetEditToolRequestBody instance
         */
        SetEditToolRequestBody.create = function create(properties) {
            return new SetEditToolRequestBody(properties);
        };

        /**
         * Encodes the specified SetEditToolRequestBody message. Does not implicitly {@link ptsl.SetEditToolRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {ptsl.ISetEditToolRequestBody} message SetEditToolRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetEditToolRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.editTool != null && Object.hasOwnProperty.call(message, "editTool"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.editTool);
            return writer;
        };

        /**
         * Encodes the specified SetEditToolRequestBody message, length delimited. Does not implicitly {@link ptsl.SetEditToolRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {ptsl.ISetEditToolRequestBody} message SetEditToolRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetEditToolRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetEditToolRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetEditToolRequestBody} SetEditToolRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetEditToolRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetEditToolRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.editTool = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetEditToolRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetEditToolRequestBody} SetEditToolRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetEditToolRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetEditToolRequestBody message.
         * @function verify
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetEditToolRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.editTool != null && message.hasOwnProperty("editTool"))
                switch (message.editTool) {
                default:
                    return "editTool: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                case 8:
                case 9:
                case 9:
                case 10:
                case 10:
                case 11:
                case 11:
                case 12:
                case 12:
                case 13:
                case 13:
                case 14:
                case 14:
                case 15:
                case 15:
                case 16:
                case 16:
                case 17:
                case 17:
                case 18:
                case 18:
                case 19:
                case 19:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetEditToolRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetEditToolRequestBody} SetEditToolRequestBody
         */
        SetEditToolRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetEditToolRequestBody)
                return object;
            var message = new $root.ptsl.SetEditToolRequestBody();
            switch (object.editTool) {
            default:
                if (typeof object.editTool === "number") {
                    message.editTool = object.editTool;
                    break;
                }
                break;
            case "ET_Unknown":
            case 0:
                message.editTool = 0;
                break;
            case "ETool_Unknown":
            case 0:
                message.editTool = 0;
                break;
            case "ET_ZoomNormal":
            case 1:
                message.editTool = 1;
                break;
            case "ETool_ZoomNormal":
            case 1:
                message.editTool = 1;
                break;
            case "ET_ZoomSingle":
            case 2:
                message.editTool = 2;
                break;
            case "ETool_ZoomSingle":
            case 2:
                message.editTool = 2;
                break;
            case "ET_TrimStandard":
            case 3:
                message.editTool = 3;
                break;
            case "ETool_TrimStandard":
            case 3:
                message.editTool = 3;
                break;
            case "ET_TrimTce":
            case 4:
                message.editTool = 4;
                break;
            case "ETool_TrimTce":
            case 4:
                message.editTool = 4;
                break;
            case "ET_TrimScrub":
            case 5:
                message.editTool = 5;
                break;
            case "ETool_TrimScrub":
            case 5:
                message.editTool = 5;
                break;
            case "ET_TrimLoop":
            case 6:
                message.editTool = 6;
                break;
            case "ETool_TrimLoop":
            case 6:
                message.editTool = 6;
                break;
            case "ET_Selector":
            case 7:
                message.editTool = 7;
                break;
            case "ETool_Selector":
            case 7:
                message.editTool = 7;
                break;
            case "ET_GrabberTime":
            case 8:
                message.editTool = 8;
                break;
            case "ETool_GrabberTime":
            case 8:
                message.editTool = 8;
                break;
            case "ET_GrabberSeparation":
            case 9:
                message.editTool = 9;
                break;
            case "ETool_GrabberSeparation":
            case 9:
                message.editTool = 9;
                break;
            case "ET_GrabberObject":
            case 10:
                message.editTool = 10;
                break;
            case "ETool_GrabberObject":
            case 10:
                message.editTool = 10;
                break;
            case "ET_SmartTool":
            case 11:
                message.editTool = 11;
                break;
            case "ETool_SmartTool":
            case 11:
                message.editTool = 11;
                break;
            case "ET_Scrubber":
            case 12:
                message.editTool = 12;
                break;
            case "ETool_Scrubber":
            case 12:
                message.editTool = 12;
                break;
            case "ET_PencilFreeHand":
            case 13:
                message.editTool = 13;
                break;
            case "ETool_PencilFreeHand":
            case 13:
                message.editTool = 13;
                break;
            case "ET_PencilLine":
            case 14:
                message.editTool = 14;
                break;
            case "ETool_PencilLine":
            case 14:
                message.editTool = 14;
                break;
            case "ET_PencilTriangle":
            case 15:
                message.editTool = 15;
                break;
            case "ETool_PencilTriangle":
            case 15:
                message.editTool = 15;
                break;
            case "ET_PencilSquare":
            case 16:
                message.editTool = 16;
                break;
            case "ETool_PencilSquare":
            case 16:
                message.editTool = 16;
                break;
            case "ET_PencilRandom":
            case 17:
                message.editTool = 17;
                break;
            case "ETool_PencilRandom":
            case 17:
                message.editTool = 17;
                break;
            case "ET_PencilParabolic":
            case 18:
                message.editTool = 18;
                break;
            case "ETool_PencilParabolic":
            case 18:
                message.editTool = 18;
                break;
            case "ET_PencilSCurve":
            case 19:
                message.editTool = 19;
                break;
            case "ETool_PencilSCurve":
            case 19:
                message.editTool = 19;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetEditToolRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {ptsl.SetEditToolRequestBody} message SetEditToolRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetEditToolRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.editTool = options.enums === String ? "ET_Unknown" : 0;
            if (message.editTool != null && message.hasOwnProperty("editTool"))
                object.editTool = options.enums === String ? $root.ptsl.EditTool[message.editTool] === undefined ? message.editTool : $root.ptsl.EditTool[message.editTool] : message.editTool;
            return object;
        };

        /**
         * Converts this SetEditToolRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetEditToolRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetEditToolRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetEditToolRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetEditToolRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetEditToolRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetEditToolRequestBody";
        };

        return SetEditToolRequestBody;
    })();

    ptsl.RecallZoomPresetRequestBody = (function() {

        /**
         * Properties of a RecallZoomPresetRequestBody.
         * @memberof ptsl
         * @interface IRecallZoomPresetRequestBody
         * @property {number|null} [zoomPreset] RecallZoomPresetRequestBody zoomPreset
         */

        /**
         * Constructs a new RecallZoomPresetRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes RecallZoomPreset request data.
         * @implements IRecallZoomPresetRequestBody
         * @constructor
         * @param {ptsl.IRecallZoomPresetRequestBody=} [properties] Properties to set
         */
        function RecallZoomPresetRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecallZoomPresetRequestBody zoomPreset.
         * @member {number} zoomPreset
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @instance
         */
        RecallZoomPresetRequestBody.prototype.zoomPreset = 0;

        /**
         * Creates a new RecallZoomPresetRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {ptsl.IRecallZoomPresetRequestBody=} [properties] Properties to set
         * @returns {ptsl.RecallZoomPresetRequestBody} RecallZoomPresetRequestBody instance
         */
        RecallZoomPresetRequestBody.create = function create(properties) {
            return new RecallZoomPresetRequestBody(properties);
        };

        /**
         * Encodes the specified RecallZoomPresetRequestBody message. Does not implicitly {@link ptsl.RecallZoomPresetRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {ptsl.IRecallZoomPresetRequestBody} message RecallZoomPresetRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallZoomPresetRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.zoomPreset != null && Object.hasOwnProperty.call(message, "zoomPreset"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.zoomPreset);
            return writer;
        };

        /**
         * Encodes the specified RecallZoomPresetRequestBody message, length delimited. Does not implicitly {@link ptsl.RecallZoomPresetRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {ptsl.IRecallZoomPresetRequestBody} message RecallZoomPresetRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallZoomPresetRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecallZoomPresetRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RecallZoomPresetRequestBody} RecallZoomPresetRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallZoomPresetRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RecallZoomPresetRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.zoomPreset = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecallZoomPresetRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RecallZoomPresetRequestBody} RecallZoomPresetRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallZoomPresetRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecallZoomPresetRequestBody message.
         * @function verify
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecallZoomPresetRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.zoomPreset != null && message.hasOwnProperty("zoomPreset"))
                if (!$util.isInteger(message.zoomPreset))
                    return "zoomPreset: integer expected";
            return null;
        };

        /**
         * Creates a RecallZoomPresetRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RecallZoomPresetRequestBody} RecallZoomPresetRequestBody
         */
        RecallZoomPresetRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RecallZoomPresetRequestBody)
                return object;
            var message = new $root.ptsl.RecallZoomPresetRequestBody();
            if (object.zoomPreset != null)
                message.zoomPreset = object.zoomPreset | 0;
            return message;
        };

        /**
         * Creates a plain object from a RecallZoomPresetRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {ptsl.RecallZoomPresetRequestBody} message RecallZoomPresetRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecallZoomPresetRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.zoomPreset = 0;
            if (message.zoomPreset != null && message.hasOwnProperty("zoomPreset"))
                object.zoomPreset = message.zoomPreset;
            return object;
        };

        /**
         * Converts this RecallZoomPresetRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecallZoomPresetRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RecallZoomPresetRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RecallZoomPresetRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RecallZoomPresetRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RecallZoomPresetRequestBody";
        };

        return RecallZoomPresetRequestBody;
    })();

    ptsl.GetEditModeOptionsResponseBody = (function() {

        /**
         * Properties of a GetEditModeOptionsResponseBody.
         * @memberof ptsl
         * @interface IGetEditModeOptionsResponseBody
         * @property {ptsl.IEditModeOptions|null} [editModeOptions] GetEditModeOptionsResponseBody editModeOptions
         */

        /**
         * Constructs a new GetEditModeOptionsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetEditModeOptions response data.
         * @implements IGetEditModeOptionsResponseBody
         * @constructor
         * @param {ptsl.IGetEditModeOptionsResponseBody=} [properties] Properties to set
         */
        function GetEditModeOptionsResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetEditModeOptionsResponseBody editModeOptions.
         * @member {ptsl.IEditModeOptions|null|undefined} editModeOptions
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @instance
         */
        GetEditModeOptionsResponseBody.prototype.editModeOptions = null;

        /**
         * Creates a new GetEditModeOptionsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {ptsl.IGetEditModeOptionsResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetEditModeOptionsResponseBody} GetEditModeOptionsResponseBody instance
         */
        GetEditModeOptionsResponseBody.create = function create(properties) {
            return new GetEditModeOptionsResponseBody(properties);
        };

        /**
         * Encodes the specified GetEditModeOptionsResponseBody message. Does not implicitly {@link ptsl.GetEditModeOptionsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {ptsl.IGetEditModeOptionsResponseBody} message GetEditModeOptionsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditModeOptionsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.editModeOptions != null && Object.hasOwnProperty.call(message, "editModeOptions"))
                $root.ptsl.EditModeOptions.encode(message.editModeOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetEditModeOptionsResponseBody message, length delimited. Does not implicitly {@link ptsl.GetEditModeOptionsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {ptsl.IGetEditModeOptionsResponseBody} message GetEditModeOptionsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditModeOptionsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEditModeOptionsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetEditModeOptionsResponseBody} GetEditModeOptionsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditModeOptionsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetEditModeOptionsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.editModeOptions = $root.ptsl.EditModeOptions.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEditModeOptionsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetEditModeOptionsResponseBody} GetEditModeOptionsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditModeOptionsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEditModeOptionsResponseBody message.
         * @function verify
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEditModeOptionsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.editModeOptions != null && message.hasOwnProperty("editModeOptions")) {
                var error = $root.ptsl.EditModeOptions.verify(message.editModeOptions);
                if (error)
                    return "editModeOptions." + error;
            }
            return null;
        };

        /**
         * Creates a GetEditModeOptionsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetEditModeOptionsResponseBody} GetEditModeOptionsResponseBody
         */
        GetEditModeOptionsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetEditModeOptionsResponseBody)
                return object;
            var message = new $root.ptsl.GetEditModeOptionsResponseBody();
            if (object.editModeOptions != null) {
                if (typeof object.editModeOptions !== "object")
                    throw TypeError(".ptsl.GetEditModeOptionsResponseBody.editModeOptions: object expected");
                message.editModeOptions = $root.ptsl.EditModeOptions.fromObject(object.editModeOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEditModeOptionsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {ptsl.GetEditModeOptionsResponseBody} message GetEditModeOptionsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEditModeOptionsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.editModeOptions = null;
            if (message.editModeOptions != null && message.hasOwnProperty("editModeOptions"))
                object.editModeOptions = $root.ptsl.EditModeOptions.toObject(message.editModeOptions, options);
            return object;
        };

        /**
         * Converts this GetEditModeOptionsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEditModeOptionsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetEditModeOptionsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetEditModeOptionsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetEditModeOptionsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetEditModeOptionsResponseBody";
        };

        return GetEditModeOptionsResponseBody;
    })();

    ptsl.SetEditModeOptionsRequestBody = (function() {

        /**
         * Properties of a SetEditModeOptionsRequestBody.
         * @memberof ptsl
         * @interface ISetEditModeOptionsRequestBody
         * @property {ptsl.IEditModeOptions|null} [editModeOptions] SetEditModeOptionsRequestBody editModeOptions
         */

        /**
         * Constructs a new SetEditModeOptionsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetEditModeOptions request data.
         * @implements ISetEditModeOptionsRequestBody
         * @constructor
         * @param {ptsl.ISetEditModeOptionsRequestBody=} [properties] Properties to set
         */
        function SetEditModeOptionsRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetEditModeOptionsRequestBody editModeOptions.
         * @member {ptsl.IEditModeOptions|null|undefined} editModeOptions
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @instance
         */
        SetEditModeOptionsRequestBody.prototype.editModeOptions = null;

        /**
         * Creates a new SetEditModeOptionsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {ptsl.ISetEditModeOptionsRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetEditModeOptionsRequestBody} SetEditModeOptionsRequestBody instance
         */
        SetEditModeOptionsRequestBody.create = function create(properties) {
            return new SetEditModeOptionsRequestBody(properties);
        };

        /**
         * Encodes the specified SetEditModeOptionsRequestBody message. Does not implicitly {@link ptsl.SetEditModeOptionsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {ptsl.ISetEditModeOptionsRequestBody} message SetEditModeOptionsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetEditModeOptionsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.editModeOptions != null && Object.hasOwnProperty.call(message, "editModeOptions"))
                $root.ptsl.EditModeOptions.encode(message.editModeOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetEditModeOptionsRequestBody message, length delimited. Does not implicitly {@link ptsl.SetEditModeOptionsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {ptsl.ISetEditModeOptionsRequestBody} message SetEditModeOptionsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetEditModeOptionsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetEditModeOptionsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetEditModeOptionsRequestBody} SetEditModeOptionsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetEditModeOptionsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetEditModeOptionsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.editModeOptions = $root.ptsl.EditModeOptions.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetEditModeOptionsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetEditModeOptionsRequestBody} SetEditModeOptionsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetEditModeOptionsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetEditModeOptionsRequestBody message.
         * @function verify
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetEditModeOptionsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.editModeOptions != null && message.hasOwnProperty("editModeOptions")) {
                var error = $root.ptsl.EditModeOptions.verify(message.editModeOptions);
                if (error)
                    return "editModeOptions." + error;
            }
            return null;
        };

        /**
         * Creates a SetEditModeOptionsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetEditModeOptionsRequestBody} SetEditModeOptionsRequestBody
         */
        SetEditModeOptionsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetEditModeOptionsRequestBody)
                return object;
            var message = new $root.ptsl.SetEditModeOptionsRequestBody();
            if (object.editModeOptions != null) {
                if (typeof object.editModeOptions !== "object")
                    throw TypeError(".ptsl.SetEditModeOptionsRequestBody.editModeOptions: object expected");
                message.editModeOptions = $root.ptsl.EditModeOptions.fromObject(object.editModeOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a SetEditModeOptionsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {ptsl.SetEditModeOptionsRequestBody} message SetEditModeOptionsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetEditModeOptionsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.editModeOptions = null;
            if (message.editModeOptions != null && message.hasOwnProperty("editModeOptions"))
                object.editModeOptions = $root.ptsl.EditModeOptions.toObject(message.editModeOptions, options);
            return object;
        };

        /**
         * Converts this SetEditModeOptionsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetEditModeOptionsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetEditModeOptionsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetEditModeOptionsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetEditModeOptionsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetEditModeOptionsRequestBody";
        };

        return SetEditModeOptionsRequestBody;
    })();

    /**
     * Type of video synchronization mode.
     * @name ptsl.TimelineUpdateVideo
     * @enum {number}
     * @property {number} TUV_Unknown=0 * @deprecated ptsl::TimelineUpdateVideo::TUV_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimelineUpdateVideo::TUVideo_Unknown
     * @property {number} TUVideo_Unknown=0 TUVideo_Unknown value
     * @property {number} TUV_None=1 * @deprecated ptsl::TimelineUpdateVideo::TUV_None is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimelineUpdateVideo::TUVideo_None
     * @property {number} TUVideo_None=1 TUVideo_None value
     * @property {number} TUV_In=2 * @deprecated ptsl::TimelineUpdateVideo::TUV_In is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimelineUpdateVideo::TUVideo_In
     * @property {number} TUVideo_In=2 TUVideo_In value
     * @property {number} TUV_Out=3 * @deprecated ptsl::TimelineUpdateVideo::TUV_Out is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::TimelineUpdateVideo::TUVideo_Out
     * @property {number} TUVideo_Out=3 TUVideo_Out value
     */
    ptsl.TimelineUpdateVideo = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TUV_Unknown"] = 0;
        values["TUVideo_Unknown"] = 0;
        values[valuesById[1] = "TUV_None"] = 1;
        values["TUVideo_None"] = 1;
        values[valuesById[2] = "TUV_In"] = 2;
        values["TUVideo_In"] = 2;
        values[valuesById[3] = "TUV_Out"] = 3;
        values["TUVideo_Out"] = 3;
        return values;
    })();

    ptsl.SetTimelineSelectionRequestBody = (function() {

        /**
         * Properties of a SetTimelineSelectionRequestBody.
         * @memberof ptsl
         * @interface ISetTimelineSelectionRequestBody
         * @property {string|null} [playStartMarkerTime] SetTimelineSelectionRequestBody playStartMarkerTime
         * @property {string|null} [inTime] SetTimelineSelectionRequestBody inTime
         * @property {string|null} [outTime] SetTimelineSelectionRequestBody outTime
         * @property {string|null} [preRollStartTime] SetTimelineSelectionRequestBody preRollStartTime
         * @property {string|null} [postRollStopTime] SetTimelineSelectionRequestBody postRollStopTime
         * @property {ptsl.TripleBool|null} [preRollEnabled] SetTimelineSelectionRequestBody preRollEnabled
         * @property {ptsl.TripleBool|null} [postRollEnabled] SetTimelineSelectionRequestBody postRollEnabled
         * @property {ptsl.TimelineUpdateVideo|null} [updateVideoTo] SetTimelineSelectionRequestBody updateVideoTo
         * @property {ptsl.TripleBool|null} [propagateToSatellites] SetTimelineSelectionRequestBody propagateToSatellites
         * @property {ptsl.TimelineLocationType|null} [locationType] * Use the new parameter 'location_type' to specify time units explicitly.
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new SetTimelineSelectionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTimelineSelection request data.
         * @implements ISetTimelineSelectionRequestBody
         * @constructor
         * @param {ptsl.ISetTimelineSelectionRequestBody=} [properties] Properties to set
         */
        function SetTimelineSelectionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTimelineSelectionRequestBody playStartMarkerTime.
         * @member {string} playStartMarkerTime
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.playStartMarkerTime = "";

        /**
         * SetTimelineSelectionRequestBody inTime.
         * @member {string} inTime
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.inTime = "";

        /**
         * SetTimelineSelectionRequestBody outTime.
         * @member {string} outTime
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.outTime = "";

        /**
         * SetTimelineSelectionRequestBody preRollStartTime.
         * @member {string} preRollStartTime
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.preRollStartTime = "";

        /**
         * SetTimelineSelectionRequestBody postRollStopTime.
         * @member {string} postRollStopTime
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.postRollStopTime = "";

        /**
         * SetTimelineSelectionRequestBody preRollEnabled.
         * @member {ptsl.TripleBool} preRollEnabled
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.preRollEnabled = 0;

        /**
         * SetTimelineSelectionRequestBody postRollEnabled.
         * @member {ptsl.TripleBool} postRollEnabled
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.postRollEnabled = 0;

        /**
         * SetTimelineSelectionRequestBody updateVideoTo.
         * @member {ptsl.TimelineUpdateVideo} updateVideoTo
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.updateVideoTo = 0;

        /**
         * SetTimelineSelectionRequestBody propagateToSatellites.
         * @member {ptsl.TripleBool} propagateToSatellites
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.propagateToSatellites = 0;

        /**
         * * Use the new parameter 'location_type' to specify time units explicitly.
         * * @since Pro Tools 2025.06
         * @member {ptsl.TimelineLocationType} locationType
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         */
        SetTimelineSelectionRequestBody.prototype.locationType = 0;

        /**
         * Creates a new SetTimelineSelectionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.ISetTimelineSelectionRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTimelineSelectionRequestBody} SetTimelineSelectionRequestBody instance
         */
        SetTimelineSelectionRequestBody.create = function create(properties) {
            return new SetTimelineSelectionRequestBody(properties);
        };

        /**
         * Encodes the specified SetTimelineSelectionRequestBody message. Does not implicitly {@link ptsl.SetTimelineSelectionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.ISetTimelineSelectionRequestBody} message SetTimelineSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTimelineSelectionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playStartMarkerTime != null && Object.hasOwnProperty.call(message, "playStartMarkerTime"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playStartMarkerTime);
            if (message.inTime != null && Object.hasOwnProperty.call(message, "inTime"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.inTime);
            if (message.outTime != null && Object.hasOwnProperty.call(message, "outTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.outTime);
            if (message.preRollStartTime != null && Object.hasOwnProperty.call(message, "preRollStartTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.preRollStartTime);
            if (message.postRollStopTime != null && Object.hasOwnProperty.call(message, "postRollStopTime"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.postRollStopTime);
            if (message.preRollEnabled != null && Object.hasOwnProperty.call(message, "preRollEnabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.preRollEnabled);
            if (message.postRollEnabled != null && Object.hasOwnProperty.call(message, "postRollEnabled"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.postRollEnabled);
            if (message.updateVideoTo != null && Object.hasOwnProperty.call(message, "updateVideoTo"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.updateVideoTo);
            if (message.propagateToSatellites != null && Object.hasOwnProperty.call(message, "propagateToSatellites"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.propagateToSatellites);
            if (message.locationType != null && Object.hasOwnProperty.call(message, "locationType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.locationType);
            return writer;
        };

        /**
         * Encodes the specified SetTimelineSelectionRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTimelineSelectionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.ISetTimelineSelectionRequestBody} message SetTimelineSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTimelineSelectionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTimelineSelectionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTimelineSelectionRequestBody} SetTimelineSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTimelineSelectionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTimelineSelectionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.playStartMarkerTime = reader.string();
                        break;
                    }
                case 2: {
                        message.inTime = reader.string();
                        break;
                    }
                case 3: {
                        message.outTime = reader.string();
                        break;
                    }
                case 4: {
                        message.preRollStartTime = reader.string();
                        break;
                    }
                case 5: {
                        message.postRollStopTime = reader.string();
                        break;
                    }
                case 6: {
                        message.preRollEnabled = reader.int32();
                        break;
                    }
                case 7: {
                        message.postRollEnabled = reader.int32();
                        break;
                    }
                case 8: {
                        message.updateVideoTo = reader.int32();
                        break;
                    }
                case 9: {
                        message.propagateToSatellites = reader.int32();
                        break;
                    }
                case 10: {
                        message.locationType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTimelineSelectionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTimelineSelectionRequestBody} SetTimelineSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTimelineSelectionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTimelineSelectionRequestBody message.
         * @function verify
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTimelineSelectionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playStartMarkerTime != null && message.hasOwnProperty("playStartMarkerTime"))
                if (!$util.isString(message.playStartMarkerTime))
                    return "playStartMarkerTime: string expected";
            if (message.inTime != null && message.hasOwnProperty("inTime"))
                if (!$util.isString(message.inTime))
                    return "inTime: string expected";
            if (message.outTime != null && message.hasOwnProperty("outTime"))
                if (!$util.isString(message.outTime))
                    return "outTime: string expected";
            if (message.preRollStartTime != null && message.hasOwnProperty("preRollStartTime"))
                if (!$util.isString(message.preRollStartTime))
                    return "preRollStartTime: string expected";
            if (message.postRollStopTime != null && message.hasOwnProperty("postRollStopTime"))
                if (!$util.isString(message.postRollStopTime))
                    return "postRollStopTime: string expected";
            if (message.preRollEnabled != null && message.hasOwnProperty("preRollEnabled"))
                switch (message.preRollEnabled) {
                default:
                    return "preRollEnabled: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.postRollEnabled != null && message.hasOwnProperty("postRollEnabled"))
                switch (message.postRollEnabled) {
                default:
                    return "postRollEnabled: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.updateVideoTo != null && message.hasOwnProperty("updateVideoTo"))
                switch (message.updateVideoTo) {
                default:
                    return "updateVideoTo: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.propagateToSatellites != null && message.hasOwnProperty("propagateToSatellites"))
                switch (message.propagateToSatellites) {
                default:
                    return "propagateToSatellites: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                switch (message.locationType) {
                default:
                    return "locationType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetTimelineSelectionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTimelineSelectionRequestBody} SetTimelineSelectionRequestBody
         */
        SetTimelineSelectionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTimelineSelectionRequestBody)
                return object;
            var message = new $root.ptsl.SetTimelineSelectionRequestBody();
            if (object.playStartMarkerTime != null)
                message.playStartMarkerTime = String(object.playStartMarkerTime);
            if (object.inTime != null)
                message.inTime = String(object.inTime);
            if (object.outTime != null)
                message.outTime = String(object.outTime);
            if (object.preRollStartTime != null)
                message.preRollStartTime = String(object.preRollStartTime);
            if (object.postRollStopTime != null)
                message.postRollStopTime = String(object.postRollStopTime);
            switch (object.preRollEnabled) {
            default:
                if (typeof object.preRollEnabled === "number") {
                    message.preRollEnabled = object.preRollEnabled;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.preRollEnabled = 0;
                break;
            case "TB_None":
            case 1:
                message.preRollEnabled = 1;
                break;
            case "TBool_None":
            case 1:
                message.preRollEnabled = 1;
                break;
            case "TB_False":
            case 2:
                message.preRollEnabled = 2;
                break;
            case "TBool_False":
            case 2:
                message.preRollEnabled = 2;
                break;
            case "TB_True":
            case 3:
                message.preRollEnabled = 3;
                break;
            case "TBool_True":
            case 3:
                message.preRollEnabled = 3;
                break;
            }
            switch (object.postRollEnabled) {
            default:
                if (typeof object.postRollEnabled === "number") {
                    message.postRollEnabled = object.postRollEnabled;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.postRollEnabled = 0;
                break;
            case "TB_None":
            case 1:
                message.postRollEnabled = 1;
                break;
            case "TBool_None":
            case 1:
                message.postRollEnabled = 1;
                break;
            case "TB_False":
            case 2:
                message.postRollEnabled = 2;
                break;
            case "TBool_False":
            case 2:
                message.postRollEnabled = 2;
                break;
            case "TB_True":
            case 3:
                message.postRollEnabled = 3;
                break;
            case "TBool_True":
            case 3:
                message.postRollEnabled = 3;
                break;
            }
            switch (object.updateVideoTo) {
            default:
                if (typeof object.updateVideoTo === "number") {
                    message.updateVideoTo = object.updateVideoTo;
                    break;
                }
                break;
            case "TUV_Unknown":
            case 0:
                message.updateVideoTo = 0;
                break;
            case "TUVideo_Unknown":
            case 0:
                message.updateVideoTo = 0;
                break;
            case "TUV_None":
            case 1:
                message.updateVideoTo = 1;
                break;
            case "TUVideo_None":
            case 1:
                message.updateVideoTo = 1;
                break;
            case "TUV_In":
            case 2:
                message.updateVideoTo = 2;
                break;
            case "TUVideo_In":
            case 2:
                message.updateVideoTo = 2;
                break;
            case "TUV_Out":
            case 3:
                message.updateVideoTo = 3;
                break;
            case "TUVideo_Out":
            case 3:
                message.updateVideoTo = 3;
                break;
            }
            switch (object.propagateToSatellites) {
            default:
                if (typeof object.propagateToSatellites === "number") {
                    message.propagateToSatellites = object.propagateToSatellites;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.propagateToSatellites = 0;
                break;
            case "TB_None":
            case 1:
                message.propagateToSatellites = 1;
                break;
            case "TBool_None":
            case 1:
                message.propagateToSatellites = 1;
                break;
            case "TB_False":
            case 2:
                message.propagateToSatellites = 2;
                break;
            case "TBool_False":
            case 2:
                message.propagateToSatellites = 2;
                break;
            case "TB_True":
            case 3:
                message.propagateToSatellites = 3;
                break;
            case "TBool_True":
            case 3:
                message.propagateToSatellites = 3;
                break;
            }
            switch (object.locationType) {
            default:
                if (typeof object.locationType === "number") {
                    message.locationType = object.locationType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.locationType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.locationType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.locationType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.locationType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.locationType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.locationType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.locationType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.locationType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.locationType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetTimelineSelectionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.SetTimelineSelectionRequestBody} message SetTimelineSelectionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTimelineSelectionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playStartMarkerTime = "";
                object.inTime = "";
                object.outTime = "";
                object.preRollStartTime = "";
                object.postRollStopTime = "";
                object.preRollEnabled = options.enums === String ? "TBool_Unknown" : 0;
                object.postRollEnabled = options.enums === String ? "TBool_Unknown" : 0;
                object.updateVideoTo = options.enums === String ? "TUV_Unknown" : 0;
                object.propagateToSatellites = options.enums === String ? "TBool_Unknown" : 0;
                object.locationType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.playStartMarkerTime != null && message.hasOwnProperty("playStartMarkerTime"))
                object.playStartMarkerTime = message.playStartMarkerTime;
            if (message.inTime != null && message.hasOwnProperty("inTime"))
                object.inTime = message.inTime;
            if (message.outTime != null && message.hasOwnProperty("outTime"))
                object.outTime = message.outTime;
            if (message.preRollStartTime != null && message.hasOwnProperty("preRollStartTime"))
                object.preRollStartTime = message.preRollStartTime;
            if (message.postRollStopTime != null && message.hasOwnProperty("postRollStopTime"))
                object.postRollStopTime = message.postRollStopTime;
            if (message.preRollEnabled != null && message.hasOwnProperty("preRollEnabled"))
                object.preRollEnabled = options.enums === String ? $root.ptsl.TripleBool[message.preRollEnabled] === undefined ? message.preRollEnabled : $root.ptsl.TripleBool[message.preRollEnabled] : message.preRollEnabled;
            if (message.postRollEnabled != null && message.hasOwnProperty("postRollEnabled"))
                object.postRollEnabled = options.enums === String ? $root.ptsl.TripleBool[message.postRollEnabled] === undefined ? message.postRollEnabled : $root.ptsl.TripleBool[message.postRollEnabled] : message.postRollEnabled;
            if (message.updateVideoTo != null && message.hasOwnProperty("updateVideoTo"))
                object.updateVideoTo = options.enums === String ? $root.ptsl.TimelineUpdateVideo[message.updateVideoTo] === undefined ? message.updateVideoTo : $root.ptsl.TimelineUpdateVideo[message.updateVideoTo] : message.updateVideoTo;
            if (message.propagateToSatellites != null && message.hasOwnProperty("propagateToSatellites"))
                object.propagateToSatellites = options.enums === String ? $root.ptsl.TripleBool[message.propagateToSatellites] === undefined ? message.propagateToSatellites : $root.ptsl.TripleBool[message.propagateToSatellites] : message.propagateToSatellites;
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                object.locationType = options.enums === String ? $root.ptsl.TimelineLocationType[message.locationType] === undefined ? message.locationType : $root.ptsl.TimelineLocationType[message.locationType] : message.locationType;
            return object;
        };

        /**
         * Converts this SetTimelineSelectionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTimelineSelectionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTimelineSelectionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTimelineSelectionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTimelineSelectionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTimelineSelectionRequestBody";
        };

        return SetTimelineSelectionRequestBody;
    })();

    ptsl.GetTimelineSelectionRequestBody = (function() {

        /**
         * Properties of a GetTimelineSelectionRequestBody.
         * @memberof ptsl
         * @interface IGetTimelineSelectionRequestBody
         * @property {ptsl.TrackOffsetOptions|null} [timeScale] * @deprecated since Pro Tools 2025.06, use location_type
         * @property {ptsl.TimelineLocationType|null} [locationType] * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new GetTimelineSelectionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTimelineSelection request data.
         * @implements IGetTimelineSelectionRequestBody
         * @constructor
         * @param {ptsl.IGetTimelineSelectionRequestBody=} [properties] Properties to set
         */
        function GetTimelineSelectionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2025.06, use location_type
         * @member {ptsl.TrackOffsetOptions} timeScale
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @instance
         */
        GetTimelineSelectionRequestBody.prototype.timeScale = 0;

        /**
         * * @since Pro Tools 2025.06
         * @member {ptsl.TimelineLocationType} locationType
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @instance
         */
        GetTimelineSelectionRequestBody.prototype.locationType = 0;

        /**
         * Creates a new GetTimelineSelectionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.IGetTimelineSelectionRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetTimelineSelectionRequestBody} GetTimelineSelectionRequestBody instance
         */
        GetTimelineSelectionRequestBody.create = function create(properties) {
            return new GetTimelineSelectionRequestBody(properties);
        };

        /**
         * Encodes the specified GetTimelineSelectionRequestBody message. Does not implicitly {@link ptsl.GetTimelineSelectionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.IGetTimelineSelectionRequestBody} message GetTimelineSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimelineSelectionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeScale != null && Object.hasOwnProperty.call(message, "timeScale"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.timeScale);
            if (message.locationType != null && Object.hasOwnProperty.call(message, "locationType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.locationType);
            return writer;
        };

        /**
         * Encodes the specified GetTimelineSelectionRequestBody message, length delimited. Does not implicitly {@link ptsl.GetTimelineSelectionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.IGetTimelineSelectionRequestBody} message GetTimelineSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimelineSelectionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTimelineSelectionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTimelineSelectionRequestBody} GetTimelineSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimelineSelectionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTimelineSelectionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.timeScale = reader.int32();
                        break;
                    }
                case 2: {
                        message.locationType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTimelineSelectionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTimelineSelectionRequestBody} GetTimelineSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimelineSelectionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTimelineSelectionRequestBody message.
         * @function verify
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTimelineSelectionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeScale != null && message.hasOwnProperty("timeScale"))
                switch (message.timeScale) {
                default:
                    return "timeScale: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                switch (message.locationType) {
                default:
                    return "locationType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetTimelineSelectionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTimelineSelectionRequestBody} GetTimelineSelectionRequestBody
         */
        GetTimelineSelectionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTimelineSelectionRequestBody)
                return object;
            var message = new $root.ptsl.GetTimelineSelectionRequestBody();
            switch (object.timeScale) {
            default:
                if (typeof object.timeScale === "number") {
                    message.timeScale = object.timeScale;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.timeScale = 0;
                break;
            case "BarsBeats":
            case 1:
                message.timeScale = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.timeScale = 1;
                break;
            case "MinSecs":
            case 2:
                message.timeScale = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.timeScale = 2;
                break;
            case "TimeCode":
            case 3:
                message.timeScale = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.timeScale = 3;
                break;
            case "FeetFrames":
            case 4:
                message.timeScale = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.timeScale = 4;
                break;
            case "Samples":
            case 5:
                message.timeScale = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.timeScale = 5;
                break;
            }
            switch (object.locationType) {
            default:
                if (typeof object.locationType === "number") {
                    message.locationType = object.locationType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.locationType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.locationType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.locationType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.locationType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.locationType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.locationType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.locationType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.locationType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.locationType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTimelineSelectionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {ptsl.GetTimelineSelectionRequestBody} message GetTimelineSelectionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTimelineSelectionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.timeScale = options.enums === String ? "TOOptions_Unknown" : 0;
                object.locationType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.timeScale != null && message.hasOwnProperty("timeScale"))
                object.timeScale = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.timeScale] === undefined ? message.timeScale : $root.ptsl.TrackOffsetOptions[message.timeScale] : message.timeScale;
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                object.locationType = options.enums === String ? $root.ptsl.TimelineLocationType[message.locationType] === undefined ? message.locationType : $root.ptsl.TimelineLocationType[message.locationType] : message.locationType;
            return object;
        };

        /**
         * Converts this GetTimelineSelectionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTimelineSelectionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTimelineSelectionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetTimelineSelectionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTimelineSelectionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTimelineSelectionRequestBody";
        };

        return GetTimelineSelectionRequestBody;
    })();

    ptsl.GetTimelineSelectionResponseBody = (function() {

        /**
         * Properties of a GetTimelineSelectionResponseBody.
         * @memberof ptsl
         * @interface IGetTimelineSelectionResponseBody
         * @property {string|null} [playStartMarkerTime] GetTimelineSelectionResponseBody playStartMarkerTime
         * @property {string|null} [inTime] GetTimelineSelectionResponseBody inTime
         * @property {string|null} [outTime] GetTimelineSelectionResponseBody outTime
         * @property {string|null} [preRollStartTime] GetTimelineSelectionResponseBody preRollStartTime
         * @property {string|null} [postRollStopTime] GetTimelineSelectionResponseBody postRollStopTime
         * @property {boolean|null} [preRollEnabled] GetTimelineSelectionResponseBody preRollEnabled
         * @property {boolean|null} [postRollEnabled] GetTimelineSelectionResponseBody postRollEnabled
         */

        /**
         * Constructs a new GetTimelineSelectionResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTimelineSelection response data.
         * @implements IGetTimelineSelectionResponseBody
         * @constructor
         * @param {ptsl.IGetTimelineSelectionResponseBody=} [properties] Properties to set
         */
        function GetTimelineSelectionResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTimelineSelectionResponseBody playStartMarkerTime.
         * @member {string} playStartMarkerTime
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         */
        GetTimelineSelectionResponseBody.prototype.playStartMarkerTime = "";

        /**
         * GetTimelineSelectionResponseBody inTime.
         * @member {string} inTime
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         */
        GetTimelineSelectionResponseBody.prototype.inTime = "";

        /**
         * GetTimelineSelectionResponseBody outTime.
         * @member {string} outTime
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         */
        GetTimelineSelectionResponseBody.prototype.outTime = "";

        /**
         * GetTimelineSelectionResponseBody preRollStartTime.
         * @member {string} preRollStartTime
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         */
        GetTimelineSelectionResponseBody.prototype.preRollStartTime = "";

        /**
         * GetTimelineSelectionResponseBody postRollStopTime.
         * @member {string} postRollStopTime
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         */
        GetTimelineSelectionResponseBody.prototype.postRollStopTime = "";

        /**
         * GetTimelineSelectionResponseBody preRollEnabled.
         * @member {boolean} preRollEnabled
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         */
        GetTimelineSelectionResponseBody.prototype.preRollEnabled = false;

        /**
         * GetTimelineSelectionResponseBody postRollEnabled.
         * @member {boolean} postRollEnabled
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         */
        GetTimelineSelectionResponseBody.prototype.postRollEnabled = false;

        /**
         * Creates a new GetTimelineSelectionResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {ptsl.IGetTimelineSelectionResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetTimelineSelectionResponseBody} GetTimelineSelectionResponseBody instance
         */
        GetTimelineSelectionResponseBody.create = function create(properties) {
            return new GetTimelineSelectionResponseBody(properties);
        };

        /**
         * Encodes the specified GetTimelineSelectionResponseBody message. Does not implicitly {@link ptsl.GetTimelineSelectionResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {ptsl.IGetTimelineSelectionResponseBody} message GetTimelineSelectionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimelineSelectionResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playStartMarkerTime != null && Object.hasOwnProperty.call(message, "playStartMarkerTime"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playStartMarkerTime);
            if (message.inTime != null && Object.hasOwnProperty.call(message, "inTime"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.inTime);
            if (message.outTime != null && Object.hasOwnProperty.call(message, "outTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.outTime);
            if (message.preRollStartTime != null && Object.hasOwnProperty.call(message, "preRollStartTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.preRollStartTime);
            if (message.postRollStopTime != null && Object.hasOwnProperty.call(message, "postRollStopTime"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.postRollStopTime);
            if (message.preRollEnabled != null && Object.hasOwnProperty.call(message, "preRollEnabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.preRollEnabled);
            if (message.postRollEnabled != null && Object.hasOwnProperty.call(message, "postRollEnabled"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.postRollEnabled);
            return writer;
        };

        /**
         * Encodes the specified GetTimelineSelectionResponseBody message, length delimited. Does not implicitly {@link ptsl.GetTimelineSelectionResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {ptsl.IGetTimelineSelectionResponseBody} message GetTimelineSelectionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimelineSelectionResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTimelineSelectionResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTimelineSelectionResponseBody} GetTimelineSelectionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimelineSelectionResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTimelineSelectionResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.playStartMarkerTime = reader.string();
                        break;
                    }
                case 2: {
                        message.inTime = reader.string();
                        break;
                    }
                case 3: {
                        message.outTime = reader.string();
                        break;
                    }
                case 4: {
                        message.preRollStartTime = reader.string();
                        break;
                    }
                case 5: {
                        message.postRollStopTime = reader.string();
                        break;
                    }
                case 6: {
                        message.preRollEnabled = reader.bool();
                        break;
                    }
                case 7: {
                        message.postRollEnabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTimelineSelectionResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTimelineSelectionResponseBody} GetTimelineSelectionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimelineSelectionResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTimelineSelectionResponseBody message.
         * @function verify
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTimelineSelectionResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playStartMarkerTime != null && message.hasOwnProperty("playStartMarkerTime"))
                if (!$util.isString(message.playStartMarkerTime))
                    return "playStartMarkerTime: string expected";
            if (message.inTime != null && message.hasOwnProperty("inTime"))
                if (!$util.isString(message.inTime))
                    return "inTime: string expected";
            if (message.outTime != null && message.hasOwnProperty("outTime"))
                if (!$util.isString(message.outTime))
                    return "outTime: string expected";
            if (message.preRollStartTime != null && message.hasOwnProperty("preRollStartTime"))
                if (!$util.isString(message.preRollStartTime))
                    return "preRollStartTime: string expected";
            if (message.postRollStopTime != null && message.hasOwnProperty("postRollStopTime"))
                if (!$util.isString(message.postRollStopTime))
                    return "postRollStopTime: string expected";
            if (message.preRollEnabled != null && message.hasOwnProperty("preRollEnabled"))
                if (typeof message.preRollEnabled !== "boolean")
                    return "preRollEnabled: boolean expected";
            if (message.postRollEnabled != null && message.hasOwnProperty("postRollEnabled"))
                if (typeof message.postRollEnabled !== "boolean")
                    return "postRollEnabled: boolean expected";
            return null;
        };

        /**
         * Creates a GetTimelineSelectionResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTimelineSelectionResponseBody} GetTimelineSelectionResponseBody
         */
        GetTimelineSelectionResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTimelineSelectionResponseBody)
                return object;
            var message = new $root.ptsl.GetTimelineSelectionResponseBody();
            if (object.playStartMarkerTime != null)
                message.playStartMarkerTime = String(object.playStartMarkerTime);
            if (object.inTime != null)
                message.inTime = String(object.inTime);
            if (object.outTime != null)
                message.outTime = String(object.outTime);
            if (object.preRollStartTime != null)
                message.preRollStartTime = String(object.preRollStartTime);
            if (object.postRollStopTime != null)
                message.postRollStopTime = String(object.postRollStopTime);
            if (object.preRollEnabled != null)
                message.preRollEnabled = Boolean(object.preRollEnabled);
            if (object.postRollEnabled != null)
                message.postRollEnabled = Boolean(object.postRollEnabled);
            return message;
        };

        /**
         * Creates a plain object from a GetTimelineSelectionResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {ptsl.GetTimelineSelectionResponseBody} message GetTimelineSelectionResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTimelineSelectionResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playStartMarkerTime = "";
                object.inTime = "";
                object.outTime = "";
                object.preRollStartTime = "";
                object.postRollStopTime = "";
                object.preRollEnabled = false;
                object.postRollEnabled = false;
            }
            if (message.playStartMarkerTime != null && message.hasOwnProperty("playStartMarkerTime"))
                object.playStartMarkerTime = message.playStartMarkerTime;
            if (message.inTime != null && message.hasOwnProperty("inTime"))
                object.inTime = message.inTime;
            if (message.outTime != null && message.hasOwnProperty("outTime"))
                object.outTime = message.outTime;
            if (message.preRollStartTime != null && message.hasOwnProperty("preRollStartTime"))
                object.preRollStartTime = message.preRollStartTime;
            if (message.postRollStopTime != null && message.hasOwnProperty("postRollStopTime"))
                object.postRollStopTime = message.postRollStopTime;
            if (message.preRollEnabled != null && message.hasOwnProperty("preRollEnabled"))
                object.preRollEnabled = message.preRollEnabled;
            if (message.postRollEnabled != null && message.hasOwnProperty("postRollEnabled"))
                object.postRollEnabled = message.postRollEnabled;
            return object;
        };

        /**
         * Converts this GetTimelineSelectionResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTimelineSelectionResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTimelineSelectionResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetTimelineSelectionResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTimelineSelectionResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTimelineSelectionResponseBody";
        };

        return GetTimelineSelectionResponseBody;
    })();

    /**
     * Type of the track's possible selection.
     * @name ptsl.SelectionMode
     * @enum {number}
     * @property {number} SM_Unknown=0 * @deprecated ptsl::SelectionMode::SM_Unknown is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SelectionMode::SMode_Unknown
     * @property {number} SMode_Unknown=0 SMode_Unknown value
     * @property {number} SM_Replace=1 * @deprecated ptsl::SelectionMode::SM_Replace is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SelectionMode::SMode_Replace
     * @property {number} SMode_Replace=1 SMode_Replace value
     * @property {number} SM_Add=2 * @deprecated ptsl::SelectionMode::SM_Add is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SelectionMode::SMode_Add
     * @property {number} SMode_Add=2 SMode_Add value
     * @property {number} SM_Subtract=3 * @deprecated ptsl::SelectionMode::SM_Subtract is deprecated starting in Pro Tools 2025.06
     * * Replaced with @ref ptsl::SelectionMode::SMode_Subtract
     * @property {number} SMode_Subtract=3 SMode_Subtract value
     */
    ptsl.SelectionMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SM_Unknown"] = 0;
        values["SMode_Unknown"] = 0;
        values[valuesById[1] = "SM_Replace"] = 1;
        values["SMode_Replace"] = 1;
        values[valuesById[2] = "SM_Add"] = 2;
        values["SMode_Add"] = 2;
        values[valuesById[3] = "SM_Subtract"] = 3;
        values["SMode_Subtract"] = 3;
        return values;
    })();

    ptsl.SelectTracksByNameRequestBody = (function() {

        /**
         * Properties of a SelectTracksByNameRequestBody.
         * @memberof ptsl
         * @interface ISelectTracksByNameRequestBody
         * @property {Array.<string>|null} [trackNames] SelectTracksByNameRequestBody trackNames
         * @property {ptsl.SelectionMode|null} [selectionMode] SelectTracksByNameRequestBody selectionMode
         * @property {ptsl.IPaginationRequest|null} [paginationRequest] SelectTracksByNameRequestBody paginationRequest
         */

        /**
         * Constructs a new SelectTracksByNameRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SelectTracksByName request data.
         * @implements ISelectTracksByNameRequestBody
         * @constructor
         * @param {ptsl.ISelectTracksByNameRequestBody=} [properties] Properties to set
         */
        function SelectTracksByNameRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SelectTracksByNameRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @instance
         */
        SelectTracksByNameRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SelectTracksByNameRequestBody selectionMode.
         * @member {ptsl.SelectionMode} selectionMode
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @instance
         */
        SelectTracksByNameRequestBody.prototype.selectionMode = 0;

        /**
         * SelectTracksByNameRequestBody paginationRequest.
         * @member {ptsl.IPaginationRequest|null|undefined} paginationRequest
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @instance
         */
        SelectTracksByNameRequestBody.prototype.paginationRequest = null;

        /**
         * Creates a new SelectTracksByNameRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {ptsl.ISelectTracksByNameRequestBody=} [properties] Properties to set
         * @returns {ptsl.SelectTracksByNameRequestBody} SelectTracksByNameRequestBody instance
         */
        SelectTracksByNameRequestBody.create = function create(properties) {
            return new SelectTracksByNameRequestBody(properties);
        };

        /**
         * Encodes the specified SelectTracksByNameRequestBody message. Does not implicitly {@link ptsl.SelectTracksByNameRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {ptsl.ISelectTracksByNameRequestBody} message SelectTracksByNameRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectTracksByNameRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.selectionMode != null && Object.hasOwnProperty.call(message, "selectionMode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.selectionMode);
            if (message.paginationRequest != null && Object.hasOwnProperty.call(message, "paginationRequest"))
                $root.ptsl.PaginationRequest.encode(message.paginationRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SelectTracksByNameRequestBody message, length delimited. Does not implicitly {@link ptsl.SelectTracksByNameRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {ptsl.ISelectTracksByNameRequestBody} message SelectTracksByNameRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectTracksByNameRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SelectTracksByNameRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SelectTracksByNameRequestBody} SelectTracksByNameRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectTracksByNameRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SelectTracksByNameRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.selectionMode = reader.int32();
                        break;
                    }
                case 3: {
                        message.paginationRequest = $root.ptsl.PaginationRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SelectTracksByNameRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SelectTracksByNameRequestBody} SelectTracksByNameRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectTracksByNameRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SelectTracksByNameRequestBody message.
         * @function verify
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SelectTracksByNameRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.selectionMode != null && message.hasOwnProperty("selectionMode"))
                switch (message.selectionMode) {
                default:
                    return "selectionMode: enum value expected";
                case 0:
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest")) {
                var error = $root.ptsl.PaginationRequest.verify(message.paginationRequest);
                if (error)
                    return "paginationRequest." + error;
            }
            return null;
        };

        /**
         * Creates a SelectTracksByNameRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SelectTracksByNameRequestBody} SelectTracksByNameRequestBody
         */
        SelectTracksByNameRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SelectTracksByNameRequestBody)
                return object;
            var message = new $root.ptsl.SelectTracksByNameRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SelectTracksByNameRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            switch (object.selectionMode) {
            default:
                if (typeof object.selectionMode === "number") {
                    message.selectionMode = object.selectionMode;
                    break;
                }
                break;
            case "SM_Unknown":
            case 0:
                message.selectionMode = 0;
                break;
            case "SMode_Unknown":
            case 0:
                message.selectionMode = 0;
                break;
            case "SM_Replace":
            case 1:
                message.selectionMode = 1;
                break;
            case "SMode_Replace":
            case 1:
                message.selectionMode = 1;
                break;
            case "SM_Add":
            case 2:
                message.selectionMode = 2;
                break;
            case "SMode_Add":
            case 2:
                message.selectionMode = 2;
                break;
            case "SM_Subtract":
            case 3:
                message.selectionMode = 3;
                break;
            case "SMode_Subtract":
            case 3:
                message.selectionMode = 3;
                break;
            }
            if (object.paginationRequest != null) {
                if (typeof object.paginationRequest !== "object")
                    throw TypeError(".ptsl.SelectTracksByNameRequestBody.paginationRequest: object expected");
                message.paginationRequest = $root.ptsl.PaginationRequest.fromObject(object.paginationRequest);
            }
            return message;
        };

        /**
         * Creates a plain object from a SelectTracksByNameRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {ptsl.SelectTracksByNameRequestBody} message SelectTracksByNameRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SelectTracksByNameRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults) {
                object.selectionMode = options.enums === String ? "SM_Unknown" : 0;
                object.paginationRequest = null;
            }
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.selectionMode != null && message.hasOwnProperty("selectionMode"))
                object.selectionMode = options.enums === String ? $root.ptsl.SelectionMode[message.selectionMode] === undefined ? message.selectionMode : $root.ptsl.SelectionMode[message.selectionMode] : message.selectionMode;
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest"))
                object.paginationRequest = $root.ptsl.PaginationRequest.toObject(message.paginationRequest, options);
            return object;
        };

        /**
         * Converts this SelectTracksByNameRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SelectTracksByNameRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SelectTracksByNameRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SelectTracksByNameRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SelectTracksByNameRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SelectTracksByNameRequestBody";
        };

        return SelectTracksByNameRequestBody;
    })();

    ptsl.SelectTracksByNameResponseBody = (function() {

        /**
         * Properties of a SelectTracksByNameResponseBody.
         * @memberof ptsl
         * @interface ISelectTracksByNameResponseBody
         * @property {ptsl.IPagination|null} [stats] * @deprecated since Pro Tools 2023.09, use pagination_response
         * @property {Array.<ptsl.ITrack>|null} [trackList] SelectTracksByNameResponseBody trackList
         * @property {ptsl.IPaginationResponse|null} [paginationResponse] * @since Pro Tools 2023.09
         */

        /**
         * Constructs a new SelectTracksByNameResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes SelectTracksByName response data.
         * @implements ISelectTracksByNameResponseBody
         * @constructor
         * @param {ptsl.ISelectTracksByNameResponseBody=} [properties] Properties to set
         */
        function SelectTracksByNameResponseBody(properties) {
            this.trackList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2023.09, use pagination_response
         * @member {ptsl.IPagination|null|undefined} stats
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @instance
         */
        SelectTracksByNameResponseBody.prototype.stats = null;

        /**
         * SelectTracksByNameResponseBody trackList.
         * @member {Array.<ptsl.ITrack>} trackList
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @instance
         */
        SelectTracksByNameResponseBody.prototype.trackList = $util.emptyArray;

        /**
         * * @since Pro Tools 2023.09
         * @member {ptsl.IPaginationResponse|null|undefined} paginationResponse
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @instance
         */
        SelectTracksByNameResponseBody.prototype.paginationResponse = null;

        /**
         * Creates a new SelectTracksByNameResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {ptsl.ISelectTracksByNameResponseBody=} [properties] Properties to set
         * @returns {ptsl.SelectTracksByNameResponseBody} SelectTracksByNameResponseBody instance
         */
        SelectTracksByNameResponseBody.create = function create(properties) {
            return new SelectTracksByNameResponseBody(properties);
        };

        /**
         * Encodes the specified SelectTracksByNameResponseBody message. Does not implicitly {@link ptsl.SelectTracksByNameResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {ptsl.ISelectTracksByNameResponseBody} message SelectTracksByNameResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectTracksByNameResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stats != null && Object.hasOwnProperty.call(message, "stats"))
                $root.ptsl.Pagination.encode(message.stats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trackList != null && message.trackList.length)
                for (var i = 0; i < message.trackList.length; ++i)
                    $root.ptsl.Track.encode(message.trackList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.paginationResponse != null && Object.hasOwnProperty.call(message, "paginationResponse"))
                $root.ptsl.PaginationResponse.encode(message.paginationResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SelectTracksByNameResponseBody message, length delimited. Does not implicitly {@link ptsl.SelectTracksByNameResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {ptsl.ISelectTracksByNameResponseBody} message SelectTracksByNameResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectTracksByNameResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SelectTracksByNameResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SelectTracksByNameResponseBody} SelectTracksByNameResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectTracksByNameResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SelectTracksByNameResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.stats = $root.ptsl.Pagination.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.trackList && message.trackList.length))
                            message.trackList = [];
                        message.trackList.push($root.ptsl.Track.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.paginationResponse = $root.ptsl.PaginationResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SelectTracksByNameResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SelectTracksByNameResponseBody} SelectTracksByNameResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectTracksByNameResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SelectTracksByNameResponseBody message.
         * @function verify
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SelectTracksByNameResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stats != null && message.hasOwnProperty("stats")) {
                var error = $root.ptsl.Pagination.verify(message.stats);
                if (error)
                    return "stats." + error;
            }
            if (message.trackList != null && message.hasOwnProperty("trackList")) {
                if (!Array.isArray(message.trackList))
                    return "trackList: array expected";
                for (var i = 0; i < message.trackList.length; ++i) {
                    var error = $root.ptsl.Track.verify(message.trackList[i]);
                    if (error)
                        return "trackList." + error;
                }
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse")) {
                var error = $root.ptsl.PaginationResponse.verify(message.paginationResponse);
                if (error)
                    return "paginationResponse." + error;
            }
            return null;
        };

        /**
         * Creates a SelectTracksByNameResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SelectTracksByNameResponseBody} SelectTracksByNameResponseBody
         */
        SelectTracksByNameResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SelectTracksByNameResponseBody)
                return object;
            var message = new $root.ptsl.SelectTracksByNameResponseBody();
            if (object.stats != null) {
                if (typeof object.stats !== "object")
                    throw TypeError(".ptsl.SelectTracksByNameResponseBody.stats: object expected");
                message.stats = $root.ptsl.Pagination.fromObject(object.stats);
            }
            if (object.trackList) {
                if (!Array.isArray(object.trackList))
                    throw TypeError(".ptsl.SelectTracksByNameResponseBody.trackList: array expected");
                message.trackList = [];
                for (var i = 0; i < object.trackList.length; ++i) {
                    if (typeof object.trackList[i] !== "object")
                        throw TypeError(".ptsl.SelectTracksByNameResponseBody.trackList: object expected");
                    message.trackList[i] = $root.ptsl.Track.fromObject(object.trackList[i]);
                }
            }
            if (object.paginationResponse != null) {
                if (typeof object.paginationResponse !== "object")
                    throw TypeError(".ptsl.SelectTracksByNameResponseBody.paginationResponse: object expected");
                message.paginationResponse = $root.ptsl.PaginationResponse.fromObject(object.paginationResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a SelectTracksByNameResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {ptsl.SelectTracksByNameResponseBody} message SelectTracksByNameResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SelectTracksByNameResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackList = [];
            if (options.defaults) {
                object.stats = null;
                object.paginationResponse = null;
            }
            if (message.stats != null && message.hasOwnProperty("stats"))
                object.stats = $root.ptsl.Pagination.toObject(message.stats, options);
            if (message.trackList && message.trackList.length) {
                object.trackList = [];
                for (var j = 0; j < message.trackList.length; ++j)
                    object.trackList[j] = $root.ptsl.Track.toObject(message.trackList[j], options);
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse"))
                object.paginationResponse = $root.ptsl.PaginationResponse.toObject(message.paginationResponse, options);
            return object;
        };

        /**
         * Converts this SelectTracksByNameResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SelectTracksByNameResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SelectTracksByNameResponseBody
         * @function getTypeUrl
         * @memberof ptsl.SelectTracksByNameResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SelectTracksByNameResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SelectTracksByNameResponseBody";
        };

        return SelectTracksByNameResponseBody;
    })();

    ptsl.ImportFailureInfo = (function() {

        /**
         * Properties of an ImportFailureInfo.
         * @memberof ptsl
         * @interface IImportFailureInfo
         * @property {string|null} [filePath] ImportFailureInfo filePath
         * @property {string|null} [failureMessage] ImportFailureInfo failureMessage
         */

        /**
         * Constructs a new ImportFailureInfo.
         * @memberof ptsl
         * @classdesc A file and the failure related to it during importing.
         * @implements IImportFailureInfo
         * @constructor
         * @param {ptsl.IImportFailureInfo=} [properties] Properties to set
         */
        function ImportFailureInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportFailureInfo filePath.
         * @member {string} filePath
         * @memberof ptsl.ImportFailureInfo
         * @instance
         */
        ImportFailureInfo.prototype.filePath = "";

        /**
         * ImportFailureInfo failureMessage.
         * @member {string} failureMessage
         * @memberof ptsl.ImportFailureInfo
         * @instance
         */
        ImportFailureInfo.prototype.failureMessage = "";

        /**
         * Creates a new ImportFailureInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {ptsl.IImportFailureInfo=} [properties] Properties to set
         * @returns {ptsl.ImportFailureInfo} ImportFailureInfo instance
         */
        ImportFailureInfo.create = function create(properties) {
            return new ImportFailureInfo(properties);
        };

        /**
         * Encodes the specified ImportFailureInfo message. Does not implicitly {@link ptsl.ImportFailureInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {ptsl.IImportFailureInfo} message ImportFailureInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFailureInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.filePath);
            if (message.failureMessage != null && Object.hasOwnProperty.call(message, "failureMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.failureMessage);
            return writer;
        };

        /**
         * Encodes the specified ImportFailureInfo message, length delimited. Does not implicitly {@link ptsl.ImportFailureInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {ptsl.IImportFailureInfo} message ImportFailureInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFailureInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportFailureInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportFailureInfo} ImportFailureInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFailureInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportFailureInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.filePath = reader.string();
                        break;
                    }
                case 2: {
                        message.failureMessage = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportFailureInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportFailureInfo} ImportFailureInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFailureInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportFailureInfo message.
         * @function verify
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportFailureInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                if (!$util.isString(message.filePath))
                    return "filePath: string expected";
            if (message.failureMessage != null && message.hasOwnProperty("failureMessage"))
                if (!$util.isString(message.failureMessage))
                    return "failureMessage: string expected";
            return null;
        };

        /**
         * Creates an ImportFailureInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportFailureInfo} ImportFailureInfo
         */
        ImportFailureInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportFailureInfo)
                return object;
            var message = new $root.ptsl.ImportFailureInfo();
            if (object.filePath != null)
                message.filePath = String(object.filePath);
            if (object.failureMessage != null)
                message.failureMessage = String(object.failureMessage);
            return message;
        };

        /**
         * Creates a plain object from an ImportFailureInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {ptsl.ImportFailureInfo} message ImportFailureInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportFailureInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filePath = "";
                object.failureMessage = "";
            }
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                object.filePath = message.filePath;
            if (message.failureMessage != null && message.hasOwnProperty("failureMessage"))
                object.failureMessage = message.failureMessage;
            return object;
        };

        /**
         * Converts this ImportFailureInfo to JSON.
         * @function toJSON
         * @memberof ptsl.ImportFailureInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportFailureInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportFailureInfo
         * @function getTypeUrl
         * @memberof ptsl.ImportFailureInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportFailureInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportFailureInfo";
        };

        return ImportFailureInfo;
    })();

    ptsl.ImportVideoRequestBody = (function() {

        /**
         * Properties of an ImportVideoRequestBody.
         * @memberof ptsl
         * @interface IImportVideoRequestBody
         * @property {Array.<string>|null} [videoFileList] ImportVideoRequestBody videoFileList
         * @property {ptsl.MediaDestination|null} [destination] ImportVideoRequestBody destination
         * @property {ptsl.MediaLocation|null} [location] ImportVideoRequestBody location
         * @property {ptsl.ISpotLocationData|null} [spotLocationData] ImportVideoRequestBody spotLocationData
         * @property {number|null} [gapsBetweenClips] ImportVideoRequestBody gapsBetweenClips
         * @property {boolean|null} [importAudioFromFile] ImportVideoRequestBody importAudioFromFile
         * @property {string|null} [audioDestinationPath] ImportVideoRequestBody audioDestinationPath
         * @property {boolean|null} [removeExistingVideoTracks] ImportVideoRequestBody removeExistingVideoTracks
         * @property {boolean|null} [removeExistingVideoClips] ImportVideoRequestBody removeExistingVideoClips
         * @property {boolean|null} [clearDestinationVideoTrackPlaylist] ImportVideoRequestBody clearDestinationVideoTrackPlaylist
         */

        /**
         * Constructs a new ImportVideoRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ImportVideo request data.
         * @implements IImportVideoRequestBody
         * @constructor
         * @param {ptsl.IImportVideoRequestBody=} [properties] Properties to set
         */
        function ImportVideoRequestBody(properties) {
            this.videoFileList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportVideoRequestBody videoFileList.
         * @member {Array.<string>} videoFileList
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.videoFileList = $util.emptyArray;

        /**
         * ImportVideoRequestBody destination.
         * @member {ptsl.MediaDestination} destination
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.destination = 0;

        /**
         * ImportVideoRequestBody location.
         * @member {ptsl.MediaLocation} location
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.location = 0;

        /**
         * ImportVideoRequestBody spotLocationData.
         * @member {ptsl.ISpotLocationData|null|undefined} spotLocationData
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.spotLocationData = null;

        /**
         * ImportVideoRequestBody gapsBetweenClips.
         * @member {number} gapsBetweenClips
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.gapsBetweenClips = 0;

        /**
         * ImportVideoRequestBody importAudioFromFile.
         * @member {boolean} importAudioFromFile
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.importAudioFromFile = false;

        /**
         * ImportVideoRequestBody audioDestinationPath.
         * @member {string} audioDestinationPath
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.audioDestinationPath = "";

        /**
         * ImportVideoRequestBody removeExistingVideoTracks.
         * @member {boolean} removeExistingVideoTracks
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.removeExistingVideoTracks = false;

        /**
         * ImportVideoRequestBody removeExistingVideoClips.
         * @member {boolean} removeExistingVideoClips
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.removeExistingVideoClips = false;

        /**
         * ImportVideoRequestBody clearDestinationVideoTrackPlaylist.
         * @member {boolean} clearDestinationVideoTrackPlaylist
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         */
        ImportVideoRequestBody.prototype.clearDestinationVideoTrackPlaylist = false;

        /**
         * Creates a new ImportVideoRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {ptsl.IImportVideoRequestBody=} [properties] Properties to set
         * @returns {ptsl.ImportVideoRequestBody} ImportVideoRequestBody instance
         */
        ImportVideoRequestBody.create = function create(properties) {
            return new ImportVideoRequestBody(properties);
        };

        /**
         * Encodes the specified ImportVideoRequestBody message. Does not implicitly {@link ptsl.ImportVideoRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {ptsl.IImportVideoRequestBody} message ImportVideoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportVideoRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.videoFileList != null && message.videoFileList.length)
                for (var i = 0; i < message.videoFileList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.videoFileList[i]);
            if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.destination);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.location);
            if (message.spotLocationData != null && Object.hasOwnProperty.call(message, "spotLocationData"))
                $root.ptsl.SpotLocationData.encode(message.spotLocationData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.gapsBetweenClips != null && Object.hasOwnProperty.call(message, "gapsBetweenClips"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.gapsBetweenClips);
            if (message.importAudioFromFile != null && Object.hasOwnProperty.call(message, "importAudioFromFile"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.importAudioFromFile);
            if (message.audioDestinationPath != null && Object.hasOwnProperty.call(message, "audioDestinationPath"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.audioDestinationPath);
            if (message.removeExistingVideoTracks != null && Object.hasOwnProperty.call(message, "removeExistingVideoTracks"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.removeExistingVideoTracks);
            if (message.removeExistingVideoClips != null && Object.hasOwnProperty.call(message, "removeExistingVideoClips"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.removeExistingVideoClips);
            if (message.clearDestinationVideoTrackPlaylist != null && Object.hasOwnProperty.call(message, "clearDestinationVideoTrackPlaylist"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.clearDestinationVideoTrackPlaylist);
            return writer;
        };

        /**
         * Encodes the specified ImportVideoRequestBody message, length delimited. Does not implicitly {@link ptsl.ImportVideoRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {ptsl.IImportVideoRequestBody} message ImportVideoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportVideoRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportVideoRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportVideoRequestBody} ImportVideoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportVideoRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportVideoRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.videoFileList && message.videoFileList.length))
                            message.videoFileList = [];
                        message.videoFileList.push(reader.string());
                        break;
                    }
                case 2: {
                        message.destination = reader.int32();
                        break;
                    }
                case 3: {
                        message.location = reader.int32();
                        break;
                    }
                case 4: {
                        message.spotLocationData = $root.ptsl.SpotLocationData.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.gapsBetweenClips = reader.int32();
                        break;
                    }
                case 6: {
                        message.importAudioFromFile = reader.bool();
                        break;
                    }
                case 7: {
                        message.audioDestinationPath = reader.string();
                        break;
                    }
                case 8: {
                        message.removeExistingVideoTracks = reader.bool();
                        break;
                    }
                case 9: {
                        message.removeExistingVideoClips = reader.bool();
                        break;
                    }
                case 10: {
                        message.clearDestinationVideoTrackPlaylist = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportVideoRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportVideoRequestBody} ImportVideoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportVideoRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportVideoRequestBody message.
         * @function verify
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportVideoRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.videoFileList != null && message.hasOwnProperty("videoFileList")) {
                if (!Array.isArray(message.videoFileList))
                    return "videoFileList: array expected";
                for (var i = 0; i < message.videoFileList.length; ++i)
                    if (!$util.isString(message.videoFileList[i]))
                        return "videoFileList: string[] expected";
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                switch (message.destination) {
                default:
                    return "destination: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.location != null && message.hasOwnProperty("location"))
                switch (message.location) {
                default:
                    return "location: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.spotLocationData != null && message.hasOwnProperty("spotLocationData")) {
                var error = $root.ptsl.SpotLocationData.verify(message.spotLocationData);
                if (error)
                    return "spotLocationData." + error;
            }
            if (message.gapsBetweenClips != null && message.hasOwnProperty("gapsBetweenClips"))
                if (!$util.isInteger(message.gapsBetweenClips))
                    return "gapsBetweenClips: integer expected";
            if (message.importAudioFromFile != null && message.hasOwnProperty("importAudioFromFile"))
                if (typeof message.importAudioFromFile !== "boolean")
                    return "importAudioFromFile: boolean expected";
            if (message.audioDestinationPath != null && message.hasOwnProperty("audioDestinationPath"))
                if (!$util.isString(message.audioDestinationPath))
                    return "audioDestinationPath: string expected";
            if (message.removeExistingVideoTracks != null && message.hasOwnProperty("removeExistingVideoTracks"))
                if (typeof message.removeExistingVideoTracks !== "boolean")
                    return "removeExistingVideoTracks: boolean expected";
            if (message.removeExistingVideoClips != null && message.hasOwnProperty("removeExistingVideoClips"))
                if (typeof message.removeExistingVideoClips !== "boolean")
                    return "removeExistingVideoClips: boolean expected";
            if (message.clearDestinationVideoTrackPlaylist != null && message.hasOwnProperty("clearDestinationVideoTrackPlaylist"))
                if (typeof message.clearDestinationVideoTrackPlaylist !== "boolean")
                    return "clearDestinationVideoTrackPlaylist: boolean expected";
            return null;
        };

        /**
         * Creates an ImportVideoRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportVideoRequestBody} ImportVideoRequestBody
         */
        ImportVideoRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportVideoRequestBody)
                return object;
            var message = new $root.ptsl.ImportVideoRequestBody();
            if (object.videoFileList) {
                if (!Array.isArray(object.videoFileList))
                    throw TypeError(".ptsl.ImportVideoRequestBody.videoFileList: array expected");
                message.videoFileList = [];
                for (var i = 0; i < object.videoFileList.length; ++i)
                    message.videoFileList[i] = String(object.videoFileList[i]);
            }
            switch (object.destination) {
            default:
                if (typeof object.destination === "number") {
                    message.destination = object.destination;
                    break;
                }
                break;
            case "MDestination_Unknown":
            case 0:
                message.destination = 0;
                break;
            case "MD_None":
            case 1:
                message.destination = 1;
                break;
            case "MDestination_None":
            case 1:
                message.destination = 1;
                break;
            case "MD_MainVideoTrack":
            case 2:
                message.destination = 2;
                break;
            case "MDestination_MainVideoTrack":
            case 2:
                message.destination = 2;
                break;
            case "MD_NewTrack":
            case 3:
                message.destination = 3;
                break;
            case "MDestination_NewTrack":
            case 3:
                message.destination = 3;
                break;
            case "MD_ClipList":
            case 4:
                message.destination = 4;
                break;
            case "MDestination_ClipList":
            case 4:
                message.destination = 4;
                break;
            }
            switch (object.location) {
            default:
                if (typeof object.location === "number") {
                    message.location = object.location;
                    break;
                }
                break;
            case "MLocation_Unknown":
            case 0:
                message.location = 0;
                break;
            case "ML_None":
            case 1:
                message.location = 1;
                break;
            case "MLocation_None":
            case 1:
                message.location = 1;
                break;
            case "ML_SessionStart":
            case 2:
                message.location = 2;
                break;
            case "MLocation_SessionStart":
            case 2:
                message.location = 2;
                break;
            case "ML_SongStart":
            case 3:
                message.location = 3;
                break;
            case "MLocation_SongStart":
            case 3:
                message.location = 3;
                break;
            case "ML_Selection":
            case 4:
                message.location = 4;
                break;
            case "MLocation_Selection":
            case 4:
                message.location = 4;
                break;
            case "ML_Spot":
            case 5:
                message.location = 5;
                break;
            case "MLocation_Spot":
            case 5:
                message.location = 5;
                break;
            }
            if (object.spotLocationData != null) {
                if (typeof object.spotLocationData !== "object")
                    throw TypeError(".ptsl.ImportVideoRequestBody.spotLocationData: object expected");
                message.spotLocationData = $root.ptsl.SpotLocationData.fromObject(object.spotLocationData);
            }
            if (object.gapsBetweenClips != null)
                message.gapsBetweenClips = object.gapsBetweenClips | 0;
            if (object.importAudioFromFile != null)
                message.importAudioFromFile = Boolean(object.importAudioFromFile);
            if (object.audioDestinationPath != null)
                message.audioDestinationPath = String(object.audioDestinationPath);
            if (object.removeExistingVideoTracks != null)
                message.removeExistingVideoTracks = Boolean(object.removeExistingVideoTracks);
            if (object.removeExistingVideoClips != null)
                message.removeExistingVideoClips = Boolean(object.removeExistingVideoClips);
            if (object.clearDestinationVideoTrackPlaylist != null)
                message.clearDestinationVideoTrackPlaylist = Boolean(object.clearDestinationVideoTrackPlaylist);
            return message;
        };

        /**
         * Creates a plain object from an ImportVideoRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {ptsl.ImportVideoRequestBody} message ImportVideoRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportVideoRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.videoFileList = [];
            if (options.defaults) {
                object.destination = options.enums === String ? "MDestination_Unknown" : 0;
                object.location = options.enums === String ? "MLocation_Unknown" : 0;
                object.spotLocationData = null;
                object.gapsBetweenClips = 0;
                object.importAudioFromFile = false;
                object.audioDestinationPath = "";
                object.removeExistingVideoTracks = false;
                object.removeExistingVideoClips = false;
                object.clearDestinationVideoTrackPlaylist = false;
            }
            if (message.videoFileList && message.videoFileList.length) {
                object.videoFileList = [];
                for (var j = 0; j < message.videoFileList.length; ++j)
                    object.videoFileList[j] = message.videoFileList[j];
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.enums === String ? $root.ptsl.MediaDestination[message.destination] === undefined ? message.destination : $root.ptsl.MediaDestination[message.destination] : message.destination;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = options.enums === String ? $root.ptsl.MediaLocation[message.location] === undefined ? message.location : $root.ptsl.MediaLocation[message.location] : message.location;
            if (message.spotLocationData != null && message.hasOwnProperty("spotLocationData"))
                object.spotLocationData = $root.ptsl.SpotLocationData.toObject(message.spotLocationData, options);
            if (message.gapsBetweenClips != null && message.hasOwnProperty("gapsBetweenClips"))
                object.gapsBetweenClips = message.gapsBetweenClips;
            if (message.importAudioFromFile != null && message.hasOwnProperty("importAudioFromFile"))
                object.importAudioFromFile = message.importAudioFromFile;
            if (message.audioDestinationPath != null && message.hasOwnProperty("audioDestinationPath"))
                object.audioDestinationPath = message.audioDestinationPath;
            if (message.removeExistingVideoTracks != null && message.hasOwnProperty("removeExistingVideoTracks"))
                object.removeExistingVideoTracks = message.removeExistingVideoTracks;
            if (message.removeExistingVideoClips != null && message.hasOwnProperty("removeExistingVideoClips"))
                object.removeExistingVideoClips = message.removeExistingVideoClips;
            if (message.clearDestinationVideoTrackPlaylist != null && message.hasOwnProperty("clearDestinationVideoTrackPlaylist"))
                object.clearDestinationVideoTrackPlaylist = message.clearDestinationVideoTrackPlaylist;
            return object;
        };

        /**
         * Converts this ImportVideoRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ImportVideoRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportVideoRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportVideoRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ImportVideoRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportVideoRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportVideoRequestBody";
        };

        return ImportVideoRequestBody;
    })();

    ptsl.ImportVideoResponseBody = (function() {

        /**
         * Properties of an ImportVideoResponseBody.
         * @memberof ptsl
         * @interface IImportVideoResponseBody
         * @property {Array.<ptsl.IImportFailureInfo>|null} [failureList] ImportVideoResponseBody failureList
         */

        /**
         * Constructs a new ImportVideoResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes ImportVideo response data.
         * @implements IImportVideoResponseBody
         * @constructor
         * @param {ptsl.IImportVideoResponseBody=} [properties] Properties to set
         */
        function ImportVideoResponseBody(properties) {
            this.failureList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportVideoResponseBody failureList.
         * @member {Array.<ptsl.IImportFailureInfo>} failureList
         * @memberof ptsl.ImportVideoResponseBody
         * @instance
         */
        ImportVideoResponseBody.prototype.failureList = $util.emptyArray;

        /**
         * Creates a new ImportVideoResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {ptsl.IImportVideoResponseBody=} [properties] Properties to set
         * @returns {ptsl.ImportVideoResponseBody} ImportVideoResponseBody instance
         */
        ImportVideoResponseBody.create = function create(properties) {
            return new ImportVideoResponseBody(properties);
        };

        /**
         * Encodes the specified ImportVideoResponseBody message. Does not implicitly {@link ptsl.ImportVideoResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {ptsl.IImportVideoResponseBody} message ImportVideoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportVideoResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.failureList != null && message.failureList.length)
                for (var i = 0; i < message.failureList.length; ++i)
                    $root.ptsl.ImportFailureInfo.encode(message.failureList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportVideoResponseBody message, length delimited. Does not implicitly {@link ptsl.ImportVideoResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {ptsl.IImportVideoResponseBody} message ImportVideoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportVideoResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportVideoResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportVideoResponseBody} ImportVideoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportVideoResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportVideoResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.failureList && message.failureList.length))
                            message.failureList = [];
                        message.failureList.push($root.ptsl.ImportFailureInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportVideoResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportVideoResponseBody} ImportVideoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportVideoResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportVideoResponseBody message.
         * @function verify
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportVideoResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.failureList != null && message.hasOwnProperty("failureList")) {
                if (!Array.isArray(message.failureList))
                    return "failureList: array expected";
                for (var i = 0; i < message.failureList.length; ++i) {
                    var error = $root.ptsl.ImportFailureInfo.verify(message.failureList[i]);
                    if (error)
                        return "failureList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportVideoResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportVideoResponseBody} ImportVideoResponseBody
         */
        ImportVideoResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportVideoResponseBody)
                return object;
            var message = new $root.ptsl.ImportVideoResponseBody();
            if (object.failureList) {
                if (!Array.isArray(object.failureList))
                    throw TypeError(".ptsl.ImportVideoResponseBody.failureList: array expected");
                message.failureList = [];
                for (var i = 0; i < object.failureList.length; ++i) {
                    if (typeof object.failureList[i] !== "object")
                        throw TypeError(".ptsl.ImportVideoResponseBody.failureList: object expected");
                    message.failureList[i] = $root.ptsl.ImportFailureInfo.fromObject(object.failureList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportVideoResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {ptsl.ImportVideoResponseBody} message ImportVideoResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportVideoResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.failureList = [];
            if (message.failureList && message.failureList.length) {
                object.failureList = [];
                for (var j = 0; j < message.failureList.length; ++j)
                    object.failureList[j] = $root.ptsl.ImportFailureInfo.toObject(message.failureList[j], options);
            }
            return object;
        };

        /**
         * Converts this ImportVideoResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ImportVideoResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportVideoResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportVideoResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ImportVideoResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportVideoResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportVideoResponseBody";
        };

        return ImportVideoResponseBody;
    })();

    ptsl.SelectMemoryLocationRequestBody = (function() {

        /**
         * Properties of a SelectMemoryLocationRequestBody.
         * @memberof ptsl
         * @interface ISelectMemoryLocationRequestBody
         * @property {number|null} [number] SelectMemoryLocationRequestBody number
         */

        /**
         * Constructs a new SelectMemoryLocationRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SelectMemoryLocation request data.
         * @implements ISelectMemoryLocationRequestBody
         * @constructor
         * @param {ptsl.ISelectMemoryLocationRequestBody=} [properties] Properties to set
         */
        function SelectMemoryLocationRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SelectMemoryLocationRequestBody number.
         * @member {number} number
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @instance
         */
        SelectMemoryLocationRequestBody.prototype.number = 0;

        /**
         * Creates a new SelectMemoryLocationRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {ptsl.ISelectMemoryLocationRequestBody=} [properties] Properties to set
         * @returns {ptsl.SelectMemoryLocationRequestBody} SelectMemoryLocationRequestBody instance
         */
        SelectMemoryLocationRequestBody.create = function create(properties) {
            return new SelectMemoryLocationRequestBody(properties);
        };

        /**
         * Encodes the specified SelectMemoryLocationRequestBody message. Does not implicitly {@link ptsl.SelectMemoryLocationRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {ptsl.ISelectMemoryLocationRequestBody} message SelectMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectMemoryLocationRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.number);
            return writer;
        };

        /**
         * Encodes the specified SelectMemoryLocationRequestBody message, length delimited. Does not implicitly {@link ptsl.SelectMemoryLocationRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {ptsl.ISelectMemoryLocationRequestBody} message SelectMemoryLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SelectMemoryLocationRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SelectMemoryLocationRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SelectMemoryLocationRequestBody} SelectMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectMemoryLocationRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SelectMemoryLocationRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.number = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SelectMemoryLocationRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SelectMemoryLocationRequestBody} SelectMemoryLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SelectMemoryLocationRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SelectMemoryLocationRequestBody message.
         * @function verify
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SelectMemoryLocationRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            return null;
        };

        /**
         * Creates a SelectMemoryLocationRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SelectMemoryLocationRequestBody} SelectMemoryLocationRequestBody
         */
        SelectMemoryLocationRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SelectMemoryLocationRequestBody)
                return object;
            var message = new $root.ptsl.SelectMemoryLocationRequestBody();
            if (object.number != null)
                message.number = object.number | 0;
            return message;
        };

        /**
         * Creates a plain object from a SelectMemoryLocationRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {ptsl.SelectMemoryLocationRequestBody} message SelectMemoryLocationRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SelectMemoryLocationRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.number = 0;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            return object;
        };

        /**
         * Converts this SelectMemoryLocationRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SelectMemoryLocationRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SelectMemoryLocationRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SelectMemoryLocationRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SelectMemoryLocationRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SelectMemoryLocationRequestBody";
        };

        return SelectMemoryLocationRequestBody;
    })();

    ptsl.SetTrackMuteStateRequestBody = (function() {

        /**
         * Properties of a SetTrackMuteStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackMuteStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackMuteStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackMuteStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackMuteStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackMuteState request data.
         * @implements ISetTrackMuteStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackMuteStateRequestBody=} [properties] Properties to set
         */
        function SetTrackMuteStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackMuteStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @instance
         */
        SetTrackMuteStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackMuteStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @instance
         */
        SetTrackMuteStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackMuteStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {ptsl.ISetTrackMuteStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackMuteStateRequestBody} SetTrackMuteStateRequestBody instance
         */
        SetTrackMuteStateRequestBody.create = function create(properties) {
            return new SetTrackMuteStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackMuteStateRequestBody message. Does not implicitly {@link ptsl.SetTrackMuteStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {ptsl.ISetTrackMuteStateRequestBody} message SetTrackMuteStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackMuteStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackMuteStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackMuteStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {ptsl.ISetTrackMuteStateRequestBody} message SetTrackMuteStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackMuteStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackMuteStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackMuteStateRequestBody} SetTrackMuteStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackMuteStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackMuteStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackMuteStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackMuteStateRequestBody} SetTrackMuteStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackMuteStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackMuteStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackMuteStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackMuteStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackMuteStateRequestBody} SetTrackMuteStateRequestBody
         */
        SetTrackMuteStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackMuteStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackMuteStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackMuteStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackMuteStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {ptsl.SetTrackMuteStateRequestBody} message SetTrackMuteStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackMuteStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackMuteStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackMuteStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackMuteStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackMuteStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackMuteStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackMuteStateRequestBody";
        };

        return SetTrackMuteStateRequestBody;
    })();

    ptsl.SetTrackSoloStateRequestBody = (function() {

        /**
         * Properties of a SetTrackSoloStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackSoloStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackSoloStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackSoloStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackSoloStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackSoloState request data.
         * @implements ISetTrackSoloStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackSoloStateRequestBody=} [properties] Properties to set
         */
        function SetTrackSoloStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackSoloStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @instance
         */
        SetTrackSoloStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackSoloStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @instance
         */
        SetTrackSoloStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackSoloStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSoloStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackSoloStateRequestBody} SetTrackSoloStateRequestBody instance
         */
        SetTrackSoloStateRequestBody.create = function create(properties) {
            return new SetTrackSoloStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackSoloStateRequestBody message. Does not implicitly {@link ptsl.SetTrackSoloStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSoloStateRequestBody} message SetTrackSoloStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackSoloStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackSoloStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackSoloStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSoloStateRequestBody} message SetTrackSoloStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackSoloStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackSoloStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackSoloStateRequestBody} SetTrackSoloStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackSoloStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackSoloStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackSoloStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackSoloStateRequestBody} SetTrackSoloStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackSoloStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackSoloStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackSoloStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackSoloStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackSoloStateRequestBody} SetTrackSoloStateRequestBody
         */
        SetTrackSoloStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackSoloStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackSoloStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackSoloStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackSoloStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {ptsl.SetTrackSoloStateRequestBody} message SetTrackSoloStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackSoloStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackSoloStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackSoloStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackSoloStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackSoloStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackSoloStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackSoloStateRequestBody";
        };

        return SetTrackSoloStateRequestBody;
    })();

    ptsl.SetTrackSoloSafeStateRequestBody = (function() {

        /**
         * Properties of a SetTrackSoloSafeStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackSoloSafeStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackSoloSafeStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackSoloSafeStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackSoloSafeStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackSoloSafeState request data.
         * @implements ISetTrackSoloSafeStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackSoloSafeStateRequestBody=} [properties] Properties to set
         */
        function SetTrackSoloSafeStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackSoloSafeStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @instance
         */
        SetTrackSoloSafeStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackSoloSafeStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @instance
         */
        SetTrackSoloSafeStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackSoloSafeStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSoloSafeStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackSoloSafeStateRequestBody} SetTrackSoloSafeStateRequestBody instance
         */
        SetTrackSoloSafeStateRequestBody.create = function create(properties) {
            return new SetTrackSoloSafeStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackSoloSafeStateRequestBody message. Does not implicitly {@link ptsl.SetTrackSoloSafeStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSoloSafeStateRequestBody} message SetTrackSoloSafeStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackSoloSafeStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackSoloSafeStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackSoloSafeStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSoloSafeStateRequestBody} message SetTrackSoloSafeStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackSoloSafeStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackSoloSafeStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackSoloSafeStateRequestBody} SetTrackSoloSafeStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackSoloSafeStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackSoloSafeStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackSoloSafeStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackSoloSafeStateRequestBody} SetTrackSoloSafeStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackSoloSafeStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackSoloSafeStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackSoloSafeStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackSoloSafeStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackSoloSafeStateRequestBody} SetTrackSoloSafeStateRequestBody
         */
        SetTrackSoloSafeStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackSoloSafeStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackSoloSafeStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackSoloSafeStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackSoloSafeStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {ptsl.SetTrackSoloSafeStateRequestBody} message SetTrackSoloSafeStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackSoloSafeStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackSoloSafeStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackSoloSafeStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackSoloSafeStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackSoloSafeStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackSoloSafeStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackSoloSafeStateRequestBody";
        };

        return SetTrackSoloSafeStateRequestBody;
    })();

    ptsl.SetTrackRecordEnableStateRequestBody = (function() {

        /**
         * Properties of a SetTrackRecordEnableStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackRecordEnableStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackRecordEnableStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackRecordEnableStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackRecordEnableStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackRecordEnableState request data.
         * @implements ISetTrackRecordEnableStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackRecordEnableStateRequestBody=} [properties] Properties to set
         */
        function SetTrackRecordEnableStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackRecordEnableStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @instance
         */
        SetTrackRecordEnableStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackRecordEnableStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @instance
         */
        SetTrackRecordEnableStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackRecordEnableStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {ptsl.ISetTrackRecordEnableStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackRecordEnableStateRequestBody} SetTrackRecordEnableStateRequestBody instance
         */
        SetTrackRecordEnableStateRequestBody.create = function create(properties) {
            return new SetTrackRecordEnableStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackRecordEnableStateRequestBody message. Does not implicitly {@link ptsl.SetTrackRecordEnableStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {ptsl.ISetTrackRecordEnableStateRequestBody} message SetTrackRecordEnableStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackRecordEnableStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackRecordEnableStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackRecordEnableStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {ptsl.ISetTrackRecordEnableStateRequestBody} message SetTrackRecordEnableStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackRecordEnableStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackRecordEnableStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackRecordEnableStateRequestBody} SetTrackRecordEnableStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackRecordEnableStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackRecordEnableStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackRecordEnableStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackRecordEnableStateRequestBody} SetTrackRecordEnableStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackRecordEnableStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackRecordEnableStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackRecordEnableStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackRecordEnableStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackRecordEnableStateRequestBody} SetTrackRecordEnableStateRequestBody
         */
        SetTrackRecordEnableStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackRecordEnableStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackRecordEnableStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackRecordEnableStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackRecordEnableStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {ptsl.SetTrackRecordEnableStateRequestBody} message SetTrackRecordEnableStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackRecordEnableStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackRecordEnableStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackRecordEnableStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackRecordEnableStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackRecordEnableStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackRecordEnableStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackRecordEnableStateRequestBody";
        };

        return SetTrackRecordEnableStateRequestBody;
    })();

    ptsl.SetTrackRecordSafeEnableStateRequestBody = (function() {

        /**
         * Properties of a SetTrackRecordSafeEnableStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackRecordSafeEnableStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackRecordSafeEnableStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackRecordSafeEnableStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackRecordSafeEnableStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackRecordSafeEnableState request data.
         * @implements ISetTrackRecordSafeEnableStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackRecordSafeEnableStateRequestBody=} [properties] Properties to set
         */
        function SetTrackRecordSafeEnableStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackRecordSafeEnableStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @instance
         */
        SetTrackRecordSafeEnableStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackRecordSafeEnableStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @instance
         */
        SetTrackRecordSafeEnableStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackRecordSafeEnableStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {ptsl.ISetTrackRecordSafeEnableStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackRecordSafeEnableStateRequestBody} SetTrackRecordSafeEnableStateRequestBody instance
         */
        SetTrackRecordSafeEnableStateRequestBody.create = function create(properties) {
            return new SetTrackRecordSafeEnableStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackRecordSafeEnableStateRequestBody message. Does not implicitly {@link ptsl.SetTrackRecordSafeEnableStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {ptsl.ISetTrackRecordSafeEnableStateRequestBody} message SetTrackRecordSafeEnableStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackRecordSafeEnableStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackRecordSafeEnableStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackRecordSafeEnableStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {ptsl.ISetTrackRecordSafeEnableStateRequestBody} message SetTrackRecordSafeEnableStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackRecordSafeEnableStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackRecordSafeEnableStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackRecordSafeEnableStateRequestBody} SetTrackRecordSafeEnableStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackRecordSafeEnableStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackRecordSafeEnableStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackRecordSafeEnableStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackRecordSafeEnableStateRequestBody} SetTrackRecordSafeEnableStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackRecordSafeEnableStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackRecordSafeEnableStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackRecordSafeEnableStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackRecordSafeEnableStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackRecordSafeEnableStateRequestBody} SetTrackRecordSafeEnableStateRequestBody
         */
        SetTrackRecordSafeEnableStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackRecordSafeEnableStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackRecordSafeEnableStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackRecordSafeEnableStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackRecordSafeEnableStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {ptsl.SetTrackRecordSafeEnableStateRequestBody} message SetTrackRecordSafeEnableStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackRecordSafeEnableStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackRecordSafeEnableStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackRecordSafeEnableStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackRecordSafeEnableStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackRecordSafeEnableStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackRecordSafeEnableStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackRecordSafeEnableStateRequestBody";
        };

        return SetTrackRecordSafeEnableStateRequestBody;
    })();

    ptsl.SetTrackInputMonitorStateRequestBody = (function() {

        /**
         * Properties of a SetTrackInputMonitorStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackInputMonitorStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackInputMonitorStateRequestBody trackNames
         * @property {boolean|null} [enabled] * Note: when Preferences->Operation->Record->"PEC/Direct Style Input Monitoring" is ON, enabled=true means "PEC" and enabled=false means "Direct Style".
         */

        /**
         * Constructs a new SetTrackInputMonitorStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackInputMonitorState request data.
         * @implements ISetTrackInputMonitorStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackInputMonitorStateRequestBody=} [properties] Properties to set
         */
        function SetTrackInputMonitorStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackInputMonitorStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @instance
         */
        SetTrackInputMonitorStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * * Note: when Preferences->Operation->Record->"PEC/Direct Style Input Monitoring" is ON, enabled=true means "PEC" and enabled=false means "Direct Style".
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @instance
         */
        SetTrackInputMonitorStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackInputMonitorStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {ptsl.ISetTrackInputMonitorStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackInputMonitorStateRequestBody} SetTrackInputMonitorStateRequestBody instance
         */
        SetTrackInputMonitorStateRequestBody.create = function create(properties) {
            return new SetTrackInputMonitorStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackInputMonitorStateRequestBody message. Does not implicitly {@link ptsl.SetTrackInputMonitorStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {ptsl.ISetTrackInputMonitorStateRequestBody} message SetTrackInputMonitorStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackInputMonitorStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackInputMonitorStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackInputMonitorStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {ptsl.ISetTrackInputMonitorStateRequestBody} message SetTrackInputMonitorStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackInputMonitorStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackInputMonitorStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackInputMonitorStateRequestBody} SetTrackInputMonitorStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackInputMonitorStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackInputMonitorStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackInputMonitorStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackInputMonitorStateRequestBody} SetTrackInputMonitorStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackInputMonitorStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackInputMonitorStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackInputMonitorStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackInputMonitorStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackInputMonitorStateRequestBody} SetTrackInputMonitorStateRequestBody
         */
        SetTrackInputMonitorStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackInputMonitorStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackInputMonitorStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackInputMonitorStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackInputMonitorStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {ptsl.SetTrackInputMonitorStateRequestBody} message SetTrackInputMonitorStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackInputMonitorStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackInputMonitorStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackInputMonitorStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackInputMonitorStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackInputMonitorStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackInputMonitorStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackInputMonitorStateRequestBody";
        };

        return SetTrackInputMonitorStateRequestBody;
    })();

    ptsl.SetTrackSmartDspStateRequestBody = (function() {

        /**
         * Properties of a SetTrackSmartDspStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackSmartDspStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackSmartDspStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackSmartDspStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackSmartDspStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackSmartDspState request data.
         * @implements ISetTrackSmartDspStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackSmartDspStateRequestBody=} [properties] Properties to set
         */
        function SetTrackSmartDspStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackSmartDspStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @instance
         */
        SetTrackSmartDspStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackSmartDspStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @instance
         */
        SetTrackSmartDspStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackSmartDspStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSmartDspStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackSmartDspStateRequestBody} SetTrackSmartDspStateRequestBody instance
         */
        SetTrackSmartDspStateRequestBody.create = function create(properties) {
            return new SetTrackSmartDspStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackSmartDspStateRequestBody message. Does not implicitly {@link ptsl.SetTrackSmartDspStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSmartDspStateRequestBody} message SetTrackSmartDspStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackSmartDspStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackSmartDspStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackSmartDspStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {ptsl.ISetTrackSmartDspStateRequestBody} message SetTrackSmartDspStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackSmartDspStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackSmartDspStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackSmartDspStateRequestBody} SetTrackSmartDspStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackSmartDspStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackSmartDspStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackSmartDspStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackSmartDspStateRequestBody} SetTrackSmartDspStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackSmartDspStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackSmartDspStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackSmartDspStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackSmartDspStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackSmartDspStateRequestBody} SetTrackSmartDspStateRequestBody
         */
        SetTrackSmartDspStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackSmartDspStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackSmartDspStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackSmartDspStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackSmartDspStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {ptsl.SetTrackSmartDspStateRequestBody} message SetTrackSmartDspStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackSmartDspStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackSmartDspStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackSmartDspStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackSmartDspStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackSmartDspStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackSmartDspStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackSmartDspStateRequestBody";
        };

        return SetTrackSmartDspStateRequestBody;
    })();

    ptsl.SetTrackHiddenStateRequestBody = (function() {

        /**
         * Properties of a SetTrackHiddenStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackHiddenStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackHiddenStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackHiddenStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackHiddenStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackHiddenState request data.
         * @implements ISetTrackHiddenStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackHiddenStateRequestBody=} [properties] Properties to set
         */
        function SetTrackHiddenStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackHiddenStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @instance
         */
        SetTrackHiddenStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackHiddenStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @instance
         */
        SetTrackHiddenStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackHiddenStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackHiddenStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackHiddenStateRequestBody} SetTrackHiddenStateRequestBody instance
         */
        SetTrackHiddenStateRequestBody.create = function create(properties) {
            return new SetTrackHiddenStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackHiddenStateRequestBody message. Does not implicitly {@link ptsl.SetTrackHiddenStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackHiddenStateRequestBody} message SetTrackHiddenStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackHiddenStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackHiddenStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackHiddenStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackHiddenStateRequestBody} message SetTrackHiddenStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackHiddenStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackHiddenStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackHiddenStateRequestBody} SetTrackHiddenStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackHiddenStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackHiddenStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackHiddenStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackHiddenStateRequestBody} SetTrackHiddenStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackHiddenStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackHiddenStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackHiddenStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackHiddenStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackHiddenStateRequestBody} SetTrackHiddenStateRequestBody
         */
        SetTrackHiddenStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackHiddenStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackHiddenStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackHiddenStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackHiddenStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {ptsl.SetTrackHiddenStateRequestBody} message SetTrackHiddenStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackHiddenStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackHiddenStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackHiddenStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackHiddenStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackHiddenStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackHiddenStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackHiddenStateRequestBody";
        };

        return SetTrackHiddenStateRequestBody;
    })();

    ptsl.SetTrackInactiveStateRequestBody = (function() {

        /**
         * Properties of a SetTrackInactiveStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackInactiveStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackInactiveStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackInactiveStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackInactiveStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackInactiveState request data.
         * @implements ISetTrackInactiveStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackInactiveStateRequestBody=} [properties] Properties to set
         */
        function SetTrackInactiveStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackInactiveStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @instance
         */
        SetTrackInactiveStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackInactiveStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @instance
         */
        SetTrackInactiveStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackInactiveStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {ptsl.ISetTrackInactiveStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackInactiveStateRequestBody} SetTrackInactiveStateRequestBody instance
         */
        SetTrackInactiveStateRequestBody.create = function create(properties) {
            return new SetTrackInactiveStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackInactiveStateRequestBody message. Does not implicitly {@link ptsl.SetTrackInactiveStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {ptsl.ISetTrackInactiveStateRequestBody} message SetTrackInactiveStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackInactiveStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackInactiveStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackInactiveStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {ptsl.ISetTrackInactiveStateRequestBody} message SetTrackInactiveStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackInactiveStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackInactiveStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackInactiveStateRequestBody} SetTrackInactiveStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackInactiveStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackInactiveStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackInactiveStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackInactiveStateRequestBody} SetTrackInactiveStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackInactiveStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackInactiveStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackInactiveStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackInactiveStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackInactiveStateRequestBody} SetTrackInactiveStateRequestBody
         */
        SetTrackInactiveStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackInactiveStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackInactiveStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackInactiveStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackInactiveStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {ptsl.SetTrackInactiveStateRequestBody} message SetTrackInactiveStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackInactiveStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackInactiveStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackInactiveStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackInactiveStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackInactiveStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackInactiveStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackInactiveStateRequestBody";
        };

        return SetTrackInactiveStateRequestBody;
    })();

    ptsl.SetTrackFrozenStateRequestBody = (function() {

        /**
         * Properties of a SetTrackFrozenStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackFrozenStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackFrozenStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackFrozenStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackFrozenStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackFrozenState request data.
         * @implements ISetTrackFrozenStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackFrozenStateRequestBody=} [properties] Properties to set
         */
        function SetTrackFrozenStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackFrozenStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @instance
         */
        SetTrackFrozenStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackFrozenStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @instance
         */
        SetTrackFrozenStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackFrozenStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackFrozenStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackFrozenStateRequestBody} SetTrackFrozenStateRequestBody instance
         */
        SetTrackFrozenStateRequestBody.create = function create(properties) {
            return new SetTrackFrozenStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackFrozenStateRequestBody message. Does not implicitly {@link ptsl.SetTrackFrozenStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackFrozenStateRequestBody} message SetTrackFrozenStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackFrozenStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackFrozenStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackFrozenStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackFrozenStateRequestBody} message SetTrackFrozenStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackFrozenStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackFrozenStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackFrozenStateRequestBody} SetTrackFrozenStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackFrozenStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackFrozenStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackFrozenStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackFrozenStateRequestBody} SetTrackFrozenStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackFrozenStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackFrozenStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackFrozenStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackFrozenStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackFrozenStateRequestBody} SetTrackFrozenStateRequestBody
         */
        SetTrackFrozenStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackFrozenStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackFrozenStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackFrozenStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackFrozenStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {ptsl.SetTrackFrozenStateRequestBody} message SetTrackFrozenStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackFrozenStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackFrozenStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackFrozenStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackFrozenStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackFrozenStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackFrozenStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackFrozenStateRequestBody";
        };

        return SetTrackFrozenStateRequestBody;
    })();

    ptsl.SetTrackOnlineStateRequestBody = (function() {

        /**
         * Properties of a SetTrackOnlineStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackOnlineStateRequestBody
         * @property {string|null} [trackName] SetTrackOnlineStateRequestBody trackName
         * @property {boolean|null} [enabled] SetTrackOnlineStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackOnlineStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackOnlineState request data.
         * @implements ISetTrackOnlineStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackOnlineStateRequestBody=} [properties] Properties to set
         */
        function SetTrackOnlineStateRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackOnlineStateRequestBody trackName.
         * @member {string} trackName
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @instance
         */
        SetTrackOnlineStateRequestBody.prototype.trackName = "";

        /**
         * SetTrackOnlineStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @instance
         */
        SetTrackOnlineStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackOnlineStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {ptsl.ISetTrackOnlineStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackOnlineStateRequestBody} SetTrackOnlineStateRequestBody instance
         */
        SetTrackOnlineStateRequestBody.create = function create(properties) {
            return new SetTrackOnlineStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackOnlineStateRequestBody message. Does not implicitly {@link ptsl.SetTrackOnlineStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {ptsl.ISetTrackOnlineStateRequestBody} message SetTrackOnlineStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackOnlineStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackName);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackOnlineStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackOnlineStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {ptsl.ISetTrackOnlineStateRequestBody} message SetTrackOnlineStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackOnlineStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackOnlineStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackOnlineStateRequestBody} SetTrackOnlineStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackOnlineStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackOnlineStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.trackName = reader.string();
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackOnlineStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackOnlineStateRequestBody} SetTrackOnlineStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackOnlineStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackOnlineStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackOnlineStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackOnlineStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackOnlineStateRequestBody} SetTrackOnlineStateRequestBody
         */
        SetTrackOnlineStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackOnlineStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackOnlineStateRequestBody();
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackOnlineStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {ptsl.SetTrackOnlineStateRequestBody} message SetTrackOnlineStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackOnlineStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trackName = "";
                object.enabled = false;
            }
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackOnlineStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackOnlineStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackOnlineStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackOnlineStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackOnlineStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackOnlineStateRequestBody";
        };

        return SetTrackOnlineStateRequestBody;
    })();

    ptsl.SetTrackOpenStateRequestBody = (function() {

        /**
         * Properties of a SetTrackOpenStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackOpenStateRequestBody
         * @property {Array.<string>|null} [trackNames] SetTrackOpenStateRequestBody trackNames
         * @property {boolean|null} [enabled] SetTrackOpenStateRequestBody enabled
         */

        /**
         * Constructs a new SetTrackOpenStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackOpenState request data.
         * @implements ISetTrackOpenStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackOpenStateRequestBody=} [properties] Properties to set
         */
        function SetTrackOpenStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetTrackOpenStateRequestBody trackNames.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @instance
         */
        SetTrackOpenStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * SetTrackOpenStateRequestBody enabled.
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @instance
         */
        SetTrackOpenStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackOpenStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackOpenStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackOpenStateRequestBody} SetTrackOpenStateRequestBody instance
         */
        SetTrackOpenStateRequestBody.create = function create(properties) {
            return new SetTrackOpenStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackOpenStateRequestBody message. Does not implicitly {@link ptsl.SetTrackOpenStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackOpenStateRequestBody} message SetTrackOpenStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackOpenStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackOpenStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackOpenStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {ptsl.ISetTrackOpenStateRequestBody} message SetTrackOpenStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackOpenStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackOpenStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackOpenStateRequestBody} SetTrackOpenStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackOpenStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackOpenStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackOpenStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackOpenStateRequestBody} SetTrackOpenStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackOpenStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackOpenStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackOpenStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackOpenStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackOpenStateRequestBody} SetTrackOpenStateRequestBody
         */
        SetTrackOpenStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackOpenStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackOpenStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackOpenStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackOpenStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {ptsl.SetTrackOpenStateRequestBody} message SetTrackOpenStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackOpenStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackOpenStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackOpenStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackOpenStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackOpenStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackOpenStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackOpenStateRequestBody";
        };

        return SetTrackOpenStateRequestBody;
    })();

    ptsl.GetSessionIDsResponseBody = (function() {

        /**
         * Properties of a GetSessionIDsResponseBody.
         * @memberof ptsl
         * @interface IGetSessionIDsResponseBody
         * @property {string|null} [originId] GetSessionIDsResponseBody originId
         * @property {string|null} [instanceId] GetSessionIDsResponseBody instanceId
         * @property {string|null} [parentId] GetSessionIDsResponseBody parentId
         */

        /**
         * Constructs a new GetSessionIDsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionIDs response data.
         * @implements IGetSessionIDsResponseBody
         * @constructor
         * @param {ptsl.IGetSessionIDsResponseBody=} [properties] Properties to set
         */
        function GetSessionIDsResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSessionIDsResponseBody originId.
         * @member {string} originId
         * @memberof ptsl.GetSessionIDsResponseBody
         * @instance
         */
        GetSessionIDsResponseBody.prototype.originId = "";

        /**
         * GetSessionIDsResponseBody instanceId.
         * @member {string} instanceId
         * @memberof ptsl.GetSessionIDsResponseBody
         * @instance
         */
        GetSessionIDsResponseBody.prototype.instanceId = "";

        /**
         * GetSessionIDsResponseBody parentId.
         * @member {string} parentId
         * @memberof ptsl.GetSessionIDsResponseBody
         * @instance
         */
        GetSessionIDsResponseBody.prototype.parentId = "";

        /**
         * Creates a new GetSessionIDsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {ptsl.IGetSessionIDsResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionIDsResponseBody} GetSessionIDsResponseBody instance
         */
        GetSessionIDsResponseBody.create = function create(properties) {
            return new GetSessionIDsResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionIDsResponseBody message. Does not implicitly {@link ptsl.GetSessionIDsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {ptsl.IGetSessionIDsResponseBody} message GetSessionIDsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionIDsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originId != null && Object.hasOwnProperty.call(message, "originId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.originId);
            if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.instanceId);
            if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.parentId);
            return writer;
        };

        /**
         * Encodes the specified GetSessionIDsResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionIDsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {ptsl.IGetSessionIDsResponseBody} message GetSessionIDsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionIDsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionIDsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionIDsResponseBody} GetSessionIDsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionIDsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionIDsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.originId = reader.string();
                        break;
                    }
                case 2: {
                        message.instanceId = reader.string();
                        break;
                    }
                case 3: {
                        message.parentId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionIDsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionIDsResponseBody} GetSessionIDsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionIDsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionIDsResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionIDsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.originId != null && message.hasOwnProperty("originId"))
                if (!$util.isString(message.originId))
                    return "originId: string expected";
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (!$util.isString(message.instanceId))
                    return "instanceId: string expected";
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                if (!$util.isString(message.parentId))
                    return "parentId: string expected";
            return null;
        };

        /**
         * Creates a GetSessionIDsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionIDsResponseBody} GetSessionIDsResponseBody
         */
        GetSessionIDsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionIDsResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionIDsResponseBody();
            if (object.originId != null)
                message.originId = String(object.originId);
            if (object.instanceId != null)
                message.instanceId = String(object.instanceId);
            if (object.parentId != null)
                message.parentId = String(object.parentId);
            return message;
        };

        /**
         * Creates a plain object from a GetSessionIDsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {ptsl.GetSessionIDsResponseBody} message GetSessionIDsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionIDsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.originId = "";
                object.instanceId = "";
                object.parentId = "";
            }
            if (message.originId != null && message.hasOwnProperty("originId"))
                object.originId = message.originId;
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                object.instanceId = message.instanceId;
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                object.parentId = message.parentId;
            return object;
        };

        /**
         * Converts this GetSessionIDsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionIDsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionIDsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionIDsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionIDsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionIDsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionIDsResponseBody";
        };

        return GetSessionIDsResponseBody;
    })();

    ptsl.GetMemoryLocationsManageModeResponseBody = (function() {

        /**
         * Properties of a GetMemoryLocationsManageModeResponseBody.
         * @memberof ptsl
         * @interface IGetMemoryLocationsManageModeResponseBody
         * @property {boolean|null} [enabled] * Whether the Memory Locations Manage Mode is enabled or disabled.
         */

        /**
         * Constructs a new GetMemoryLocationsManageModeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetMemoryLocationsManageMode response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IGetMemoryLocationsManageModeResponseBody
         * @constructor
         * @param {ptsl.IGetMemoryLocationsManageModeResponseBody=} [properties] Properties to set
         */
        function GetMemoryLocationsManageModeResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Whether the Memory Locations Manage Mode is enabled or disabled.
         * @member {boolean} enabled
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @instance
         */
        GetMemoryLocationsManageModeResponseBody.prototype.enabled = false;

        /**
         * Creates a new GetMemoryLocationsManageModeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {ptsl.IGetMemoryLocationsManageModeResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetMemoryLocationsManageModeResponseBody} GetMemoryLocationsManageModeResponseBody instance
         */
        GetMemoryLocationsManageModeResponseBody.create = function create(properties) {
            return new GetMemoryLocationsManageModeResponseBody(properties);
        };

        /**
         * Encodes the specified GetMemoryLocationsManageModeResponseBody message. Does not implicitly {@link ptsl.GetMemoryLocationsManageModeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {ptsl.IGetMemoryLocationsManageModeResponseBody} message GetMemoryLocationsManageModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMemoryLocationsManageModeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified GetMemoryLocationsManageModeResponseBody message, length delimited. Does not implicitly {@link ptsl.GetMemoryLocationsManageModeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {ptsl.IGetMemoryLocationsManageModeResponseBody} message GetMemoryLocationsManageModeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMemoryLocationsManageModeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMemoryLocationsManageModeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetMemoryLocationsManageModeResponseBody} GetMemoryLocationsManageModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMemoryLocationsManageModeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetMemoryLocationsManageModeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMemoryLocationsManageModeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetMemoryLocationsManageModeResponseBody} GetMemoryLocationsManageModeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMemoryLocationsManageModeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMemoryLocationsManageModeResponseBody message.
         * @function verify
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMemoryLocationsManageModeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a GetMemoryLocationsManageModeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetMemoryLocationsManageModeResponseBody} GetMemoryLocationsManageModeResponseBody
         */
        GetMemoryLocationsManageModeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetMemoryLocationsManageModeResponseBody)
                return object;
            var message = new $root.ptsl.GetMemoryLocationsManageModeResponseBody();
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a GetMemoryLocationsManageModeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {ptsl.GetMemoryLocationsManageModeResponseBody} message GetMemoryLocationsManageModeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMemoryLocationsManageModeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enabled = false;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this GetMemoryLocationsManageModeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMemoryLocationsManageModeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetMemoryLocationsManageModeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetMemoryLocationsManageModeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMemoryLocationsManageModeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetMemoryLocationsManageModeResponseBody";
        };

        return GetMemoryLocationsManageModeResponseBody;
    })();

    ptsl.SetMemoryLocationsManageModeRequestBody = (function() {

        /**
         * Properties of a SetMemoryLocationsManageModeRequestBody.
         * @memberof ptsl
         * @interface ISetMemoryLocationsManageModeRequestBody
         * @property {boolean|null} [enabled] * Whether to enable or disable the Memory Locations Manage Mode.
         */

        /**
         * Constructs a new SetMemoryLocationsManageModeRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetMemoryLocationsManageMode request data.
         * 
         * @since Pro Tools 2024.06
         * @implements ISetMemoryLocationsManageModeRequestBody
         * @constructor
         * @param {ptsl.ISetMemoryLocationsManageModeRequestBody=} [properties] Properties to set
         */
        function SetMemoryLocationsManageModeRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Whether to enable or disable the Memory Locations Manage Mode.
         * @member {boolean} enabled
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @instance
         */
        SetMemoryLocationsManageModeRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetMemoryLocationsManageModeRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {ptsl.ISetMemoryLocationsManageModeRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetMemoryLocationsManageModeRequestBody} SetMemoryLocationsManageModeRequestBody instance
         */
        SetMemoryLocationsManageModeRequestBody.create = function create(properties) {
            return new SetMemoryLocationsManageModeRequestBody(properties);
        };

        /**
         * Encodes the specified SetMemoryLocationsManageModeRequestBody message. Does not implicitly {@link ptsl.SetMemoryLocationsManageModeRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {ptsl.ISetMemoryLocationsManageModeRequestBody} message SetMemoryLocationsManageModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMemoryLocationsManageModeRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetMemoryLocationsManageModeRequestBody message, length delimited. Does not implicitly {@link ptsl.SetMemoryLocationsManageModeRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {ptsl.ISetMemoryLocationsManageModeRequestBody} message SetMemoryLocationsManageModeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMemoryLocationsManageModeRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetMemoryLocationsManageModeRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetMemoryLocationsManageModeRequestBody} SetMemoryLocationsManageModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMemoryLocationsManageModeRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetMemoryLocationsManageModeRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetMemoryLocationsManageModeRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetMemoryLocationsManageModeRequestBody} SetMemoryLocationsManageModeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMemoryLocationsManageModeRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetMemoryLocationsManageModeRequestBody message.
         * @function verify
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetMemoryLocationsManageModeRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetMemoryLocationsManageModeRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetMemoryLocationsManageModeRequestBody} SetMemoryLocationsManageModeRequestBody
         */
        SetMemoryLocationsManageModeRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetMemoryLocationsManageModeRequestBody)
                return object;
            var message = new $root.ptsl.SetMemoryLocationsManageModeRequestBody();
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetMemoryLocationsManageModeRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {ptsl.SetMemoryLocationsManageModeRequestBody} message SetMemoryLocationsManageModeRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetMemoryLocationsManageModeRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enabled = false;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetMemoryLocationsManageModeRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetMemoryLocationsManageModeRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetMemoryLocationsManageModeRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetMemoryLocationsManageModeRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetMemoryLocationsManageModeRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetMemoryLocationsManageModeRequestBody";
        };

        return SetMemoryLocationsManageModeRequestBody;
    })();

    ptsl.HostReadyCheckResponseBody = (function() {

        /**
         * Properties of a HostReadyCheckResponseBody.
         * @memberof ptsl
         * @interface IHostReadyCheckResponseBody
         * @property {boolean|null} [isHostReady] HostReadyCheckResponseBody isHostReady
         */

        /**
         * Constructs a new HostReadyCheckResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes whether Pro Tools is fully loaded to execute PTSL commands.
         * 
         * @since Pro Tools 2024.06
         * @implements IHostReadyCheckResponseBody
         * @constructor
         * @param {ptsl.IHostReadyCheckResponseBody=} [properties] Properties to set
         */
        function HostReadyCheckResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HostReadyCheckResponseBody isHostReady.
         * @member {boolean} isHostReady
         * @memberof ptsl.HostReadyCheckResponseBody
         * @instance
         */
        HostReadyCheckResponseBody.prototype.isHostReady = false;

        /**
         * Creates a new HostReadyCheckResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {ptsl.IHostReadyCheckResponseBody=} [properties] Properties to set
         * @returns {ptsl.HostReadyCheckResponseBody} HostReadyCheckResponseBody instance
         */
        HostReadyCheckResponseBody.create = function create(properties) {
            return new HostReadyCheckResponseBody(properties);
        };

        /**
         * Encodes the specified HostReadyCheckResponseBody message. Does not implicitly {@link ptsl.HostReadyCheckResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {ptsl.IHostReadyCheckResponseBody} message HostReadyCheckResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HostReadyCheckResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isHostReady != null && Object.hasOwnProperty.call(message, "isHostReady"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isHostReady);
            return writer;
        };

        /**
         * Encodes the specified HostReadyCheckResponseBody message, length delimited. Does not implicitly {@link ptsl.HostReadyCheckResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {ptsl.IHostReadyCheckResponseBody} message HostReadyCheckResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HostReadyCheckResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HostReadyCheckResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.HostReadyCheckResponseBody} HostReadyCheckResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HostReadyCheckResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.HostReadyCheckResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.isHostReady = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HostReadyCheckResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.HostReadyCheckResponseBody} HostReadyCheckResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HostReadyCheckResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HostReadyCheckResponseBody message.
         * @function verify
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HostReadyCheckResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isHostReady != null && message.hasOwnProperty("isHostReady"))
                if (typeof message.isHostReady !== "boolean")
                    return "isHostReady: boolean expected";
            return null;
        };

        /**
         * Creates a HostReadyCheckResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.HostReadyCheckResponseBody} HostReadyCheckResponseBody
         */
        HostReadyCheckResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.HostReadyCheckResponseBody)
                return object;
            var message = new $root.ptsl.HostReadyCheckResponseBody();
            if (object.isHostReady != null)
                message.isHostReady = Boolean(object.isHostReady);
            return message;
        };

        /**
         * Creates a plain object from a HostReadyCheckResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {ptsl.HostReadyCheckResponseBody} message HostReadyCheckResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HostReadyCheckResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isHostReady = false;
            if (message.isHostReady != null && message.hasOwnProperty("isHostReady"))
                object.isHostReady = message.isHostReady;
            return object;
        };

        /**
         * Converts this HostReadyCheckResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.HostReadyCheckResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HostReadyCheckResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for HostReadyCheckResponseBody
         * @function getTypeUrl
         * @memberof ptsl.HostReadyCheckResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HostReadyCheckResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.HostReadyCheckResponseBody";
        };

        return HostReadyCheckResponseBody;
    })();

    ptsl.SetMainCounterFormatRequestBody = (function() {

        /**
         * Properties of a SetMainCounterFormatRequestBody.
         * @memberof ptsl
         * @interface ISetMainCounterFormatRequestBody
         * @property {ptsl.TrackOffsetOptions|null} [timeScale] * @deprecated since Pro Tools 2025.06, use location_type
         * @property {ptsl.TimelineLocationType|null} [locationType] * The time scale (type) of the counter.
         * *
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new SetMainCounterFormatRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetMainCounterFormat request data.
         * 
         * @since Pro Tools 2024.06
         * @implements ISetMainCounterFormatRequestBody
         * @constructor
         * @param {ptsl.ISetMainCounterFormatRequestBody=} [properties] Properties to set
         */
        function SetMainCounterFormatRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2025.06, use location_type
         * @member {ptsl.TrackOffsetOptions} timeScale
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @instance
         */
        SetMainCounterFormatRequestBody.prototype.timeScale = 0;

        /**
         * * The time scale (type) of the counter.
         * *
         * * @since Pro Tools 2025.06
         * @member {ptsl.TimelineLocationType} locationType
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @instance
         */
        SetMainCounterFormatRequestBody.prototype.locationType = 0;

        /**
         * Creates a new SetMainCounterFormatRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {ptsl.ISetMainCounterFormatRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetMainCounterFormatRequestBody} SetMainCounterFormatRequestBody instance
         */
        SetMainCounterFormatRequestBody.create = function create(properties) {
            return new SetMainCounterFormatRequestBody(properties);
        };

        /**
         * Encodes the specified SetMainCounterFormatRequestBody message. Does not implicitly {@link ptsl.SetMainCounterFormatRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {ptsl.ISetMainCounterFormatRequestBody} message SetMainCounterFormatRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMainCounterFormatRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeScale != null && Object.hasOwnProperty.call(message, "timeScale"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.timeScale);
            if (message.locationType != null && Object.hasOwnProperty.call(message, "locationType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.locationType);
            return writer;
        };

        /**
         * Encodes the specified SetMainCounterFormatRequestBody message, length delimited. Does not implicitly {@link ptsl.SetMainCounterFormatRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {ptsl.ISetMainCounterFormatRequestBody} message SetMainCounterFormatRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMainCounterFormatRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetMainCounterFormatRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetMainCounterFormatRequestBody} SetMainCounterFormatRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMainCounterFormatRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetMainCounterFormatRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.timeScale = reader.int32();
                        break;
                    }
                case 2: {
                        message.locationType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetMainCounterFormatRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetMainCounterFormatRequestBody} SetMainCounterFormatRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMainCounterFormatRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetMainCounterFormatRequestBody message.
         * @function verify
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetMainCounterFormatRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeScale != null && message.hasOwnProperty("timeScale"))
                switch (message.timeScale) {
                default:
                    return "timeScale: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                switch (message.locationType) {
                default:
                    return "locationType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetMainCounterFormatRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetMainCounterFormatRequestBody} SetMainCounterFormatRequestBody
         */
        SetMainCounterFormatRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetMainCounterFormatRequestBody)
                return object;
            var message = new $root.ptsl.SetMainCounterFormatRequestBody();
            switch (object.timeScale) {
            default:
                if (typeof object.timeScale === "number") {
                    message.timeScale = object.timeScale;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.timeScale = 0;
                break;
            case "BarsBeats":
            case 1:
                message.timeScale = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.timeScale = 1;
                break;
            case "MinSecs":
            case 2:
                message.timeScale = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.timeScale = 2;
                break;
            case "TimeCode":
            case 3:
                message.timeScale = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.timeScale = 3;
                break;
            case "FeetFrames":
            case 4:
                message.timeScale = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.timeScale = 4;
                break;
            case "Samples":
            case 5:
                message.timeScale = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.timeScale = 5;
                break;
            }
            switch (object.locationType) {
            default:
                if (typeof object.locationType === "number") {
                    message.locationType = object.locationType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.locationType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.locationType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.locationType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.locationType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.locationType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.locationType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.locationType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.locationType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.locationType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetMainCounterFormatRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {ptsl.SetMainCounterFormatRequestBody} message SetMainCounterFormatRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetMainCounterFormatRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.timeScale = options.enums === String ? "TOOptions_Unknown" : 0;
                object.locationType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.timeScale != null && message.hasOwnProperty("timeScale"))
                object.timeScale = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.timeScale] === undefined ? message.timeScale : $root.ptsl.TrackOffsetOptions[message.timeScale] : message.timeScale;
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                object.locationType = options.enums === String ? $root.ptsl.TimelineLocationType[message.locationType] === undefined ? message.locationType : $root.ptsl.TimelineLocationType[message.locationType] : message.locationType;
            return object;
        };

        /**
         * Converts this SetMainCounterFormatRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetMainCounterFormatRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetMainCounterFormatRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetMainCounterFormatRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetMainCounterFormatRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetMainCounterFormatRequestBody";
        };

        return SetMainCounterFormatRequestBody;
    })();

    ptsl.SetSubCounterFormatRequestBody = (function() {

        /**
         * Properties of a SetSubCounterFormatRequestBody.
         * @memberof ptsl
         * @interface ISetSubCounterFormatRequestBody
         * @property {ptsl.TrackOffsetOptions|null} [timeScale] * @deprecated since Pro Tools 2025.06, use location_type
         * @property {ptsl.TimelineLocationType|null} [locationType] * The time scale (type) of the counter.
         * *
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new SetSubCounterFormatRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetSubCounterFormat request data.
         * 
         * @since Pro Tools 2024.06
         * @implements ISetSubCounterFormatRequestBody
         * @constructor
         * @param {ptsl.ISetSubCounterFormatRequestBody=} [properties] Properties to set
         */
        function SetSubCounterFormatRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2025.06, use location_type
         * @member {ptsl.TrackOffsetOptions} timeScale
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @instance
         */
        SetSubCounterFormatRequestBody.prototype.timeScale = 0;

        /**
         * * The time scale (type) of the counter.
         * *
         * * @since Pro Tools 2025.06
         * @member {ptsl.TimelineLocationType} locationType
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @instance
         */
        SetSubCounterFormatRequestBody.prototype.locationType = 0;

        /**
         * Creates a new SetSubCounterFormatRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {ptsl.ISetSubCounterFormatRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetSubCounterFormatRequestBody} SetSubCounterFormatRequestBody instance
         */
        SetSubCounterFormatRequestBody.create = function create(properties) {
            return new SetSubCounterFormatRequestBody(properties);
        };

        /**
         * Encodes the specified SetSubCounterFormatRequestBody message. Does not implicitly {@link ptsl.SetSubCounterFormatRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {ptsl.ISetSubCounterFormatRequestBody} message SetSubCounterFormatRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSubCounterFormatRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeScale != null && Object.hasOwnProperty.call(message, "timeScale"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.timeScale);
            if (message.locationType != null && Object.hasOwnProperty.call(message, "locationType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.locationType);
            return writer;
        };

        /**
         * Encodes the specified SetSubCounterFormatRequestBody message, length delimited. Does not implicitly {@link ptsl.SetSubCounterFormatRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {ptsl.ISetSubCounterFormatRequestBody} message SetSubCounterFormatRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSubCounterFormatRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetSubCounterFormatRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetSubCounterFormatRequestBody} SetSubCounterFormatRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSubCounterFormatRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetSubCounterFormatRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.timeScale = reader.int32();
                        break;
                    }
                case 2: {
                        message.locationType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetSubCounterFormatRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetSubCounterFormatRequestBody} SetSubCounterFormatRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSubCounterFormatRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetSubCounterFormatRequestBody message.
         * @function verify
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSubCounterFormatRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeScale != null && message.hasOwnProperty("timeScale"))
                switch (message.timeScale) {
                default:
                    return "timeScale: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                switch (message.locationType) {
                default:
                    return "locationType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetSubCounterFormatRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetSubCounterFormatRequestBody} SetSubCounterFormatRequestBody
         */
        SetSubCounterFormatRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetSubCounterFormatRequestBody)
                return object;
            var message = new $root.ptsl.SetSubCounterFormatRequestBody();
            switch (object.timeScale) {
            default:
                if (typeof object.timeScale === "number") {
                    message.timeScale = object.timeScale;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.timeScale = 0;
                break;
            case "BarsBeats":
            case 1:
                message.timeScale = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.timeScale = 1;
                break;
            case "MinSecs":
            case 2:
                message.timeScale = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.timeScale = 2;
                break;
            case "TimeCode":
            case 3:
                message.timeScale = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.timeScale = 3;
                break;
            case "FeetFrames":
            case 4:
                message.timeScale = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.timeScale = 4;
                break;
            case "Samples":
            case 5:
                message.timeScale = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.timeScale = 5;
                break;
            }
            switch (object.locationType) {
            default:
                if (typeof object.locationType === "number") {
                    message.locationType = object.locationType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.locationType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.locationType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.locationType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.locationType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.locationType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.locationType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.locationType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.locationType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.locationType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetSubCounterFormatRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {ptsl.SetSubCounterFormatRequestBody} message SetSubCounterFormatRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSubCounterFormatRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.timeScale = options.enums === String ? "TOOptions_Unknown" : 0;
                object.locationType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.timeScale != null && message.hasOwnProperty("timeScale"))
                object.timeScale = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.timeScale] === undefined ? message.timeScale : $root.ptsl.TrackOffsetOptions[message.timeScale] : message.timeScale;
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                object.locationType = options.enums === String ? $root.ptsl.TimelineLocationType[message.locationType] === undefined ? message.locationType : $root.ptsl.TimelineLocationType[message.locationType] : message.locationType;
            return object;
        };

        /**
         * Converts this SetSubCounterFormatRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSubCounterFormatRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetSubCounterFormatRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetSubCounterFormatRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetSubCounterFormatRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetSubCounterFormatRequestBody";
        };

        return SetSubCounterFormatRequestBody;
    })();

    ptsl.GetMainCounterFormatResponseBody = (function() {

        /**
         * Properties of a GetMainCounterFormatResponseBody.
         * @memberof ptsl
         * @interface IGetMainCounterFormatResponseBody
         * @property {ptsl.TrackOffsetOptions|null} [currentSetting] * @deprecated since Pro Tools 2025.06, use current_type
         * @property {Array.<ptsl.TrackOffsetOptions>|null} [possibleSettings] * @deprecated since Pro Tools 2025.06, use possible_types
         * @property {ptsl.TimelineLocationType|null} [currentType] * The time scale (type) of the counter.
         * * @since Pro Tools 2025.06
         * @property {Array.<ptsl.TimelineLocationType>|null} [possibleTypes] * The supported time scales (types) of the counter (tier-depended).
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new GetMainCounterFormatResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetMainCounterFormat response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IGetMainCounterFormatResponseBody
         * @constructor
         * @param {ptsl.IGetMainCounterFormatResponseBody=} [properties] Properties to set
         */
        function GetMainCounterFormatResponseBody(properties) {
            this.possibleSettings = [];
            this.possibleTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2025.06, use current_type
         * @member {ptsl.TrackOffsetOptions} currentSetting
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @instance
         */
        GetMainCounterFormatResponseBody.prototype.currentSetting = 0;

        /**
         * * @deprecated since Pro Tools 2025.06, use possible_types
         * @member {Array.<ptsl.TrackOffsetOptions>} possibleSettings
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @instance
         */
        GetMainCounterFormatResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * * The time scale (type) of the counter.
         * * @since Pro Tools 2025.06
         * @member {ptsl.TimelineLocationType} currentType
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @instance
         */
        GetMainCounterFormatResponseBody.prototype.currentType = 0;

        /**
         * * The supported time scales (types) of the counter (tier-depended).
         * * @since Pro Tools 2025.06
         * @member {Array.<ptsl.TimelineLocationType>} possibleTypes
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @instance
         */
        GetMainCounterFormatResponseBody.prototype.possibleTypes = $util.emptyArray;

        /**
         * Creates a new GetMainCounterFormatResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {ptsl.IGetMainCounterFormatResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetMainCounterFormatResponseBody} GetMainCounterFormatResponseBody instance
         */
        GetMainCounterFormatResponseBody.create = function create(properties) {
            return new GetMainCounterFormatResponseBody(properties);
        };

        /**
         * Encodes the specified GetMainCounterFormatResponseBody message. Does not implicitly {@link ptsl.GetMainCounterFormatResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {ptsl.IGetMainCounterFormatResponseBody} message GetMainCounterFormatResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMainCounterFormatResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            if (message.currentType != null && Object.hasOwnProperty.call(message, "currentType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.currentType);
            if (message.possibleTypes != null && message.possibleTypes.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.possibleTypes.length; ++i)
                    writer.int32(message.possibleTypes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetMainCounterFormatResponseBody message, length delimited. Does not implicitly {@link ptsl.GetMainCounterFormatResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {ptsl.IGetMainCounterFormatResponseBody} message GetMainCounterFormatResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMainCounterFormatResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMainCounterFormatResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetMainCounterFormatResponseBody} GetMainCounterFormatResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMainCounterFormatResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetMainCounterFormatResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                case 3: {
                        message.currentType = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.possibleTypes && message.possibleTypes.length))
                            message.possibleTypes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleTypes.push(reader.int32());
                        } else
                            message.possibleTypes.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMainCounterFormatResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetMainCounterFormatResponseBody} GetMainCounterFormatResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMainCounterFormatResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMainCounterFormatResponseBody message.
         * @function verify
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMainCounterFormatResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                        break;
                    }
            }
            if (message.currentType != null && message.hasOwnProperty("currentType"))
                switch (message.currentType) {
                default:
                    return "currentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.possibleTypes != null && message.hasOwnProperty("possibleTypes")) {
                if (!Array.isArray(message.possibleTypes))
                    return "possibleTypes: array expected";
                for (var i = 0; i < message.possibleTypes.length; ++i)
                    switch (message.possibleTypes[i]) {
                    default:
                        return "possibleTypes: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetMainCounterFormatResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetMainCounterFormatResponseBody} GetMainCounterFormatResponseBody
         */
        GetMainCounterFormatResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetMainCounterFormatResponseBody)
                return object;
            var message = new $root.ptsl.GetMainCounterFormatResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "BarsBeats":
            case 1:
                message.currentSetting = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.currentSetting = 1;
                break;
            case "MinSecs":
            case 2:
                message.currentSetting = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.currentSetting = 2;
                break;
            case "TimeCode":
            case 3:
                message.currentSetting = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.currentSetting = 3;
                break;
            case "FeetFrames":
            case 4:
                message.currentSetting = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.currentSetting = 4;
                break;
            case "Samples":
            case 5:
                message.currentSetting = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.currentSetting = 5;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetMainCounterFormatResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "TOOptions_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "BarsBeats":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "TOOptions_BarsBeats":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "MinSecs":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "TOOptions_MinSecs":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "TimeCode":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "TOOptions_TimeCode":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "FeetFrames":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "TOOptions_FeetFrames":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "Samples":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "TOOptions_Samples":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    }
            }
            switch (object.currentType) {
            default:
                if (typeof object.currentType === "number") {
                    message.currentType = object.currentType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.currentType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.currentType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.currentType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.currentType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.currentType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.currentType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.currentType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.currentType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.currentType = 8;
                break;
            }
            if (object.possibleTypes) {
                if (!Array.isArray(object.possibleTypes))
                    throw TypeError(".ptsl.GetMainCounterFormatResponseBody.possibleTypes: array expected");
                message.possibleTypes = [];
                for (var i = 0; i < object.possibleTypes.length; ++i)
                    switch (object.possibleTypes[i]) {
                    default:
                        if (typeof object.possibleTypes[i] === "number") {
                            message.possibleTypes[i] = object.possibleTypes[i];
                            break;
                        }
                    case "TLType_Unknown":
                    case 0:
                        message.possibleTypes[i] = 0;
                        break;
                    case "TLType_Samples":
                    case 1:
                        message.possibleTypes[i] = 1;
                        break;
                    case "TLType_Ticks":
                    case 2:
                        message.possibleTypes[i] = 2;
                        break;
                    case "TLType_Frames":
                    case 3:
                        message.possibleTypes[i] = 3;
                        break;
                    case "TLType_MinSecs":
                    case 4:
                        message.possibleTypes[i] = 4;
                        break;
                    case "TLType_TimeCode":
                    case 5:
                        message.possibleTypes[i] = 5;
                        break;
                    case "TLType_BarsBeats":
                    case 6:
                        message.possibleTypes[i] = 6;
                        break;
                    case "TLType_FeetFrames":
                    case 7:
                        message.possibleTypes[i] = 7;
                        break;
                    case "TLType_Seconds":
                    case 8:
                        message.possibleTypes[i] = 8;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetMainCounterFormatResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {ptsl.GetMainCounterFormatResponseBody} message GetMainCounterFormatResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMainCounterFormatResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.possibleSettings = [];
                object.possibleTypes = [];
            }
            if (options.defaults) {
                object.currentSetting = options.enums === String ? "TOOptions_Unknown" : 0;
                object.currentType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.TrackOffsetOptions[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.TrackOffsetOptions[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            if (message.currentType != null && message.hasOwnProperty("currentType"))
                object.currentType = options.enums === String ? $root.ptsl.TimelineLocationType[message.currentType] === undefined ? message.currentType : $root.ptsl.TimelineLocationType[message.currentType] : message.currentType;
            if (message.possibleTypes && message.possibleTypes.length) {
                object.possibleTypes = [];
                for (var j = 0; j < message.possibleTypes.length; ++j)
                    object.possibleTypes[j] = options.enums === String ? $root.ptsl.TimelineLocationType[message.possibleTypes[j]] === undefined ? message.possibleTypes[j] : $root.ptsl.TimelineLocationType[message.possibleTypes[j]] : message.possibleTypes[j];
            }
            return object;
        };

        /**
         * Converts this GetMainCounterFormatResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMainCounterFormatResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetMainCounterFormatResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetMainCounterFormatResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMainCounterFormatResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetMainCounterFormatResponseBody";
        };

        return GetMainCounterFormatResponseBody;
    })();

    ptsl.GetSubCounterFormatResponseBody = (function() {

        /**
         * Properties of a GetSubCounterFormatResponseBody.
         * @memberof ptsl
         * @interface IGetSubCounterFormatResponseBody
         * @property {ptsl.TrackOffsetOptions|null} [currentSetting] * @deprecated since Pro Tools 2025.06, use current_type
         * @property {Array.<ptsl.TrackOffsetOptions>|null} [possibleSettings] * @deprecated since Pro Tools 2025.06, use possible_types
         * @property {ptsl.TimelineLocationType|null} [currentType] * The time scale (type) of the counter.
         * * @since Pro Tools 2025.06
         * @property {Array.<ptsl.TimelineLocationType>|null} [possibleTypes] * The supported time scales (types) of the counter (tier-depended).
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new GetSubCounterFormatResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSubCounterFormat response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IGetSubCounterFormatResponseBody
         * @constructor
         * @param {ptsl.IGetSubCounterFormatResponseBody=} [properties] Properties to set
         */
        function GetSubCounterFormatResponseBody(properties) {
            this.possibleSettings = [];
            this.possibleTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * @deprecated since Pro Tools 2025.06, use current_type
         * @member {ptsl.TrackOffsetOptions} currentSetting
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @instance
         */
        GetSubCounterFormatResponseBody.prototype.currentSetting = 0;

        /**
         * * @deprecated since Pro Tools 2025.06, use possible_types
         * @member {Array.<ptsl.TrackOffsetOptions>} possibleSettings
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @instance
         */
        GetSubCounterFormatResponseBody.prototype.possibleSettings = $util.emptyArray;

        /**
         * * The time scale (type) of the counter.
         * * @since Pro Tools 2025.06
         * @member {ptsl.TimelineLocationType} currentType
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @instance
         */
        GetSubCounterFormatResponseBody.prototype.currentType = 0;

        /**
         * * The supported time scales (types) of the counter (tier-depended).
         * * @since Pro Tools 2025.06
         * @member {Array.<ptsl.TimelineLocationType>} possibleTypes
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @instance
         */
        GetSubCounterFormatResponseBody.prototype.possibleTypes = $util.emptyArray;

        /**
         * Creates a new GetSubCounterFormatResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {ptsl.IGetSubCounterFormatResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSubCounterFormatResponseBody} GetSubCounterFormatResponseBody instance
         */
        GetSubCounterFormatResponseBody.create = function create(properties) {
            return new GetSubCounterFormatResponseBody(properties);
        };

        /**
         * Encodes the specified GetSubCounterFormatResponseBody message. Does not implicitly {@link ptsl.GetSubCounterFormatResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {ptsl.IGetSubCounterFormatResponseBody} message GetSubCounterFormatResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSubCounterFormatResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSetting != null && Object.hasOwnProperty.call(message, "currentSetting"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentSetting);
            if (message.possibleSettings != null && message.possibleSettings.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    writer.int32(message.possibleSettings[i]);
                writer.ldelim();
            }
            if (message.currentType != null && Object.hasOwnProperty.call(message, "currentType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.currentType);
            if (message.possibleTypes != null && message.possibleTypes.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.possibleTypes.length; ++i)
                    writer.int32(message.possibleTypes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetSubCounterFormatResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSubCounterFormatResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {ptsl.IGetSubCounterFormatResponseBody} message GetSubCounterFormatResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSubCounterFormatResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSubCounterFormatResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSubCounterFormatResponseBody} GetSubCounterFormatResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSubCounterFormatResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSubCounterFormatResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.currentSetting = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.possibleSettings && message.possibleSettings.length))
                            message.possibleSettings = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleSettings.push(reader.int32());
                        } else
                            message.possibleSettings.push(reader.int32());
                        break;
                    }
                case 3: {
                        message.currentType = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.possibleTypes && message.possibleTypes.length))
                            message.possibleTypes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.possibleTypes.push(reader.int32());
                        } else
                            message.possibleTypes.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSubCounterFormatResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSubCounterFormatResponseBody} GetSubCounterFormatResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSubCounterFormatResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSubCounterFormatResponseBody message.
         * @function verify
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSubCounterFormatResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                switch (message.currentSetting) {
                default:
                    return "currentSetting: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                    break;
                }
            if (message.possibleSettings != null && message.hasOwnProperty("possibleSettings")) {
                if (!Array.isArray(message.possibleSettings))
                    return "possibleSettings: array expected";
                for (var i = 0; i < message.possibleSettings.length; ++i)
                    switch (message.possibleSettings[i]) {
                    default:
                        return "possibleSettings: enum value[] expected";
                    case 0:
                    case 1:
                    case 1:
                    case 2:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 5:
                        break;
                    }
            }
            if (message.currentType != null && message.hasOwnProperty("currentType"))
                switch (message.currentType) {
                default:
                    return "currentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.possibleTypes != null && message.hasOwnProperty("possibleTypes")) {
                if (!Array.isArray(message.possibleTypes))
                    return "possibleTypes: array expected";
                for (var i = 0; i < message.possibleTypes.length; ++i)
                    switch (message.possibleTypes[i]) {
                    default:
                        return "possibleTypes: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a GetSubCounterFormatResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSubCounterFormatResponseBody} GetSubCounterFormatResponseBody
         */
        GetSubCounterFormatResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSubCounterFormatResponseBody)
                return object;
            var message = new $root.ptsl.GetSubCounterFormatResponseBody();
            switch (object.currentSetting) {
            default:
                if (typeof object.currentSetting === "number") {
                    message.currentSetting = object.currentSetting;
                    break;
                }
                break;
            case "TOOptions_Unknown":
            case 0:
                message.currentSetting = 0;
                break;
            case "BarsBeats":
            case 1:
                message.currentSetting = 1;
                break;
            case "TOOptions_BarsBeats":
            case 1:
                message.currentSetting = 1;
                break;
            case "MinSecs":
            case 2:
                message.currentSetting = 2;
                break;
            case "TOOptions_MinSecs":
            case 2:
                message.currentSetting = 2;
                break;
            case "TimeCode":
            case 3:
                message.currentSetting = 3;
                break;
            case "TOOptions_TimeCode":
            case 3:
                message.currentSetting = 3;
                break;
            case "FeetFrames":
            case 4:
                message.currentSetting = 4;
                break;
            case "TOOptions_FeetFrames":
            case 4:
                message.currentSetting = 4;
                break;
            case "Samples":
            case 5:
                message.currentSetting = 5;
                break;
            case "TOOptions_Samples":
            case 5:
                message.currentSetting = 5;
                break;
            }
            if (object.possibleSettings) {
                if (!Array.isArray(object.possibleSettings))
                    throw TypeError(".ptsl.GetSubCounterFormatResponseBody.possibleSettings: array expected");
                message.possibleSettings = [];
                for (var i = 0; i < object.possibleSettings.length; ++i)
                    switch (object.possibleSettings[i]) {
                    default:
                        if (typeof object.possibleSettings[i] === "number") {
                            message.possibleSettings[i] = object.possibleSettings[i];
                            break;
                        }
                    case "TOOptions_Unknown":
                    case 0:
                        message.possibleSettings[i] = 0;
                        break;
                    case "BarsBeats":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "TOOptions_BarsBeats":
                    case 1:
                        message.possibleSettings[i] = 1;
                        break;
                    case "MinSecs":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "TOOptions_MinSecs":
                    case 2:
                        message.possibleSettings[i] = 2;
                        break;
                    case "TimeCode":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "TOOptions_TimeCode":
                    case 3:
                        message.possibleSettings[i] = 3;
                        break;
                    case "FeetFrames":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "TOOptions_FeetFrames":
                    case 4:
                        message.possibleSettings[i] = 4;
                        break;
                    case "Samples":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    case "TOOptions_Samples":
                    case 5:
                        message.possibleSettings[i] = 5;
                        break;
                    }
            }
            switch (object.currentType) {
            default:
                if (typeof object.currentType === "number") {
                    message.currentType = object.currentType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.currentType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.currentType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.currentType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.currentType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.currentType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.currentType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.currentType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.currentType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.currentType = 8;
                break;
            }
            if (object.possibleTypes) {
                if (!Array.isArray(object.possibleTypes))
                    throw TypeError(".ptsl.GetSubCounterFormatResponseBody.possibleTypes: array expected");
                message.possibleTypes = [];
                for (var i = 0; i < object.possibleTypes.length; ++i)
                    switch (object.possibleTypes[i]) {
                    default:
                        if (typeof object.possibleTypes[i] === "number") {
                            message.possibleTypes[i] = object.possibleTypes[i];
                            break;
                        }
                    case "TLType_Unknown":
                    case 0:
                        message.possibleTypes[i] = 0;
                        break;
                    case "TLType_Samples":
                    case 1:
                        message.possibleTypes[i] = 1;
                        break;
                    case "TLType_Ticks":
                    case 2:
                        message.possibleTypes[i] = 2;
                        break;
                    case "TLType_Frames":
                    case 3:
                        message.possibleTypes[i] = 3;
                        break;
                    case "TLType_MinSecs":
                    case 4:
                        message.possibleTypes[i] = 4;
                        break;
                    case "TLType_TimeCode":
                    case 5:
                        message.possibleTypes[i] = 5;
                        break;
                    case "TLType_BarsBeats":
                    case 6:
                        message.possibleTypes[i] = 6;
                        break;
                    case "TLType_FeetFrames":
                    case 7:
                        message.possibleTypes[i] = 7;
                        break;
                    case "TLType_Seconds":
                    case 8:
                        message.possibleTypes[i] = 8;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSubCounterFormatResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {ptsl.GetSubCounterFormatResponseBody} message GetSubCounterFormatResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSubCounterFormatResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.possibleSettings = [];
                object.possibleTypes = [];
            }
            if (options.defaults) {
                object.currentSetting = options.enums === String ? "TOOptions_Unknown" : 0;
                object.currentType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.currentSetting != null && message.hasOwnProperty("currentSetting"))
                object.currentSetting = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.currentSetting] === undefined ? message.currentSetting : $root.ptsl.TrackOffsetOptions[message.currentSetting] : message.currentSetting;
            if (message.possibleSettings && message.possibleSettings.length) {
                object.possibleSettings = [];
                for (var j = 0; j < message.possibleSettings.length; ++j)
                    object.possibleSettings[j] = options.enums === String ? $root.ptsl.TrackOffsetOptions[message.possibleSettings[j]] === undefined ? message.possibleSettings[j] : $root.ptsl.TrackOffsetOptions[message.possibleSettings[j]] : message.possibleSettings[j];
            }
            if (message.currentType != null && message.hasOwnProperty("currentType"))
                object.currentType = options.enums === String ? $root.ptsl.TimelineLocationType[message.currentType] === undefined ? message.currentType : $root.ptsl.TimelineLocationType[message.currentType] : message.currentType;
            if (message.possibleTypes && message.possibleTypes.length) {
                object.possibleTypes = [];
                for (var j = 0; j < message.possibleTypes.length; ++j)
                    object.possibleTypes[j] = options.enums === String ? $root.ptsl.TimelineLocationType[message.possibleTypes[j]] === undefined ? message.possibleTypes[j] : $root.ptsl.TimelineLocationType[message.possibleTypes[j]] : message.possibleTypes[j];
            }
            return object;
        };

        /**
         * Converts this GetSubCounterFormatResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSubCounterFormatResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSubCounterFormatResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSubCounterFormatResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSubCounterFormatResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSubCounterFormatResponseBody";
        };

        return GetSubCounterFormatResponseBody;
    })();

    ptsl.UndoHistoryOperation = (function() {

        /**
         * Properties of an UndoHistoryOperation.
         * @memberof ptsl
         * @interface IUndoHistoryOperation
         * @property {string|null} [time] * The time of the operation (ISO 8601 format).
         * @property {string|null} [operation] * The name of the operation.
         * @property {string|null} [details] * The details of the operation (if available).
         */

        /**
         * Constructs a new UndoHistoryOperation.
         * @memberof ptsl
         * @classdesc A single Undo/Redo operation (see menu Window -> Undo History in the Pro Tools UI).
         * 
         * @since Pro Tools 2024.06
         * @implements IUndoHistoryOperation
         * @constructor
         * @param {ptsl.IUndoHistoryOperation=} [properties] Properties to set
         */
        function UndoHistoryOperation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The time of the operation (ISO 8601 format).
         * @member {string} time
         * @memberof ptsl.UndoHistoryOperation
         * @instance
         */
        UndoHistoryOperation.prototype.time = "";

        /**
         * * The name of the operation.
         * @member {string} operation
         * @memberof ptsl.UndoHistoryOperation
         * @instance
         */
        UndoHistoryOperation.prototype.operation = "";

        /**
         * * The details of the operation (if available).
         * @member {string} details
         * @memberof ptsl.UndoHistoryOperation
         * @instance
         */
        UndoHistoryOperation.prototype.details = "";

        /**
         * Creates a new UndoHistoryOperation instance using the specified properties.
         * @function create
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {ptsl.IUndoHistoryOperation=} [properties] Properties to set
         * @returns {ptsl.UndoHistoryOperation} UndoHistoryOperation instance
         */
        UndoHistoryOperation.create = function create(properties) {
            return new UndoHistoryOperation(properties);
        };

        /**
         * Encodes the specified UndoHistoryOperation message. Does not implicitly {@link ptsl.UndoHistoryOperation.verify|verify} messages.
         * @function encode
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {ptsl.IUndoHistoryOperation} message UndoHistoryOperation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoHistoryOperation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.operation);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.details);
            return writer;
        };

        /**
         * Encodes the specified UndoHistoryOperation message, length delimited. Does not implicitly {@link ptsl.UndoHistoryOperation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {ptsl.IUndoHistoryOperation} message UndoHistoryOperation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoHistoryOperation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndoHistoryOperation message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.UndoHistoryOperation} UndoHistoryOperation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoHistoryOperation.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.UndoHistoryOperation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.time = reader.string();
                        break;
                    }
                case 2: {
                        message.operation = reader.string();
                        break;
                    }
                case 3: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndoHistoryOperation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.UndoHistoryOperation} UndoHistoryOperation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoHistoryOperation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndoHistoryOperation message.
         * @function verify
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndoHistoryOperation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isString(message.time))
                    return "time: string expected";
            if (message.operation != null && message.hasOwnProperty("operation"))
                if (!$util.isString(message.operation))
                    return "operation: string expected";
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };

        /**
         * Creates an UndoHistoryOperation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.UndoHistoryOperation} UndoHistoryOperation
         */
        UndoHistoryOperation.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.UndoHistoryOperation)
                return object;
            var message = new $root.ptsl.UndoHistoryOperation();
            if (object.time != null)
                message.time = String(object.time);
            if (object.operation != null)
                message.operation = String(object.operation);
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };

        /**
         * Creates a plain object from an UndoHistoryOperation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {ptsl.UndoHistoryOperation} message UndoHistoryOperation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndoHistoryOperation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.operation = "";
                object.details = "";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.operation != null && message.hasOwnProperty("operation"))
                object.operation = message.operation;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };

        /**
         * Converts this UndoHistoryOperation to JSON.
         * @function toJSON
         * @memberof ptsl.UndoHistoryOperation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndoHistoryOperation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UndoHistoryOperation
         * @function getTypeUrl
         * @memberof ptsl.UndoHistoryOperation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UndoHistoryOperation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.UndoHistoryOperation";
        };

        return UndoHistoryOperation;
    })();

    ptsl.UndoRequestBody = (function() {

        /**
         * Properties of an UndoRequestBody.
         * @memberof ptsl
         * @interface IUndoRequestBody
         * @property {number|null} [levels] * The number of levels to undo.
         */

        /**
         * Constructs a new UndoRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes Undo request data.
         * 
         * @since Pro Tools 2024.06
         * @implements IUndoRequestBody
         * @constructor
         * @param {ptsl.IUndoRequestBody=} [properties] Properties to set
         */
        function UndoRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The number of levels to undo.
         * @member {number} levels
         * @memberof ptsl.UndoRequestBody
         * @instance
         */
        UndoRequestBody.prototype.levels = 0;

        /**
         * Creates a new UndoRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {ptsl.IUndoRequestBody=} [properties] Properties to set
         * @returns {ptsl.UndoRequestBody} UndoRequestBody instance
         */
        UndoRequestBody.create = function create(properties) {
            return new UndoRequestBody(properties);
        };

        /**
         * Encodes the specified UndoRequestBody message. Does not implicitly {@link ptsl.UndoRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {ptsl.IUndoRequestBody} message UndoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.levels != null && Object.hasOwnProperty.call(message, "levels"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.levels);
            return writer;
        };

        /**
         * Encodes the specified UndoRequestBody message, length delimited. Does not implicitly {@link ptsl.UndoRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {ptsl.IUndoRequestBody} message UndoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndoRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.UndoRequestBody} UndoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.UndoRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.levels = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndoRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.UndoRequestBody} UndoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndoRequestBody message.
         * @function verify
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndoRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.levels != null && message.hasOwnProperty("levels"))
                if (!$util.isInteger(message.levels))
                    return "levels: integer expected";
            return null;
        };

        /**
         * Creates an UndoRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.UndoRequestBody} UndoRequestBody
         */
        UndoRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.UndoRequestBody)
                return object;
            var message = new $root.ptsl.UndoRequestBody();
            if (object.levels != null)
                message.levels = object.levels | 0;
            return message;
        };

        /**
         * Creates a plain object from an UndoRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {ptsl.UndoRequestBody} message UndoRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndoRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.levels = 0;
            if (message.levels != null && message.hasOwnProperty("levels"))
                object.levels = message.levels;
            return object;
        };

        /**
         * Converts this UndoRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.UndoRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndoRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UndoRequestBody
         * @function getTypeUrl
         * @memberof ptsl.UndoRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UndoRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.UndoRequestBody";
        };

        return UndoRequestBody;
    })();

    ptsl.UndoResponseBody = (function() {

        /**
         * Properties of an UndoResponseBody.
         * @memberof ptsl
         * @interface IUndoResponseBody
         * @property {Array.<ptsl.IUndoHistoryOperation>|null} [operations] * The list of successfully undone operations.
         */

        /**
         * Constructs a new UndoResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes Undo response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IUndoResponseBody
         * @constructor
         * @param {ptsl.IUndoResponseBody=} [properties] Properties to set
         */
        function UndoResponseBody(properties) {
            this.operations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The list of successfully undone operations.
         * @member {Array.<ptsl.IUndoHistoryOperation>} operations
         * @memberof ptsl.UndoResponseBody
         * @instance
         */
        UndoResponseBody.prototype.operations = $util.emptyArray;

        /**
         * Creates a new UndoResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {ptsl.IUndoResponseBody=} [properties] Properties to set
         * @returns {ptsl.UndoResponseBody} UndoResponseBody instance
         */
        UndoResponseBody.create = function create(properties) {
            return new UndoResponseBody(properties);
        };

        /**
         * Encodes the specified UndoResponseBody message. Does not implicitly {@link ptsl.UndoResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {ptsl.IUndoResponseBody} message UndoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operations != null && message.operations.length)
                for (var i = 0; i < message.operations.length; ++i)
                    $root.ptsl.UndoHistoryOperation.encode(message.operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UndoResponseBody message, length delimited. Does not implicitly {@link ptsl.UndoResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {ptsl.IUndoResponseBody} message UndoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndoResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.UndoResponseBody} UndoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.UndoResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.ptsl.UndoHistoryOperation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndoResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.UndoResponseBody} UndoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndoResponseBody message.
         * @function verify
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndoResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (var i = 0; i < message.operations.length; ++i) {
                    var error = $root.ptsl.UndoHistoryOperation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UndoResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.UndoResponseBody} UndoResponseBody
         */
        UndoResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.UndoResponseBody)
                return object;
            var message = new $root.ptsl.UndoResponseBody();
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".ptsl.UndoResponseBody.operations: array expected");
                message.operations = [];
                for (var i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".ptsl.UndoResponseBody.operations: object expected");
                    message.operations[i] = $root.ptsl.UndoHistoryOperation.fromObject(object.operations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UndoResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {ptsl.UndoResponseBody} message UndoResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndoResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.operations = [];
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (var j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.ptsl.UndoHistoryOperation.toObject(message.operations[j], options);
            }
            return object;
        };

        /**
         * Converts this UndoResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.UndoResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndoResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UndoResponseBody
         * @function getTypeUrl
         * @memberof ptsl.UndoResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UndoResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.UndoResponseBody";
        };

        return UndoResponseBody;
    })();

    ptsl.RedoRequestBody = (function() {

        /**
         * Properties of a RedoRequestBody.
         * @memberof ptsl
         * @interface IRedoRequestBody
         * @property {number|null} [levels] * The number of levels to redo.
         */

        /**
         * Constructs a new RedoRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes Redo request data.
         * 
         * @since Pro Tools 2024.06
         * @implements IRedoRequestBody
         * @constructor
         * @param {ptsl.IRedoRequestBody=} [properties] Properties to set
         */
        function RedoRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The number of levels to redo.
         * @member {number} levels
         * @memberof ptsl.RedoRequestBody
         * @instance
         */
        RedoRequestBody.prototype.levels = 0;

        /**
         * Creates a new RedoRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {ptsl.IRedoRequestBody=} [properties] Properties to set
         * @returns {ptsl.RedoRequestBody} RedoRequestBody instance
         */
        RedoRequestBody.create = function create(properties) {
            return new RedoRequestBody(properties);
        };

        /**
         * Encodes the specified RedoRequestBody message. Does not implicitly {@link ptsl.RedoRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {ptsl.IRedoRequestBody} message RedoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.levels != null && Object.hasOwnProperty.call(message, "levels"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.levels);
            return writer;
        };

        /**
         * Encodes the specified RedoRequestBody message, length delimited. Does not implicitly {@link ptsl.RedoRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {ptsl.IRedoRequestBody} message RedoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedoRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RedoRequestBody} RedoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RedoRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.levels = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedoRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RedoRequestBody} RedoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedoRequestBody message.
         * @function verify
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedoRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.levels != null && message.hasOwnProperty("levels"))
                if (!$util.isInteger(message.levels))
                    return "levels: integer expected";
            return null;
        };

        /**
         * Creates a RedoRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RedoRequestBody} RedoRequestBody
         */
        RedoRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RedoRequestBody)
                return object;
            var message = new $root.ptsl.RedoRequestBody();
            if (object.levels != null)
                message.levels = object.levels | 0;
            return message;
        };

        /**
         * Creates a plain object from a RedoRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {ptsl.RedoRequestBody} message RedoRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedoRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.levels = 0;
            if (message.levels != null && message.hasOwnProperty("levels"))
                object.levels = message.levels;
            return object;
        };

        /**
         * Converts this RedoRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RedoRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedoRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RedoRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RedoRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RedoRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RedoRequestBody";
        };

        return RedoRequestBody;
    })();

    ptsl.RedoResponseBody = (function() {

        /**
         * Properties of a RedoResponseBody.
         * @memberof ptsl
         * @interface IRedoResponseBody
         * @property {Array.<ptsl.IUndoHistoryOperation>|null} [operations] * The list of successfully redone operations.
         */

        /**
         * Constructs a new RedoResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes Redo response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IRedoResponseBody
         * @constructor
         * @param {ptsl.IRedoResponseBody=} [properties] Properties to set
         */
        function RedoResponseBody(properties) {
            this.operations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The list of successfully redone operations.
         * @member {Array.<ptsl.IUndoHistoryOperation>} operations
         * @memberof ptsl.RedoResponseBody
         * @instance
         */
        RedoResponseBody.prototype.operations = $util.emptyArray;

        /**
         * Creates a new RedoResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {ptsl.IRedoResponseBody=} [properties] Properties to set
         * @returns {ptsl.RedoResponseBody} RedoResponseBody instance
         */
        RedoResponseBody.create = function create(properties) {
            return new RedoResponseBody(properties);
        };

        /**
         * Encodes the specified RedoResponseBody message. Does not implicitly {@link ptsl.RedoResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {ptsl.IRedoResponseBody} message RedoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operations != null && message.operations.length)
                for (var i = 0; i < message.operations.length; ++i)
                    $root.ptsl.UndoHistoryOperation.encode(message.operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RedoResponseBody message, length delimited. Does not implicitly {@link ptsl.RedoResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {ptsl.IRedoResponseBody} message RedoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedoResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RedoResponseBody} RedoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RedoResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.ptsl.UndoHistoryOperation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedoResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RedoResponseBody} RedoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedoResponseBody message.
         * @function verify
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedoResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (var i = 0; i < message.operations.length; ++i) {
                    var error = $root.ptsl.UndoHistoryOperation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RedoResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RedoResponseBody} RedoResponseBody
         */
        RedoResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RedoResponseBody)
                return object;
            var message = new $root.ptsl.RedoResponseBody();
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".ptsl.RedoResponseBody.operations: array expected");
                message.operations = [];
                for (var i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".ptsl.RedoResponseBody.operations: object expected");
                    message.operations[i] = $root.ptsl.UndoHistoryOperation.fromObject(object.operations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RedoResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {ptsl.RedoResponseBody} message RedoResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedoResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.operations = [];
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (var j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.ptsl.UndoHistoryOperation.toObject(message.operations[j], options);
            }
            return object;
        };

        /**
         * Converts this RedoResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.RedoResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedoResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RedoResponseBody
         * @function getTypeUrl
         * @memberof ptsl.RedoResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RedoResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RedoResponseBody";
        };

        return RedoResponseBody;
    })();

    ptsl.UndoAllResponseBody = (function() {

        /**
         * Properties of an UndoAllResponseBody.
         * @memberof ptsl
         * @interface IUndoAllResponseBody
         * @property {Array.<ptsl.IUndoHistoryOperation>|null} [operations] * The list of successfully undone operations.
         */

        /**
         * Constructs a new UndoAllResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes UndoAll response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IUndoAllResponseBody
         * @constructor
         * @param {ptsl.IUndoAllResponseBody=} [properties] Properties to set
         */
        function UndoAllResponseBody(properties) {
            this.operations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The list of successfully undone operations.
         * @member {Array.<ptsl.IUndoHistoryOperation>} operations
         * @memberof ptsl.UndoAllResponseBody
         * @instance
         */
        UndoAllResponseBody.prototype.operations = $util.emptyArray;

        /**
         * Creates a new UndoAllResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {ptsl.IUndoAllResponseBody=} [properties] Properties to set
         * @returns {ptsl.UndoAllResponseBody} UndoAllResponseBody instance
         */
        UndoAllResponseBody.create = function create(properties) {
            return new UndoAllResponseBody(properties);
        };

        /**
         * Encodes the specified UndoAllResponseBody message. Does not implicitly {@link ptsl.UndoAllResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {ptsl.IUndoAllResponseBody} message UndoAllResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoAllResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operations != null && message.operations.length)
                for (var i = 0; i < message.operations.length; ++i)
                    $root.ptsl.UndoHistoryOperation.encode(message.operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UndoAllResponseBody message, length delimited. Does not implicitly {@link ptsl.UndoAllResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {ptsl.IUndoAllResponseBody} message UndoAllResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoAllResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndoAllResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.UndoAllResponseBody} UndoAllResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoAllResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.UndoAllResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.ptsl.UndoHistoryOperation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndoAllResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.UndoAllResponseBody} UndoAllResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoAllResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndoAllResponseBody message.
         * @function verify
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndoAllResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (var i = 0; i < message.operations.length; ++i) {
                    var error = $root.ptsl.UndoHistoryOperation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UndoAllResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.UndoAllResponseBody} UndoAllResponseBody
         */
        UndoAllResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.UndoAllResponseBody)
                return object;
            var message = new $root.ptsl.UndoAllResponseBody();
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".ptsl.UndoAllResponseBody.operations: array expected");
                message.operations = [];
                for (var i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".ptsl.UndoAllResponseBody.operations: object expected");
                    message.operations[i] = $root.ptsl.UndoHistoryOperation.fromObject(object.operations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UndoAllResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {ptsl.UndoAllResponseBody} message UndoAllResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndoAllResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.operations = [];
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (var j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.ptsl.UndoHistoryOperation.toObject(message.operations[j], options);
            }
            return object;
        };

        /**
         * Converts this UndoAllResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.UndoAllResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndoAllResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UndoAllResponseBody
         * @function getTypeUrl
         * @memberof ptsl.UndoAllResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UndoAllResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.UndoAllResponseBody";
        };

        return UndoAllResponseBody;
    })();

    ptsl.RedoAllResponseBody = (function() {

        /**
         * Properties of a RedoAllResponseBody.
         * @memberof ptsl
         * @interface IRedoAllResponseBody
         * @property {Array.<ptsl.IUndoHistoryOperation>|null} [operations] * The list of successfully redone operations.
         */

        /**
         * Constructs a new RedoAllResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes RedoAll response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IRedoAllResponseBody
         * @constructor
         * @param {ptsl.IRedoAllResponseBody=} [properties] Properties to set
         */
        function RedoAllResponseBody(properties) {
            this.operations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The list of successfully redone operations.
         * @member {Array.<ptsl.IUndoHistoryOperation>} operations
         * @memberof ptsl.RedoAllResponseBody
         * @instance
         */
        RedoAllResponseBody.prototype.operations = $util.emptyArray;

        /**
         * Creates a new RedoAllResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {ptsl.IRedoAllResponseBody=} [properties] Properties to set
         * @returns {ptsl.RedoAllResponseBody} RedoAllResponseBody instance
         */
        RedoAllResponseBody.create = function create(properties) {
            return new RedoAllResponseBody(properties);
        };

        /**
         * Encodes the specified RedoAllResponseBody message. Does not implicitly {@link ptsl.RedoAllResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {ptsl.IRedoAllResponseBody} message RedoAllResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoAllResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operations != null && message.operations.length)
                for (var i = 0; i < message.operations.length; ++i)
                    $root.ptsl.UndoHistoryOperation.encode(message.operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RedoAllResponseBody message, length delimited. Does not implicitly {@link ptsl.RedoAllResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {ptsl.IRedoAllResponseBody} message RedoAllResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoAllResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedoAllResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RedoAllResponseBody} RedoAllResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoAllResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RedoAllResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.ptsl.UndoHistoryOperation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedoAllResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RedoAllResponseBody} RedoAllResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoAllResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedoAllResponseBody message.
         * @function verify
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedoAllResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (var i = 0; i < message.operations.length; ++i) {
                    var error = $root.ptsl.UndoHistoryOperation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RedoAllResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RedoAllResponseBody} RedoAllResponseBody
         */
        RedoAllResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RedoAllResponseBody)
                return object;
            var message = new $root.ptsl.RedoAllResponseBody();
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".ptsl.RedoAllResponseBody.operations: array expected");
                message.operations = [];
                for (var i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".ptsl.RedoAllResponseBody.operations: object expected");
                    message.operations[i] = $root.ptsl.UndoHistoryOperation.fromObject(object.operations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RedoAllResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {ptsl.RedoAllResponseBody} message RedoAllResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedoAllResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.operations = [];
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (var j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.ptsl.UndoHistoryOperation.toObject(message.operations[j], options);
            }
            return object;
        };

        /**
         * Converts this RedoAllResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.RedoAllResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedoAllResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RedoAllResponseBody
         * @function getTypeUrl
         * @memberof ptsl.RedoAllResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RedoAllResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RedoAllResponseBody";
        };

        return RedoAllResponseBody;
    })();

    ptsl.SetTrackDSPModeSafeStateRequestBody = (function() {

        /**
         * Properties of a SetTrackDSPModeSafeStateRequestBody.
         * @memberof ptsl
         * @interface ISetTrackDSPModeSafeStateRequestBody
         * @property {Array.<string>|null} [trackNames] * Tracks to set the DSP Mode Safe state.
         * @property {boolean|null} [enabled] * The state to set (`true` for enabling the DSP Mode Safe, `false` for disabling the DSP Mode Safe).
         */

        /**
         * Constructs a new SetTrackDSPModeSafeStateRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SetTrackDSPModeSafeState request data.
         * 
         * @since Pro Tools 2024.06
         * @implements ISetTrackDSPModeSafeStateRequestBody
         * @constructor
         * @param {ptsl.ISetTrackDSPModeSafeStateRequestBody=} [properties] Properties to set
         */
        function SetTrackDSPModeSafeStateRequestBody(properties) {
            this.trackNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Tracks to set the DSP Mode Safe state.
         * @member {Array.<string>} trackNames
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @instance
         */
        SetTrackDSPModeSafeStateRequestBody.prototype.trackNames = $util.emptyArray;

        /**
         * * The state to set (`true` for enabling the DSP Mode Safe, `false` for disabling the DSP Mode Safe).
         * @member {boolean} enabled
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @instance
         */
        SetTrackDSPModeSafeStateRequestBody.prototype.enabled = false;

        /**
         * Creates a new SetTrackDSPModeSafeStateRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {ptsl.ISetTrackDSPModeSafeStateRequestBody=} [properties] Properties to set
         * @returns {ptsl.SetTrackDSPModeSafeStateRequestBody} SetTrackDSPModeSafeStateRequestBody instance
         */
        SetTrackDSPModeSafeStateRequestBody.create = function create(properties) {
            return new SetTrackDSPModeSafeStateRequestBody(properties);
        };

        /**
         * Encodes the specified SetTrackDSPModeSafeStateRequestBody message. Does not implicitly {@link ptsl.SetTrackDSPModeSafeStateRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {ptsl.ISetTrackDSPModeSafeStateRequestBody} message SetTrackDSPModeSafeStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackDSPModeSafeStateRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackNames != null && message.trackNames.length)
                for (var i = 0; i < message.trackNames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNames[i]);
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
            return writer;
        };

        /**
         * Encodes the specified SetTrackDSPModeSafeStateRequestBody message, length delimited. Does not implicitly {@link ptsl.SetTrackDSPModeSafeStateRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {ptsl.ISetTrackDSPModeSafeStateRequestBody} message SetTrackDSPModeSafeStateRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetTrackDSPModeSafeStateRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetTrackDSPModeSafeStateRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SetTrackDSPModeSafeStateRequestBody} SetTrackDSPModeSafeStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackDSPModeSafeStateRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SetTrackDSPModeSafeStateRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.trackNames && message.trackNames.length))
                            message.trackNames = [];
                        message.trackNames.push(reader.string());
                        break;
                    }
                case 2: {
                        message.enabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetTrackDSPModeSafeStateRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SetTrackDSPModeSafeStateRequestBody} SetTrackDSPModeSafeStateRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetTrackDSPModeSafeStateRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetTrackDSPModeSafeStateRequestBody message.
         * @function verify
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetTrackDSPModeSafeStateRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackNames != null && message.hasOwnProperty("trackNames")) {
                if (!Array.isArray(message.trackNames))
                    return "trackNames: array expected";
                for (var i = 0; i < message.trackNames.length; ++i)
                    if (!$util.isString(message.trackNames[i]))
                        return "trackNames: string[] expected";
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };

        /**
         * Creates a SetTrackDSPModeSafeStateRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SetTrackDSPModeSafeStateRequestBody} SetTrackDSPModeSafeStateRequestBody
         */
        SetTrackDSPModeSafeStateRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SetTrackDSPModeSafeStateRequestBody)
                return object;
            var message = new $root.ptsl.SetTrackDSPModeSafeStateRequestBody();
            if (object.trackNames) {
                if (!Array.isArray(object.trackNames))
                    throw TypeError(".ptsl.SetTrackDSPModeSafeStateRequestBody.trackNames: array expected");
                message.trackNames = [];
                for (var i = 0; i < object.trackNames.length; ++i)
                    message.trackNames[i] = String(object.trackNames[i]);
            }
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };

        /**
         * Creates a plain object from a SetTrackDSPModeSafeStateRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {ptsl.SetTrackDSPModeSafeStateRequestBody} message SetTrackDSPModeSafeStateRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetTrackDSPModeSafeStateRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trackNames = [];
            if (options.defaults)
                object.enabled = false;
            if (message.trackNames && message.trackNames.length) {
                object.trackNames = [];
                for (var j = 0; j < message.trackNames.length; ++j)
                    object.trackNames[j] = message.trackNames[j];
            }
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };

        /**
         * Converts this SetTrackDSPModeSafeStateRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetTrackDSPModeSafeStateRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SetTrackDSPModeSafeStateRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SetTrackDSPModeSafeStateRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SetTrackDSPModeSafeStateRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SetTrackDSPModeSafeStateRequestBody";
        };

        return SetTrackDSPModeSafeStateRequestBody;
    })();

    ptsl.GetSessionSystemDelayInfoResponseBody = (function() {

        /**
         * Properties of a GetSessionSystemDelayInfoResponseBody.
         * @memberof ptsl
         * @interface IGetSessionSystemDelayInfoResponseBody
         * @property {number|null} [samples] * The System Delay value of the current session measured in samples.
         * @property {boolean|null} [delayCompensationEnabled] * Indicates whether the Delay Compensation is enabled (`true`) or disabled (`false`).
         */

        /**
         * Constructs a new GetSessionSystemDelayInfoResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetSessionSystemDelayInfo response data.
         * 
         * @since Pro Tools 2024.06
         * @implements IGetSessionSystemDelayInfoResponseBody
         * @constructor
         * @param {ptsl.IGetSessionSystemDelayInfoResponseBody=} [properties] Properties to set
         */
        function GetSessionSystemDelayInfoResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The System Delay value of the current session measured in samples.
         * @member {number} samples
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @instance
         */
        GetSessionSystemDelayInfoResponseBody.prototype.samples = 0;

        /**
         * * Indicates whether the Delay Compensation is enabled (`true`) or disabled (`false`).
         * @member {boolean} delayCompensationEnabled
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @instance
         */
        GetSessionSystemDelayInfoResponseBody.prototype.delayCompensationEnabled = false;

        /**
         * Creates a new GetSessionSystemDelayInfoResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {ptsl.IGetSessionSystemDelayInfoResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetSessionSystemDelayInfoResponseBody} GetSessionSystemDelayInfoResponseBody instance
         */
        GetSessionSystemDelayInfoResponseBody.create = function create(properties) {
            return new GetSessionSystemDelayInfoResponseBody(properties);
        };

        /**
         * Encodes the specified GetSessionSystemDelayInfoResponseBody message. Does not implicitly {@link ptsl.GetSessionSystemDelayInfoResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {ptsl.IGetSessionSystemDelayInfoResponseBody} message GetSessionSystemDelayInfoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionSystemDelayInfoResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.samples != null && Object.hasOwnProperty.call(message, "samples"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.samples);
            if (message.delayCompensationEnabled != null && Object.hasOwnProperty.call(message, "delayCompensationEnabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.delayCompensationEnabled);
            return writer;
        };

        /**
         * Encodes the specified GetSessionSystemDelayInfoResponseBody message, length delimited. Does not implicitly {@link ptsl.GetSessionSystemDelayInfoResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {ptsl.IGetSessionSystemDelayInfoResponseBody} message GetSessionSystemDelayInfoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSessionSystemDelayInfoResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSessionSystemDelayInfoResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetSessionSystemDelayInfoResponseBody} GetSessionSystemDelayInfoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionSystemDelayInfoResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetSessionSystemDelayInfoResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.samples = reader.int32();
                        break;
                    }
                case 2: {
                        message.delayCompensationEnabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSessionSystemDelayInfoResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetSessionSystemDelayInfoResponseBody} GetSessionSystemDelayInfoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSessionSystemDelayInfoResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSessionSystemDelayInfoResponseBody message.
         * @function verify
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSessionSystemDelayInfoResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.samples != null && message.hasOwnProperty("samples"))
                if (!$util.isInteger(message.samples))
                    return "samples: integer expected";
            if (message.delayCompensationEnabled != null && message.hasOwnProperty("delayCompensationEnabled"))
                if (typeof message.delayCompensationEnabled !== "boolean")
                    return "delayCompensationEnabled: boolean expected";
            return null;
        };

        /**
         * Creates a GetSessionSystemDelayInfoResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetSessionSystemDelayInfoResponseBody} GetSessionSystemDelayInfoResponseBody
         */
        GetSessionSystemDelayInfoResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetSessionSystemDelayInfoResponseBody)
                return object;
            var message = new $root.ptsl.GetSessionSystemDelayInfoResponseBody();
            if (object.samples != null)
                message.samples = object.samples | 0;
            if (object.delayCompensationEnabled != null)
                message.delayCompensationEnabled = Boolean(object.delayCompensationEnabled);
            return message;
        };

        /**
         * Creates a plain object from a GetSessionSystemDelayInfoResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {ptsl.GetSessionSystemDelayInfoResponseBody} message GetSessionSystemDelayInfoResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSessionSystemDelayInfoResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.samples = 0;
                object.delayCompensationEnabled = false;
            }
            if (message.samples != null && message.hasOwnProperty("samples"))
                object.samples = message.samples;
            if (message.delayCompensationEnabled != null && message.hasOwnProperty("delayCompensationEnabled"))
                object.delayCompensationEnabled = message.delayCompensationEnabled;
            return object;
        };

        /**
         * Converts this GetSessionSystemDelayInfoResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSessionSystemDelayInfoResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSessionSystemDelayInfoResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetSessionSystemDelayInfoResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSessionSystemDelayInfoResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetSessionSystemDelayInfoResponseBody";
        };

        return GetSessionSystemDelayInfoResponseBody;
    })();

    /**
     * Possible reasons why clip groups could not be created on specific tracks.
     * 
     * @since Pro Tools 2024.06
     * @name ptsl.TrackFromClipGroupExclusionReason
     * @enum {number}
     * @property {number} TCGEReason_Unknown=0 * Tech-only value returned when the reason is unknown.
     * @property {number} TCGEReason_TrackTypeIsNotAllowed=1 * Clip groups cannot be created on particular track types (e.g. Aux Input, VCA or Master).
     * @property {number} TCGEReason_TrackIsFrozen=2 * Clip groups cannot be created on frozen tracks.
     * @property {number} TCGEReason_TrackIsClosed=3 * Clip groups cannot be created on closed Folder tracks.
     * @property {number} TCGEReason_TrackIsLocked=4 * Clip groups cannot be created on locked Video tracks.
     * @property {number} TCGEReason_TrackIsInPlaylistView=5 * Clip groups cannot be created on tracks in playlists view.
     * @property {number} TCGEReason_TrackIsElasticAudioWithFades=6 * Clip groups with embedded fades are not supported on Elastic Audio-enabled tracks.
     */
    ptsl.TrackFromClipGroupExclusionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TCGEReason_Unknown"] = 0;
        values[valuesById[1] = "TCGEReason_TrackTypeIsNotAllowed"] = 1;
        values[valuesById[2] = "TCGEReason_TrackIsFrozen"] = 2;
        values[valuesById[3] = "TCGEReason_TrackIsClosed"] = 3;
        values[valuesById[4] = "TCGEReason_TrackIsLocked"] = 4;
        values[valuesById[5] = "TCGEReason_TrackIsInPlaylistView"] = 5;
        values[valuesById[6] = "TCGEReason_TrackIsElasticAudioWithFades"] = 6;
        return values;
    })();

    ptsl.TrackExcludedFromClipGroupInfo = (function() {

        /**
         * Properties of a TrackExcludedFromClipGroupInfo.
         * @memberof ptsl
         * @interface ITrackExcludedFromClipGroupInfo
         * @property {string|null} [trackName] * The name of the track.
         * @property {ptsl.TrackFromClipGroupExclusionReason|null} [reason] * The reason why the clip group could not be created on a particular track.
         */

        /**
         * Constructs a new TrackExcludedFromClipGroupInfo.
         * @memberof ptsl
         * @classdesc Structure that describes a track on which the clip group could not be created.
         * 
         * @since Pro Tools 2024.06
         * @implements ITrackExcludedFromClipGroupInfo
         * @constructor
         * @param {ptsl.ITrackExcludedFromClipGroupInfo=} [properties] Properties to set
         */
        function TrackExcludedFromClipGroupInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The name of the track.
         * @member {string} trackName
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @instance
         */
        TrackExcludedFromClipGroupInfo.prototype.trackName = "";

        /**
         * * The reason why the clip group could not be created on a particular track.
         * @member {ptsl.TrackFromClipGroupExclusionReason} reason
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @instance
         */
        TrackExcludedFromClipGroupInfo.prototype.reason = 0;

        /**
         * Creates a new TrackExcludedFromClipGroupInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {ptsl.ITrackExcludedFromClipGroupInfo=} [properties] Properties to set
         * @returns {ptsl.TrackExcludedFromClipGroupInfo} TrackExcludedFromClipGroupInfo instance
         */
        TrackExcludedFromClipGroupInfo.create = function create(properties) {
            return new TrackExcludedFromClipGroupInfo(properties);
        };

        /**
         * Encodes the specified TrackExcludedFromClipGroupInfo message. Does not implicitly {@link ptsl.TrackExcludedFromClipGroupInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {ptsl.ITrackExcludedFromClipGroupInfo} message TrackExcludedFromClipGroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackExcludedFromClipGroupInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackName);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified TrackExcludedFromClipGroupInfo message, length delimited. Does not implicitly {@link ptsl.TrackExcludedFromClipGroupInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {ptsl.ITrackExcludedFromClipGroupInfo} message TrackExcludedFromClipGroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrackExcludedFromClipGroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrackExcludedFromClipGroupInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.TrackExcludedFromClipGroupInfo} TrackExcludedFromClipGroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackExcludedFromClipGroupInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.TrackExcludedFromClipGroupInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.trackName = reader.string();
                        break;
                    }
                case 2: {
                        message.reason = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrackExcludedFromClipGroupInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.TrackExcludedFromClipGroupInfo} TrackExcludedFromClipGroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrackExcludedFromClipGroupInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrackExcludedFromClipGroupInfo message.
         * @function verify
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrackExcludedFromClipGroupInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                if (!$util.isString(message.trackName))
                    return "trackName: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates a TrackExcludedFromClipGroupInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.TrackExcludedFromClipGroupInfo} TrackExcludedFromClipGroupInfo
         */
        TrackExcludedFromClipGroupInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.TrackExcludedFromClipGroupInfo)
                return object;
            var message = new $root.ptsl.TrackExcludedFromClipGroupInfo();
            if (object.trackName != null)
                message.trackName = String(object.trackName);
            switch (object.reason) {
            default:
                if (typeof object.reason === "number") {
                    message.reason = object.reason;
                    break;
                }
                break;
            case "TCGEReason_Unknown":
            case 0:
                message.reason = 0;
                break;
            case "TCGEReason_TrackTypeIsNotAllowed":
            case 1:
                message.reason = 1;
                break;
            case "TCGEReason_TrackIsFrozen":
            case 2:
                message.reason = 2;
                break;
            case "TCGEReason_TrackIsClosed":
            case 3:
                message.reason = 3;
                break;
            case "TCGEReason_TrackIsLocked":
            case 4:
                message.reason = 4;
                break;
            case "TCGEReason_TrackIsInPlaylistView":
            case 5:
                message.reason = 5;
                break;
            case "TCGEReason_TrackIsElasticAudioWithFades":
            case 6:
                message.reason = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TrackExcludedFromClipGroupInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {ptsl.TrackExcludedFromClipGroupInfo} message TrackExcludedFromClipGroupInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrackExcludedFromClipGroupInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trackName = "";
                object.reason = options.enums === String ? "TCGEReason_Unknown" : 0;
            }
            if (message.trackName != null && message.hasOwnProperty("trackName"))
                object.trackName = message.trackName;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ptsl.TrackFromClipGroupExclusionReason[message.reason] === undefined ? message.reason : $root.ptsl.TrackFromClipGroupExclusionReason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this TrackExcludedFromClipGroupInfo to JSON.
         * @function toJSON
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrackExcludedFromClipGroupInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrackExcludedFromClipGroupInfo
         * @function getTypeUrl
         * @memberof ptsl.TrackExcludedFromClipGroupInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrackExcludedFromClipGroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.TrackExcludedFromClipGroupInfo";
        };

        return TrackExcludedFromClipGroupInfo;
    })();

    ptsl.RepeatSelectionRequestBody = (function() {

        /**
         * Properties of a RepeatSelectionRequestBody.
         * @memberof ptsl
         * @interface IRepeatSelectionRequestBody
         * @property {number|null} [numRepeats] * The number of repeats to repeat selection.
         */

        /**
         * Constructs a new RepeatSelectionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes RepeatSelection request data.
         * 
         * @since Pro Tools 2024.06
         * @implements IRepeatSelectionRequestBody
         * @constructor
         * @param {ptsl.IRepeatSelectionRequestBody=} [properties] Properties to set
         */
        function RepeatSelectionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The number of repeats to repeat selection.
         * @member {number} numRepeats
         * @memberof ptsl.RepeatSelectionRequestBody
         * @instance
         */
        RepeatSelectionRequestBody.prototype.numRepeats = 0;

        /**
         * Creates a new RepeatSelectionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {ptsl.IRepeatSelectionRequestBody=} [properties] Properties to set
         * @returns {ptsl.RepeatSelectionRequestBody} RepeatSelectionRequestBody instance
         */
        RepeatSelectionRequestBody.create = function create(properties) {
            return new RepeatSelectionRequestBody(properties);
        };

        /**
         * Encodes the specified RepeatSelectionRequestBody message. Does not implicitly {@link ptsl.RepeatSelectionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {ptsl.IRepeatSelectionRequestBody} message RepeatSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatSelectionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numRepeats != null && Object.hasOwnProperty.call(message, "numRepeats"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.numRepeats);
            return writer;
        };

        /**
         * Encodes the specified RepeatSelectionRequestBody message, length delimited. Does not implicitly {@link ptsl.RepeatSelectionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {ptsl.IRepeatSelectionRequestBody} message RepeatSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RepeatSelectionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RepeatSelectionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RepeatSelectionRequestBody} RepeatSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatSelectionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RepeatSelectionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.numRepeats = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RepeatSelectionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RepeatSelectionRequestBody} RepeatSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RepeatSelectionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RepeatSelectionRequestBody message.
         * @function verify
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RepeatSelectionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numRepeats != null && message.hasOwnProperty("numRepeats"))
                if (!$util.isInteger(message.numRepeats))
                    return "numRepeats: integer expected";
            return null;
        };

        /**
         * Creates a RepeatSelectionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RepeatSelectionRequestBody} RepeatSelectionRequestBody
         */
        RepeatSelectionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RepeatSelectionRequestBody)
                return object;
            var message = new $root.ptsl.RepeatSelectionRequestBody();
            if (object.numRepeats != null)
                message.numRepeats = object.numRepeats | 0;
            return message;
        };

        /**
         * Creates a plain object from a RepeatSelectionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {ptsl.RepeatSelectionRequestBody} message RepeatSelectionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RepeatSelectionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.numRepeats = 0;
            if (message.numRepeats != null && message.hasOwnProperty("numRepeats"))
                object.numRepeats = message.numRepeats;
            return object;
        };

        /**
         * Converts this RepeatSelectionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.RepeatSelectionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RepeatSelectionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RepeatSelectionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.RepeatSelectionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RepeatSelectionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RepeatSelectionRequestBody";
        };

        return RepeatSelectionRequestBody;
    })();

    /**
     * Types for global timeline times.
     * 
     * @since Pro Tools 2024.10
     * @name ptsl.TimelineLocationType
     * @enum {number}
     * @property {number} TLType_Unknown=0 TLType_Unknown value
     * @property {number} TLType_Samples=1 TLType_Samples value
     * @property {number} TLType_Ticks=2 TLType_Ticks value
     * @property {number} TLType_Frames=3 TLType_Frames value
     * @property {number} TLType_MinSecs=4 TLType_MinSecs value
     * @property {number} TLType_TimeCode=5 TLType_TimeCode value
     * @property {number} TLType_BarsBeats=6 TLType_BarsBeats value
     * @property {number} TLType_FeetFrames=7 TLType_FeetFrames value
     * @property {number} TLType_Seconds=8 TLType_Seconds value
     */
    ptsl.TimelineLocationType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TLType_Unknown"] = 0;
        values[valuesById[1] = "TLType_Samples"] = 1;
        values[valuesById[2] = "TLType_Ticks"] = 2;
        values[valuesById[3] = "TLType_Frames"] = 3;
        values[valuesById[4] = "TLType_MinSecs"] = 4;
        values[valuesById[5] = "TLType_TimeCode"] = 5;
        values[valuesById[6] = "TLType_BarsBeats"] = 6;
        values[valuesById[7] = "TLType_FeetFrames"] = 7;
        values[valuesById[8] = "TLType_Seconds"] = 8;
        return values;
    })();

    /**
     * One of the fundamental time units.
     * 
     * @since Pro Tools 2024.10
     * @name ptsl.BasicTimeType
     * @enum {number}
     * @property {number} BTType_Unknown=0 BTType_Unknown value
     * @property {number} BTType_Samples=1 BTType_Samples value
     * @property {number} BTType_Ticks=2 BTType_Ticks value
     * @property {number} BTType_Frames=3 BTType_Frames value
     */
    ptsl.BasicTimeType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BTType_Unknown"] = 0;
        values[valuesById[1] = "BTType_Samples"] = 1;
        values[valuesById[2] = "BTType_Ticks"] = 2;
        values[valuesById[3] = "BTType_Frames"] = 3;
        return values;
    })();

    ptsl.TimelineLocation = (function() {

        /**
         * Properties of a TimelineLocation.
         * @memberof ptsl
         * @interface ITimelineLocation
         * @property {string|null} [location] * Location string, as appropriate for the unit.
         * @property {ptsl.TimelineLocationType|null} [timeType] * Type of the location time.
         */

        /**
         * Constructs a new TimelineLocation.
         * @memberof ptsl
         * @classdesc Structure that represents a time in the Pro Tools timeline;
         * can be expressed in a variety of units.
         * 
         * @since Pro Tools 2024.10
         * @implements ITimelineLocation
         * @constructor
         * @param {ptsl.ITimelineLocation=} [properties] Properties to set
         */
        function TimelineLocation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Location string, as appropriate for the unit.
         * @member {string} location
         * @memberof ptsl.TimelineLocation
         * @instance
         */
        TimelineLocation.prototype.location = "";

        /**
         * * Type of the location time.
         * @member {ptsl.TimelineLocationType} timeType
         * @memberof ptsl.TimelineLocation
         * @instance
         */
        TimelineLocation.prototype.timeType = 0;

        /**
         * Creates a new TimelineLocation instance using the specified properties.
         * @function create
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {ptsl.ITimelineLocation=} [properties] Properties to set
         * @returns {ptsl.TimelineLocation} TimelineLocation instance
         */
        TimelineLocation.create = function create(properties) {
            return new TimelineLocation(properties);
        };

        /**
         * Encodes the specified TimelineLocation message. Does not implicitly {@link ptsl.TimelineLocation.verify|verify} messages.
         * @function encode
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {ptsl.ITimelineLocation} message TimelineLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimelineLocation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.location);
            if (message.timeType != null && Object.hasOwnProperty.call(message, "timeType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeType);
            return writer;
        };

        /**
         * Encodes the specified TimelineLocation message, length delimited. Does not implicitly {@link ptsl.TimelineLocation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {ptsl.ITimelineLocation} message TimelineLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimelineLocation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimelineLocation message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.TimelineLocation} TimelineLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimelineLocation.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.TimelineLocation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.location = reader.string();
                        break;
                    }
                case 2: {
                        message.timeType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TimelineLocation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.TimelineLocation} TimelineLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimelineLocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimelineLocation message.
         * @function verify
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimelineLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                switch (message.timeType) {
                default:
                    return "timeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a TimelineLocation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.TimelineLocation} TimelineLocation
         */
        TimelineLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.TimelineLocation)
                return object;
            var message = new $root.ptsl.TimelineLocation();
            if (object.location != null)
                message.location = String(object.location);
            switch (object.timeType) {
            default:
                if (typeof object.timeType === "number") {
                    message.timeType = object.timeType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.timeType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.timeType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.timeType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.timeType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.timeType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.timeType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.timeType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.timeType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.timeType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TimelineLocation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {ptsl.TimelineLocation} message TimelineLocation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimelineLocation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.location = "";
                object.timeType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                object.timeType = options.enums === String ? $root.ptsl.TimelineLocationType[message.timeType] === undefined ? message.timeType : $root.ptsl.TimelineLocationType[message.timeType] : message.timeType;
            return object;
        };

        /**
         * Converts this TimelineLocation to JSON.
         * @function toJSON
         * @memberof ptsl.TimelineLocation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimelineLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TimelineLocation
         * @function getTypeUrl
         * @memberof ptsl.TimelineLocation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TimelineLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.TimelineLocation";
        };

        return TimelineLocation;
    })();

    ptsl.MediaTimePosition = (function() {

        /**
         * Properties of a MediaTimePosition.
         * @memberof ptsl
         * @interface IMediaTimePosition
         * @property {number|Long|null} [position] * Position, as appropriate for the unit.
         * @property {ptsl.BasicTimeType|null} [timeType] * Type of the position time.
         */

        /**
         * Constructs a new MediaTimePosition.
         * @memberof ptsl
         * @classdesc Structure that represents an internal position within a piece of media.
         * Not relative to the global timeline. Can only be expressed in fundamental units, depending on media type.
         * 
         * @since Pro Tools 2024.10
         * @implements IMediaTimePosition
         * @constructor
         * @param {ptsl.IMediaTimePosition=} [properties] Properties to set
         */
        function MediaTimePosition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Position, as appropriate for the unit.
         * @member {number|Long} position
         * @memberof ptsl.MediaTimePosition
         * @instance
         */
        MediaTimePosition.prototype.position = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * * Type of the position time.
         * @member {ptsl.BasicTimeType} timeType
         * @memberof ptsl.MediaTimePosition
         * @instance
         */
        MediaTimePosition.prototype.timeType = 0;

        /**
         * Creates a new MediaTimePosition instance using the specified properties.
         * @function create
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {ptsl.IMediaTimePosition=} [properties] Properties to set
         * @returns {ptsl.MediaTimePosition} MediaTimePosition instance
         */
        MediaTimePosition.create = function create(properties) {
            return new MediaTimePosition(properties);
        };

        /**
         * Encodes the specified MediaTimePosition message. Does not implicitly {@link ptsl.MediaTimePosition.verify|verify} messages.
         * @function encode
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {ptsl.IMediaTimePosition} message MediaTimePosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaTimePosition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.position);
            if (message.timeType != null && Object.hasOwnProperty.call(message, "timeType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeType);
            return writer;
        };

        /**
         * Encodes the specified MediaTimePosition message, length delimited. Does not implicitly {@link ptsl.MediaTimePosition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {ptsl.IMediaTimePosition} message MediaTimePosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaTimePosition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaTimePosition message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.MediaTimePosition} MediaTimePosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaTimePosition.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.MediaTimePosition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.position = reader.int64();
                        break;
                    }
                case 2: {
                        message.timeType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaTimePosition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.MediaTimePosition} MediaTimePosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaTimePosition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaTimePosition message.
         * @function verify
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaTimePosition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isInteger(message.position) && !(message.position && $util.isInteger(message.position.low) && $util.isInteger(message.position.high)))
                    return "position: integer|Long expected";
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                switch (message.timeType) {
                default:
                    return "timeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a MediaTimePosition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.MediaTimePosition} MediaTimePosition
         */
        MediaTimePosition.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.MediaTimePosition)
                return object;
            var message = new $root.ptsl.MediaTimePosition();
            if (object.position != null)
                if ($util.Long)
                    (message.position = $util.Long.fromValue(object.position)).unsigned = false;
                else if (typeof object.position === "string")
                    message.position = parseInt(object.position, 10);
                else if (typeof object.position === "number")
                    message.position = object.position;
                else if (typeof object.position === "object")
                    message.position = new $util.LongBits(object.position.low >>> 0, object.position.high >>> 0).toNumber();
            switch (object.timeType) {
            default:
                if (typeof object.timeType === "number") {
                    message.timeType = object.timeType;
                    break;
                }
                break;
            case "BTType_Unknown":
            case 0:
                message.timeType = 0;
                break;
            case "BTType_Samples":
            case 1:
                message.timeType = 1;
                break;
            case "BTType_Ticks":
            case 2:
                message.timeType = 2;
                break;
            case "BTType_Frames":
            case 3:
                message.timeType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MediaTimePosition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {ptsl.MediaTimePosition} message MediaTimePosition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaTimePosition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.position = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.position = options.longs === String ? "0" : 0;
                object.timeType = options.enums === String ? "BTType_Unknown" : 0;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                if (typeof message.position === "number")
                    object.position = options.longs === String ? String(message.position) : message.position;
                else
                    object.position = options.longs === String ? $util.Long.prototype.toString.call(message.position) : options.longs === Number ? new $util.LongBits(message.position.low >>> 0, message.position.high >>> 0).toNumber() : message.position;
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                object.timeType = options.enums === String ? $root.ptsl.BasicTimeType[message.timeType] === undefined ? message.timeType : $root.ptsl.BasicTimeType[message.timeType] : message.timeType;
            return object;
        };

        /**
         * Converts this MediaTimePosition to JSON.
         * @function toJSON
         * @memberof ptsl.MediaTimePosition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaTimePosition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MediaTimePosition
         * @function getTypeUrl
         * @memberof ptsl.MediaTimePosition
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MediaTimePosition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.MediaTimePosition";
        };

        return MediaTimePosition;
    })();

    ptsl.TimeLength = (function() {

        /**
         * Properties of a TimeLength.
         * @memberof ptsl
         * @interface ITimeLength
         * @property {number|Long|null} [length] * Length, as appropriate for the unit. Can be positive or negative.
         * @property {ptsl.BasicTimeType|null} [timeType] * Type of the location time.
         */

        /**
         * Constructs a new TimeLength.
         * @memberof ptsl
         * @classdesc Structure that represents a typed relative time position - can apply to both media and timeline times.
         * Not relative to the global timeline. Can only be expressed in fundamental units, depending on media type.
         * 
         * @since Pro Tools 2024.10
         * @implements ITimeLength
         * @constructor
         * @param {ptsl.ITimeLength=} [properties] Properties to set
         */
        function TimeLength(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Length, as appropriate for the unit. Can be positive or negative.
         * @member {number|Long} length
         * @memberof ptsl.TimeLength
         * @instance
         */
        TimeLength.prototype.length = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * * Type of the location time.
         * @member {ptsl.BasicTimeType} timeType
         * @memberof ptsl.TimeLength
         * @instance
         */
        TimeLength.prototype.timeType = 0;

        /**
         * Creates a new TimeLength instance using the specified properties.
         * @function create
         * @memberof ptsl.TimeLength
         * @static
         * @param {ptsl.ITimeLength=} [properties] Properties to set
         * @returns {ptsl.TimeLength} TimeLength instance
         */
        TimeLength.create = function create(properties) {
            return new TimeLength(properties);
        };

        /**
         * Encodes the specified TimeLength message. Does not implicitly {@link ptsl.TimeLength.verify|verify} messages.
         * @function encode
         * @memberof ptsl.TimeLength
         * @static
         * @param {ptsl.ITimeLength} message TimeLength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeLength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.length);
            if (message.timeType != null && Object.hasOwnProperty.call(message, "timeType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeType);
            return writer;
        };

        /**
         * Encodes the specified TimeLength message, length delimited. Does not implicitly {@link ptsl.TimeLength.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.TimeLength
         * @static
         * @param {ptsl.ITimeLength} message TimeLength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeLength.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimeLength message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.TimeLength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.TimeLength} TimeLength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeLength.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.TimeLength();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.length = reader.int64();
                        break;
                    }
                case 2: {
                        message.timeType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TimeLength message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.TimeLength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.TimeLength} TimeLength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeLength.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimeLength message.
         * @function verify
         * @memberof ptsl.TimeLength
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimeLength.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length"))
                if (!$util.isInteger(message.length) && !(message.length && $util.isInteger(message.length.low) && $util.isInteger(message.length.high)))
                    return "length: integer|Long expected";
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                switch (message.timeType) {
                default:
                    return "timeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a TimeLength message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.TimeLength
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.TimeLength} TimeLength
         */
        TimeLength.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.TimeLength)
                return object;
            var message = new $root.ptsl.TimeLength();
            if (object.length != null)
                if ($util.Long)
                    (message.length = $util.Long.fromValue(object.length)).unsigned = false;
                else if (typeof object.length === "string")
                    message.length = parseInt(object.length, 10);
                else if (typeof object.length === "number")
                    message.length = object.length;
                else if (typeof object.length === "object")
                    message.length = new $util.LongBits(object.length.low >>> 0, object.length.high >>> 0).toNumber();
            switch (object.timeType) {
            default:
                if (typeof object.timeType === "number") {
                    message.timeType = object.timeType;
                    break;
                }
                break;
            case "BTType_Unknown":
            case 0:
                message.timeType = 0;
                break;
            case "BTType_Samples":
            case 1:
                message.timeType = 1;
                break;
            case "BTType_Ticks":
            case 2:
                message.timeType = 2;
                break;
            case "BTType_Frames":
            case 3:
                message.timeType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TimeLength message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.TimeLength
         * @static
         * @param {ptsl.TimeLength} message TimeLength
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimeLength.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.length = options.longs === String ? "0" : 0;
                object.timeType = options.enums === String ? "BTType_Unknown" : 0;
            }
            if (message.length != null && message.hasOwnProperty("length"))
                if (typeof message.length === "number")
                    object.length = options.longs === String ? String(message.length) : message.length;
                else
                    object.length = options.longs === String ? $util.Long.prototype.toString.call(message.length) : options.longs === Number ? new $util.LongBits(message.length.low >>> 0, message.length.high >>> 0).toNumber() : message.length;
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                object.timeType = options.enums === String ? $root.ptsl.BasicTimeType[message.timeType] === undefined ? message.timeType : $root.ptsl.BasicTimeType[message.timeType] : message.timeType;
            return object;
        };

        /**
         * Converts this TimeLength to JSON.
         * @function toJSON
         * @memberof ptsl.TimeLength
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimeLength.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TimeLength
         * @function getTypeUrl
         * @memberof ptsl.TimeLength
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TimeLength.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.TimeLength";
        };

        return TimeLength;
    })();

    ptsl.ClearAllMemoryLocationsResponseBody = (function() {

        /**
         * Properties of a ClearAllMemoryLocationsResponseBody.
         * @memberof ptsl
         * @interface IClearAllMemoryLocationsResponseBody
         * @property {number|null} [successCount] * The number of successfully cleared memory locations.
         * @property {number|null} [failureCount] * The number of memory locations which were not cleared.
         * @property {Array.<number>|null} [failureList] * The list of memory locations which were not cleared.
         */

        /**
         * Constructs a new ClearAllMemoryLocationsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes ClearAllMemoryLocations response data.
         * 
         * @since Pro Tools 2024.10
         * @implements IClearAllMemoryLocationsResponseBody
         * @constructor
         * @param {ptsl.IClearAllMemoryLocationsResponseBody=} [properties] Properties to set
         */
        function ClearAllMemoryLocationsResponseBody(properties) {
            this.failureList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The number of successfully cleared memory locations.
         * @member {number} successCount
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @instance
         */
        ClearAllMemoryLocationsResponseBody.prototype.successCount = 0;

        /**
         * * The number of memory locations which were not cleared.
         * @member {number} failureCount
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @instance
         */
        ClearAllMemoryLocationsResponseBody.prototype.failureCount = 0;

        /**
         * * The list of memory locations which were not cleared.
         * @member {Array.<number>} failureList
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @instance
         */
        ClearAllMemoryLocationsResponseBody.prototype.failureList = $util.emptyArray;

        /**
         * Creates a new ClearAllMemoryLocationsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {ptsl.IClearAllMemoryLocationsResponseBody=} [properties] Properties to set
         * @returns {ptsl.ClearAllMemoryLocationsResponseBody} ClearAllMemoryLocationsResponseBody instance
         */
        ClearAllMemoryLocationsResponseBody.create = function create(properties) {
            return new ClearAllMemoryLocationsResponseBody(properties);
        };

        /**
         * Encodes the specified ClearAllMemoryLocationsResponseBody message. Does not implicitly {@link ptsl.ClearAllMemoryLocationsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {ptsl.IClearAllMemoryLocationsResponseBody} message ClearAllMemoryLocationsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearAllMemoryLocationsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.successCount != null && Object.hasOwnProperty.call(message, "successCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.successCount);
            if (message.failureCount != null && Object.hasOwnProperty.call(message, "failureCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.failureCount);
            if (message.failureList != null && message.failureList.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.failureList.length; ++i)
                    writer.int32(message.failureList[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ClearAllMemoryLocationsResponseBody message, length delimited. Does not implicitly {@link ptsl.ClearAllMemoryLocationsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {ptsl.IClearAllMemoryLocationsResponseBody} message ClearAllMemoryLocationsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearAllMemoryLocationsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClearAllMemoryLocationsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ClearAllMemoryLocationsResponseBody} ClearAllMemoryLocationsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearAllMemoryLocationsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ClearAllMemoryLocationsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.successCount = reader.int32();
                        break;
                    }
                case 2: {
                        message.failureCount = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.failureList && message.failureList.length))
                            message.failureList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.failureList.push(reader.int32());
                        } else
                            message.failureList.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClearAllMemoryLocationsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ClearAllMemoryLocationsResponseBody} ClearAllMemoryLocationsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearAllMemoryLocationsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClearAllMemoryLocationsResponseBody message.
         * @function verify
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearAllMemoryLocationsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.successCount != null && message.hasOwnProperty("successCount"))
                if (!$util.isInteger(message.successCount))
                    return "successCount: integer expected";
            if (message.failureCount != null && message.hasOwnProperty("failureCount"))
                if (!$util.isInteger(message.failureCount))
                    return "failureCount: integer expected";
            if (message.failureList != null && message.hasOwnProperty("failureList")) {
                if (!Array.isArray(message.failureList))
                    return "failureList: array expected";
                for (var i = 0; i < message.failureList.length; ++i)
                    if (!$util.isInteger(message.failureList[i]))
                        return "failureList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a ClearAllMemoryLocationsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ClearAllMemoryLocationsResponseBody} ClearAllMemoryLocationsResponseBody
         */
        ClearAllMemoryLocationsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ClearAllMemoryLocationsResponseBody)
                return object;
            var message = new $root.ptsl.ClearAllMemoryLocationsResponseBody();
            if (object.successCount != null)
                message.successCount = object.successCount | 0;
            if (object.failureCount != null)
                message.failureCount = object.failureCount | 0;
            if (object.failureList) {
                if (!Array.isArray(object.failureList))
                    throw TypeError(".ptsl.ClearAllMemoryLocationsResponseBody.failureList: array expected");
                message.failureList = [];
                for (var i = 0; i < object.failureList.length; ++i)
                    message.failureList[i] = object.failureList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClearAllMemoryLocationsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {ptsl.ClearAllMemoryLocationsResponseBody} message ClearAllMemoryLocationsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearAllMemoryLocationsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.failureList = [];
            if (options.defaults) {
                object.successCount = 0;
                object.failureCount = 0;
            }
            if (message.successCount != null && message.hasOwnProperty("successCount"))
                object.successCount = message.successCount;
            if (message.failureCount != null && message.hasOwnProperty("failureCount"))
                object.failureCount = message.failureCount;
            if (message.failureList && message.failureList.length) {
                object.failureList = [];
                for (var j = 0; j < message.failureList.length; ++j)
                    object.failureList[j] = message.failureList[j];
            }
            return object;
        };

        /**
         * Converts this ClearAllMemoryLocationsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearAllMemoryLocationsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClearAllMemoryLocationsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ClearAllMemoryLocationsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClearAllMemoryLocationsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ClearAllMemoryLocationsResponseBody";
        };

        return ClearAllMemoryLocationsResponseBody;
    })();

    ptsl.GetTimeAsTypeRequestBody = (function() {

        /**
         * Properties of a GetTimeAsTypeRequestBody.
         * @memberof ptsl
         * @interface IGetTimeAsTypeRequestBody
         * @property {ptsl.ITimelineLocation|null} [location] * The timeline location to convert
         * @property {ptsl.TimelineLocationType|null} [timeType] * Desired timeline location type to convert to
         */

        /**
         * Constructs a new GetTimeAsTypeRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTimeAsType request data.
         * 
         * @since Pro Tools 2025.06
         * @implements IGetTimeAsTypeRequestBody
         * @constructor
         * @param {ptsl.IGetTimeAsTypeRequestBody=} [properties] Properties to set
         */
        function GetTimeAsTypeRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The timeline location to convert
         * @member {ptsl.ITimelineLocation|null|undefined} location
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @instance
         */
        GetTimeAsTypeRequestBody.prototype.location = null;

        /**
         * * Desired timeline location type to convert to
         * @member {ptsl.TimelineLocationType} timeType
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @instance
         */
        GetTimeAsTypeRequestBody.prototype.timeType = 0;

        /**
         * Creates a new GetTimeAsTypeRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {ptsl.IGetTimeAsTypeRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetTimeAsTypeRequestBody} GetTimeAsTypeRequestBody instance
         */
        GetTimeAsTypeRequestBody.create = function create(properties) {
            return new GetTimeAsTypeRequestBody(properties);
        };

        /**
         * Encodes the specified GetTimeAsTypeRequestBody message. Does not implicitly {@link ptsl.GetTimeAsTypeRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {ptsl.IGetTimeAsTypeRequestBody} message GetTimeAsTypeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimeAsTypeRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                $root.ptsl.TimelineLocation.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.timeType != null && Object.hasOwnProperty.call(message, "timeType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeType);
            return writer;
        };

        /**
         * Encodes the specified GetTimeAsTypeRequestBody message, length delimited. Does not implicitly {@link ptsl.GetTimeAsTypeRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {ptsl.IGetTimeAsTypeRequestBody} message GetTimeAsTypeRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimeAsTypeRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTimeAsTypeRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTimeAsTypeRequestBody} GetTimeAsTypeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimeAsTypeRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTimeAsTypeRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.location = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.timeType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTimeAsTypeRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTimeAsTypeRequestBody} GetTimeAsTypeRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimeAsTypeRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTimeAsTypeRequestBody message.
         * @function verify
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTimeAsTypeRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.location != null && message.hasOwnProperty("location")) {
                var error = $root.ptsl.TimelineLocation.verify(message.location);
                if (error)
                    return "location." + error;
            }
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                switch (message.timeType) {
                default:
                    return "timeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetTimeAsTypeRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTimeAsTypeRequestBody} GetTimeAsTypeRequestBody
         */
        GetTimeAsTypeRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTimeAsTypeRequestBody)
                return object;
            var message = new $root.ptsl.GetTimeAsTypeRequestBody();
            if (object.location != null) {
                if (typeof object.location !== "object")
                    throw TypeError(".ptsl.GetTimeAsTypeRequestBody.location: object expected");
                message.location = $root.ptsl.TimelineLocation.fromObject(object.location);
            }
            switch (object.timeType) {
            default:
                if (typeof object.timeType === "number") {
                    message.timeType = object.timeType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.timeType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.timeType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.timeType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.timeType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.timeType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.timeType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.timeType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.timeType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.timeType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTimeAsTypeRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {ptsl.GetTimeAsTypeRequestBody} message GetTimeAsTypeRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTimeAsTypeRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.location = null;
                object.timeType = options.enums === String ? "TLType_Unknown" : 0;
            }
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = $root.ptsl.TimelineLocation.toObject(message.location, options);
            if (message.timeType != null && message.hasOwnProperty("timeType"))
                object.timeType = options.enums === String ? $root.ptsl.TimelineLocationType[message.timeType] === undefined ? message.timeType : $root.ptsl.TimelineLocationType[message.timeType] : message.timeType;
            return object;
        };

        /**
         * Converts this GetTimeAsTypeRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTimeAsTypeRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTimeAsTypeRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetTimeAsTypeRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTimeAsTypeRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTimeAsTypeRequestBody";
        };

        return GetTimeAsTypeRequestBody;
    })();

    ptsl.GetTimeAsTypeResponseBody = (function() {

        /**
         * Properties of a GetTimeAsTypeResponseBody.
         * @memberof ptsl
         * @interface IGetTimeAsTypeResponseBody
         * @property {ptsl.ITimelineLocation|null} [convertedLocation] * The converted timeline location
         */

        /**
         * Constructs a new GetTimeAsTypeResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetTimeAsType response data.
         * 
         * @since Pro Tools 2025.06
         * @implements IGetTimeAsTypeResponseBody
         * @constructor
         * @param {ptsl.IGetTimeAsTypeResponseBody=} [properties] Properties to set
         */
        function GetTimeAsTypeResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The converted timeline location
         * @member {ptsl.ITimelineLocation|null|undefined} convertedLocation
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @instance
         */
        GetTimeAsTypeResponseBody.prototype.convertedLocation = null;

        /**
         * Creates a new GetTimeAsTypeResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {ptsl.IGetTimeAsTypeResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetTimeAsTypeResponseBody} GetTimeAsTypeResponseBody instance
         */
        GetTimeAsTypeResponseBody.create = function create(properties) {
            return new GetTimeAsTypeResponseBody(properties);
        };

        /**
         * Encodes the specified GetTimeAsTypeResponseBody message. Does not implicitly {@link ptsl.GetTimeAsTypeResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {ptsl.IGetTimeAsTypeResponseBody} message GetTimeAsTypeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimeAsTypeResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convertedLocation != null && Object.hasOwnProperty.call(message, "convertedLocation"))
                $root.ptsl.TimelineLocation.encode(message.convertedLocation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTimeAsTypeResponseBody message, length delimited. Does not implicitly {@link ptsl.GetTimeAsTypeResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {ptsl.IGetTimeAsTypeResponseBody} message GetTimeAsTypeResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTimeAsTypeResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTimeAsTypeResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetTimeAsTypeResponseBody} GetTimeAsTypeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimeAsTypeResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetTimeAsTypeResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.convertedLocation = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTimeAsTypeResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetTimeAsTypeResponseBody} GetTimeAsTypeResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTimeAsTypeResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTimeAsTypeResponseBody message.
         * @function verify
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTimeAsTypeResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convertedLocation != null && message.hasOwnProperty("convertedLocation")) {
                var error = $root.ptsl.TimelineLocation.verify(message.convertedLocation);
                if (error)
                    return "convertedLocation." + error;
            }
            return null;
        };

        /**
         * Creates a GetTimeAsTypeResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetTimeAsTypeResponseBody} GetTimeAsTypeResponseBody
         */
        GetTimeAsTypeResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetTimeAsTypeResponseBody)
                return object;
            var message = new $root.ptsl.GetTimeAsTypeResponseBody();
            if (object.convertedLocation != null) {
                if (typeof object.convertedLocation !== "object")
                    throw TypeError(".ptsl.GetTimeAsTypeResponseBody.convertedLocation: object expected");
                message.convertedLocation = $root.ptsl.TimelineLocation.fromObject(object.convertedLocation);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTimeAsTypeResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {ptsl.GetTimeAsTypeResponseBody} message GetTimeAsTypeResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTimeAsTypeResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convertedLocation = null;
            if (message.convertedLocation != null && message.hasOwnProperty("convertedLocation"))
                object.convertedLocation = $root.ptsl.TimelineLocation.toObject(message.convertedLocation, options);
            return object;
        };

        /**
         * Converts this GetTimeAsTypeResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTimeAsTypeResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTimeAsTypeResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetTimeAsTypeResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTimeAsTypeResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetTimeAsTypeResponseBody";
        };

        return GetTimeAsTypeResponseBody;
    })();

    ptsl.SubtractLocationsRequestBody = (function() {

        /**
         * Properties of a SubtractLocationsRequestBody.
         * @memberof ptsl
         * @interface ISubtractLocationsRequestBody
         * @property {ptsl.ITimelineLocation|null} [firstLocation] * First subtraction operand
         * @property {ptsl.ITimelineLocation|null} [secondLocation] * Second subtraction operand
         * @property {ptsl.BasicTimeType|null} [desiredLengthType] * BasicTimeType unit used for operation result
         */

        /**
         * Constructs a new SubtractLocationsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SubtractLocations request data.
         * 
         * @since Pro Tools 2025.06
         * @implements ISubtractLocationsRequestBody
         * @constructor
         * @param {ptsl.ISubtractLocationsRequestBody=} [properties] Properties to set
         */
        function SubtractLocationsRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * First subtraction operand
         * @member {ptsl.ITimelineLocation|null|undefined} firstLocation
         * @memberof ptsl.SubtractLocationsRequestBody
         * @instance
         */
        SubtractLocationsRequestBody.prototype.firstLocation = null;

        /**
         * * Second subtraction operand
         * @member {ptsl.ITimelineLocation|null|undefined} secondLocation
         * @memberof ptsl.SubtractLocationsRequestBody
         * @instance
         */
        SubtractLocationsRequestBody.prototype.secondLocation = null;

        /**
         * * BasicTimeType unit used for operation result
         * @member {ptsl.BasicTimeType} desiredLengthType
         * @memberof ptsl.SubtractLocationsRequestBody
         * @instance
         */
        SubtractLocationsRequestBody.prototype.desiredLengthType = 0;

        /**
         * Creates a new SubtractLocationsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {ptsl.ISubtractLocationsRequestBody=} [properties] Properties to set
         * @returns {ptsl.SubtractLocationsRequestBody} SubtractLocationsRequestBody instance
         */
        SubtractLocationsRequestBody.create = function create(properties) {
            return new SubtractLocationsRequestBody(properties);
        };

        /**
         * Encodes the specified SubtractLocationsRequestBody message. Does not implicitly {@link ptsl.SubtractLocationsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {ptsl.ISubtractLocationsRequestBody} message SubtractLocationsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractLocationsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.firstLocation != null && Object.hasOwnProperty.call(message, "firstLocation"))
                $root.ptsl.TimelineLocation.encode(message.firstLocation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.secondLocation != null && Object.hasOwnProperty.call(message, "secondLocation"))
                $root.ptsl.TimelineLocation.encode(message.secondLocation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.desiredLengthType != null && Object.hasOwnProperty.call(message, "desiredLengthType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.desiredLengthType);
            return writer;
        };

        /**
         * Encodes the specified SubtractLocationsRequestBody message, length delimited. Does not implicitly {@link ptsl.SubtractLocationsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {ptsl.ISubtractLocationsRequestBody} message SubtractLocationsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractLocationsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubtractLocationsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SubtractLocationsRequestBody} SubtractLocationsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractLocationsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SubtractLocationsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.firstLocation = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.secondLocation = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.desiredLengthType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubtractLocationsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SubtractLocationsRequestBody} SubtractLocationsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractLocationsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubtractLocationsRequestBody message.
         * @function verify
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubtractLocationsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.firstLocation != null && message.hasOwnProperty("firstLocation")) {
                var error = $root.ptsl.TimelineLocation.verify(message.firstLocation);
                if (error)
                    return "firstLocation." + error;
            }
            if (message.secondLocation != null && message.hasOwnProperty("secondLocation")) {
                var error = $root.ptsl.TimelineLocation.verify(message.secondLocation);
                if (error)
                    return "secondLocation." + error;
            }
            if (message.desiredLengthType != null && message.hasOwnProperty("desiredLengthType"))
                switch (message.desiredLengthType) {
                default:
                    return "desiredLengthType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a SubtractLocationsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SubtractLocationsRequestBody} SubtractLocationsRequestBody
         */
        SubtractLocationsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SubtractLocationsRequestBody)
                return object;
            var message = new $root.ptsl.SubtractLocationsRequestBody();
            if (object.firstLocation != null) {
                if (typeof object.firstLocation !== "object")
                    throw TypeError(".ptsl.SubtractLocationsRequestBody.firstLocation: object expected");
                message.firstLocation = $root.ptsl.TimelineLocation.fromObject(object.firstLocation);
            }
            if (object.secondLocation != null) {
                if (typeof object.secondLocation !== "object")
                    throw TypeError(".ptsl.SubtractLocationsRequestBody.secondLocation: object expected");
                message.secondLocation = $root.ptsl.TimelineLocation.fromObject(object.secondLocation);
            }
            switch (object.desiredLengthType) {
            default:
                if (typeof object.desiredLengthType === "number") {
                    message.desiredLengthType = object.desiredLengthType;
                    break;
                }
                break;
            case "BTType_Unknown":
            case 0:
                message.desiredLengthType = 0;
                break;
            case "BTType_Samples":
            case 1:
                message.desiredLengthType = 1;
                break;
            case "BTType_Ticks":
            case 2:
                message.desiredLengthType = 2;
                break;
            case "BTType_Frames":
            case 3:
                message.desiredLengthType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SubtractLocationsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {ptsl.SubtractLocationsRequestBody} message SubtractLocationsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubtractLocationsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.firstLocation = null;
                object.secondLocation = null;
                object.desiredLengthType = options.enums === String ? "BTType_Unknown" : 0;
            }
            if (message.firstLocation != null && message.hasOwnProperty("firstLocation"))
                object.firstLocation = $root.ptsl.TimelineLocation.toObject(message.firstLocation, options);
            if (message.secondLocation != null && message.hasOwnProperty("secondLocation"))
                object.secondLocation = $root.ptsl.TimelineLocation.toObject(message.secondLocation, options);
            if (message.desiredLengthType != null && message.hasOwnProperty("desiredLengthType"))
                object.desiredLengthType = options.enums === String ? $root.ptsl.BasicTimeType[message.desiredLengthType] === undefined ? message.desiredLengthType : $root.ptsl.BasicTimeType[message.desiredLengthType] : message.desiredLengthType;
            return object;
        };

        /**
         * Converts this SubtractLocationsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SubtractLocationsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubtractLocationsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubtractLocationsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SubtractLocationsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubtractLocationsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SubtractLocationsRequestBody";
        };

        return SubtractLocationsRequestBody;
    })();

    ptsl.SubtractLocationsResponseBody = (function() {

        /**
         * Properties of a SubtractLocationsResponseBody.
         * @memberof ptsl
         * @interface ISubtractLocationsResponseBody
         * @property {ptsl.ITimeLength|null} [length] * Resulting length
         */

        /**
         * Constructs a new SubtractLocationsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes SubtractLocations response data.
         * 
         * @since Pro Tools 2025.06
         * @implements ISubtractLocationsResponseBody
         * @constructor
         * @param {ptsl.ISubtractLocationsResponseBody=} [properties] Properties to set
         */
        function SubtractLocationsResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Resulting length
         * @member {ptsl.ITimeLength|null|undefined} length
         * @memberof ptsl.SubtractLocationsResponseBody
         * @instance
         */
        SubtractLocationsResponseBody.prototype.length = null;

        /**
         * Creates a new SubtractLocationsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {ptsl.ISubtractLocationsResponseBody=} [properties] Properties to set
         * @returns {ptsl.SubtractLocationsResponseBody} SubtractLocationsResponseBody instance
         */
        SubtractLocationsResponseBody.create = function create(properties) {
            return new SubtractLocationsResponseBody(properties);
        };

        /**
         * Encodes the specified SubtractLocationsResponseBody message. Does not implicitly {@link ptsl.SubtractLocationsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {ptsl.ISubtractLocationsResponseBody} message SubtractLocationsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractLocationsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                $root.ptsl.TimeLength.encode(message.length, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubtractLocationsResponseBody message, length delimited. Does not implicitly {@link ptsl.SubtractLocationsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {ptsl.ISubtractLocationsResponseBody} message SubtractLocationsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractLocationsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubtractLocationsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SubtractLocationsResponseBody} SubtractLocationsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractLocationsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SubtractLocationsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.length = $root.ptsl.TimeLength.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubtractLocationsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SubtractLocationsResponseBody} SubtractLocationsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractLocationsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubtractLocationsResponseBody message.
         * @function verify
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubtractLocationsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length")) {
                var error = $root.ptsl.TimeLength.verify(message.length);
                if (error)
                    return "length." + error;
            }
            return null;
        };

        /**
         * Creates a SubtractLocationsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SubtractLocationsResponseBody} SubtractLocationsResponseBody
         */
        SubtractLocationsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SubtractLocationsResponseBody)
                return object;
            var message = new $root.ptsl.SubtractLocationsResponseBody();
            if (object.length != null) {
                if (typeof object.length !== "object")
                    throw TypeError(".ptsl.SubtractLocationsResponseBody.length: object expected");
                message.length = $root.ptsl.TimeLength.fromObject(object.length);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubtractLocationsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {ptsl.SubtractLocationsResponseBody} message SubtractLocationsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubtractLocationsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.length = null;
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = $root.ptsl.TimeLength.toObject(message.length, options);
            return object;
        };

        /**
         * Converts this SubtractLocationsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.SubtractLocationsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubtractLocationsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubtractLocationsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.SubtractLocationsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubtractLocationsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SubtractLocationsResponseBody";
        };

        return SubtractLocationsResponseBody;
    })();

    ptsl.AddLengthToLocationRequestBody = (function() {

        /**
         * Properties of an AddLengthToLocationRequestBody.
         * @memberof ptsl
         * @interface IAddLengthToLocationRequestBody
         * @property {ptsl.ITimelineLocation|null} [location] * Timeline location to add length to
         * @property {ptsl.ITimeLength|null} [length] * Length to add
         */

        /**
         * Constructs a new AddLengthToLocationRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes AddLengthToLocation request data.
         * 
         * @since Pro Tools 2025.06
         * @implements IAddLengthToLocationRequestBody
         * @constructor
         * @param {ptsl.IAddLengthToLocationRequestBody=} [properties] Properties to set
         */
        function AddLengthToLocationRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Timeline location to add length to
         * @member {ptsl.ITimelineLocation|null|undefined} location
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @instance
         */
        AddLengthToLocationRequestBody.prototype.location = null;

        /**
         * * Length to add
         * @member {ptsl.ITimeLength|null|undefined} length
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @instance
         */
        AddLengthToLocationRequestBody.prototype.length = null;

        /**
         * Creates a new AddLengthToLocationRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {ptsl.IAddLengthToLocationRequestBody=} [properties] Properties to set
         * @returns {ptsl.AddLengthToLocationRequestBody} AddLengthToLocationRequestBody instance
         */
        AddLengthToLocationRequestBody.create = function create(properties) {
            return new AddLengthToLocationRequestBody(properties);
        };

        /**
         * Encodes the specified AddLengthToLocationRequestBody message. Does not implicitly {@link ptsl.AddLengthToLocationRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {ptsl.IAddLengthToLocationRequestBody} message AddLengthToLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToLocationRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                $root.ptsl.TimelineLocation.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                $root.ptsl.TimeLength.encode(message.length, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddLengthToLocationRequestBody message, length delimited. Does not implicitly {@link ptsl.AddLengthToLocationRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {ptsl.IAddLengthToLocationRequestBody} message AddLengthToLocationRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToLocationRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddLengthToLocationRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.AddLengthToLocationRequestBody} AddLengthToLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToLocationRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.AddLengthToLocationRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.location = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.length = $root.ptsl.TimeLength.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddLengthToLocationRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.AddLengthToLocationRequestBody} AddLengthToLocationRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToLocationRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddLengthToLocationRequestBody message.
         * @function verify
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddLengthToLocationRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.location != null && message.hasOwnProperty("location")) {
                var error = $root.ptsl.TimelineLocation.verify(message.location);
                if (error)
                    return "location." + error;
            }
            if (message.length != null && message.hasOwnProperty("length")) {
                var error = $root.ptsl.TimeLength.verify(message.length);
                if (error)
                    return "length." + error;
            }
            return null;
        };

        /**
         * Creates an AddLengthToLocationRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.AddLengthToLocationRequestBody} AddLengthToLocationRequestBody
         */
        AddLengthToLocationRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.AddLengthToLocationRequestBody)
                return object;
            var message = new $root.ptsl.AddLengthToLocationRequestBody();
            if (object.location != null) {
                if (typeof object.location !== "object")
                    throw TypeError(".ptsl.AddLengthToLocationRequestBody.location: object expected");
                message.location = $root.ptsl.TimelineLocation.fromObject(object.location);
            }
            if (object.length != null) {
                if (typeof object.length !== "object")
                    throw TypeError(".ptsl.AddLengthToLocationRequestBody.length: object expected");
                message.length = $root.ptsl.TimeLength.fromObject(object.length);
            }
            return message;
        };

        /**
         * Creates a plain object from an AddLengthToLocationRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {ptsl.AddLengthToLocationRequestBody} message AddLengthToLocationRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddLengthToLocationRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.location = null;
                object.length = null;
            }
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = $root.ptsl.TimelineLocation.toObject(message.location, options);
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = $root.ptsl.TimeLength.toObject(message.length, options);
            return object;
        };

        /**
         * Converts this AddLengthToLocationRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddLengthToLocationRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddLengthToLocationRequestBody
         * @function getTypeUrl
         * @memberof ptsl.AddLengthToLocationRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddLengthToLocationRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.AddLengthToLocationRequestBody";
        };

        return AddLengthToLocationRequestBody;
    })();

    ptsl.AddLengthToLocationResponseBody = (function() {

        /**
         * Properties of an AddLengthToLocationResponseBody.
         * @memberof ptsl
         * @interface IAddLengthToLocationResponseBody
         * @property {ptsl.ITimelineLocation|null} [resultLocation] * Resulting location
         */

        /**
         * Constructs a new AddLengthToLocationResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes AddLengthToLocation response data.
         * 
         * @since Pro Tools 2025.06
         * @implements IAddLengthToLocationResponseBody
         * @constructor
         * @param {ptsl.IAddLengthToLocationResponseBody=} [properties] Properties to set
         */
        function AddLengthToLocationResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Resulting location
         * @member {ptsl.ITimelineLocation|null|undefined} resultLocation
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @instance
         */
        AddLengthToLocationResponseBody.prototype.resultLocation = null;

        /**
         * Creates a new AddLengthToLocationResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {ptsl.IAddLengthToLocationResponseBody=} [properties] Properties to set
         * @returns {ptsl.AddLengthToLocationResponseBody} AddLengthToLocationResponseBody instance
         */
        AddLengthToLocationResponseBody.create = function create(properties) {
            return new AddLengthToLocationResponseBody(properties);
        };

        /**
         * Encodes the specified AddLengthToLocationResponseBody message. Does not implicitly {@link ptsl.AddLengthToLocationResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {ptsl.IAddLengthToLocationResponseBody} message AddLengthToLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToLocationResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultLocation != null && Object.hasOwnProperty.call(message, "resultLocation"))
                $root.ptsl.TimelineLocation.encode(message.resultLocation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddLengthToLocationResponseBody message, length delimited. Does not implicitly {@link ptsl.AddLengthToLocationResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {ptsl.IAddLengthToLocationResponseBody} message AddLengthToLocationResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToLocationResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddLengthToLocationResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.AddLengthToLocationResponseBody} AddLengthToLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToLocationResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.AddLengthToLocationResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.resultLocation = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddLengthToLocationResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.AddLengthToLocationResponseBody} AddLengthToLocationResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToLocationResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddLengthToLocationResponseBody message.
         * @function verify
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddLengthToLocationResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultLocation != null && message.hasOwnProperty("resultLocation")) {
                var error = $root.ptsl.TimelineLocation.verify(message.resultLocation);
                if (error)
                    return "resultLocation." + error;
            }
            return null;
        };

        /**
         * Creates an AddLengthToLocationResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.AddLengthToLocationResponseBody} AddLengthToLocationResponseBody
         */
        AddLengthToLocationResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.AddLengthToLocationResponseBody)
                return object;
            var message = new $root.ptsl.AddLengthToLocationResponseBody();
            if (object.resultLocation != null) {
                if (typeof object.resultLocation !== "object")
                    throw TypeError(".ptsl.AddLengthToLocationResponseBody.resultLocation: object expected");
                message.resultLocation = $root.ptsl.TimelineLocation.fromObject(object.resultLocation);
            }
            return message;
        };

        /**
         * Creates a plain object from an AddLengthToLocationResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {ptsl.AddLengthToLocationResponseBody} message AddLengthToLocationResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddLengthToLocationResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.resultLocation = null;
            if (message.resultLocation != null && message.hasOwnProperty("resultLocation"))
                object.resultLocation = $root.ptsl.TimelineLocation.toObject(message.resultLocation, options);
            return object;
        };

        /**
         * Converts this AddLengthToLocationResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddLengthToLocationResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddLengthToLocationResponseBody
         * @function getTypeUrl
         * @memberof ptsl.AddLengthToLocationResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddLengthToLocationResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.AddLengthToLocationResponseBody";
        };

        return AddLengthToLocationResponseBody;
    })();

    ptsl.SubtractPositionsRequestBody = (function() {

        /**
         * Properties of a SubtractPositionsRequestBody.
         * @memberof ptsl
         * @interface ISubtractPositionsRequestBody
         * @property {ptsl.IMediaTimePosition|null} [firstPosition] * First subtraction operand
         * @property {ptsl.IMediaTimePosition|null} [secondPosition] * Second subtraction operand
         */

        /**
         * Constructs a new SubtractPositionsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SubtractPositions request data.
         * 
         * @since Pro Tools 2025.06
         * @implements ISubtractPositionsRequestBody
         * @constructor
         * @param {ptsl.ISubtractPositionsRequestBody=} [properties] Properties to set
         */
        function SubtractPositionsRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * First subtraction operand
         * @member {ptsl.IMediaTimePosition|null|undefined} firstPosition
         * @memberof ptsl.SubtractPositionsRequestBody
         * @instance
         */
        SubtractPositionsRequestBody.prototype.firstPosition = null;

        /**
         * * Second subtraction operand
         * @member {ptsl.IMediaTimePosition|null|undefined} secondPosition
         * @memberof ptsl.SubtractPositionsRequestBody
         * @instance
         */
        SubtractPositionsRequestBody.prototype.secondPosition = null;

        /**
         * Creates a new SubtractPositionsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {ptsl.ISubtractPositionsRequestBody=} [properties] Properties to set
         * @returns {ptsl.SubtractPositionsRequestBody} SubtractPositionsRequestBody instance
         */
        SubtractPositionsRequestBody.create = function create(properties) {
            return new SubtractPositionsRequestBody(properties);
        };

        /**
         * Encodes the specified SubtractPositionsRequestBody message. Does not implicitly {@link ptsl.SubtractPositionsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {ptsl.ISubtractPositionsRequestBody} message SubtractPositionsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractPositionsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.firstPosition != null && Object.hasOwnProperty.call(message, "firstPosition"))
                $root.ptsl.MediaTimePosition.encode(message.firstPosition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.secondPosition != null && Object.hasOwnProperty.call(message, "secondPosition"))
                $root.ptsl.MediaTimePosition.encode(message.secondPosition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubtractPositionsRequestBody message, length delimited. Does not implicitly {@link ptsl.SubtractPositionsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {ptsl.ISubtractPositionsRequestBody} message SubtractPositionsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractPositionsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubtractPositionsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SubtractPositionsRequestBody} SubtractPositionsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractPositionsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SubtractPositionsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.firstPosition = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.secondPosition = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubtractPositionsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SubtractPositionsRequestBody} SubtractPositionsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractPositionsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubtractPositionsRequestBody message.
         * @function verify
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubtractPositionsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.firstPosition != null && message.hasOwnProperty("firstPosition")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.firstPosition);
                if (error)
                    return "firstPosition." + error;
            }
            if (message.secondPosition != null && message.hasOwnProperty("secondPosition")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.secondPosition);
                if (error)
                    return "secondPosition." + error;
            }
            return null;
        };

        /**
         * Creates a SubtractPositionsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SubtractPositionsRequestBody} SubtractPositionsRequestBody
         */
        SubtractPositionsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SubtractPositionsRequestBody)
                return object;
            var message = new $root.ptsl.SubtractPositionsRequestBody();
            if (object.firstPosition != null) {
                if (typeof object.firstPosition !== "object")
                    throw TypeError(".ptsl.SubtractPositionsRequestBody.firstPosition: object expected");
                message.firstPosition = $root.ptsl.MediaTimePosition.fromObject(object.firstPosition);
            }
            if (object.secondPosition != null) {
                if (typeof object.secondPosition !== "object")
                    throw TypeError(".ptsl.SubtractPositionsRequestBody.secondPosition: object expected");
                message.secondPosition = $root.ptsl.MediaTimePosition.fromObject(object.secondPosition);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubtractPositionsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {ptsl.SubtractPositionsRequestBody} message SubtractPositionsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubtractPositionsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.firstPosition = null;
                object.secondPosition = null;
            }
            if (message.firstPosition != null && message.hasOwnProperty("firstPosition"))
                object.firstPosition = $root.ptsl.MediaTimePosition.toObject(message.firstPosition, options);
            if (message.secondPosition != null && message.hasOwnProperty("secondPosition"))
                object.secondPosition = $root.ptsl.MediaTimePosition.toObject(message.secondPosition, options);
            return object;
        };

        /**
         * Converts this SubtractPositionsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SubtractPositionsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubtractPositionsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubtractPositionsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SubtractPositionsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubtractPositionsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SubtractPositionsRequestBody";
        };

        return SubtractPositionsRequestBody;
    })();

    ptsl.SubtractPositionsResponseBody = (function() {

        /**
         * Properties of a SubtractPositionsResponseBody.
         * @memberof ptsl
         * @interface ISubtractPositionsResponseBody
         * @property {ptsl.ITimeLength|null} [length] * Resulting length
         */

        /**
         * Constructs a new SubtractPositionsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes SubtractPositions response data.
         * 
         * @since Pro Tools 2025.06
         * @implements ISubtractPositionsResponseBody
         * @constructor
         * @param {ptsl.ISubtractPositionsResponseBody=} [properties] Properties to set
         */
        function SubtractPositionsResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Resulting length
         * @member {ptsl.ITimeLength|null|undefined} length
         * @memberof ptsl.SubtractPositionsResponseBody
         * @instance
         */
        SubtractPositionsResponseBody.prototype.length = null;

        /**
         * Creates a new SubtractPositionsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {ptsl.ISubtractPositionsResponseBody=} [properties] Properties to set
         * @returns {ptsl.SubtractPositionsResponseBody} SubtractPositionsResponseBody instance
         */
        SubtractPositionsResponseBody.create = function create(properties) {
            return new SubtractPositionsResponseBody(properties);
        };

        /**
         * Encodes the specified SubtractPositionsResponseBody message. Does not implicitly {@link ptsl.SubtractPositionsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {ptsl.ISubtractPositionsResponseBody} message SubtractPositionsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractPositionsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                $root.ptsl.TimeLength.encode(message.length, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubtractPositionsResponseBody message, length delimited. Does not implicitly {@link ptsl.SubtractPositionsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {ptsl.ISubtractPositionsResponseBody} message SubtractPositionsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubtractPositionsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubtractPositionsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SubtractPositionsResponseBody} SubtractPositionsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractPositionsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SubtractPositionsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.length = $root.ptsl.TimeLength.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubtractPositionsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SubtractPositionsResponseBody} SubtractPositionsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubtractPositionsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubtractPositionsResponseBody message.
         * @function verify
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubtractPositionsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length")) {
                var error = $root.ptsl.TimeLength.verify(message.length);
                if (error)
                    return "length." + error;
            }
            return null;
        };

        /**
         * Creates a SubtractPositionsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SubtractPositionsResponseBody} SubtractPositionsResponseBody
         */
        SubtractPositionsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SubtractPositionsResponseBody)
                return object;
            var message = new $root.ptsl.SubtractPositionsResponseBody();
            if (object.length != null) {
                if (typeof object.length !== "object")
                    throw TypeError(".ptsl.SubtractPositionsResponseBody.length: object expected");
                message.length = $root.ptsl.TimeLength.fromObject(object.length);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubtractPositionsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {ptsl.SubtractPositionsResponseBody} message SubtractPositionsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubtractPositionsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.length = null;
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = $root.ptsl.TimeLength.toObject(message.length, options);
            return object;
        };

        /**
         * Converts this SubtractPositionsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.SubtractPositionsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubtractPositionsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubtractPositionsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.SubtractPositionsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubtractPositionsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SubtractPositionsResponseBody";
        };

        return SubtractPositionsResponseBody;
    })();

    ptsl.AddLengthToPositionRequestBody = (function() {

        /**
         * Properties of an AddLengthToPositionRequestBody.
         * @memberof ptsl
         * @interface IAddLengthToPositionRequestBody
         * @property {ptsl.IMediaTimePosition|null} [position] * Timeline position to add length to
         * @property {ptsl.ITimeLength|null} [length] * Length to add
         */

        /**
         * Constructs a new AddLengthToPositionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes AddLengthToPosition request data.
         * 
         * @since Pro Tools 2025.06
         * @implements IAddLengthToPositionRequestBody
         * @constructor
         * @param {ptsl.IAddLengthToPositionRequestBody=} [properties] Properties to set
         */
        function AddLengthToPositionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Timeline position to add length to
         * @member {ptsl.IMediaTimePosition|null|undefined} position
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @instance
         */
        AddLengthToPositionRequestBody.prototype.position = null;

        /**
         * * Length to add
         * @member {ptsl.ITimeLength|null|undefined} length
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @instance
         */
        AddLengthToPositionRequestBody.prototype.length = null;

        /**
         * Creates a new AddLengthToPositionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {ptsl.IAddLengthToPositionRequestBody=} [properties] Properties to set
         * @returns {ptsl.AddLengthToPositionRequestBody} AddLengthToPositionRequestBody instance
         */
        AddLengthToPositionRequestBody.create = function create(properties) {
            return new AddLengthToPositionRequestBody(properties);
        };

        /**
         * Encodes the specified AddLengthToPositionRequestBody message. Does not implicitly {@link ptsl.AddLengthToPositionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {ptsl.IAddLengthToPositionRequestBody} message AddLengthToPositionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToPositionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.ptsl.MediaTimePosition.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                $root.ptsl.TimeLength.encode(message.length, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddLengthToPositionRequestBody message, length delimited. Does not implicitly {@link ptsl.AddLengthToPositionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {ptsl.IAddLengthToPositionRequestBody} message AddLengthToPositionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToPositionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddLengthToPositionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.AddLengthToPositionRequestBody} AddLengthToPositionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToPositionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.AddLengthToPositionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.position = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.length = $root.ptsl.TimeLength.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddLengthToPositionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.AddLengthToPositionRequestBody} AddLengthToPositionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToPositionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddLengthToPositionRequestBody message.
         * @function verify
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddLengthToPositionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.length != null && message.hasOwnProperty("length")) {
                var error = $root.ptsl.TimeLength.verify(message.length);
                if (error)
                    return "length." + error;
            }
            return null;
        };

        /**
         * Creates an AddLengthToPositionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.AddLengthToPositionRequestBody} AddLengthToPositionRequestBody
         */
        AddLengthToPositionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.AddLengthToPositionRequestBody)
                return object;
            var message = new $root.ptsl.AddLengthToPositionRequestBody();
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".ptsl.AddLengthToPositionRequestBody.position: object expected");
                message.position = $root.ptsl.MediaTimePosition.fromObject(object.position);
            }
            if (object.length != null) {
                if (typeof object.length !== "object")
                    throw TypeError(".ptsl.AddLengthToPositionRequestBody.length: object expected");
                message.length = $root.ptsl.TimeLength.fromObject(object.length);
            }
            return message;
        };

        /**
         * Creates a plain object from an AddLengthToPositionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {ptsl.AddLengthToPositionRequestBody} message AddLengthToPositionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddLengthToPositionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = null;
                object.length = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.ptsl.MediaTimePosition.toObject(message.position, options);
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = $root.ptsl.TimeLength.toObject(message.length, options);
            return object;
        };

        /**
         * Converts this AddLengthToPositionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddLengthToPositionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddLengthToPositionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.AddLengthToPositionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddLengthToPositionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.AddLengthToPositionRequestBody";
        };

        return AddLengthToPositionRequestBody;
    })();

    ptsl.AddLengthToPositionResponseBody = (function() {

        /**
         * Properties of an AddLengthToPositionResponseBody.
         * @memberof ptsl
         * @interface IAddLengthToPositionResponseBody
         * @property {ptsl.IMediaTimePosition|null} [resultPosition] * Resulting position
         */

        /**
         * Constructs a new AddLengthToPositionResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes AddLengthToPosition response data.
         * 
         * @since Pro Tools 2025.06
         * @implements IAddLengthToPositionResponseBody
         * @constructor
         * @param {ptsl.IAddLengthToPositionResponseBody=} [properties] Properties to set
         */
        function AddLengthToPositionResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Resulting position
         * @member {ptsl.IMediaTimePosition|null|undefined} resultPosition
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @instance
         */
        AddLengthToPositionResponseBody.prototype.resultPosition = null;

        /**
         * Creates a new AddLengthToPositionResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {ptsl.IAddLengthToPositionResponseBody=} [properties] Properties to set
         * @returns {ptsl.AddLengthToPositionResponseBody} AddLengthToPositionResponseBody instance
         */
        AddLengthToPositionResponseBody.create = function create(properties) {
            return new AddLengthToPositionResponseBody(properties);
        };

        /**
         * Encodes the specified AddLengthToPositionResponseBody message. Does not implicitly {@link ptsl.AddLengthToPositionResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {ptsl.IAddLengthToPositionResponseBody} message AddLengthToPositionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToPositionResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultPosition != null && Object.hasOwnProperty.call(message, "resultPosition"))
                $root.ptsl.MediaTimePosition.encode(message.resultPosition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddLengthToPositionResponseBody message, length delimited. Does not implicitly {@link ptsl.AddLengthToPositionResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {ptsl.IAddLengthToPositionResponseBody} message AddLengthToPositionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddLengthToPositionResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddLengthToPositionResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.AddLengthToPositionResponseBody} AddLengthToPositionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToPositionResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.AddLengthToPositionResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.resultPosition = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddLengthToPositionResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.AddLengthToPositionResponseBody} AddLengthToPositionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddLengthToPositionResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddLengthToPositionResponseBody message.
         * @function verify
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddLengthToPositionResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultPosition != null && message.hasOwnProperty("resultPosition")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.resultPosition);
                if (error)
                    return "resultPosition." + error;
            }
            return null;
        };

        /**
         * Creates an AddLengthToPositionResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.AddLengthToPositionResponseBody} AddLengthToPositionResponseBody
         */
        AddLengthToPositionResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.AddLengthToPositionResponseBody)
                return object;
            var message = new $root.ptsl.AddLengthToPositionResponseBody();
            if (object.resultPosition != null) {
                if (typeof object.resultPosition !== "object")
                    throw TypeError(".ptsl.AddLengthToPositionResponseBody.resultPosition: object expected");
                message.resultPosition = $root.ptsl.MediaTimePosition.fromObject(object.resultPosition);
            }
            return message;
        };

        /**
         * Creates a plain object from an AddLengthToPositionResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {ptsl.AddLengthToPositionResponseBody} message AddLengthToPositionResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddLengthToPositionResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.resultPosition = null;
            if (message.resultPosition != null && message.hasOwnProperty("resultPosition"))
                object.resultPosition = $root.ptsl.MediaTimePosition.toObject(message.resultPosition, options);
            return object;
        };

        /**
         * Converts this AddLengthToPositionResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddLengthToPositionResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddLengthToPositionResponseBody
         * @function getTypeUrl
         * @memberof ptsl.AddLengthToPositionResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddLengthToPositionResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.AddLengthToPositionResponseBody";
        };

        return AddLengthToPositionResponseBody;
    })();

    ptsl.ImportAudioToClipListResponseEntry = (function() {

        /**
         * Properties of an ImportAudioToClipListResponseEntry.
         * @memberof ptsl
         * @interface IImportAudioToClipListResponseEntry
         * @property {string|null} [originalInputPath] * Original input file path.
         * @property {Array.<ptsl.IImportAudioToClipListResponseEntryFile>|null} [destinationFileList] * List of imported audio files.
         * * This will have multiple entries if a multichannel audio file was split into multi-mono.
         */

        /**
         * Constructs a new ImportAudioToClipListResponseEntry.
         * @memberof ptsl
         * @classdesc ImportAudioToClipList response entry for a single requested audio file.
         * 
         * @since Pro Tools 2025.06
         * @implements IImportAudioToClipListResponseEntry
         * @constructor
         * @param {ptsl.IImportAudioToClipListResponseEntry=} [properties] Properties to set
         */
        function ImportAudioToClipListResponseEntry(properties) {
            this.destinationFileList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Original input file path.
         * @member {string} originalInputPath
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @instance
         */
        ImportAudioToClipListResponseEntry.prototype.originalInputPath = "";

        /**
         * * List of imported audio files.
         * * This will have multiple entries if a multichannel audio file was split into multi-mono.
         * @member {Array.<ptsl.IImportAudioToClipListResponseEntryFile>} destinationFileList
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @instance
         */
        ImportAudioToClipListResponseEntry.prototype.destinationFileList = $util.emptyArray;

        /**
         * Creates a new ImportAudioToClipListResponseEntry instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {ptsl.IImportAudioToClipListResponseEntry=} [properties] Properties to set
         * @returns {ptsl.ImportAudioToClipListResponseEntry} ImportAudioToClipListResponseEntry instance
         */
        ImportAudioToClipListResponseEntry.create = function create(properties) {
            return new ImportAudioToClipListResponseEntry(properties);
        };

        /**
         * Encodes the specified ImportAudioToClipListResponseEntry message. Does not implicitly {@link ptsl.ImportAudioToClipListResponseEntry.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {ptsl.IImportAudioToClipListResponseEntry} message ImportAudioToClipListResponseEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListResponseEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originalInputPath != null && Object.hasOwnProperty.call(message, "originalInputPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.originalInputPath);
            if (message.destinationFileList != null && message.destinationFileList.length)
                for (var i = 0; i < message.destinationFileList.length; ++i)
                    $root.ptsl.ImportAudioToClipListResponseEntryFile.encode(message.destinationFileList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportAudioToClipListResponseEntry message, length delimited. Does not implicitly {@link ptsl.ImportAudioToClipListResponseEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {ptsl.IImportAudioToClipListResponseEntry} message ImportAudioToClipListResponseEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListResponseEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportAudioToClipListResponseEntry message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportAudioToClipListResponseEntry} ImportAudioToClipListResponseEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListResponseEntry.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportAudioToClipListResponseEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.originalInputPath = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.destinationFileList && message.destinationFileList.length))
                            message.destinationFileList = [];
                        message.destinationFileList.push($root.ptsl.ImportAudioToClipListResponseEntryFile.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportAudioToClipListResponseEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportAudioToClipListResponseEntry} ImportAudioToClipListResponseEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListResponseEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportAudioToClipListResponseEntry message.
         * @function verify
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportAudioToClipListResponseEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.originalInputPath != null && message.hasOwnProperty("originalInputPath"))
                if (!$util.isString(message.originalInputPath))
                    return "originalInputPath: string expected";
            if (message.destinationFileList != null && message.hasOwnProperty("destinationFileList")) {
                if (!Array.isArray(message.destinationFileList))
                    return "destinationFileList: array expected";
                for (var i = 0; i < message.destinationFileList.length; ++i) {
                    var error = $root.ptsl.ImportAudioToClipListResponseEntryFile.verify(message.destinationFileList[i]);
                    if (error)
                        return "destinationFileList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportAudioToClipListResponseEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportAudioToClipListResponseEntry} ImportAudioToClipListResponseEntry
         */
        ImportAudioToClipListResponseEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportAudioToClipListResponseEntry)
                return object;
            var message = new $root.ptsl.ImportAudioToClipListResponseEntry();
            if (object.originalInputPath != null)
                message.originalInputPath = String(object.originalInputPath);
            if (object.destinationFileList) {
                if (!Array.isArray(object.destinationFileList))
                    throw TypeError(".ptsl.ImportAudioToClipListResponseEntry.destinationFileList: array expected");
                message.destinationFileList = [];
                for (var i = 0; i < object.destinationFileList.length; ++i) {
                    if (typeof object.destinationFileList[i] !== "object")
                        throw TypeError(".ptsl.ImportAudioToClipListResponseEntry.destinationFileList: object expected");
                    message.destinationFileList[i] = $root.ptsl.ImportAudioToClipListResponseEntryFile.fromObject(object.destinationFileList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportAudioToClipListResponseEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {ptsl.ImportAudioToClipListResponseEntry} message ImportAudioToClipListResponseEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportAudioToClipListResponseEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.destinationFileList = [];
            if (options.defaults)
                object.originalInputPath = "";
            if (message.originalInputPath != null && message.hasOwnProperty("originalInputPath"))
                object.originalInputPath = message.originalInputPath;
            if (message.destinationFileList && message.destinationFileList.length) {
                object.destinationFileList = [];
                for (var j = 0; j < message.destinationFileList.length; ++j)
                    object.destinationFileList[j] = $root.ptsl.ImportAudioToClipListResponseEntryFile.toObject(message.destinationFileList[j], options);
            }
            return object;
        };

        /**
         * Converts this ImportAudioToClipListResponseEntry to JSON.
         * @function toJSON
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportAudioToClipListResponseEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportAudioToClipListResponseEntry
         * @function getTypeUrl
         * @memberof ptsl.ImportAudioToClipListResponseEntry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportAudioToClipListResponseEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportAudioToClipListResponseEntry";
        };

        return ImportAudioToClipListResponseEntry;
    })();

    ptsl.ImportAudioToClipListResponseEntryFile = (function() {

        /**
         * Properties of an ImportAudioToClipListResponseEntryFile.
         * @memberof ptsl
         * @interface IImportAudioToClipListResponseEntryFile
         * @property {string|null} [fileId] * This is a session-specific ID to identify an audio file.
         * * It's not related to any IDs stamped into the file.
         * * This ID is persisted between runs and stored in the session, but may be different from one session to another that uses the same file.
         * @property {string|null} [filePath] * Location of the new audio file.
         * @property {Array.<string>|null} [clipIdList] * ID(s) for the (whole-file) clip(s) representing the imported file. Has multiple entries for multichannel files.
         */

        /**
         * Constructs a new ImportAudioToClipListResponseEntryFile.
         * @memberof ptsl
         * @classdesc ImportAudioToClipList response entry for a single imported audio file.
         * 
         * @since Pro Tools 2025.06
         * @implements IImportAudioToClipListResponseEntryFile
         * @constructor
         * @param {ptsl.IImportAudioToClipListResponseEntryFile=} [properties] Properties to set
         */
        function ImportAudioToClipListResponseEntryFile(properties) {
            this.clipIdList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * This is a session-specific ID to identify an audio file.
         * * It's not related to any IDs stamped into the file.
         * * This ID is persisted between runs and stored in the session, but may be different from one session to another that uses the same file.
         * @member {string} fileId
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @instance
         */
        ImportAudioToClipListResponseEntryFile.prototype.fileId = "";

        /**
         * * Location of the new audio file.
         * @member {string} filePath
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @instance
         */
        ImportAudioToClipListResponseEntryFile.prototype.filePath = "";

        /**
         * * ID(s) for the (whole-file) clip(s) representing the imported file. Has multiple entries for multichannel files.
         * @member {Array.<string>} clipIdList
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @instance
         */
        ImportAudioToClipListResponseEntryFile.prototype.clipIdList = $util.emptyArray;

        /**
         * Creates a new ImportAudioToClipListResponseEntryFile instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {ptsl.IImportAudioToClipListResponseEntryFile=} [properties] Properties to set
         * @returns {ptsl.ImportAudioToClipListResponseEntryFile} ImportAudioToClipListResponseEntryFile instance
         */
        ImportAudioToClipListResponseEntryFile.create = function create(properties) {
            return new ImportAudioToClipListResponseEntryFile(properties);
        };

        /**
         * Encodes the specified ImportAudioToClipListResponseEntryFile message. Does not implicitly {@link ptsl.ImportAudioToClipListResponseEntryFile.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {ptsl.IImportAudioToClipListResponseEntryFile} message ImportAudioToClipListResponseEntryFile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListResponseEntryFile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileId);
            if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.filePath);
            if (message.clipIdList != null && message.clipIdList.length)
                for (var i = 0; i < message.clipIdList.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clipIdList[i]);
            return writer;
        };

        /**
         * Encodes the specified ImportAudioToClipListResponseEntryFile message, length delimited. Does not implicitly {@link ptsl.ImportAudioToClipListResponseEntryFile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {ptsl.IImportAudioToClipListResponseEntryFile} message ImportAudioToClipListResponseEntryFile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListResponseEntryFile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportAudioToClipListResponseEntryFile message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportAudioToClipListResponseEntryFile} ImportAudioToClipListResponseEntryFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListResponseEntryFile.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportAudioToClipListResponseEntryFile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fileId = reader.string();
                        break;
                    }
                case 2: {
                        message.filePath = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.clipIdList && message.clipIdList.length))
                            message.clipIdList = [];
                        message.clipIdList.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportAudioToClipListResponseEntryFile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportAudioToClipListResponseEntryFile} ImportAudioToClipListResponseEntryFile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListResponseEntryFile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportAudioToClipListResponseEntryFile message.
         * @function verify
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportAudioToClipListResponseEntryFile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                if (!$util.isString(message.fileId))
                    return "fileId: string expected";
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                if (!$util.isString(message.filePath))
                    return "filePath: string expected";
            if (message.clipIdList != null && message.hasOwnProperty("clipIdList")) {
                if (!Array.isArray(message.clipIdList))
                    return "clipIdList: array expected";
                for (var i = 0; i < message.clipIdList.length; ++i)
                    if (!$util.isString(message.clipIdList[i]))
                        return "clipIdList: string[] expected";
            }
            return null;
        };

        /**
         * Creates an ImportAudioToClipListResponseEntryFile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportAudioToClipListResponseEntryFile} ImportAudioToClipListResponseEntryFile
         */
        ImportAudioToClipListResponseEntryFile.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportAudioToClipListResponseEntryFile)
                return object;
            var message = new $root.ptsl.ImportAudioToClipListResponseEntryFile();
            if (object.fileId != null)
                message.fileId = String(object.fileId);
            if (object.filePath != null)
                message.filePath = String(object.filePath);
            if (object.clipIdList) {
                if (!Array.isArray(object.clipIdList))
                    throw TypeError(".ptsl.ImportAudioToClipListResponseEntryFile.clipIdList: array expected");
                message.clipIdList = [];
                for (var i = 0; i < object.clipIdList.length; ++i)
                    message.clipIdList[i] = String(object.clipIdList[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportAudioToClipListResponseEntryFile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {ptsl.ImportAudioToClipListResponseEntryFile} message ImportAudioToClipListResponseEntryFile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportAudioToClipListResponseEntryFile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clipIdList = [];
            if (options.defaults) {
                object.fileId = "";
                object.filePath = "";
            }
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                object.fileId = message.fileId;
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                object.filePath = message.filePath;
            if (message.clipIdList && message.clipIdList.length) {
                object.clipIdList = [];
                for (var j = 0; j < message.clipIdList.length; ++j)
                    object.clipIdList[j] = message.clipIdList[j];
            }
            return object;
        };

        /**
         * Converts this ImportAudioToClipListResponseEntryFile to JSON.
         * @function toJSON
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportAudioToClipListResponseEntryFile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportAudioToClipListResponseEntryFile
         * @function getTypeUrl
         * @memberof ptsl.ImportAudioToClipListResponseEntryFile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportAudioToClipListResponseEntryFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportAudioToClipListResponseEntryFile";
        };

        return ImportAudioToClipListResponseEntryFile;
    })();

    ptsl.ImportAudioToClipListRequestBody = (function() {

        /**
         * Properties of an ImportAudioToClipListRequestBody.
         * @memberof ptsl
         * @interface IImportAudioToClipListRequestBody
         * @property {Array.<string>|null} [fileList] * List of audio files to import.
         * @property {ptsl.AudioOperations|null} [audioOperations] * How to import the input media.
         * * Optional. If not provided, the default behavior is chosen by Pro Tools.
         * * Note: Pro Tools cannot always honor this request. Discrepancies will be noted in the response (check ImportAudioToClipListResponseBody.failure_list).
         * @property {string|null} [destinationPath] * The destination path for the imported audio.
         * * Optional. If not provided, the audio will be imported to the session's audio files folder.
         */

        /**
         * Constructs a new ImportAudioToClipListRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ImportAudioToClipList request data.
         * 
         * @since Pro Tools 2025.06
         * @implements IImportAudioToClipListRequestBody
         * @constructor
         * @param {ptsl.IImportAudioToClipListRequestBody=} [properties] Properties to set
         */
        function ImportAudioToClipListRequestBody(properties) {
            this.fileList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of audio files to import.
         * @member {Array.<string>} fileList
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @instance
         */
        ImportAudioToClipListRequestBody.prototype.fileList = $util.emptyArray;

        /**
         * * How to import the input media.
         * * Optional. If not provided, the default behavior is chosen by Pro Tools.
         * * Note: Pro Tools cannot always honor this request. Discrepancies will be noted in the response (check ImportAudioToClipListResponseBody.failure_list).
         * @member {ptsl.AudioOperations} audioOperations
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @instance
         */
        ImportAudioToClipListRequestBody.prototype.audioOperations = 0;

        /**
         * * The destination path for the imported audio.
         * * Optional. If not provided, the audio will be imported to the session's audio files folder.
         * @member {string} destinationPath
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @instance
         */
        ImportAudioToClipListRequestBody.prototype.destinationPath = "";

        /**
         * Creates a new ImportAudioToClipListRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {ptsl.IImportAudioToClipListRequestBody=} [properties] Properties to set
         * @returns {ptsl.ImportAudioToClipListRequestBody} ImportAudioToClipListRequestBody instance
         */
        ImportAudioToClipListRequestBody.create = function create(properties) {
            return new ImportAudioToClipListRequestBody(properties);
        };

        /**
         * Encodes the specified ImportAudioToClipListRequestBody message. Does not implicitly {@link ptsl.ImportAudioToClipListRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {ptsl.IImportAudioToClipListRequestBody} message ImportAudioToClipListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileList != null && message.fileList.length)
                for (var i = 0; i < message.fileList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileList[i]);
            if (message.audioOperations != null && Object.hasOwnProperty.call(message, "audioOperations"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.audioOperations);
            if (message.destinationPath != null && Object.hasOwnProperty.call(message, "destinationPath"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.destinationPath);
            return writer;
        };

        /**
         * Encodes the specified ImportAudioToClipListRequestBody message, length delimited. Does not implicitly {@link ptsl.ImportAudioToClipListRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {ptsl.IImportAudioToClipListRequestBody} message ImportAudioToClipListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportAudioToClipListRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportAudioToClipListRequestBody} ImportAudioToClipListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportAudioToClipListRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.fileList && message.fileList.length))
                            message.fileList = [];
                        message.fileList.push(reader.string());
                        break;
                    }
                case 2: {
                        message.audioOperations = reader.int32();
                        break;
                    }
                case 3: {
                        message.destinationPath = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportAudioToClipListRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportAudioToClipListRequestBody} ImportAudioToClipListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportAudioToClipListRequestBody message.
         * @function verify
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportAudioToClipListRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileList != null && message.hasOwnProperty("fileList")) {
                if (!Array.isArray(message.fileList))
                    return "fileList: array expected";
                for (var i = 0; i < message.fileList.length; ++i)
                    if (!$util.isString(message.fileList[i]))
                        return "fileList: string[] expected";
            }
            if (message.audioOperations != null && message.hasOwnProperty("audioOperations"))
                switch (message.audioOperations) {
                default:
                    return "audioOperations: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                if (!$util.isString(message.destinationPath))
                    return "destinationPath: string expected";
            return null;
        };

        /**
         * Creates an ImportAudioToClipListRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportAudioToClipListRequestBody} ImportAudioToClipListRequestBody
         */
        ImportAudioToClipListRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportAudioToClipListRequestBody)
                return object;
            var message = new $root.ptsl.ImportAudioToClipListRequestBody();
            if (object.fileList) {
                if (!Array.isArray(object.fileList))
                    throw TypeError(".ptsl.ImportAudioToClipListRequestBody.fileList: array expected");
                message.fileList = [];
                for (var i = 0; i < object.fileList.length; ++i)
                    message.fileList[i] = String(object.fileList[i]);
            }
            switch (object.audioOperations) {
            default:
                if (typeof object.audioOperations === "number") {
                    message.audioOperations = object.audioOperations;
                    break;
                }
                break;
            case "AOperations_Unknown":
            case 0:
                message.audioOperations = 0;
                break;
            case "AddAudio":
            case 1:
                message.audioOperations = 1;
                break;
            case "AOperations_AddAudio":
            case 1:
                message.audioOperations = 1;
                break;
            case "CopyAudio":
            case 2:
                message.audioOperations = 2;
                break;
            case "AOperations_CopyAudio":
            case 2:
                message.audioOperations = 2;
                break;
            case "ConvertAudio":
            case 3:
                message.audioOperations = 3;
                break;
            case "AOperations_ConvertAudio":
            case 3:
                message.audioOperations = 3;
                break;
            case "Default":
            case 4:
                message.audioOperations = 4;
                break;
            case "AOperations_Default":
            case 4:
                message.audioOperations = 4;
                break;
            }
            if (object.destinationPath != null)
                message.destinationPath = String(object.destinationPath);
            return message;
        };

        /**
         * Creates a plain object from an ImportAudioToClipListRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {ptsl.ImportAudioToClipListRequestBody} message ImportAudioToClipListRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportAudioToClipListRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fileList = [];
            if (options.defaults) {
                object.audioOperations = options.enums === String ? "AOperations_Unknown" : 0;
                object.destinationPath = "";
            }
            if (message.fileList && message.fileList.length) {
                object.fileList = [];
                for (var j = 0; j < message.fileList.length; ++j)
                    object.fileList[j] = message.fileList[j];
            }
            if (message.audioOperations != null && message.hasOwnProperty("audioOperations"))
                object.audioOperations = options.enums === String ? $root.ptsl.AudioOperations[message.audioOperations] === undefined ? message.audioOperations : $root.ptsl.AudioOperations[message.audioOperations] : message.audioOperations;
            if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                object.destinationPath = message.destinationPath;
            return object;
        };

        /**
         * Converts this ImportAudioToClipListRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportAudioToClipListRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportAudioToClipListRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ImportAudioToClipListRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportAudioToClipListRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportAudioToClipListRequestBody";
        };

        return ImportAudioToClipListRequestBody;
    })();

    ptsl.ImportAudioToClipListResponseBody = (function() {

        /**
         * Properties of an ImportAudioToClipListResponseBody.
         * @memberof ptsl
         * @interface IImportAudioToClipListResponseBody
         * @property {Array.<ptsl.IImportAudioToClipListResponseEntry>|null} [fileList] * List of successfully imported audio files.
         * @property {Array.<ptsl.IImportFailureInfo>|null} [failureList] * List of audio files that could not be imported.
         */

        /**
         * Constructs a new ImportAudioToClipListResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes ImportAudioToClipList response data.
         * 
         * @since Pro Tools 2025.06
         * @implements IImportAudioToClipListResponseBody
         * @constructor
         * @param {ptsl.IImportAudioToClipListResponseBody=} [properties] Properties to set
         */
        function ImportAudioToClipListResponseBody(properties) {
            this.fileList = [];
            this.failureList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of successfully imported audio files.
         * @member {Array.<ptsl.IImportAudioToClipListResponseEntry>} fileList
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @instance
         */
        ImportAudioToClipListResponseBody.prototype.fileList = $util.emptyArray;

        /**
         * * List of audio files that could not be imported.
         * @member {Array.<ptsl.IImportFailureInfo>} failureList
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @instance
         */
        ImportAudioToClipListResponseBody.prototype.failureList = $util.emptyArray;

        /**
         * Creates a new ImportAudioToClipListResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {ptsl.IImportAudioToClipListResponseBody=} [properties] Properties to set
         * @returns {ptsl.ImportAudioToClipListResponseBody} ImportAudioToClipListResponseBody instance
         */
        ImportAudioToClipListResponseBody.create = function create(properties) {
            return new ImportAudioToClipListResponseBody(properties);
        };

        /**
         * Encodes the specified ImportAudioToClipListResponseBody message. Does not implicitly {@link ptsl.ImportAudioToClipListResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {ptsl.IImportAudioToClipListResponseBody} message ImportAudioToClipListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileList != null && message.fileList.length)
                for (var i = 0; i < message.fileList.length; ++i)
                    $root.ptsl.ImportAudioToClipListResponseEntry.encode(message.fileList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.failureList != null && message.failureList.length)
                for (var i = 0; i < message.failureList.length; ++i)
                    $root.ptsl.ImportFailureInfo.encode(message.failureList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportAudioToClipListResponseBody message, length delimited. Does not implicitly {@link ptsl.ImportAudioToClipListResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {ptsl.IImportAudioToClipListResponseBody} message ImportAudioToClipListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportAudioToClipListResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportAudioToClipListResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ImportAudioToClipListResponseBody} ImportAudioToClipListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ImportAudioToClipListResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.fileList && message.fileList.length))
                            message.fileList = [];
                        message.fileList.push($root.ptsl.ImportAudioToClipListResponseEntry.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.failureList && message.failureList.length))
                            message.failureList = [];
                        message.failureList.push($root.ptsl.ImportFailureInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportAudioToClipListResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ImportAudioToClipListResponseBody} ImportAudioToClipListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportAudioToClipListResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportAudioToClipListResponseBody message.
         * @function verify
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportAudioToClipListResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileList != null && message.hasOwnProperty("fileList")) {
                if (!Array.isArray(message.fileList))
                    return "fileList: array expected";
                for (var i = 0; i < message.fileList.length; ++i) {
                    var error = $root.ptsl.ImportAudioToClipListResponseEntry.verify(message.fileList[i]);
                    if (error)
                        return "fileList." + error;
                }
            }
            if (message.failureList != null && message.hasOwnProperty("failureList")) {
                if (!Array.isArray(message.failureList))
                    return "failureList: array expected";
                for (var i = 0; i < message.failureList.length; ++i) {
                    var error = $root.ptsl.ImportFailureInfo.verify(message.failureList[i]);
                    if (error)
                        return "failureList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportAudioToClipListResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ImportAudioToClipListResponseBody} ImportAudioToClipListResponseBody
         */
        ImportAudioToClipListResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ImportAudioToClipListResponseBody)
                return object;
            var message = new $root.ptsl.ImportAudioToClipListResponseBody();
            if (object.fileList) {
                if (!Array.isArray(object.fileList))
                    throw TypeError(".ptsl.ImportAudioToClipListResponseBody.fileList: array expected");
                message.fileList = [];
                for (var i = 0; i < object.fileList.length; ++i) {
                    if (typeof object.fileList[i] !== "object")
                        throw TypeError(".ptsl.ImportAudioToClipListResponseBody.fileList: object expected");
                    message.fileList[i] = $root.ptsl.ImportAudioToClipListResponseEntry.fromObject(object.fileList[i]);
                }
            }
            if (object.failureList) {
                if (!Array.isArray(object.failureList))
                    throw TypeError(".ptsl.ImportAudioToClipListResponseBody.failureList: array expected");
                message.failureList = [];
                for (var i = 0; i < object.failureList.length; ++i) {
                    if (typeof object.failureList[i] !== "object")
                        throw TypeError(".ptsl.ImportAudioToClipListResponseBody.failureList: object expected");
                    message.failureList[i] = $root.ptsl.ImportFailureInfo.fromObject(object.failureList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportAudioToClipListResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {ptsl.ImportAudioToClipListResponseBody} message ImportAudioToClipListResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportAudioToClipListResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fileList = [];
                object.failureList = [];
            }
            if (message.fileList && message.fileList.length) {
                object.fileList = [];
                for (var j = 0; j < message.fileList.length; ++j)
                    object.fileList[j] = $root.ptsl.ImportAudioToClipListResponseEntry.toObject(message.fileList[j], options);
            }
            if (message.failureList && message.failureList.length) {
                object.failureList = [];
                for (var j = 0; j < message.failureList.length; ++j)
                    object.failureList[j] = $root.ptsl.ImportFailureInfo.toObject(message.failureList[j], options);
            }
            return object;
        };

        /**
         * Converts this ImportAudioToClipListResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportAudioToClipListResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImportAudioToClipListResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ImportAudioToClipListResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImportAudioToClipListResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ImportAudioToClipListResponseBody";
        };

        return ImportAudioToClipListResponseBody;
    })();

    ptsl.ClipInstanceAttributes = (function() {

        /**
         * Properties of a ClipInstanceAttributes.
         * @memberof ptsl
         * @interface IClipInstanceAttributes
         * @property {number|null} [colorIndex] * Color index
         */

        /**
         * Constructs a new ClipInstanceAttributes.
         * @memberof ptsl
         * @classdesc Structure that describes different attributes of clip elements that can be adjusted
         * @implements IClipInstanceAttributes
         * @constructor
         * @param {ptsl.IClipInstanceAttributes=} [properties] Properties to set
         */
        function ClipInstanceAttributes(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Color index
         * @member {number} colorIndex
         * @memberof ptsl.ClipInstanceAttributes
         * @instance
         */
        ClipInstanceAttributes.prototype.colorIndex = 0;

        /**
         * Creates a new ClipInstanceAttributes instance using the specified properties.
         * @function create
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {ptsl.IClipInstanceAttributes=} [properties] Properties to set
         * @returns {ptsl.ClipInstanceAttributes} ClipInstanceAttributes instance
         */
        ClipInstanceAttributes.create = function create(properties) {
            return new ClipInstanceAttributes(properties);
        };

        /**
         * Encodes the specified ClipInstanceAttributes message. Does not implicitly {@link ptsl.ClipInstanceAttributes.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {ptsl.IClipInstanceAttributes} message ClipInstanceAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClipInstanceAttributes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.colorIndex != null && Object.hasOwnProperty.call(message, "colorIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.colorIndex);
            return writer;
        };

        /**
         * Encodes the specified ClipInstanceAttributes message, length delimited. Does not implicitly {@link ptsl.ClipInstanceAttributes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {ptsl.IClipInstanceAttributes} message ClipInstanceAttributes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClipInstanceAttributes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClipInstanceAttributes message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ClipInstanceAttributes} ClipInstanceAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClipInstanceAttributes.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ClipInstanceAttributes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.colorIndex = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClipInstanceAttributes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ClipInstanceAttributes} ClipInstanceAttributes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClipInstanceAttributes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClipInstanceAttributes message.
         * @function verify
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClipInstanceAttributes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                if (!$util.isInteger(message.colorIndex))
                    return "colorIndex: integer expected";
            return null;
        };

        /**
         * Creates a ClipInstanceAttributes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ClipInstanceAttributes} ClipInstanceAttributes
         */
        ClipInstanceAttributes.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ClipInstanceAttributes)
                return object;
            var message = new $root.ptsl.ClipInstanceAttributes();
            if (object.colorIndex != null)
                message.colorIndex = object.colorIndex | 0;
            return message;
        };

        /**
         * Creates a plain object from a ClipInstanceAttributes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {ptsl.ClipInstanceAttributes} message ClipInstanceAttributes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClipInstanceAttributes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.colorIndex = 0;
            if (message.colorIndex != null && message.hasOwnProperty("colorIndex"))
                object.colorIndex = message.colorIndex;
            return object;
        };

        /**
         * Converts this ClipInstanceAttributes to JSON.
         * @function toJSON
         * @memberof ptsl.ClipInstanceAttributes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClipInstanceAttributes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClipInstanceAttributes
         * @function getTypeUrl
         * @memberof ptsl.ClipInstanceAttributes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClipInstanceAttributes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ClipInstanceAttributes";
        };

        return ClipInstanceAttributes;
    })();

    ptsl.SpotClipsByIDRequestBody = (function() {

        /**
         * Properties of a SpotClipsByIDRequestBody.
         * @memberof ptsl
         * @interface ISpotClipsByIDRequestBody
         * @property {Array.<string>|null} [srcClips] * List of clip IDs to make up a multichannel clip
         * @property {string|null} [dstTrackId] * Track ID to place clips on
         * @property {string|null} [dstTrackName] * Track name to place clips on
         * @property {ptsl.ISpotLocationData|null} [dstLocationData] * Placement parameters
         * @property {ptsl.IClipInstanceAttributes|null} [clipInstanceAttributes] * Attributes for a resulting clip instance
         */

        /**
         * Constructs a new SpotClipsByIDRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SpotClipsByID request data.
         * @implements ISpotClipsByIDRequestBody
         * @constructor
         * @param {ptsl.ISpotClipsByIDRequestBody=} [properties] Properties to set
         */
        function SpotClipsByIDRequestBody(properties) {
            this.srcClips = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of clip IDs to make up a multichannel clip
         * @member {Array.<string>} srcClips
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @instance
         */
        SpotClipsByIDRequestBody.prototype.srcClips = $util.emptyArray;

        /**
         * * Track ID to place clips on
         * @member {string} dstTrackId
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @instance
         */
        SpotClipsByIDRequestBody.prototype.dstTrackId = "";

        /**
         * * Track name to place clips on
         * @member {string} dstTrackName
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @instance
         */
        SpotClipsByIDRequestBody.prototype.dstTrackName = "";

        /**
         * * Placement parameters
         * @member {ptsl.ISpotLocationData|null|undefined} dstLocationData
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @instance
         */
        SpotClipsByIDRequestBody.prototype.dstLocationData = null;

        /**
         * * Attributes for a resulting clip instance
         * @member {ptsl.IClipInstanceAttributes|null|undefined} clipInstanceAttributes
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @instance
         */
        SpotClipsByIDRequestBody.prototype.clipInstanceAttributes = null;

        /**
         * Creates a new SpotClipsByIDRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {ptsl.ISpotClipsByIDRequestBody=} [properties] Properties to set
         * @returns {ptsl.SpotClipsByIDRequestBody} SpotClipsByIDRequestBody instance
         */
        SpotClipsByIDRequestBody.create = function create(properties) {
            return new SpotClipsByIDRequestBody(properties);
        };

        /**
         * Encodes the specified SpotClipsByIDRequestBody message. Does not implicitly {@link ptsl.SpotClipsByIDRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {ptsl.ISpotClipsByIDRequestBody} message SpotClipsByIDRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpotClipsByIDRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.srcClips != null && message.srcClips.length)
                for (var i = 0; i < message.srcClips.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.srcClips[i]);
            if (message.dstTrackId != null && Object.hasOwnProperty.call(message, "dstTrackId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.dstTrackId);
            if (message.dstTrackName != null && Object.hasOwnProperty.call(message, "dstTrackName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.dstTrackName);
            if (message.dstLocationData != null && Object.hasOwnProperty.call(message, "dstLocationData"))
                $root.ptsl.SpotLocationData.encode(message.dstLocationData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.clipInstanceAttributes != null && Object.hasOwnProperty.call(message, "clipInstanceAttributes"))
                $root.ptsl.ClipInstanceAttributes.encode(message.clipInstanceAttributes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SpotClipsByIDRequestBody message, length delimited. Does not implicitly {@link ptsl.SpotClipsByIDRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {ptsl.ISpotClipsByIDRequestBody} message SpotClipsByIDRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpotClipsByIDRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpotClipsByIDRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SpotClipsByIDRequestBody} SpotClipsByIDRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpotClipsByIDRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SpotClipsByIDRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.srcClips && message.srcClips.length))
                            message.srcClips = [];
                        message.srcClips.push(reader.string());
                        break;
                    }
                case 2: {
                        message.dstTrackId = reader.string();
                        break;
                    }
                case 3: {
                        message.dstTrackName = reader.string();
                        break;
                    }
                case 4: {
                        message.dstLocationData = $root.ptsl.SpotLocationData.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.clipInstanceAttributes = $root.ptsl.ClipInstanceAttributes.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpotClipsByIDRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SpotClipsByIDRequestBody} SpotClipsByIDRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpotClipsByIDRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpotClipsByIDRequestBody message.
         * @function verify
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpotClipsByIDRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.srcClips != null && message.hasOwnProperty("srcClips")) {
                if (!Array.isArray(message.srcClips))
                    return "srcClips: array expected";
                for (var i = 0; i < message.srcClips.length; ++i)
                    if (!$util.isString(message.srcClips[i]))
                        return "srcClips: string[] expected";
            }
            if (message.dstTrackId != null && message.hasOwnProperty("dstTrackId"))
                if (!$util.isString(message.dstTrackId))
                    return "dstTrackId: string expected";
            if (message.dstTrackName != null && message.hasOwnProperty("dstTrackName"))
                if (!$util.isString(message.dstTrackName))
                    return "dstTrackName: string expected";
            if (message.dstLocationData != null && message.hasOwnProperty("dstLocationData")) {
                var error = $root.ptsl.SpotLocationData.verify(message.dstLocationData);
                if (error)
                    return "dstLocationData." + error;
            }
            if (message.clipInstanceAttributes != null && message.hasOwnProperty("clipInstanceAttributes")) {
                var error = $root.ptsl.ClipInstanceAttributes.verify(message.clipInstanceAttributes);
                if (error)
                    return "clipInstanceAttributes." + error;
            }
            return null;
        };

        /**
         * Creates a SpotClipsByIDRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SpotClipsByIDRequestBody} SpotClipsByIDRequestBody
         */
        SpotClipsByIDRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SpotClipsByIDRequestBody)
                return object;
            var message = new $root.ptsl.SpotClipsByIDRequestBody();
            if (object.srcClips) {
                if (!Array.isArray(object.srcClips))
                    throw TypeError(".ptsl.SpotClipsByIDRequestBody.srcClips: array expected");
                message.srcClips = [];
                for (var i = 0; i < object.srcClips.length; ++i)
                    message.srcClips[i] = String(object.srcClips[i]);
            }
            if (object.dstTrackId != null)
                message.dstTrackId = String(object.dstTrackId);
            if (object.dstTrackName != null)
                message.dstTrackName = String(object.dstTrackName);
            if (object.dstLocationData != null) {
                if (typeof object.dstLocationData !== "object")
                    throw TypeError(".ptsl.SpotClipsByIDRequestBody.dstLocationData: object expected");
                message.dstLocationData = $root.ptsl.SpotLocationData.fromObject(object.dstLocationData);
            }
            if (object.clipInstanceAttributes != null) {
                if (typeof object.clipInstanceAttributes !== "object")
                    throw TypeError(".ptsl.SpotClipsByIDRequestBody.clipInstanceAttributes: object expected");
                message.clipInstanceAttributes = $root.ptsl.ClipInstanceAttributes.fromObject(object.clipInstanceAttributes);
            }
            return message;
        };

        /**
         * Creates a plain object from a SpotClipsByIDRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {ptsl.SpotClipsByIDRequestBody} message SpotClipsByIDRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpotClipsByIDRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.srcClips = [];
            if (options.defaults) {
                object.dstTrackId = "";
                object.dstTrackName = "";
                object.dstLocationData = null;
                object.clipInstanceAttributes = null;
            }
            if (message.srcClips && message.srcClips.length) {
                object.srcClips = [];
                for (var j = 0; j < message.srcClips.length; ++j)
                    object.srcClips[j] = message.srcClips[j];
            }
            if (message.dstTrackId != null && message.hasOwnProperty("dstTrackId"))
                object.dstTrackId = message.dstTrackId;
            if (message.dstTrackName != null && message.hasOwnProperty("dstTrackName"))
                object.dstTrackName = message.dstTrackName;
            if (message.dstLocationData != null && message.hasOwnProperty("dstLocationData"))
                object.dstLocationData = $root.ptsl.SpotLocationData.toObject(message.dstLocationData, options);
            if (message.clipInstanceAttributes != null && message.hasOwnProperty("clipInstanceAttributes"))
                object.clipInstanceAttributes = $root.ptsl.ClipInstanceAttributes.toObject(message.clipInstanceAttributes, options);
            return object;
        };

        /**
         * Converts this SpotClipsByIDRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpotClipsByIDRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SpotClipsByIDRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SpotClipsByIDRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SpotClipsByIDRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SpotClipsByIDRequestBody";
        };

        return SpotClipsByIDRequestBody;
    })();

    /**
     * Pro Tools clip type
     * 
     * @since Pro Tools 2025.06
     * @name ptsl.ClipType
     * @enum {number}
     * @property {number} ClipType_Unknown=0 * Tech-only value. Don't use it in requests.
     * @property {number} ClipType_Audio=1 ClipType_Audio value
     * @property {number} ClipType_Midi=2 ClipType_Midi value
     * @property {number} ClipType_Video=3 ClipType_Video value
     * @property {number} ClipType_AudioClipGroup=4 ClipType_AudioClipGroup value
     * @property {number} ClipType_MidiClipGroup=5 ClipType_MidiClipGroup value
     * @property {number} ClipType_VideoClipGroup=6 ClipType_VideoClipGroup value
     * @property {number} ClipType_MixedClipGroup=7 ClipType_MixedClipGroup value
     */
    ptsl.ClipType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ClipType_Unknown"] = 0;
        values[valuesById[1] = "ClipType_Audio"] = 1;
        values[valuesById[2] = "ClipType_Midi"] = 2;
        values[valuesById[3] = "ClipType_Video"] = 3;
        values[valuesById[4] = "ClipType_AudioClipGroup"] = 4;
        values[valuesById[5] = "ClipType_MidiClipGroup"] = 5;
        values[valuesById[6] = "ClipType_VideoClipGroup"] = 6;
        values[valuesById[7] = "ClipType_MixedClipGroup"] = 7;
        return values;
    })();

    ptsl.Clip = (function() {

        /**
         * Properties of a Clip.
         * @memberof ptsl
         * @interface IClip
         * @property {string|null} [fileId] * Source file identifier
         * @property {string|null} [clipId] * Clip identifier
         * @property {string|null} [clipFullName] * Full name
         * @property {string|null} [clipRootName] * Base name
         * @property {ptsl.ClipType|null} [clipType] * Clip type
         * @property {ptsl.IMediaTimePosition|null} [startPoint] * Clip start point
         * @property {ptsl.IMediaTimePosition|null} [endPoint] * Clip end point
         * @property {ptsl.IMediaTimePosition|null} [syncPoint] * Clip sync point
         * @property {string|null} [groupName] * Multitrack Group clip name which current clip is a part of
         * @property {ptsl.IMediaTimePosition|null} [srcStartPoint] * Start sample position in file
         * @property {ptsl.IMediaTimePosition|null} [srcEndPoint] * End sample position in file
         * @property {number|null} [transposeSemitones] * Number of semitones in pitch transposition
         * @property {number|null} [transposeCents] * Number of cents in pitch transposition
         */

        /**
         * Constructs a new Clip.
         * @memberof ptsl
         * @classdesc Structure that describes Pro Tools clip
         * 
         * @since Pro Tools 2025.06
         * @implements IClip
         * @constructor
         * @param {ptsl.IClip=} [properties] Properties to set
         */
        function Clip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Source file identifier
         * @member {string} fileId
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.fileId = "";

        /**
         * * Clip identifier
         * @member {string} clipId
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.clipId = "";

        /**
         * * Full name
         * @member {string} clipFullName
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.clipFullName = "";

        /**
         * * Base name
         * @member {string} clipRootName
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.clipRootName = "";

        /**
         * * Clip type
         * @member {ptsl.ClipType} clipType
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.clipType = 0;

        /**
         * * Clip start point
         * @member {ptsl.IMediaTimePosition|null|undefined} startPoint
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.startPoint = null;

        /**
         * * Clip end point
         * @member {ptsl.IMediaTimePosition|null|undefined} endPoint
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.endPoint = null;

        /**
         * * Clip sync point
         * @member {ptsl.IMediaTimePosition|null|undefined} syncPoint
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.syncPoint = null;

        /**
         * * Multitrack Group clip name which current clip is a part of
         * @member {string} groupName
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.groupName = "";

        /**
         * * Start sample position in file
         * @member {ptsl.IMediaTimePosition|null|undefined} srcStartPoint
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.srcStartPoint = null;

        /**
         * * End sample position in file
         * @member {ptsl.IMediaTimePosition|null|undefined} srcEndPoint
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.srcEndPoint = null;

        /**
         * * Number of semitones in pitch transposition
         * @member {number} transposeSemitones
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.transposeSemitones = 0;

        /**
         * * Number of cents in pitch transposition
         * @member {number} transposeCents
         * @memberof ptsl.Clip
         * @instance
         */
        Clip.prototype.transposeCents = 0;

        /**
         * Creates a new Clip instance using the specified properties.
         * @function create
         * @memberof ptsl.Clip
         * @static
         * @param {ptsl.IClip=} [properties] Properties to set
         * @returns {ptsl.Clip} Clip instance
         */
        Clip.create = function create(properties) {
            return new Clip(properties);
        };

        /**
         * Encodes the specified Clip message. Does not implicitly {@link ptsl.Clip.verify|verify} messages.
         * @function encode
         * @memberof ptsl.Clip
         * @static
         * @param {ptsl.IClip} message Clip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Clip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileId);
            if (message.clipId != null && Object.hasOwnProperty.call(message, "clipId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clipId);
            if (message.clipFullName != null && Object.hasOwnProperty.call(message, "clipFullName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clipFullName);
            if (message.clipRootName != null && Object.hasOwnProperty.call(message, "clipRootName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.clipRootName);
            if (message.clipType != null && Object.hasOwnProperty.call(message, "clipType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.clipType);
            if (message.startPoint != null && Object.hasOwnProperty.call(message, "startPoint"))
                $root.ptsl.MediaTimePosition.encode(message.startPoint, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.endPoint != null && Object.hasOwnProperty.call(message, "endPoint"))
                $root.ptsl.MediaTimePosition.encode(message.endPoint, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.syncPoint != null && Object.hasOwnProperty.call(message, "syncPoint"))
                $root.ptsl.MediaTimePosition.encode(message.syncPoint, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.groupName);
            if (message.srcStartPoint != null && Object.hasOwnProperty.call(message, "srcStartPoint"))
                $root.ptsl.MediaTimePosition.encode(message.srcStartPoint, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.srcEndPoint != null && Object.hasOwnProperty.call(message, "srcEndPoint"))
                $root.ptsl.MediaTimePosition.encode(message.srcEndPoint, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.transposeSemitones != null && Object.hasOwnProperty.call(message, "transposeSemitones"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.transposeSemitones);
            if (message.transposeCents != null && Object.hasOwnProperty.call(message, "transposeCents"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.transposeCents);
            return writer;
        };

        /**
         * Encodes the specified Clip message, length delimited. Does not implicitly {@link ptsl.Clip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.Clip
         * @static
         * @param {ptsl.IClip} message Clip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Clip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Clip message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.Clip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.Clip} Clip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Clip.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.Clip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fileId = reader.string();
                        break;
                    }
                case 2: {
                        message.clipId = reader.string();
                        break;
                    }
                case 3: {
                        message.clipFullName = reader.string();
                        break;
                    }
                case 4: {
                        message.clipRootName = reader.string();
                        break;
                    }
                case 5: {
                        message.clipType = reader.int32();
                        break;
                    }
                case 6: {
                        message.startPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.endPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.syncPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.groupName = reader.string();
                        break;
                    }
                case 10: {
                        message.srcStartPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.srcEndPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.transposeSemitones = reader.int32();
                        break;
                    }
                case 13: {
                        message.transposeCents = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Clip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.Clip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.Clip} Clip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Clip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Clip message.
         * @function verify
         * @memberof ptsl.Clip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Clip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                if (!$util.isString(message.fileId))
                    return "fileId: string expected";
            if (message.clipId != null && message.hasOwnProperty("clipId"))
                if (!$util.isString(message.clipId))
                    return "clipId: string expected";
            if (message.clipFullName != null && message.hasOwnProperty("clipFullName"))
                if (!$util.isString(message.clipFullName))
                    return "clipFullName: string expected";
            if (message.clipRootName != null && message.hasOwnProperty("clipRootName"))
                if (!$util.isString(message.clipRootName))
                    return "clipRootName: string expected";
            if (message.clipType != null && message.hasOwnProperty("clipType"))
                switch (message.clipType) {
                default:
                    return "clipType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.startPoint != null && message.hasOwnProperty("startPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.startPoint);
                if (error)
                    return "startPoint." + error;
            }
            if (message.endPoint != null && message.hasOwnProperty("endPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.endPoint);
                if (error)
                    return "endPoint." + error;
            }
            if (message.syncPoint != null && message.hasOwnProperty("syncPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.syncPoint);
                if (error)
                    return "syncPoint." + error;
            }
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                if (!$util.isString(message.groupName))
                    return "groupName: string expected";
            if (message.srcStartPoint != null && message.hasOwnProperty("srcStartPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.srcStartPoint);
                if (error)
                    return "srcStartPoint." + error;
            }
            if (message.srcEndPoint != null && message.hasOwnProperty("srcEndPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.srcEndPoint);
                if (error)
                    return "srcEndPoint." + error;
            }
            if (message.transposeSemitones != null && message.hasOwnProperty("transposeSemitones"))
                if (!$util.isInteger(message.transposeSemitones))
                    return "transposeSemitones: integer expected";
            if (message.transposeCents != null && message.hasOwnProperty("transposeCents"))
                if (!$util.isInteger(message.transposeCents))
                    return "transposeCents: integer expected";
            return null;
        };

        /**
         * Creates a Clip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.Clip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.Clip} Clip
         */
        Clip.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.Clip)
                return object;
            var message = new $root.ptsl.Clip();
            if (object.fileId != null)
                message.fileId = String(object.fileId);
            if (object.clipId != null)
                message.clipId = String(object.clipId);
            if (object.clipFullName != null)
                message.clipFullName = String(object.clipFullName);
            if (object.clipRootName != null)
                message.clipRootName = String(object.clipRootName);
            switch (object.clipType) {
            default:
                if (typeof object.clipType === "number") {
                    message.clipType = object.clipType;
                    break;
                }
                break;
            case "ClipType_Unknown":
            case 0:
                message.clipType = 0;
                break;
            case "ClipType_Audio":
            case 1:
                message.clipType = 1;
                break;
            case "ClipType_Midi":
            case 2:
                message.clipType = 2;
                break;
            case "ClipType_Video":
            case 3:
                message.clipType = 3;
                break;
            case "ClipType_AudioClipGroup":
            case 4:
                message.clipType = 4;
                break;
            case "ClipType_MidiClipGroup":
            case 5:
                message.clipType = 5;
                break;
            case "ClipType_VideoClipGroup":
            case 6:
                message.clipType = 6;
                break;
            case "ClipType_MixedClipGroup":
            case 7:
                message.clipType = 7;
                break;
            }
            if (object.startPoint != null) {
                if (typeof object.startPoint !== "object")
                    throw TypeError(".ptsl.Clip.startPoint: object expected");
                message.startPoint = $root.ptsl.MediaTimePosition.fromObject(object.startPoint);
            }
            if (object.endPoint != null) {
                if (typeof object.endPoint !== "object")
                    throw TypeError(".ptsl.Clip.endPoint: object expected");
                message.endPoint = $root.ptsl.MediaTimePosition.fromObject(object.endPoint);
            }
            if (object.syncPoint != null) {
                if (typeof object.syncPoint !== "object")
                    throw TypeError(".ptsl.Clip.syncPoint: object expected");
                message.syncPoint = $root.ptsl.MediaTimePosition.fromObject(object.syncPoint);
            }
            if (object.groupName != null)
                message.groupName = String(object.groupName);
            if (object.srcStartPoint != null) {
                if (typeof object.srcStartPoint !== "object")
                    throw TypeError(".ptsl.Clip.srcStartPoint: object expected");
                message.srcStartPoint = $root.ptsl.MediaTimePosition.fromObject(object.srcStartPoint);
            }
            if (object.srcEndPoint != null) {
                if (typeof object.srcEndPoint !== "object")
                    throw TypeError(".ptsl.Clip.srcEndPoint: object expected");
                message.srcEndPoint = $root.ptsl.MediaTimePosition.fromObject(object.srcEndPoint);
            }
            if (object.transposeSemitones != null)
                message.transposeSemitones = object.transposeSemitones | 0;
            if (object.transposeCents != null)
                message.transposeCents = object.transposeCents | 0;
            return message;
        };

        /**
         * Creates a plain object from a Clip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.Clip
         * @static
         * @param {ptsl.Clip} message Clip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Clip.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fileId = "";
                object.clipId = "";
                object.clipFullName = "";
                object.clipRootName = "";
                object.clipType = options.enums === String ? "ClipType_Unknown" : 0;
                object.startPoint = null;
                object.endPoint = null;
                object.syncPoint = null;
                object.groupName = "";
                object.srcStartPoint = null;
                object.srcEndPoint = null;
                object.transposeSemitones = 0;
                object.transposeCents = 0;
            }
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                object.fileId = message.fileId;
            if (message.clipId != null && message.hasOwnProperty("clipId"))
                object.clipId = message.clipId;
            if (message.clipFullName != null && message.hasOwnProperty("clipFullName"))
                object.clipFullName = message.clipFullName;
            if (message.clipRootName != null && message.hasOwnProperty("clipRootName"))
                object.clipRootName = message.clipRootName;
            if (message.clipType != null && message.hasOwnProperty("clipType"))
                object.clipType = options.enums === String ? $root.ptsl.ClipType[message.clipType] === undefined ? message.clipType : $root.ptsl.ClipType[message.clipType] : message.clipType;
            if (message.startPoint != null && message.hasOwnProperty("startPoint"))
                object.startPoint = $root.ptsl.MediaTimePosition.toObject(message.startPoint, options);
            if (message.endPoint != null && message.hasOwnProperty("endPoint"))
                object.endPoint = $root.ptsl.MediaTimePosition.toObject(message.endPoint, options);
            if (message.syncPoint != null && message.hasOwnProperty("syncPoint"))
                object.syncPoint = $root.ptsl.MediaTimePosition.toObject(message.syncPoint, options);
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                object.groupName = message.groupName;
            if (message.srcStartPoint != null && message.hasOwnProperty("srcStartPoint"))
                object.srcStartPoint = $root.ptsl.MediaTimePosition.toObject(message.srcStartPoint, options);
            if (message.srcEndPoint != null && message.hasOwnProperty("srcEndPoint"))
                object.srcEndPoint = $root.ptsl.MediaTimePosition.toObject(message.srcEndPoint, options);
            if (message.transposeSemitones != null && message.hasOwnProperty("transposeSemitones"))
                object.transposeSemitones = message.transposeSemitones;
            if (message.transposeCents != null && message.hasOwnProperty("transposeCents"))
                object.transposeCents = message.transposeCents;
            return object;
        };

        /**
         * Converts this Clip to JSON.
         * @function toJSON
         * @memberof ptsl.Clip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Clip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Clip
         * @function getTypeUrl
         * @memberof ptsl.Clip
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Clip.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.Clip";
        };

        return Clip;
    })();

    ptsl.GetClipListRequestBody = (function() {

        /**
         * Properties of a GetClipListRequestBody.
         * @memberof ptsl
         * @interface IGetClipListRequestBody
         * @property {ptsl.IPaginationRequest|null} [paginationRequest] * (optional) Enable pagination and control limit and offset
         */

        /**
         * Constructs a new GetClipListRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetClipList request data.
         * @implements IGetClipListRequestBody
         * @constructor
         * @param {ptsl.IGetClipListRequestBody=} [properties] Properties to set
         */
        function GetClipListRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * (optional) Enable pagination and control limit and offset
         * @member {ptsl.IPaginationRequest|null|undefined} paginationRequest
         * @memberof ptsl.GetClipListRequestBody
         * @instance
         */
        GetClipListRequestBody.prototype.paginationRequest = null;

        /**
         * Creates a new GetClipListRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {ptsl.IGetClipListRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetClipListRequestBody} GetClipListRequestBody instance
         */
        GetClipListRequestBody.create = function create(properties) {
            return new GetClipListRequestBody(properties);
        };

        /**
         * Encodes the specified GetClipListRequestBody message. Does not implicitly {@link ptsl.GetClipListRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {ptsl.IGetClipListRequestBody} message GetClipListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClipListRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paginationRequest != null && Object.hasOwnProperty.call(message, "paginationRequest"))
                $root.ptsl.PaginationRequest.encode(message.paginationRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetClipListRequestBody message, length delimited. Does not implicitly {@link ptsl.GetClipListRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {ptsl.IGetClipListRequestBody} message GetClipListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClipListRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetClipListRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetClipListRequestBody} GetClipListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClipListRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetClipListRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.paginationRequest = $root.ptsl.PaginationRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetClipListRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetClipListRequestBody} GetClipListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClipListRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetClipListRequestBody message.
         * @function verify
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetClipListRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest")) {
                var error = $root.ptsl.PaginationRequest.verify(message.paginationRequest);
                if (error)
                    return "paginationRequest." + error;
            }
            return null;
        };

        /**
         * Creates a GetClipListRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetClipListRequestBody} GetClipListRequestBody
         */
        GetClipListRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetClipListRequestBody)
                return object;
            var message = new $root.ptsl.GetClipListRequestBody();
            if (object.paginationRequest != null) {
                if (typeof object.paginationRequest !== "object")
                    throw TypeError(".ptsl.GetClipListRequestBody.paginationRequest: object expected");
                message.paginationRequest = $root.ptsl.PaginationRequest.fromObject(object.paginationRequest);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetClipListRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {ptsl.GetClipListRequestBody} message GetClipListRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetClipListRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.paginationRequest = null;
            if (message.paginationRequest != null && message.hasOwnProperty("paginationRequest"))
                object.paginationRequest = $root.ptsl.PaginationRequest.toObject(message.paginationRequest, options);
            return object;
        };

        /**
         * Converts this GetClipListRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetClipListRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetClipListRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetClipListRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetClipListRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetClipListRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetClipListRequestBody";
        };

        return GetClipListRequestBody;
    })();

    ptsl.GetClipListResponseBody = (function() {

        /**
         * Properties of a GetClipListResponseBody.
         * @memberof ptsl
         * @interface IGetClipListResponseBody
         * @property {Array.<ptsl.IClip>|null} [clips] GetClipListResponseBody clips
         * @property {ptsl.IPaginationResponse|null} [paginationResponse] GetClipListResponseBody paginationResponse
         */

        /**
         * Constructs a new GetClipListResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetClipList response data.
         * @implements IGetClipListResponseBody
         * @constructor
         * @param {ptsl.IGetClipListResponseBody=} [properties] Properties to set
         */
        function GetClipListResponseBody(properties) {
            this.clips = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetClipListResponseBody clips.
         * @member {Array.<ptsl.IClip>} clips
         * @memberof ptsl.GetClipListResponseBody
         * @instance
         */
        GetClipListResponseBody.prototype.clips = $util.emptyArray;

        /**
         * GetClipListResponseBody paginationResponse.
         * @member {ptsl.IPaginationResponse|null|undefined} paginationResponse
         * @memberof ptsl.GetClipListResponseBody
         * @instance
         */
        GetClipListResponseBody.prototype.paginationResponse = null;

        /**
         * Creates a new GetClipListResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {ptsl.IGetClipListResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetClipListResponseBody} GetClipListResponseBody instance
         */
        GetClipListResponseBody.create = function create(properties) {
            return new GetClipListResponseBody(properties);
        };

        /**
         * Encodes the specified GetClipListResponseBody message. Does not implicitly {@link ptsl.GetClipListResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {ptsl.IGetClipListResponseBody} message GetClipListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClipListResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clips != null && message.clips.length)
                for (var i = 0; i < message.clips.length; ++i)
                    $root.ptsl.Clip.encode(message.clips[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.paginationResponse != null && Object.hasOwnProperty.call(message, "paginationResponse"))
                $root.ptsl.PaginationResponse.encode(message.paginationResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetClipListResponseBody message, length delimited. Does not implicitly {@link ptsl.GetClipListResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {ptsl.IGetClipListResponseBody} message GetClipListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClipListResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetClipListResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetClipListResponseBody} GetClipListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClipListResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetClipListResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.clips && message.clips.length))
                            message.clips = [];
                        message.clips.push($root.ptsl.Clip.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.paginationResponse = $root.ptsl.PaginationResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetClipListResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetClipListResponseBody} GetClipListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClipListResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetClipListResponseBody message.
         * @function verify
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetClipListResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clips != null && message.hasOwnProperty("clips")) {
                if (!Array.isArray(message.clips))
                    return "clips: array expected";
                for (var i = 0; i < message.clips.length; ++i) {
                    var error = $root.ptsl.Clip.verify(message.clips[i]);
                    if (error)
                        return "clips." + error;
                }
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse")) {
                var error = $root.ptsl.PaginationResponse.verify(message.paginationResponse);
                if (error)
                    return "paginationResponse." + error;
            }
            return null;
        };

        /**
         * Creates a GetClipListResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetClipListResponseBody} GetClipListResponseBody
         */
        GetClipListResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetClipListResponseBody)
                return object;
            var message = new $root.ptsl.GetClipListResponseBody();
            if (object.clips) {
                if (!Array.isArray(object.clips))
                    throw TypeError(".ptsl.GetClipListResponseBody.clips: array expected");
                message.clips = [];
                for (var i = 0; i < object.clips.length; ++i) {
                    if (typeof object.clips[i] !== "object")
                        throw TypeError(".ptsl.GetClipListResponseBody.clips: object expected");
                    message.clips[i] = $root.ptsl.Clip.fromObject(object.clips[i]);
                }
            }
            if (object.paginationResponse != null) {
                if (typeof object.paginationResponse !== "object")
                    throw TypeError(".ptsl.GetClipListResponseBody.paginationResponse: object expected");
                message.paginationResponse = $root.ptsl.PaginationResponse.fromObject(object.paginationResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetClipListResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {ptsl.GetClipListResponseBody} message GetClipListResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetClipListResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clips = [];
            if (options.defaults)
                object.paginationResponse = null;
            if (message.clips && message.clips.length) {
                object.clips = [];
                for (var j = 0; j < message.clips.length; ++j)
                    object.clips[j] = $root.ptsl.Clip.toObject(message.clips[j], options);
            }
            if (message.paginationResponse != null && message.hasOwnProperty("paginationResponse"))
                object.paginationResponse = $root.ptsl.PaginationResponse.toObject(message.paginationResponse, options);
            return object;
        };

        /**
         * Converts this GetClipListResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetClipListResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetClipListResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetClipListResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetClipListResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetClipListResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetClipListResponseBody";
        };

        return GetClipListResponseBody;
    })();

    ptsl.AudioFileInfo = (function() {

        /**
         * Properties of an AudioFileInfo.
         * @memberof ptsl
         * @interface IAudioFileInfo
         * @property {string|null} [fileId] * The local id of the file.
         * * @since Pro Tools 2025.06
         * @property {number|null} [numChannels] * The number of channels.
         * * @since Pro Tools 2025.06
         * @property {ptsl.SampleRate|null} [sampleRate] * The sample rate.
         * * @since Pro Tools 2025.06
         * @property {ptsl.BitDepth|null} [encoding] * The encoding (16-bit int, 24-bit int, 32-bit int, 32-bit float)
         * * @since Pro Tools 2025.06
         * @property {ptsl.FileType|null} [fileType] * The type of the file (WAV, AIFF, MXF currently)
         * * @since Pro Tools 2025.06
         * @property {string|null} [smpteUid] * The SMPTE ID of the file.
         * * @since Pro Tools 2025.06
         * @property {string|null} [protoolsUmid] * The id of the file.
         * * @since Pro Tools 2025.06
         * @property {ptsl.ITimelineLocation|null} [originalTimestamp] * The original timestamp of the file.
         * * @since Pro Tools 2025.06
         * @property {ptsl.ITimelineLocation|null} [userTimestamp] * The user timestamp of the file.
         * * @since Pro Tools 2025.06
         * @property {ptsl.ITimeLength|null} [length] AudioFileInfo length
         * @property {ptsl.StemFormat|null} [stemFormat] AudioFileInfo stemFormat
         */

        /**
         * Constructs a new AudioFileInfo.
         * @memberof ptsl
         * @classdesc Structure that describes audio file info.
         * 
         * @since Pro Tools 2025.06
         * @implements IAudioFileInfo
         * @constructor
         * @param {ptsl.IAudioFileInfo=} [properties] Properties to set
         */
        function AudioFileInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The local id of the file.
         * * @since Pro Tools 2025.06
         * @member {string} fileId
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.fileId = "";

        /**
         * * The number of channels.
         * * @since Pro Tools 2025.06
         * @member {number} numChannels
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.numChannels = 0;

        /**
         * * The sample rate.
         * * @since Pro Tools 2025.06
         * @member {ptsl.SampleRate} sampleRate
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.sampleRate = 0;

        /**
         * * The encoding (16-bit int, 24-bit int, 32-bit int, 32-bit float)
         * * @since Pro Tools 2025.06
         * @member {ptsl.BitDepth} encoding
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.encoding = 0;

        /**
         * * The type of the file (WAV, AIFF, MXF currently)
         * * @since Pro Tools 2025.06
         * @member {ptsl.FileType} fileType
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.fileType = 0;

        /**
         * * The SMPTE ID of the file.
         * * @since Pro Tools 2025.06
         * @member {string} smpteUid
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.smpteUid = "";

        /**
         * * The id of the file.
         * * @since Pro Tools 2025.06
         * @member {string} protoolsUmid
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.protoolsUmid = "";

        /**
         * * The original timestamp of the file.
         * * @since Pro Tools 2025.06
         * @member {ptsl.ITimelineLocation|null|undefined} originalTimestamp
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.originalTimestamp = null;

        /**
         * * The user timestamp of the file.
         * * @since Pro Tools 2025.06
         * @member {ptsl.ITimelineLocation|null|undefined} userTimestamp
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.userTimestamp = null;

        /**
         * AudioFileInfo length.
         * @member {ptsl.ITimeLength|null|undefined} length
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.length = null;

        /**
         * AudioFileInfo stemFormat.
         * @member {ptsl.StemFormat} stemFormat
         * @memberof ptsl.AudioFileInfo
         * @instance
         */
        AudioFileInfo.prototype.stemFormat = 0;

        /**
         * Creates a new AudioFileInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {ptsl.IAudioFileInfo=} [properties] Properties to set
         * @returns {ptsl.AudioFileInfo} AudioFileInfo instance
         */
        AudioFileInfo.create = function create(properties) {
            return new AudioFileInfo(properties);
        };

        /**
         * Encodes the specified AudioFileInfo message. Does not implicitly {@link ptsl.AudioFileInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {ptsl.IAudioFileInfo} message AudioFileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioFileInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileId);
            if (message.numChannels != null && Object.hasOwnProperty.call(message, "numChannels"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numChannels);
            if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sampleRate);
            if (message.encoding != null && Object.hasOwnProperty.call(message, "encoding"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.encoding);
            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.fileType);
            if (message.smpteUid != null && Object.hasOwnProperty.call(message, "smpteUid"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.smpteUid);
            if (message.protoolsUmid != null && Object.hasOwnProperty.call(message, "protoolsUmid"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.protoolsUmid);
            if (message.originalTimestamp != null && Object.hasOwnProperty.call(message, "originalTimestamp"))
                $root.ptsl.TimelineLocation.encode(message.originalTimestamp, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.userTimestamp != null && Object.hasOwnProperty.call(message, "userTimestamp"))
                $root.ptsl.TimelineLocation.encode(message.userTimestamp, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                $root.ptsl.TimeLength.encode(message.length, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.stemFormat != null && Object.hasOwnProperty.call(message, "stemFormat"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.stemFormat);
            return writer;
        };

        /**
         * Encodes the specified AudioFileInfo message, length delimited. Does not implicitly {@link ptsl.AudioFileInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {ptsl.IAudioFileInfo} message AudioFileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioFileInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AudioFileInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.AudioFileInfo} AudioFileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioFileInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.AudioFileInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fileId = reader.string();
                        break;
                    }
                case 2: {
                        message.numChannels = reader.int32();
                        break;
                    }
                case 3: {
                        message.sampleRate = reader.int32();
                        break;
                    }
                case 4: {
                        message.encoding = reader.int32();
                        break;
                    }
                case 5: {
                        message.fileType = reader.int32();
                        break;
                    }
                case 6: {
                        message.smpteUid = reader.string();
                        break;
                    }
                case 7: {
                        message.protoolsUmid = reader.string();
                        break;
                    }
                case 8: {
                        message.originalTimestamp = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.userTimestamp = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.length = $root.ptsl.TimeLength.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.stemFormat = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AudioFileInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.AudioFileInfo} AudioFileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioFileInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AudioFileInfo message.
         * @function verify
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AudioFileInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                if (!$util.isString(message.fileId))
                    return "fileId: string expected";
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                if (!$util.isInteger(message.numChannels))
                    return "numChannels: integer expected";
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                switch (message.sampleRate) {
                default:
                    return "sampleRate: enum value expected";
                case 0:
                case 1:
                case 1:
                case 44100:
                case 44100:
                case 48000:
                case 48000:
                case 88200:
                case 88200:
                case 96000:
                case 96000:
                case 176400:
                case 176400:
                case 192000:
                case 192000:
                    break;
                }
            if (message.encoding != null && message.hasOwnProperty("encoding"))
                switch (message.encoding) {
                default:
                    return "encoding: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                    break;
                }
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                switch (message.fileType) {
                default:
                    return "fileType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                    break;
                }
            if (message.smpteUid != null && message.hasOwnProperty("smpteUid"))
                if (!$util.isString(message.smpteUid))
                    return "smpteUid: string expected";
            if (message.protoolsUmid != null && message.hasOwnProperty("protoolsUmid"))
                if (!$util.isString(message.protoolsUmid))
                    return "protoolsUmid: string expected";
            if (message.originalTimestamp != null && message.hasOwnProperty("originalTimestamp")) {
                var error = $root.ptsl.TimelineLocation.verify(message.originalTimestamp);
                if (error)
                    return "originalTimestamp." + error;
            }
            if (message.userTimestamp != null && message.hasOwnProperty("userTimestamp")) {
                var error = $root.ptsl.TimelineLocation.verify(message.userTimestamp);
                if (error)
                    return "userTimestamp." + error;
            }
            if (message.length != null && message.hasOwnProperty("length")) {
                var error = $root.ptsl.TimeLength.verify(message.length);
                if (error)
                    return "length." + error;
            }
            if (message.stemFormat != null && message.hasOwnProperty("stemFormat"))
                switch (message.stemFormat) {
                default:
                    return "stemFormat: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                    break;
                }
            return null;
        };

        /**
         * Creates an AudioFileInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.AudioFileInfo} AudioFileInfo
         */
        AudioFileInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.AudioFileInfo)
                return object;
            var message = new $root.ptsl.AudioFileInfo();
            if (object.fileId != null)
                message.fileId = String(object.fileId);
            if (object.numChannels != null)
                message.numChannels = object.numChannels | 0;
            switch (object.sampleRate) {
            default:
                if (typeof object.sampleRate === "number") {
                    message.sampleRate = object.sampleRate;
                    break;
                }
                break;
            case "SRate_Unknown":
            case 0:
                message.sampleRate = 0;
                break;
            case "SR_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SRate_None":
            case 1:
                message.sampleRate = 1;
                break;
            case "SR_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SRate_44100":
            case 44100:
                message.sampleRate = 44100;
                break;
            case "SR_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SRate_48000":
            case 48000:
                message.sampleRate = 48000;
                break;
            case "SR_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SRate_88200":
            case 88200:
                message.sampleRate = 88200;
                break;
            case "SR_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SRate_96000":
            case 96000:
                message.sampleRate = 96000;
                break;
            case "SR_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SRate_176400":
            case 176400:
                message.sampleRate = 176400;
                break;
            case "SR_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            case "SRate_192000":
            case 192000:
                message.sampleRate = 192000;
                break;
            }
            switch (object.encoding) {
            default:
                if (typeof object.encoding === "number") {
                    message.encoding = object.encoding;
                    break;
                }
                break;
            case "BDepth_Unknown":
            case 0:
                message.encoding = 0;
                break;
            case "Bit_None":
            case 1:
                message.encoding = 1;
                break;
            case "BDepth_None":
            case 1:
                message.encoding = 1;
                break;
            case "Bit16":
            case 2:
                message.encoding = 2;
                break;
            case "BDepth_16":
            case 2:
                message.encoding = 2;
                break;
            case "Bit24":
            case 3:
                message.encoding = 3;
                break;
            case "BDepth_24":
            case 3:
                message.encoding = 3;
                break;
            case "Bit32Float":
            case 4:
                message.encoding = 4;
                break;
            case "BDepth_32Float":
            case 4:
                message.encoding = 4;
                break;
            }
            switch (object.fileType) {
            default:
                if (typeof object.fileType === "number") {
                    message.fileType = object.fileType;
                    break;
                }
                break;
            case "FType_Unknown":
            case 0:
                message.fileType = 0;
                break;
            case "FT_WAVE":
            case 1:
                message.fileType = 1;
                break;
            case "FType_WAVE":
            case 1:
                message.fileType = 1;
                break;
            case "FT_AIFF":
            case 2:
                message.fileType = 2;
                break;
            case "FType_AIFF":
            case 2:
                message.fileType = 2;
                break;
            case "FT_AAF":
            case 3:
                message.fileType = 3;
                break;
            case "FType_AAF":
            case 3:
                message.fileType = 3;
                break;
            case "FT_OMF":
            case 4:
                message.fileType = 4;
                break;
            case "FType_OMF":
            case 4:
                message.fileType = 4;
                break;
            case "FType_MXF":
            case 5:
                message.fileType = 5;
                break;
            }
            if (object.smpteUid != null)
                message.smpteUid = String(object.smpteUid);
            if (object.protoolsUmid != null)
                message.protoolsUmid = String(object.protoolsUmid);
            if (object.originalTimestamp != null) {
                if (typeof object.originalTimestamp !== "object")
                    throw TypeError(".ptsl.AudioFileInfo.originalTimestamp: object expected");
                message.originalTimestamp = $root.ptsl.TimelineLocation.fromObject(object.originalTimestamp);
            }
            if (object.userTimestamp != null) {
                if (typeof object.userTimestamp !== "object")
                    throw TypeError(".ptsl.AudioFileInfo.userTimestamp: object expected");
                message.userTimestamp = $root.ptsl.TimelineLocation.fromObject(object.userTimestamp);
            }
            if (object.length != null) {
                if (typeof object.length !== "object")
                    throw TypeError(".ptsl.AudioFileInfo.length: object expected");
                message.length = $root.ptsl.TimeLength.fromObject(object.length);
            }
            switch (object.stemFormat) {
            default:
                if (typeof object.stemFormat === "number") {
                    message.stemFormat = object.stemFormat;
                    break;
                }
                break;
            case "SFormat_Unknown":
            case 0:
                message.stemFormat = 0;
                break;
            case "SFormat_Mono":
            case 1:
                message.stemFormat = 1;
                break;
            case "SFormat_Stereo":
            case 2:
                message.stemFormat = 2;
                break;
            case "SFormat_LCR":
            case 3:
                message.stemFormat = 3;
                break;
            case "SFormat_LCRS":
            case 4:
                message.stemFormat = 4;
                break;
            case "SFormat_Quad":
            case 5:
                message.stemFormat = 5;
                break;
            case "SFormat_5_0":
            case 6:
                message.stemFormat = 6;
                break;
            case "SFormat_5_1":
            case 7:
                message.stemFormat = 7;
                break;
            case "SFormat_5_0_2":
            case 8:
                message.stemFormat = 8;
                break;
            case "SFormat_5_1_2":
            case 9:
                message.stemFormat = 9;
                break;
            case "SFormat_5_0_4":
            case 10:
                message.stemFormat = 10;
                break;
            case "SFormat_5_1_4":
            case 11:
                message.stemFormat = 11;
                break;
            case "SFormat_6_0":
            case 12:
                message.stemFormat = 12;
                break;
            case "SFormat_6_1":
            case 13:
                message.stemFormat = 13;
                break;
            case "SFormat_7_0":
            case 14:
                message.stemFormat = 14;
                break;
            case "SFormat_7_1":
            case 15:
                message.stemFormat = 15;
                break;
            case "SFormat_7_0_SDDS":
            case 16:
                message.stemFormat = 16;
                break;
            case "SFormat_7_1_SDDS":
            case 17:
                message.stemFormat = 17;
                break;
            case "SFormat_7_0_2":
            case 18:
                message.stemFormat = 18;
                break;
            case "SFormat_7_1_2":
            case 19:
                message.stemFormat = 19;
                break;
            case "SFormat_7_0_4":
            case 20:
                message.stemFormat = 20;
                break;
            case "SFormat_7_1_4":
            case 21:
                message.stemFormat = 21;
                break;
            case "SFormat_7_0_6":
            case 22:
                message.stemFormat = 22;
                break;
            case "SFormat_7_1_6":
            case 23:
                message.stemFormat = 23;
                break;
            case "SFormat_9_0_4":
            case 24:
                message.stemFormat = 24;
                break;
            case "SFormat_9_1_4":
            case 25:
                message.stemFormat = 25;
                break;
            case "SFormat_9_0_6":
            case 26:
                message.stemFormat = 26;
                break;
            case "SFormat_9_1_6":
            case 27:
                message.stemFormat = 27;
                break;
            case "SFormat_1stOrderAmbisonics":
            case 28:
                message.stemFormat = 28;
                break;
            case "SFormat_2ndOrderAmbisonics":
            case 29:
                message.stemFormat = 29;
                break;
            case "SFormat_3rdOrderAmbisonics":
            case 30:
                message.stemFormat = 30;
                break;
            case "SFormat_4thOrderAmbisonics":
            case 31:
                message.stemFormat = 31;
                break;
            case "SFormat_5thOrderAmbisonics":
            case 32:
                message.stemFormat = 32;
                break;
            case "SFormat_6thOrderAmbisonics":
            case 33:
                message.stemFormat = 33;
                break;
            case "SFormat_7thOrderAmbisonics":
            case 34:
                message.stemFormat = 34;
                break;
            case "SFormat_None":
            case 35:
                message.stemFormat = 35;
                break;
            case "SFormat_2_1":
            case 36:
                message.stemFormat = 36;
                break;
            case "SFormat_Overhead":
            case 37:
                message.stemFormat = 37;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AudioFileInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {ptsl.AudioFileInfo} message AudioFileInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AudioFileInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fileId = "";
                object.numChannels = 0;
                object.sampleRate = options.enums === String ? "SRate_Unknown" : 0;
                object.encoding = options.enums === String ? "BDepth_Unknown" : 0;
                object.fileType = options.enums === String ? "FType_Unknown" : 0;
                object.smpteUid = "";
                object.protoolsUmid = "";
                object.originalTimestamp = null;
                object.userTimestamp = null;
                object.length = null;
                object.stemFormat = options.enums === String ? "SFormat_Unknown" : 0;
            }
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                object.fileId = message.fileId;
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                object.numChannels = message.numChannels;
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                object.sampleRate = options.enums === String ? $root.ptsl.SampleRate[message.sampleRate] === undefined ? message.sampleRate : $root.ptsl.SampleRate[message.sampleRate] : message.sampleRate;
            if (message.encoding != null && message.hasOwnProperty("encoding"))
                object.encoding = options.enums === String ? $root.ptsl.BitDepth[message.encoding] === undefined ? message.encoding : $root.ptsl.BitDepth[message.encoding] : message.encoding;
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.ptsl.FileType[message.fileType] === undefined ? message.fileType : $root.ptsl.FileType[message.fileType] : message.fileType;
            if (message.smpteUid != null && message.hasOwnProperty("smpteUid"))
                object.smpteUid = message.smpteUid;
            if (message.protoolsUmid != null && message.hasOwnProperty("protoolsUmid"))
                object.protoolsUmid = message.protoolsUmid;
            if (message.originalTimestamp != null && message.hasOwnProperty("originalTimestamp"))
                object.originalTimestamp = $root.ptsl.TimelineLocation.toObject(message.originalTimestamp, options);
            if (message.userTimestamp != null && message.hasOwnProperty("userTimestamp"))
                object.userTimestamp = $root.ptsl.TimelineLocation.toObject(message.userTimestamp, options);
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = $root.ptsl.TimeLength.toObject(message.length, options);
            if (message.stemFormat != null && message.hasOwnProperty("stemFormat"))
                object.stemFormat = options.enums === String ? $root.ptsl.StemFormat[message.stemFormat] === undefined ? message.stemFormat : $root.ptsl.StemFormat[message.stemFormat] : message.stemFormat;
            return object;
        };

        /**
         * Converts this AudioFileInfo to JSON.
         * @function toJSON
         * @memberof ptsl.AudioFileInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AudioFileInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AudioFileInfo
         * @function getTypeUrl
         * @memberof ptsl.AudioFileInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AudioFileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.AudioFileInfo";
        };

        return AudioFileInfo;
    })();

    ptsl.GetMediaFileInfoRequestBody = (function() {

        /**
         * Properties of a GetMediaFileInfoRequestBody.
         * @memberof ptsl
         * @interface IGetMediaFileInfoRequestBody
         * @property {string|null} [fileId] * The id of the file.
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new GetMediaFileInfoRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetMediaFileInfo request data.
         * 
         * @since Pro Tools 2025.06
         * @implements IGetMediaFileInfoRequestBody
         * @constructor
         * @param {ptsl.IGetMediaFileInfoRequestBody=} [properties] Properties to set
         */
        function GetMediaFileInfoRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The id of the file.
         * * @since Pro Tools 2025.06
         * @member {string} fileId
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @instance
         */
        GetMediaFileInfoRequestBody.prototype.fileId = "";

        /**
         * Creates a new GetMediaFileInfoRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {ptsl.IGetMediaFileInfoRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetMediaFileInfoRequestBody} GetMediaFileInfoRequestBody instance
         */
        GetMediaFileInfoRequestBody.create = function create(properties) {
            return new GetMediaFileInfoRequestBody(properties);
        };

        /**
         * Encodes the specified GetMediaFileInfoRequestBody message. Does not implicitly {@link ptsl.GetMediaFileInfoRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {ptsl.IGetMediaFileInfoRequestBody} message GetMediaFileInfoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMediaFileInfoRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileId);
            return writer;
        };

        /**
         * Encodes the specified GetMediaFileInfoRequestBody message, length delimited. Does not implicitly {@link ptsl.GetMediaFileInfoRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {ptsl.IGetMediaFileInfoRequestBody} message GetMediaFileInfoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMediaFileInfoRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMediaFileInfoRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetMediaFileInfoRequestBody} GetMediaFileInfoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMediaFileInfoRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetMediaFileInfoRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fileId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMediaFileInfoRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetMediaFileInfoRequestBody} GetMediaFileInfoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMediaFileInfoRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMediaFileInfoRequestBody message.
         * @function verify
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMediaFileInfoRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                if (!$util.isString(message.fileId))
                    return "fileId: string expected";
            return null;
        };

        /**
         * Creates a GetMediaFileInfoRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetMediaFileInfoRequestBody} GetMediaFileInfoRequestBody
         */
        GetMediaFileInfoRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetMediaFileInfoRequestBody)
                return object;
            var message = new $root.ptsl.GetMediaFileInfoRequestBody();
            if (object.fileId != null)
                message.fileId = String(object.fileId);
            return message;
        };

        /**
         * Creates a plain object from a GetMediaFileInfoRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {ptsl.GetMediaFileInfoRequestBody} message GetMediaFileInfoRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMediaFileInfoRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fileId = "";
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                object.fileId = message.fileId;
            return object;
        };

        /**
         * Converts this GetMediaFileInfoRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMediaFileInfoRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetMediaFileInfoRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetMediaFileInfoRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMediaFileInfoRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetMediaFileInfoRequestBody";
        };

        return GetMediaFileInfoRequestBody;
    })();

    ptsl.GetMediaFileInfoResponseBody = (function() {

        /**
         * Properties of a GetMediaFileInfoResponseBody.
         * @memberof ptsl
         * @interface IGetMediaFileInfoResponseBody
         * @property {ptsl.IAudioFileInfo|null} [audioFileInfo] * The audio file information.
         * * @since Pro Tools 2025.06
         */

        /**
         * Constructs a new GetMediaFileInfoResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetMediaFileInfo response data.
         * 
         * @since Pro Tools 2025.06
         * @implements IGetMediaFileInfoResponseBody
         * @constructor
         * @param {ptsl.IGetMediaFileInfoResponseBody=} [properties] Properties to set
         */
        function GetMediaFileInfoResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * The audio file information.
         * * @since Pro Tools 2025.06
         * @member {ptsl.IAudioFileInfo|null|undefined} audioFileInfo
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @instance
         */
        GetMediaFileInfoResponseBody.prototype.audioFileInfo = null;

        /**
         * Creates a new GetMediaFileInfoResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {ptsl.IGetMediaFileInfoResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetMediaFileInfoResponseBody} GetMediaFileInfoResponseBody instance
         */
        GetMediaFileInfoResponseBody.create = function create(properties) {
            return new GetMediaFileInfoResponseBody(properties);
        };

        /**
         * Encodes the specified GetMediaFileInfoResponseBody message. Does not implicitly {@link ptsl.GetMediaFileInfoResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {ptsl.IGetMediaFileInfoResponseBody} message GetMediaFileInfoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMediaFileInfoResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audioFileInfo != null && Object.hasOwnProperty.call(message, "audioFileInfo"))
                $root.ptsl.AudioFileInfo.encode(message.audioFileInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetMediaFileInfoResponseBody message, length delimited. Does not implicitly {@link ptsl.GetMediaFileInfoResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {ptsl.IGetMediaFileInfoResponseBody} message GetMediaFileInfoResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMediaFileInfoResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMediaFileInfoResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetMediaFileInfoResponseBody} GetMediaFileInfoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMediaFileInfoResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetMediaFileInfoResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.audioFileInfo = $root.ptsl.AudioFileInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMediaFileInfoResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetMediaFileInfoResponseBody} GetMediaFileInfoResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMediaFileInfoResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMediaFileInfoResponseBody message.
         * @function verify
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMediaFileInfoResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audioFileInfo != null && message.hasOwnProperty("audioFileInfo")) {
                var error = $root.ptsl.AudioFileInfo.verify(message.audioFileInfo);
                if (error)
                    return "audioFileInfo." + error;
            }
            return null;
        };

        /**
         * Creates a GetMediaFileInfoResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetMediaFileInfoResponseBody} GetMediaFileInfoResponseBody
         */
        GetMediaFileInfoResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetMediaFileInfoResponseBody)
                return object;
            var message = new $root.ptsl.GetMediaFileInfoResponseBody();
            if (object.audioFileInfo != null) {
                if (typeof object.audioFileInfo !== "object")
                    throw TypeError(".ptsl.GetMediaFileInfoResponseBody.audioFileInfo: object expected");
                message.audioFileInfo = $root.ptsl.AudioFileInfo.fromObject(object.audioFileInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetMediaFileInfoResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {ptsl.GetMediaFileInfoResponseBody} message GetMediaFileInfoResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMediaFileInfoResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.audioFileInfo = null;
            if (message.audioFileInfo != null && message.hasOwnProperty("audioFileInfo"))
                object.audioFileInfo = $root.ptsl.AudioFileInfo.toObject(message.audioFileInfo, options);
            return object;
        };

        /**
         * Converts this GetMediaFileInfoResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMediaFileInfoResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetMediaFileInfoResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetMediaFileInfoResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMediaFileInfoResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetMediaFileInfoResponseBody";
        };

        return GetMediaFileInfoResponseBody;
    })();

    /**
     * Stem format.
     * 
     * @since Pro Tools 2025.06
     * @name ptsl.StemFormat
     * @enum {number}
     * @property {number} SFormat_Unknown=0 * Tech-only value. Don't use it in requests.
     * @property {number} SFormat_Mono=1 * Mono format.
     * @property {number} SFormat_Stereo=2 * Stereo format.
     * @property {number} SFormat_LCR=3 * LCR format.
     * @property {number} SFormat_LCRS=4 * LCRS format.
     * @property {number} SFormat_Quad=5 * Quad format.
     * @property {number} SFormat_5_0=6 * 5.0 format.
     * @property {number} SFormat_5_1=7 * 5.1 format.
     * @property {number} SFormat_5_0_2=8 * 5.0.2 format.
     * @property {number} SFormat_5_1_2=9 * 5.1.2 format.
     * @property {number} SFormat_5_0_4=10 * 5.0.4 format.
     * @property {number} SFormat_5_1_4=11 * 5.1.4 format.
     * @property {number} SFormat_6_0=12 * 6.0 format.
     * @property {number} SFormat_6_1=13 * 6.1 format.
     * @property {number} SFormat_7_0=14 * 7.0 format.
     * @property {number} SFormat_7_1=15 * 7.1 format.
     * @property {number} SFormat_7_0_SDDS=16 * 7.0 SDDS format.
     * @property {number} SFormat_7_1_SDDS=17 * 7.1 SDDS format.
     * @property {number} SFormat_7_0_2=18 * 7.0.2 format.
     * @property {number} SFormat_7_1_2=19 * 7.1.2 format.
     * @property {number} SFormat_7_0_4=20 * 7.0.4 format.
     * @property {number} SFormat_7_1_4=21 * 7.1.4 format.
     * @property {number} SFormat_7_0_6=22 * 7.0.6 format.
     * @property {number} SFormat_7_1_6=23 * 7.1.6 format.
     * @property {number} SFormat_9_0_4=24 * 9.0.4 format.
     * @property {number} SFormat_9_1_4=25 * 9.1.4 format.
     * @property {number} SFormat_9_0_6=26 * 9.0.6 format.
     * @property {number} SFormat_9_1_6=27 * 9.1.6 format.
     * @property {number} SFormat_1stOrderAmbisonics=28 * 1st Order Ambisonics format.
     * @property {number} SFormat_2ndOrderAmbisonics=29 * 2nd Order Ambisonics format.
     * @property {number} SFormat_3rdOrderAmbisonics=30 * 3rd Order Ambisonics format.
     * @property {number} SFormat_4thOrderAmbisonics=31 * 4th Order Ambisonics format.
     * @property {number} SFormat_5thOrderAmbisonics=32 * 5th Order Ambisonics format.
     * @property {number} SFormat_6thOrderAmbisonics=33 * 6th Order Ambisonics format.
     * @property {number} SFormat_7thOrderAmbisonics=34 * 7th Order Ambisonics format.
     * @property {number} SFormat_None=35 * No format.
     * @property {number} SFormat_2_1=36 * 2.1 format.
     * @property {number} SFormat_Overhead=37 * Overhead format.
     */
    ptsl.StemFormat = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SFormat_Unknown"] = 0;
        values[valuesById[1] = "SFormat_Mono"] = 1;
        values[valuesById[2] = "SFormat_Stereo"] = 2;
        values[valuesById[3] = "SFormat_LCR"] = 3;
        values[valuesById[4] = "SFormat_LCRS"] = 4;
        values[valuesById[5] = "SFormat_Quad"] = 5;
        values[valuesById[6] = "SFormat_5_0"] = 6;
        values[valuesById[7] = "SFormat_5_1"] = 7;
        values[valuesById[8] = "SFormat_5_0_2"] = 8;
        values[valuesById[9] = "SFormat_5_1_2"] = 9;
        values[valuesById[10] = "SFormat_5_0_4"] = 10;
        values[valuesById[11] = "SFormat_5_1_4"] = 11;
        values[valuesById[12] = "SFormat_6_0"] = 12;
        values[valuesById[13] = "SFormat_6_1"] = 13;
        values[valuesById[14] = "SFormat_7_0"] = 14;
        values[valuesById[15] = "SFormat_7_1"] = 15;
        values[valuesById[16] = "SFormat_7_0_SDDS"] = 16;
        values[valuesById[17] = "SFormat_7_1_SDDS"] = 17;
        values[valuesById[18] = "SFormat_7_0_2"] = 18;
        values[valuesById[19] = "SFormat_7_1_2"] = 19;
        values[valuesById[20] = "SFormat_7_0_4"] = 20;
        values[valuesById[21] = "SFormat_7_1_4"] = 21;
        values[valuesById[22] = "SFormat_7_0_6"] = 22;
        values[valuesById[23] = "SFormat_7_1_6"] = 23;
        values[valuesById[24] = "SFormat_9_0_4"] = 24;
        values[valuesById[25] = "SFormat_9_1_4"] = 25;
        values[valuesById[26] = "SFormat_9_0_6"] = 26;
        values[valuesById[27] = "SFormat_9_1_6"] = 27;
        values[valuesById[28] = "SFormat_1stOrderAmbisonics"] = 28;
        values[valuesById[29] = "SFormat_2ndOrderAmbisonics"] = 29;
        values[valuesById[30] = "SFormat_3rdOrderAmbisonics"] = 30;
        values[valuesById[31] = "SFormat_4thOrderAmbisonics"] = 31;
        values[valuesById[32] = "SFormat_5thOrderAmbisonics"] = 32;
        values[valuesById[33] = "SFormat_6thOrderAmbisonics"] = 33;
        values[valuesById[34] = "SFormat_7thOrderAmbisonics"] = 34;
        values[valuesById[35] = "SFormat_None"] = 35;
        values[valuesById[36] = "SFormat_2_1"] = 36;
        values[valuesById[37] = "SFormat_Overhead"] = 37;
        return values;
    })();

    /**
     * Stem channel.
     * 
     * @since Pro Tools 2025.06
     * @name ptsl.StemChannel
     * @enum {number}
     * @property {number} SChannel_Unknown=0 * Tech-only value. Don't use it in requests.
     * @property {number} SChannel_Mono=1 * Mono channel.
     * @property {number} SChannel_Left=2 * Left channel.
     * @property {number} SChannel_Right=3 * Right channel.
     * @property {number} SChannel_Center=4 * Center channel.
     * @property {number} SChannel_LeftSurround=5 * Left Surround Rear / Left Surround channel.
     * @property {number} SChannel_CenterSurround=6 * Center Surround channel.
     * @property {number} SChannel_RightSurround=7 * Right Surround Rear / Right Surround channel.
     * @property {number} SChannel_Surround=8 * Surround channel.
     * @property {number} SChannel_LeftCenter=9 * Left Center channel.
     * @property {number} SChannel_RightCenter=10 * Right Center channel.
     * @property {number} SChannel_LeftSide=11 * Left Surround Side channel.
     * @property {number} SChannel_RightSide=12 * Right Surround Side channel.
     * @property {number} SChannel_LeftFrontHeight=13 * Left Top Front (for Atmos StemFormats) / Left Top Surround channel.
     * @property {number} SChannel_RightFrontHeight=14 * Right Top Front (for Atmos StemFormats) / Right Top Surround channel.
     * @property {number} SChannel_LeftTopMiddle=15 * Left Top Middle channel.
     * @property {number} SChannel_RightTopMiddle=16 * Right Top Middle channel.
     * @property {number} SChannel_LeftTopFront=17 * Left Top Front channel.
     * @property {number} SChannel_RightTopFront=18 * Right Top Front channel.
     * @property {number} SChannel_LeftTopRear=19 * Left Top Rear channel.
     * @property {number} SChannel_RightTopRear=20 * Right Top Rear channel.
     * @property {number} SChannel_LeftWide=21 * Left Wide channel.
     * @property {number} SChannel_RightWide=22 * Right Wide channel.
     * @property {number} SChannel_LFE=23 * LFE channel.
     * @property {number} SChannel_0=24 * 00 channel.
     * @property {number} SChannel_1=25 * 01 channel.
     * @property {number} SChannel_2=26 * 02 channel.
     * @property {number} SChannel_3=27 * 03 channel.
     * @property {number} SChannel_4=28 * 04 channel.
     * @property {number} SChannel_5=29 * 05 channel.
     * @property {number} SChannel_6=30 * 06 channel.
     * @property {number} SChannel_7=31 * 07 channel.
     * @property {number} SChannel_8=32 * 08 channel.
     * @property {number} SChannel_9=33 * 09 channel.
     * @property {number} SChannel_10=34 * 10 channel.
     * @property {number} SChannel_11=35 * 11 channel.
     * @property {number} SChannel_12=36 * 12 channel.
     * @property {number} SChannel_13=37 * 13 channel.
     * @property {number} SChannel_14=38 * 14 channel.
     * @property {number} SChannel_15=39 * 15 channel.
     * @property {number} SChannel_16=40 * 16 channel.
     * @property {number} SChannel_17=41 * 17 channel.
     * @property {number} SChannel_18=42 * 18 channel.
     * @property {number} SChannel_19=43 * 19 channel.
     * @property {number} SChannel_20=44 * 20 channel.
     * @property {number} SChannel_21=45 * 21 channel.
     * @property {number} SChannel_22=46 * 22 channel.
     * @property {number} SChannel_23=47 * 23 channel.
     * @property {number} SChannel_24=48 * 24 channel.
     * @property {number} SChannel_25=49 * 25 channel.
     * @property {number} SChannel_26=50 * 26 channel.
     * @property {number} SChannel_27=51 * 27 channel.
     * @property {number} SChannel_28=52 * 28 channel.
     * @property {number} SChannel_29=53 * 29 channel.
     * @property {number} SChannel_30=54 * 30 channel.
     * @property {number} SChannel_31=55 * 31 channel.
     * @property {number} SChannel_32=56 * 32 channel.
     * @property {number} SChannel_33=57 * 33 channel.
     * @property {number} SChannel_34=58 * 34 channel.
     * @property {number} SChannel_35=59 * 35 channel.
     * @property {number} SChannel_36=60 * 36 channel.
     * @property {number} SChannel_37=61 * 37 channel.
     * @property {number} SChannel_38=62 * 38 channel.
     * @property {number} SChannel_39=63 * 39 channel.
     * @property {number} SChannel_40=64 * 40 channel.
     * @property {number} SChannel_41=65 * 41 channel.
     * @property {number} SChannel_42=66 * 42 channel.
     * @property {number} SChannel_43=67 * 43 channel.
     * @property {number} SChannel_44=68 * 44 channel.
     * @property {number} SChannel_45=69 * 45 channel.
     * @property {number} SChannel_46=70 * 46 channel.
     * @property {number} SChannel_47=71 * 47 channel.
     * @property {number} SChannel_48=72 * 48 channel.
     * @property {number} SChannel_49=73 * 49 channel.
     * @property {number} SChannel_50=74 * 50 channel.
     * @property {number} SChannel_51=75 * 51 channel.
     * @property {number} SChannel_52=76 * 52 channel.
     * @property {number} SChannel_53=77 * 53 channel.
     * @property {number} SChannel_54=78 * 54 channel.
     * @property {number} SChannel_55=79 * 55 channel.
     * @property {number} SChannel_56=80 * 56 channel.
     * @property {number} SChannel_57=81 * 57 channel.
     * @property {number} SChannel_58=82 * 58 channel.
     * @property {number} SChannel_59=83 * 59 channel.
     * @property {number} SChannel_60=84 * 60 channel.
     * @property {number} SChannel_61=85 * 61 channel.
     * @property {number} SChannel_62=86 * 62 channel.
     * @property {number} SChannel_63=87 * 63 channel.
     */
    ptsl.StemChannel = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SChannel_Unknown"] = 0;
        values[valuesById[1] = "SChannel_Mono"] = 1;
        values[valuesById[2] = "SChannel_Left"] = 2;
        values[valuesById[3] = "SChannel_Right"] = 3;
        values[valuesById[4] = "SChannel_Center"] = 4;
        values[valuesById[5] = "SChannel_LeftSurround"] = 5;
        values[valuesById[6] = "SChannel_CenterSurround"] = 6;
        values[valuesById[7] = "SChannel_RightSurround"] = 7;
        values[valuesById[8] = "SChannel_Surround"] = 8;
        values[valuesById[9] = "SChannel_LeftCenter"] = 9;
        values[valuesById[10] = "SChannel_RightCenter"] = 10;
        values[valuesById[11] = "SChannel_LeftSide"] = 11;
        values[valuesById[12] = "SChannel_RightSide"] = 12;
        values[valuesById[13] = "SChannel_LeftFrontHeight"] = 13;
        values[valuesById[14] = "SChannel_RightFrontHeight"] = 14;
        values[valuesById[15] = "SChannel_LeftTopMiddle"] = 15;
        values[valuesById[16] = "SChannel_RightTopMiddle"] = 16;
        values[valuesById[17] = "SChannel_LeftTopFront"] = 17;
        values[valuesById[18] = "SChannel_RightTopFront"] = 18;
        values[valuesById[19] = "SChannel_LeftTopRear"] = 19;
        values[valuesById[20] = "SChannel_RightTopRear"] = 20;
        values[valuesById[21] = "SChannel_LeftWide"] = 21;
        values[valuesById[22] = "SChannel_RightWide"] = 22;
        values[valuesById[23] = "SChannel_LFE"] = 23;
        values[valuesById[24] = "SChannel_0"] = 24;
        values[valuesById[25] = "SChannel_1"] = 25;
        values[valuesById[26] = "SChannel_2"] = 26;
        values[valuesById[27] = "SChannel_3"] = 27;
        values[valuesById[28] = "SChannel_4"] = 28;
        values[valuesById[29] = "SChannel_5"] = 29;
        values[valuesById[30] = "SChannel_6"] = 30;
        values[valuesById[31] = "SChannel_7"] = 31;
        values[valuesById[32] = "SChannel_8"] = 32;
        values[valuesById[33] = "SChannel_9"] = 33;
        values[valuesById[34] = "SChannel_10"] = 34;
        values[valuesById[35] = "SChannel_11"] = 35;
        values[valuesById[36] = "SChannel_12"] = 36;
        values[valuesById[37] = "SChannel_13"] = 37;
        values[valuesById[38] = "SChannel_14"] = 38;
        values[valuesById[39] = "SChannel_15"] = 39;
        values[valuesById[40] = "SChannel_16"] = 40;
        values[valuesById[41] = "SChannel_17"] = 41;
        values[valuesById[42] = "SChannel_18"] = 42;
        values[valuesById[43] = "SChannel_19"] = 43;
        values[valuesById[44] = "SChannel_20"] = 44;
        values[valuesById[45] = "SChannel_21"] = 45;
        values[valuesById[46] = "SChannel_22"] = 46;
        values[valuesById[47] = "SChannel_23"] = 47;
        values[valuesById[48] = "SChannel_24"] = 48;
        values[valuesById[49] = "SChannel_25"] = 49;
        values[valuesById[50] = "SChannel_26"] = 50;
        values[valuesById[51] = "SChannel_27"] = 51;
        values[valuesById[52] = "SChannel_28"] = 52;
        values[valuesById[53] = "SChannel_29"] = 53;
        values[valuesById[54] = "SChannel_30"] = 54;
        values[valuesById[55] = "SChannel_31"] = 55;
        values[valuesById[56] = "SChannel_32"] = 56;
        values[valuesById[57] = "SChannel_33"] = 57;
        values[valuesById[58] = "SChannel_34"] = 58;
        values[valuesById[59] = "SChannel_35"] = 59;
        values[valuesById[60] = "SChannel_36"] = 60;
        values[valuesById[61] = "SChannel_37"] = 61;
        values[valuesById[62] = "SChannel_38"] = 62;
        values[valuesById[63] = "SChannel_39"] = 63;
        values[valuesById[64] = "SChannel_40"] = 64;
        values[valuesById[65] = "SChannel_41"] = 65;
        values[valuesById[66] = "SChannel_42"] = 66;
        values[valuesById[67] = "SChannel_43"] = 67;
        values[valuesById[68] = "SChannel_44"] = 68;
        values[valuesById[69] = "SChannel_45"] = 69;
        values[valuesById[70] = "SChannel_46"] = 70;
        values[valuesById[71] = "SChannel_47"] = 71;
        values[valuesById[72] = "SChannel_48"] = 72;
        values[valuesById[73] = "SChannel_49"] = 73;
        values[valuesById[74] = "SChannel_50"] = 74;
        values[valuesById[75] = "SChannel_51"] = 75;
        values[valuesById[76] = "SChannel_52"] = 76;
        values[valuesById[77] = "SChannel_53"] = 77;
        values[valuesById[78] = "SChannel_54"] = 78;
        values[valuesById[79] = "SChannel_55"] = 79;
        values[valuesById[80] = "SChannel_56"] = 80;
        values[valuesById[81] = "SChannel_57"] = 81;
        values[valuesById[82] = "SChannel_58"] = 82;
        values[valuesById[83] = "SChannel_59"] = 83;
        values[valuesById[84] = "SChannel_60"] = 84;
        values[valuesById[85] = "SChannel_61"] = 85;
        values[valuesById[86] = "SChannel_62"] = 86;
        values[valuesById[87] = "SChannel_63"] = 87;
        return values;
    })();

    ptsl.StemChannelId = (function() {

        /**
         * Properties of a StemChannelId.
         * @memberof ptsl
         * @interface IStemChannelId
         * @property {ptsl.StemChannel|null} [name] * Channel named identifier.
         * @property {number|null} [index] * Channel index identifier. Used with StemFormat.
         */

        /**
         * Constructs a new StemChannelId.
         * @memberof ptsl
         * @classdesc Structure that describes stem channel either by name or by index.
         * 
         * @since Pro Tools 2025.06
         * @implements IStemChannelId
         * @constructor
         * @param {ptsl.IStemChannelId=} [properties] Properties to set
         */
        function StemChannelId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Channel named identifier.
         * @member {ptsl.StemChannel} name
         * @memberof ptsl.StemChannelId
         * @instance
         */
        StemChannelId.prototype.name = 0;

        /**
         * * Channel index identifier. Used with StemFormat.
         * @member {number} index
         * @memberof ptsl.StemChannelId
         * @instance
         */
        StemChannelId.prototype.index = 0;

        /**
         * Creates a new StemChannelId instance using the specified properties.
         * @function create
         * @memberof ptsl.StemChannelId
         * @static
         * @param {ptsl.IStemChannelId=} [properties] Properties to set
         * @returns {ptsl.StemChannelId} StemChannelId instance
         */
        StemChannelId.create = function create(properties) {
            return new StemChannelId(properties);
        };

        /**
         * Encodes the specified StemChannelId message. Does not implicitly {@link ptsl.StemChannelId.verify|verify} messages.
         * @function encode
         * @memberof ptsl.StemChannelId
         * @static
         * @param {ptsl.IStemChannelId} message StemChannelId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StemChannelId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.name);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified StemChannelId message, length delimited. Does not implicitly {@link ptsl.StemChannelId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.StemChannelId
         * @static
         * @param {ptsl.IStemChannelId} message StemChannelId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StemChannelId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StemChannelId message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.StemChannelId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.StemChannelId} StemChannelId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StemChannelId.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.StemChannelId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.int32();
                        break;
                    }
                case 2: {
                        message.index = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StemChannelId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.StemChannelId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.StemChannelId} StemChannelId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StemChannelId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StemChannelId message.
         * @function verify
         * @memberof ptsl.StemChannelId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StemChannelId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                switch (message.name) {
                default:
                    return "name: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                    break;
                }
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        /**
         * Creates a StemChannelId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.StemChannelId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.StemChannelId} StemChannelId
         */
        StemChannelId.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.StemChannelId)
                return object;
            var message = new $root.ptsl.StemChannelId();
            switch (object.name) {
            default:
                if (typeof object.name === "number") {
                    message.name = object.name;
                    break;
                }
                break;
            case "SChannel_Unknown":
            case 0:
                message.name = 0;
                break;
            case "SChannel_Mono":
            case 1:
                message.name = 1;
                break;
            case "SChannel_Left":
            case 2:
                message.name = 2;
                break;
            case "SChannel_Right":
            case 3:
                message.name = 3;
                break;
            case "SChannel_Center":
            case 4:
                message.name = 4;
                break;
            case "SChannel_LeftSurround":
            case 5:
                message.name = 5;
                break;
            case "SChannel_CenterSurround":
            case 6:
                message.name = 6;
                break;
            case "SChannel_RightSurround":
            case 7:
                message.name = 7;
                break;
            case "SChannel_Surround":
            case 8:
                message.name = 8;
                break;
            case "SChannel_LeftCenter":
            case 9:
                message.name = 9;
                break;
            case "SChannel_RightCenter":
            case 10:
                message.name = 10;
                break;
            case "SChannel_LeftSide":
            case 11:
                message.name = 11;
                break;
            case "SChannel_RightSide":
            case 12:
                message.name = 12;
                break;
            case "SChannel_LeftFrontHeight":
            case 13:
                message.name = 13;
                break;
            case "SChannel_RightFrontHeight":
            case 14:
                message.name = 14;
                break;
            case "SChannel_LeftTopMiddle":
            case 15:
                message.name = 15;
                break;
            case "SChannel_RightTopMiddle":
            case 16:
                message.name = 16;
                break;
            case "SChannel_LeftTopFront":
            case 17:
                message.name = 17;
                break;
            case "SChannel_RightTopFront":
            case 18:
                message.name = 18;
                break;
            case "SChannel_LeftTopRear":
            case 19:
                message.name = 19;
                break;
            case "SChannel_RightTopRear":
            case 20:
                message.name = 20;
                break;
            case "SChannel_LeftWide":
            case 21:
                message.name = 21;
                break;
            case "SChannel_RightWide":
            case 22:
                message.name = 22;
                break;
            case "SChannel_LFE":
            case 23:
                message.name = 23;
                break;
            case "SChannel_0":
            case 24:
                message.name = 24;
                break;
            case "SChannel_1":
            case 25:
                message.name = 25;
                break;
            case "SChannel_2":
            case 26:
                message.name = 26;
                break;
            case "SChannel_3":
            case 27:
                message.name = 27;
                break;
            case "SChannel_4":
            case 28:
                message.name = 28;
                break;
            case "SChannel_5":
            case 29:
                message.name = 29;
                break;
            case "SChannel_6":
            case 30:
                message.name = 30;
                break;
            case "SChannel_7":
            case 31:
                message.name = 31;
                break;
            case "SChannel_8":
            case 32:
                message.name = 32;
                break;
            case "SChannel_9":
            case 33:
                message.name = 33;
                break;
            case "SChannel_10":
            case 34:
                message.name = 34;
                break;
            case "SChannel_11":
            case 35:
                message.name = 35;
                break;
            case "SChannel_12":
            case 36:
                message.name = 36;
                break;
            case "SChannel_13":
            case 37:
                message.name = 37;
                break;
            case "SChannel_14":
            case 38:
                message.name = 38;
                break;
            case "SChannel_15":
            case 39:
                message.name = 39;
                break;
            case "SChannel_16":
            case 40:
                message.name = 40;
                break;
            case "SChannel_17":
            case 41:
                message.name = 41;
                break;
            case "SChannel_18":
            case 42:
                message.name = 42;
                break;
            case "SChannel_19":
            case 43:
                message.name = 43;
                break;
            case "SChannel_20":
            case 44:
                message.name = 44;
                break;
            case "SChannel_21":
            case 45:
                message.name = 45;
                break;
            case "SChannel_22":
            case 46:
                message.name = 46;
                break;
            case "SChannel_23":
            case 47:
                message.name = 47;
                break;
            case "SChannel_24":
            case 48:
                message.name = 48;
                break;
            case "SChannel_25":
            case 49:
                message.name = 49;
                break;
            case "SChannel_26":
            case 50:
                message.name = 50;
                break;
            case "SChannel_27":
            case 51:
                message.name = 51;
                break;
            case "SChannel_28":
            case 52:
                message.name = 52;
                break;
            case "SChannel_29":
            case 53:
                message.name = 53;
                break;
            case "SChannel_30":
            case 54:
                message.name = 54;
                break;
            case "SChannel_31":
            case 55:
                message.name = 55;
                break;
            case "SChannel_32":
            case 56:
                message.name = 56;
                break;
            case "SChannel_33":
            case 57:
                message.name = 57;
                break;
            case "SChannel_34":
            case 58:
                message.name = 58;
                break;
            case "SChannel_35":
            case 59:
                message.name = 59;
                break;
            case "SChannel_36":
            case 60:
                message.name = 60;
                break;
            case "SChannel_37":
            case 61:
                message.name = 61;
                break;
            case "SChannel_38":
            case 62:
                message.name = 62;
                break;
            case "SChannel_39":
            case 63:
                message.name = 63;
                break;
            case "SChannel_40":
            case 64:
                message.name = 64;
                break;
            case "SChannel_41":
            case 65:
                message.name = 65;
                break;
            case "SChannel_42":
            case 66:
                message.name = 66;
                break;
            case "SChannel_43":
            case 67:
                message.name = 67;
                break;
            case "SChannel_44":
            case 68:
                message.name = 68;
                break;
            case "SChannel_45":
            case 69:
                message.name = 69;
                break;
            case "SChannel_46":
            case 70:
                message.name = 70;
                break;
            case "SChannel_47":
            case 71:
                message.name = 71;
                break;
            case "SChannel_48":
            case 72:
                message.name = 72;
                break;
            case "SChannel_49":
            case 73:
                message.name = 73;
                break;
            case "SChannel_50":
            case 74:
                message.name = 74;
                break;
            case "SChannel_51":
            case 75:
                message.name = 75;
                break;
            case "SChannel_52":
            case 76:
                message.name = 76;
                break;
            case "SChannel_53":
            case 77:
                message.name = 77;
                break;
            case "SChannel_54":
            case 78:
                message.name = 78;
                break;
            case "SChannel_55":
            case 79:
                message.name = 79;
                break;
            case "SChannel_56":
            case 80:
                message.name = 80;
                break;
            case "SChannel_57":
            case 81:
                message.name = 81;
                break;
            case "SChannel_58":
            case 82:
                message.name = 82;
                break;
            case "SChannel_59":
            case 83:
                message.name = 83;
                break;
            case "SChannel_60":
            case 84:
                message.name = 84;
                break;
            case "SChannel_61":
            case 85:
                message.name = 85;
                break;
            case "SChannel_62":
            case 86:
                message.name = 86;
                break;
            case "SChannel_63":
            case 87:
                message.name = 87;
                break;
            }
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a StemChannelId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.StemChannelId
         * @static
         * @param {ptsl.StemChannelId} message StemChannelId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StemChannelId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = options.enums === String ? "SChannel_Unknown" : 0;
                object.index = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.enums === String ? $root.ptsl.StemChannel[message.name] === undefined ? message.name : $root.ptsl.StemChannel[message.name] : message.name;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this StemChannelId to JSON.
         * @function toJSON
         * @memberof ptsl.StemChannelId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StemChannelId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StemChannelId
         * @function getTypeUrl
         * @memberof ptsl.StemChannelId
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StemChannelId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.StemChannelId";
        };

        return StemChannelId;
    })();

    ptsl.CreateAudioClipRequestEntry = (function() {

        /**
         * Properties of a CreateAudioClipRequestEntry.
         * @memberof ptsl
         * @interface ICreateAudioClipRequestEntry
         * @property {string|null} [name] * Base name of the multichannel clip (excluding channel name).
         * * Optional. If not provided, file name of the first subclip (clip_info) is used.
         * @property {ptsl.StemFormat|null} [channelFormat] * Channel format of the clip.
         * * Optional. If not provided, generic .A1, .A2, etc. channel names are used for subclips; no channel name for a single subclip in the clip_info.
         * @property {ptsl.ITimelineLocation|null} [originalTimestamp] * Original timestamp for the start of subclips.
         * * Optional. If not provided, the timestamp will follow the original timestamp from the file, and be offset by the src_start_point amount from the start of the file (applied for all subclips independently).
         * @property {ptsl.ITimelineLocation|null} [userTimestamp] * User timestamp for the start of subclips.
         * * Optional. If not provided, the timestamp will follow the user timestamp from the file, and be offset by the src_start_point amount from the start of the file (applied for all subclips independently).
         * @property {Array.<ptsl.ICreateAudioClipRequestEntryClipInfo>|null} [clipInfo] * List of subclips to create. One subclip per channel.
         */

        /**
         * Constructs a new CreateAudioClipRequestEntry.
         * @memberof ptsl
         * @classdesc Structure that describes CreateAudioClip single multi-channel clip request data.
         * 
         * @since Pro Tools 2025.06
         * @implements ICreateAudioClipRequestEntry
         * @constructor
         * @param {ptsl.ICreateAudioClipRequestEntry=} [properties] Properties to set
         */
        function CreateAudioClipRequestEntry(properties) {
            this.clipInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Base name of the multichannel clip (excluding channel name).
         * * Optional. If not provided, file name of the first subclip (clip_info) is used.
         * @member {string} name
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @instance
         */
        CreateAudioClipRequestEntry.prototype.name = "";

        /**
         * * Channel format of the clip.
         * * Optional. If not provided, generic .A1, .A2, etc. channel names are used for subclips; no channel name for a single subclip in the clip_info.
         * @member {ptsl.StemFormat} channelFormat
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @instance
         */
        CreateAudioClipRequestEntry.prototype.channelFormat = 0;

        /**
         * * Original timestamp for the start of subclips.
         * * Optional. If not provided, the timestamp will follow the original timestamp from the file, and be offset by the src_start_point amount from the start of the file (applied for all subclips independently).
         * @member {ptsl.ITimelineLocation|null|undefined} originalTimestamp
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @instance
         */
        CreateAudioClipRequestEntry.prototype.originalTimestamp = null;

        /**
         * * User timestamp for the start of subclips.
         * * Optional. If not provided, the timestamp will follow the user timestamp from the file, and be offset by the src_start_point amount from the start of the file (applied for all subclips independently).
         * @member {ptsl.ITimelineLocation|null|undefined} userTimestamp
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @instance
         */
        CreateAudioClipRequestEntry.prototype.userTimestamp = null;

        /**
         * * List of subclips to create. One subclip per channel.
         * @member {Array.<ptsl.ICreateAudioClipRequestEntryClipInfo>} clipInfo
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @instance
         */
        CreateAudioClipRequestEntry.prototype.clipInfo = $util.emptyArray;

        /**
         * Creates a new CreateAudioClipRequestEntry instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {ptsl.ICreateAudioClipRequestEntry=} [properties] Properties to set
         * @returns {ptsl.CreateAudioClipRequestEntry} CreateAudioClipRequestEntry instance
         */
        CreateAudioClipRequestEntry.create = function create(properties) {
            return new CreateAudioClipRequestEntry(properties);
        };

        /**
         * Encodes the specified CreateAudioClipRequestEntry message. Does not implicitly {@link ptsl.CreateAudioClipRequestEntry.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {ptsl.ICreateAudioClipRequestEntry} message CreateAudioClipRequestEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipRequestEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.channelFormat != null && Object.hasOwnProperty.call(message, "channelFormat"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelFormat);
            if (message.originalTimestamp != null && Object.hasOwnProperty.call(message, "originalTimestamp"))
                $root.ptsl.TimelineLocation.encode(message.originalTimestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.userTimestamp != null && Object.hasOwnProperty.call(message, "userTimestamp"))
                $root.ptsl.TimelineLocation.encode(message.userTimestamp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.clipInfo != null && message.clipInfo.length)
                for (var i = 0; i < message.clipInfo.length; ++i)
                    $root.ptsl.CreateAudioClipRequestEntryClipInfo.encode(message.clipInfo[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateAudioClipRequestEntry message, length delimited. Does not implicitly {@link ptsl.CreateAudioClipRequestEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {ptsl.ICreateAudioClipRequestEntry} message CreateAudioClipRequestEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipRequestEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAudioClipRequestEntry message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateAudioClipRequestEntry} CreateAudioClipRequestEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipRequestEntry.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateAudioClipRequestEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.channelFormat = reader.int32();
                        break;
                    }
                case 3: {
                        message.originalTimestamp = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.userTimestamp = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        if (!(message.clipInfo && message.clipInfo.length))
                            message.clipInfo = [];
                        message.clipInfo.push($root.ptsl.CreateAudioClipRequestEntryClipInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAudioClipRequestEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateAudioClipRequestEntry} CreateAudioClipRequestEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipRequestEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAudioClipRequestEntry message.
         * @function verify
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAudioClipRequestEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.channelFormat != null && message.hasOwnProperty("channelFormat"))
                switch (message.channelFormat) {
                default:
                    return "channelFormat: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                    break;
                }
            if (message.originalTimestamp != null && message.hasOwnProperty("originalTimestamp")) {
                var error = $root.ptsl.TimelineLocation.verify(message.originalTimestamp);
                if (error)
                    return "originalTimestamp." + error;
            }
            if (message.userTimestamp != null && message.hasOwnProperty("userTimestamp")) {
                var error = $root.ptsl.TimelineLocation.verify(message.userTimestamp);
                if (error)
                    return "userTimestamp." + error;
            }
            if (message.clipInfo != null && message.hasOwnProperty("clipInfo")) {
                if (!Array.isArray(message.clipInfo))
                    return "clipInfo: array expected";
                for (var i = 0; i < message.clipInfo.length; ++i) {
                    var error = $root.ptsl.CreateAudioClipRequestEntryClipInfo.verify(message.clipInfo[i]);
                    if (error)
                        return "clipInfo." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreateAudioClipRequestEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateAudioClipRequestEntry} CreateAudioClipRequestEntry
         */
        CreateAudioClipRequestEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateAudioClipRequestEntry)
                return object;
            var message = new $root.ptsl.CreateAudioClipRequestEntry();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.channelFormat) {
            default:
                if (typeof object.channelFormat === "number") {
                    message.channelFormat = object.channelFormat;
                    break;
                }
                break;
            case "SFormat_Unknown":
            case 0:
                message.channelFormat = 0;
                break;
            case "SFormat_Mono":
            case 1:
                message.channelFormat = 1;
                break;
            case "SFormat_Stereo":
            case 2:
                message.channelFormat = 2;
                break;
            case "SFormat_LCR":
            case 3:
                message.channelFormat = 3;
                break;
            case "SFormat_LCRS":
            case 4:
                message.channelFormat = 4;
                break;
            case "SFormat_Quad":
            case 5:
                message.channelFormat = 5;
                break;
            case "SFormat_5_0":
            case 6:
                message.channelFormat = 6;
                break;
            case "SFormat_5_1":
            case 7:
                message.channelFormat = 7;
                break;
            case "SFormat_5_0_2":
            case 8:
                message.channelFormat = 8;
                break;
            case "SFormat_5_1_2":
            case 9:
                message.channelFormat = 9;
                break;
            case "SFormat_5_0_4":
            case 10:
                message.channelFormat = 10;
                break;
            case "SFormat_5_1_4":
            case 11:
                message.channelFormat = 11;
                break;
            case "SFormat_6_0":
            case 12:
                message.channelFormat = 12;
                break;
            case "SFormat_6_1":
            case 13:
                message.channelFormat = 13;
                break;
            case "SFormat_7_0":
            case 14:
                message.channelFormat = 14;
                break;
            case "SFormat_7_1":
            case 15:
                message.channelFormat = 15;
                break;
            case "SFormat_7_0_SDDS":
            case 16:
                message.channelFormat = 16;
                break;
            case "SFormat_7_1_SDDS":
            case 17:
                message.channelFormat = 17;
                break;
            case "SFormat_7_0_2":
            case 18:
                message.channelFormat = 18;
                break;
            case "SFormat_7_1_2":
            case 19:
                message.channelFormat = 19;
                break;
            case "SFormat_7_0_4":
            case 20:
                message.channelFormat = 20;
                break;
            case "SFormat_7_1_4":
            case 21:
                message.channelFormat = 21;
                break;
            case "SFormat_7_0_6":
            case 22:
                message.channelFormat = 22;
                break;
            case "SFormat_7_1_6":
            case 23:
                message.channelFormat = 23;
                break;
            case "SFormat_9_0_4":
            case 24:
                message.channelFormat = 24;
                break;
            case "SFormat_9_1_4":
            case 25:
                message.channelFormat = 25;
                break;
            case "SFormat_9_0_6":
            case 26:
                message.channelFormat = 26;
                break;
            case "SFormat_9_1_6":
            case 27:
                message.channelFormat = 27;
                break;
            case "SFormat_1stOrderAmbisonics":
            case 28:
                message.channelFormat = 28;
                break;
            case "SFormat_2ndOrderAmbisonics":
            case 29:
                message.channelFormat = 29;
                break;
            case "SFormat_3rdOrderAmbisonics":
            case 30:
                message.channelFormat = 30;
                break;
            case "SFormat_4thOrderAmbisonics":
            case 31:
                message.channelFormat = 31;
                break;
            case "SFormat_5thOrderAmbisonics":
            case 32:
                message.channelFormat = 32;
                break;
            case "SFormat_6thOrderAmbisonics":
            case 33:
                message.channelFormat = 33;
                break;
            case "SFormat_7thOrderAmbisonics":
            case 34:
                message.channelFormat = 34;
                break;
            case "SFormat_None":
            case 35:
                message.channelFormat = 35;
                break;
            case "SFormat_2_1":
            case 36:
                message.channelFormat = 36;
                break;
            case "SFormat_Overhead":
            case 37:
                message.channelFormat = 37;
                break;
            }
            if (object.originalTimestamp != null) {
                if (typeof object.originalTimestamp !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntry.originalTimestamp: object expected");
                message.originalTimestamp = $root.ptsl.TimelineLocation.fromObject(object.originalTimestamp);
            }
            if (object.userTimestamp != null) {
                if (typeof object.userTimestamp !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntry.userTimestamp: object expected");
                message.userTimestamp = $root.ptsl.TimelineLocation.fromObject(object.userTimestamp);
            }
            if (object.clipInfo) {
                if (!Array.isArray(object.clipInfo))
                    throw TypeError(".ptsl.CreateAudioClipRequestEntry.clipInfo: array expected");
                message.clipInfo = [];
                for (var i = 0; i < object.clipInfo.length; ++i) {
                    if (typeof object.clipInfo[i] !== "object")
                        throw TypeError(".ptsl.CreateAudioClipRequestEntry.clipInfo: object expected");
                    message.clipInfo[i] = $root.ptsl.CreateAudioClipRequestEntryClipInfo.fromObject(object.clipInfo[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateAudioClipRequestEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {ptsl.CreateAudioClipRequestEntry} message CreateAudioClipRequestEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAudioClipRequestEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clipInfo = [];
            if (options.defaults) {
                object.name = "";
                object.channelFormat = options.enums === String ? "SFormat_Unknown" : 0;
                object.originalTimestamp = null;
                object.userTimestamp = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.channelFormat != null && message.hasOwnProperty("channelFormat"))
                object.channelFormat = options.enums === String ? $root.ptsl.StemFormat[message.channelFormat] === undefined ? message.channelFormat : $root.ptsl.StemFormat[message.channelFormat] : message.channelFormat;
            if (message.originalTimestamp != null && message.hasOwnProperty("originalTimestamp"))
                object.originalTimestamp = $root.ptsl.TimelineLocation.toObject(message.originalTimestamp, options);
            if (message.userTimestamp != null && message.hasOwnProperty("userTimestamp"))
                object.userTimestamp = $root.ptsl.TimelineLocation.toObject(message.userTimestamp, options);
            if (message.clipInfo && message.clipInfo.length) {
                object.clipInfo = [];
                for (var j = 0; j < message.clipInfo.length; ++j)
                    object.clipInfo[j] = $root.ptsl.CreateAudioClipRequestEntryClipInfo.toObject(message.clipInfo[j], options);
            }
            return object;
        };

        /**
         * Converts this CreateAudioClipRequestEntry to JSON.
         * @function toJSON
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAudioClipRequestEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateAudioClipRequestEntry
         * @function getTypeUrl
         * @memberof ptsl.CreateAudioClipRequestEntry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateAudioClipRequestEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateAudioClipRequestEntry";
        };

        return CreateAudioClipRequestEntry;
    })();

    ptsl.CreateAudioClipResponseEntry = (function() {

        /**
         * Properties of a CreateAudioClipResponseEntry.
         * @memberof ptsl
         * @interface ICreateAudioClipResponseEntry
         * @property {Array.<string>|null} [clipIds] * IDs of the created subclips forming the multichannel clip.
         * * The order of IDs corresponds to the order of subclips in the request (CreateAudioClipRequestEntry.clip_info).
         */

        /**
         * Constructs a new CreateAudioClipResponseEntry.
         * @memberof ptsl
         * @classdesc Structure that describes CreateAudioClip single multi-channel clip response data.
         * 
         * @since Pro Tools 2025.06
         * @implements ICreateAudioClipResponseEntry
         * @constructor
         * @param {ptsl.ICreateAudioClipResponseEntry=} [properties] Properties to set
         */
        function CreateAudioClipResponseEntry(properties) {
            this.clipIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * IDs of the created subclips forming the multichannel clip.
         * * The order of IDs corresponds to the order of subclips in the request (CreateAudioClipRequestEntry.clip_info).
         * @member {Array.<string>} clipIds
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @instance
         */
        CreateAudioClipResponseEntry.prototype.clipIds = $util.emptyArray;

        /**
         * Creates a new CreateAudioClipResponseEntry instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {ptsl.ICreateAudioClipResponseEntry=} [properties] Properties to set
         * @returns {ptsl.CreateAudioClipResponseEntry} CreateAudioClipResponseEntry instance
         */
        CreateAudioClipResponseEntry.create = function create(properties) {
            return new CreateAudioClipResponseEntry(properties);
        };

        /**
         * Encodes the specified CreateAudioClipResponseEntry message. Does not implicitly {@link ptsl.CreateAudioClipResponseEntry.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {ptsl.ICreateAudioClipResponseEntry} message CreateAudioClipResponseEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipResponseEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clipIds != null && message.clipIds.length)
                for (var i = 0; i < message.clipIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.clipIds[i]);
            return writer;
        };

        /**
         * Encodes the specified CreateAudioClipResponseEntry message, length delimited. Does not implicitly {@link ptsl.CreateAudioClipResponseEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {ptsl.ICreateAudioClipResponseEntry} message CreateAudioClipResponseEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipResponseEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAudioClipResponseEntry message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateAudioClipResponseEntry} CreateAudioClipResponseEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipResponseEntry.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateAudioClipResponseEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.clipIds && message.clipIds.length))
                            message.clipIds = [];
                        message.clipIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAudioClipResponseEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateAudioClipResponseEntry} CreateAudioClipResponseEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipResponseEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAudioClipResponseEntry message.
         * @function verify
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAudioClipResponseEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clipIds != null && message.hasOwnProperty("clipIds")) {
                if (!Array.isArray(message.clipIds))
                    return "clipIds: array expected";
                for (var i = 0; i < message.clipIds.length; ++i)
                    if (!$util.isString(message.clipIds[i]))
                        return "clipIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a CreateAudioClipResponseEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateAudioClipResponseEntry} CreateAudioClipResponseEntry
         */
        CreateAudioClipResponseEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateAudioClipResponseEntry)
                return object;
            var message = new $root.ptsl.CreateAudioClipResponseEntry();
            if (object.clipIds) {
                if (!Array.isArray(object.clipIds))
                    throw TypeError(".ptsl.CreateAudioClipResponseEntry.clipIds: array expected");
                message.clipIds = [];
                for (var i = 0; i < object.clipIds.length; ++i)
                    message.clipIds[i] = String(object.clipIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateAudioClipResponseEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {ptsl.CreateAudioClipResponseEntry} message CreateAudioClipResponseEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAudioClipResponseEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clipIds = [];
            if (message.clipIds && message.clipIds.length) {
                object.clipIds = [];
                for (var j = 0; j < message.clipIds.length; ++j)
                    object.clipIds[j] = message.clipIds[j];
            }
            return object;
        };

        /**
         * Converts this CreateAudioClipResponseEntry to JSON.
         * @function toJSON
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAudioClipResponseEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateAudioClipResponseEntry
         * @function getTypeUrl
         * @memberof ptsl.CreateAudioClipResponseEntry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateAudioClipResponseEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateAudioClipResponseEntry";
        };

        return CreateAudioClipResponseEntry;
    })();

    ptsl.CreateAudioClipRequestEntryClipInfo = (function() {

        /**
         * Properties of a CreateAudioClipRequestEntryClipInfo.
         * @memberof ptsl
         * @interface ICreateAudioClipRequestEntryClipInfo
         * @property {string|null} [fileId] * ID of the file to create the subclip from.
         * @property {ptsl.IMediaTimePosition|null} [srcStartPoint] * Start point of the subclip.
         * * Optional. If not provided, the start point is the start of the file.
         * @property {ptsl.IMediaTimePosition|null} [srcEndPoint] * End point of the subclip.
         * * Optional. If not provided, the end point is the end of the file.
         * @property {ptsl.IMediaTimePosition|null} [srcSyncPoint] * Sync point of the subclip.
         * * Optional. If not provided, the sync point is the start of the subclip.
         * @property {ptsl.IStemChannelId|null} [srcChannel] * Channel identifier of the file to create the subclip from.
         * * Optional. If not provided, the channel identifier is the first channel of the file.
         * @property {ptsl.IStemChannelId|null} [dstChannel] * Destination channel identifier of the subclip in the multichannel clip.
         * * Optional. Invalid for generic channel format (CreateAudioClipRequestEntry.channel_format). In that case, the index of the subclip in the request (CreateAudioClipRequestEntry.clip_info) is used as the channel identifier (.A1, .A2, etc.).
         * @property {ptsl.IMediaTimePosition|null} [startPoint] * Start point of the subclip in destination units: ticks or samples.
         * * When using ticks, 1 beat = 960000 ticks. Optional.
         * @property {ptsl.IMediaTimePosition|null} [endPoint] * End point of the subclip in destination units: ticks or samples.
         * * When using ticks, 1 beat = 960000 ticks. Optional.
         * @property {number|null} [transposeSemitones] * Number of semitones for pitch transposition.
         * * Optional. Accepts values in range [-24, 24].
         * @property {number|null} [transposeCents] * Number of cents for pitch transposition.
         * * Optional. Accepts values in range [-99, 99].
         */

        /**
         * Constructs a new CreateAudioClipRequestEntryClipInfo.
         * @memberof ptsl
         * @classdesc Structure that describes CreateAudioClip single subclip request data.
         * 
         * @since Pro Tools 2025.06
         * @implements ICreateAudioClipRequestEntryClipInfo
         * @constructor
         * @param {ptsl.ICreateAudioClipRequestEntryClipInfo=} [properties] Properties to set
         */
        function CreateAudioClipRequestEntryClipInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * ID of the file to create the subclip from.
         * @member {string} fileId
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.fileId = "";

        /**
         * * Start point of the subclip.
         * * Optional. If not provided, the start point is the start of the file.
         * @member {ptsl.IMediaTimePosition|null|undefined} srcStartPoint
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.srcStartPoint = null;

        /**
         * * End point of the subclip.
         * * Optional. If not provided, the end point is the end of the file.
         * @member {ptsl.IMediaTimePosition|null|undefined} srcEndPoint
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.srcEndPoint = null;

        /**
         * * Sync point of the subclip.
         * * Optional. If not provided, the sync point is the start of the subclip.
         * @member {ptsl.IMediaTimePosition|null|undefined} srcSyncPoint
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.srcSyncPoint = null;

        /**
         * * Channel identifier of the file to create the subclip from.
         * * Optional. If not provided, the channel identifier is the first channel of the file.
         * @member {ptsl.IStemChannelId|null|undefined} srcChannel
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.srcChannel = null;

        /**
         * * Destination channel identifier of the subclip in the multichannel clip.
         * * Optional. Invalid for generic channel format (CreateAudioClipRequestEntry.channel_format). In that case, the index of the subclip in the request (CreateAudioClipRequestEntry.clip_info) is used as the channel identifier (.A1, .A2, etc.).
         * @member {ptsl.IStemChannelId|null|undefined} dstChannel
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.dstChannel = null;

        /**
         * * Start point of the subclip in destination units: ticks or samples.
         * * When using ticks, 1 beat = 960000 ticks. Optional.
         * @member {ptsl.IMediaTimePosition|null|undefined} startPoint
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.startPoint = null;

        /**
         * * End point of the subclip in destination units: ticks or samples.
         * * When using ticks, 1 beat = 960000 ticks. Optional.
         * @member {ptsl.IMediaTimePosition|null|undefined} endPoint
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.endPoint = null;

        /**
         * * Number of semitones for pitch transposition.
         * * Optional. Accepts values in range [-24, 24].
         * @member {number} transposeSemitones
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.transposeSemitones = 0;

        /**
         * * Number of cents for pitch transposition.
         * * Optional. Accepts values in range [-99, 99].
         * @member {number} transposeCents
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         */
        CreateAudioClipRequestEntryClipInfo.prototype.transposeCents = 0;

        /**
         * Creates a new CreateAudioClipRequestEntryClipInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {ptsl.ICreateAudioClipRequestEntryClipInfo=} [properties] Properties to set
         * @returns {ptsl.CreateAudioClipRequestEntryClipInfo} CreateAudioClipRequestEntryClipInfo instance
         */
        CreateAudioClipRequestEntryClipInfo.create = function create(properties) {
            return new CreateAudioClipRequestEntryClipInfo(properties);
        };

        /**
         * Encodes the specified CreateAudioClipRequestEntryClipInfo message. Does not implicitly {@link ptsl.CreateAudioClipRequestEntryClipInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {ptsl.ICreateAudioClipRequestEntryClipInfo} message CreateAudioClipRequestEntryClipInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipRequestEntryClipInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileId);
            if (message.srcStartPoint != null && Object.hasOwnProperty.call(message, "srcStartPoint"))
                $root.ptsl.MediaTimePosition.encode(message.srcStartPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.srcEndPoint != null && Object.hasOwnProperty.call(message, "srcEndPoint"))
                $root.ptsl.MediaTimePosition.encode(message.srcEndPoint, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.srcSyncPoint != null && Object.hasOwnProperty.call(message, "srcSyncPoint"))
                $root.ptsl.MediaTimePosition.encode(message.srcSyncPoint, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.srcChannel != null && Object.hasOwnProperty.call(message, "srcChannel"))
                $root.ptsl.StemChannelId.encode(message.srcChannel, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.dstChannel != null && Object.hasOwnProperty.call(message, "dstChannel"))
                $root.ptsl.StemChannelId.encode(message.dstChannel, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.startPoint != null && Object.hasOwnProperty.call(message, "startPoint"))
                $root.ptsl.MediaTimePosition.encode(message.startPoint, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.endPoint != null && Object.hasOwnProperty.call(message, "endPoint"))
                $root.ptsl.MediaTimePosition.encode(message.endPoint, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.transposeSemitones != null && Object.hasOwnProperty.call(message, "transposeSemitones"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.transposeSemitones);
            if (message.transposeCents != null && Object.hasOwnProperty.call(message, "transposeCents"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.transposeCents);
            return writer;
        };

        /**
         * Encodes the specified CreateAudioClipRequestEntryClipInfo message, length delimited. Does not implicitly {@link ptsl.CreateAudioClipRequestEntryClipInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {ptsl.ICreateAudioClipRequestEntryClipInfo} message CreateAudioClipRequestEntryClipInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipRequestEntryClipInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAudioClipRequestEntryClipInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateAudioClipRequestEntryClipInfo} CreateAudioClipRequestEntryClipInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipRequestEntryClipInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateAudioClipRequestEntryClipInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fileId = reader.string();
                        break;
                    }
                case 2: {
                        message.srcStartPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.srcEndPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.srcSyncPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.srcChannel = $root.ptsl.StemChannelId.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.dstChannel = $root.ptsl.StemChannelId.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.startPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.endPoint = $root.ptsl.MediaTimePosition.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.transposeSemitones = reader.int32();
                        break;
                    }
                case 10: {
                        message.transposeCents = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAudioClipRequestEntryClipInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateAudioClipRequestEntryClipInfo} CreateAudioClipRequestEntryClipInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipRequestEntryClipInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAudioClipRequestEntryClipInfo message.
         * @function verify
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAudioClipRequestEntryClipInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                if (!$util.isString(message.fileId))
                    return "fileId: string expected";
            if (message.srcStartPoint != null && message.hasOwnProperty("srcStartPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.srcStartPoint);
                if (error)
                    return "srcStartPoint." + error;
            }
            if (message.srcEndPoint != null && message.hasOwnProperty("srcEndPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.srcEndPoint);
                if (error)
                    return "srcEndPoint." + error;
            }
            if (message.srcSyncPoint != null && message.hasOwnProperty("srcSyncPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.srcSyncPoint);
                if (error)
                    return "srcSyncPoint." + error;
            }
            if (message.srcChannel != null && message.hasOwnProperty("srcChannel")) {
                var error = $root.ptsl.StemChannelId.verify(message.srcChannel);
                if (error)
                    return "srcChannel." + error;
            }
            if (message.dstChannel != null && message.hasOwnProperty("dstChannel")) {
                var error = $root.ptsl.StemChannelId.verify(message.dstChannel);
                if (error)
                    return "dstChannel." + error;
            }
            if (message.startPoint != null && message.hasOwnProperty("startPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.startPoint);
                if (error)
                    return "startPoint." + error;
            }
            if (message.endPoint != null && message.hasOwnProperty("endPoint")) {
                var error = $root.ptsl.MediaTimePosition.verify(message.endPoint);
                if (error)
                    return "endPoint." + error;
            }
            if (message.transposeSemitones != null && message.hasOwnProperty("transposeSemitones"))
                if (!$util.isInteger(message.transposeSemitones))
                    return "transposeSemitones: integer expected";
            if (message.transposeCents != null && message.hasOwnProperty("transposeCents"))
                if (!$util.isInteger(message.transposeCents))
                    return "transposeCents: integer expected";
            return null;
        };

        /**
         * Creates a CreateAudioClipRequestEntryClipInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateAudioClipRequestEntryClipInfo} CreateAudioClipRequestEntryClipInfo
         */
        CreateAudioClipRequestEntryClipInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateAudioClipRequestEntryClipInfo)
                return object;
            var message = new $root.ptsl.CreateAudioClipRequestEntryClipInfo();
            if (object.fileId != null)
                message.fileId = String(object.fileId);
            if (object.srcStartPoint != null) {
                if (typeof object.srcStartPoint !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntryClipInfo.srcStartPoint: object expected");
                message.srcStartPoint = $root.ptsl.MediaTimePosition.fromObject(object.srcStartPoint);
            }
            if (object.srcEndPoint != null) {
                if (typeof object.srcEndPoint !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntryClipInfo.srcEndPoint: object expected");
                message.srcEndPoint = $root.ptsl.MediaTimePosition.fromObject(object.srcEndPoint);
            }
            if (object.srcSyncPoint != null) {
                if (typeof object.srcSyncPoint !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntryClipInfo.srcSyncPoint: object expected");
                message.srcSyncPoint = $root.ptsl.MediaTimePosition.fromObject(object.srcSyncPoint);
            }
            if (object.srcChannel != null) {
                if (typeof object.srcChannel !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntryClipInfo.srcChannel: object expected");
                message.srcChannel = $root.ptsl.StemChannelId.fromObject(object.srcChannel);
            }
            if (object.dstChannel != null) {
                if (typeof object.dstChannel !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntryClipInfo.dstChannel: object expected");
                message.dstChannel = $root.ptsl.StemChannelId.fromObject(object.dstChannel);
            }
            if (object.startPoint != null) {
                if (typeof object.startPoint !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntryClipInfo.startPoint: object expected");
                message.startPoint = $root.ptsl.MediaTimePosition.fromObject(object.startPoint);
            }
            if (object.endPoint != null) {
                if (typeof object.endPoint !== "object")
                    throw TypeError(".ptsl.CreateAudioClipRequestEntryClipInfo.endPoint: object expected");
                message.endPoint = $root.ptsl.MediaTimePosition.fromObject(object.endPoint);
            }
            if (object.transposeSemitones != null)
                message.transposeSemitones = object.transposeSemitones | 0;
            if (object.transposeCents != null)
                message.transposeCents = object.transposeCents | 0;
            return message;
        };

        /**
         * Creates a plain object from a CreateAudioClipRequestEntryClipInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {ptsl.CreateAudioClipRequestEntryClipInfo} message CreateAudioClipRequestEntryClipInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAudioClipRequestEntryClipInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fileId = "";
                object.srcStartPoint = null;
                object.srcEndPoint = null;
                object.srcSyncPoint = null;
                object.srcChannel = null;
                object.dstChannel = null;
                object.startPoint = null;
                object.endPoint = null;
                object.transposeSemitones = 0;
                object.transposeCents = 0;
            }
            if (message.fileId != null && message.hasOwnProperty("fileId"))
                object.fileId = message.fileId;
            if (message.srcStartPoint != null && message.hasOwnProperty("srcStartPoint"))
                object.srcStartPoint = $root.ptsl.MediaTimePosition.toObject(message.srcStartPoint, options);
            if (message.srcEndPoint != null && message.hasOwnProperty("srcEndPoint"))
                object.srcEndPoint = $root.ptsl.MediaTimePosition.toObject(message.srcEndPoint, options);
            if (message.srcSyncPoint != null && message.hasOwnProperty("srcSyncPoint"))
                object.srcSyncPoint = $root.ptsl.MediaTimePosition.toObject(message.srcSyncPoint, options);
            if (message.srcChannel != null && message.hasOwnProperty("srcChannel"))
                object.srcChannel = $root.ptsl.StemChannelId.toObject(message.srcChannel, options);
            if (message.dstChannel != null && message.hasOwnProperty("dstChannel"))
                object.dstChannel = $root.ptsl.StemChannelId.toObject(message.dstChannel, options);
            if (message.startPoint != null && message.hasOwnProperty("startPoint"))
                object.startPoint = $root.ptsl.MediaTimePosition.toObject(message.startPoint, options);
            if (message.endPoint != null && message.hasOwnProperty("endPoint"))
                object.endPoint = $root.ptsl.MediaTimePosition.toObject(message.endPoint, options);
            if (message.transposeSemitones != null && message.hasOwnProperty("transposeSemitones"))
                object.transposeSemitones = message.transposeSemitones;
            if (message.transposeCents != null && message.hasOwnProperty("transposeCents"))
                object.transposeCents = message.transposeCents;
            return object;
        };

        /**
         * Converts this CreateAudioClipRequestEntryClipInfo to JSON.
         * @function toJSON
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAudioClipRequestEntryClipInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateAudioClipRequestEntryClipInfo
         * @function getTypeUrl
         * @memberof ptsl.CreateAudioClipRequestEntryClipInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateAudioClipRequestEntryClipInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateAudioClipRequestEntryClipInfo";
        };

        return CreateAudioClipRequestEntryClipInfo;
    })();

    ptsl.CreateAudioClipsRequestBody = (function() {

        /**
         * Properties of a CreateAudioClipsRequestBody.
         * @memberof ptsl
         * @interface ICreateAudioClipsRequestBody
         * @property {Array.<ptsl.ICreateAudioClipRequestEntry>|null} [clipList] * List of multichannel clips to create.
         */

        /**
         * Constructs a new CreateAudioClipsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateAudioClips request data.
         * @implements ICreateAudioClipsRequestBody
         * @constructor
         * @param {ptsl.ICreateAudioClipsRequestBody=} [properties] Properties to set
         */
        function CreateAudioClipsRequestBody(properties) {
            this.clipList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of multichannel clips to create.
         * @member {Array.<ptsl.ICreateAudioClipRequestEntry>} clipList
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @instance
         */
        CreateAudioClipsRequestBody.prototype.clipList = $util.emptyArray;

        /**
         * Creates a new CreateAudioClipsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {ptsl.ICreateAudioClipsRequestBody=} [properties] Properties to set
         * @returns {ptsl.CreateAudioClipsRequestBody} CreateAudioClipsRequestBody instance
         */
        CreateAudioClipsRequestBody.create = function create(properties) {
            return new CreateAudioClipsRequestBody(properties);
        };

        /**
         * Encodes the specified CreateAudioClipsRequestBody message. Does not implicitly {@link ptsl.CreateAudioClipsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {ptsl.ICreateAudioClipsRequestBody} message CreateAudioClipsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clipList != null && message.clipList.length)
                for (var i = 0; i < message.clipList.length; ++i)
                    $root.ptsl.CreateAudioClipRequestEntry.encode(message.clipList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateAudioClipsRequestBody message, length delimited. Does not implicitly {@link ptsl.CreateAudioClipsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {ptsl.ICreateAudioClipsRequestBody} message CreateAudioClipsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAudioClipsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateAudioClipsRequestBody} CreateAudioClipsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateAudioClipsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.clipList && message.clipList.length))
                            message.clipList = [];
                        message.clipList.push($root.ptsl.CreateAudioClipRequestEntry.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAudioClipsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateAudioClipsRequestBody} CreateAudioClipsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAudioClipsRequestBody message.
         * @function verify
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAudioClipsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clipList != null && message.hasOwnProperty("clipList")) {
                if (!Array.isArray(message.clipList))
                    return "clipList: array expected";
                for (var i = 0; i < message.clipList.length; ++i) {
                    var error = $root.ptsl.CreateAudioClipRequestEntry.verify(message.clipList[i]);
                    if (error)
                        return "clipList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreateAudioClipsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateAudioClipsRequestBody} CreateAudioClipsRequestBody
         */
        CreateAudioClipsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateAudioClipsRequestBody)
                return object;
            var message = new $root.ptsl.CreateAudioClipsRequestBody();
            if (object.clipList) {
                if (!Array.isArray(object.clipList))
                    throw TypeError(".ptsl.CreateAudioClipsRequestBody.clipList: array expected");
                message.clipList = [];
                for (var i = 0; i < object.clipList.length; ++i) {
                    if (typeof object.clipList[i] !== "object")
                        throw TypeError(".ptsl.CreateAudioClipsRequestBody.clipList: object expected");
                    message.clipList[i] = $root.ptsl.CreateAudioClipRequestEntry.fromObject(object.clipList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateAudioClipsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {ptsl.CreateAudioClipsRequestBody} message CreateAudioClipsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAudioClipsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clipList = [];
            if (message.clipList && message.clipList.length) {
                object.clipList = [];
                for (var j = 0; j < message.clipList.length; ++j)
                    object.clipList[j] = $root.ptsl.CreateAudioClipRequestEntry.toObject(message.clipList[j], options);
            }
            return object;
        };

        /**
         * Converts this CreateAudioClipsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAudioClipsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateAudioClipsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CreateAudioClipsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateAudioClipsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateAudioClipsRequestBody";
        };

        return CreateAudioClipsRequestBody;
    })();

    ptsl.CreateAudioClipsResponseBody = (function() {

        /**
         * Properties of a CreateAudioClipsResponseBody.
         * @memberof ptsl
         * @interface ICreateAudioClipsResponseBody
         * @property {Array.<ptsl.ICreateAudioClipResponseEntry>|null} [clipList] * List of created multichannel clips.
         * * The order of entries corresponds to the order of multichannel clips in the request (CreateAudioClipsRequestBody.clip_list).
         * * Failed clips are indicated by an empty list of clip_ids.
         */

        /**
         * Constructs a new CreateAudioClipsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateAudioClips response data.
         * @implements ICreateAudioClipsResponseBody
         * @constructor
         * @param {ptsl.ICreateAudioClipsResponseBody=} [properties] Properties to set
         */
        function CreateAudioClipsResponseBody(properties) {
            this.clipList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of created multichannel clips.
         * * The order of entries corresponds to the order of multichannel clips in the request (CreateAudioClipsRequestBody.clip_list).
         * * Failed clips are indicated by an empty list of clip_ids.
         * @member {Array.<ptsl.ICreateAudioClipResponseEntry>} clipList
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @instance
         */
        CreateAudioClipsResponseBody.prototype.clipList = $util.emptyArray;

        /**
         * Creates a new CreateAudioClipsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {ptsl.ICreateAudioClipsResponseBody=} [properties] Properties to set
         * @returns {ptsl.CreateAudioClipsResponseBody} CreateAudioClipsResponseBody instance
         */
        CreateAudioClipsResponseBody.create = function create(properties) {
            return new CreateAudioClipsResponseBody(properties);
        };

        /**
         * Encodes the specified CreateAudioClipsResponseBody message. Does not implicitly {@link ptsl.CreateAudioClipsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {ptsl.ICreateAudioClipsResponseBody} message CreateAudioClipsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clipList != null && message.clipList.length)
                for (var i = 0; i < message.clipList.length; ++i)
                    $root.ptsl.CreateAudioClipResponseEntry.encode(message.clipList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateAudioClipsResponseBody message, length delimited. Does not implicitly {@link ptsl.CreateAudioClipsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {ptsl.ICreateAudioClipsResponseBody} message CreateAudioClipsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAudioClipsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAudioClipsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateAudioClipsResponseBody} CreateAudioClipsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateAudioClipsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.clipList && message.clipList.length))
                            message.clipList = [];
                        message.clipList.push($root.ptsl.CreateAudioClipResponseEntry.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAudioClipsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateAudioClipsResponseBody} CreateAudioClipsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAudioClipsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAudioClipsResponseBody message.
         * @function verify
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAudioClipsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clipList != null && message.hasOwnProperty("clipList")) {
                if (!Array.isArray(message.clipList))
                    return "clipList: array expected";
                for (var i = 0; i < message.clipList.length; ++i) {
                    var error = $root.ptsl.CreateAudioClipResponseEntry.verify(message.clipList[i]);
                    if (error)
                        return "clipList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreateAudioClipsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateAudioClipsResponseBody} CreateAudioClipsResponseBody
         */
        CreateAudioClipsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateAudioClipsResponseBody)
                return object;
            var message = new $root.ptsl.CreateAudioClipsResponseBody();
            if (object.clipList) {
                if (!Array.isArray(object.clipList))
                    throw TypeError(".ptsl.CreateAudioClipsResponseBody.clipList: array expected");
                message.clipList = [];
                for (var i = 0; i < object.clipList.length; ++i) {
                    if (typeof object.clipList[i] !== "object")
                        throw TypeError(".ptsl.CreateAudioClipsResponseBody.clipList: object expected");
                    message.clipList[i] = $root.ptsl.CreateAudioClipResponseEntry.fromObject(object.clipList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateAudioClipsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {ptsl.CreateAudioClipsResponseBody} message CreateAudioClipsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAudioClipsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clipList = [];
            if (message.clipList && message.clipList.length) {
                object.clipList = [];
                for (var j = 0; j < message.clipList.length; ++j)
                    object.clipList[j] = $root.ptsl.CreateAudioClipResponseEntry.toObject(message.clipList[j], options);
            }
            return object;
        };

        /**
         * Converts this CreateAudioClipsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAudioClipsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateAudioClipsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.CreateAudioClipsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateAudioClipsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateAudioClipsResponseBody";
        };

        return CreateAudioClipsResponseBody;
    })();

    ptsl.BatchJobRequestHeaderData = (function() {

        /**
         * Properties of a BatchJobRequestHeaderData.
         * @memberof ptsl
         * @interface IBatchJobRequestHeaderData
         * @property {string|null} [id] * ID of the job.
         * @property {number|null} [progress] * Progress value. Optional
         */

        /**
         * Constructs a new BatchJobRequestHeaderData.
         * @memberof ptsl
         * @classdesc Structure that contains details if current request
         * is a part of ongoing batch job operation
         * @since Pro Tools 2025.06
         * @implements IBatchJobRequestHeaderData
         * @constructor
         * @param {ptsl.IBatchJobRequestHeaderData=} [properties] Properties to set
         */
        function BatchJobRequestHeaderData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * ID of the job.
         * @member {string} id
         * @memberof ptsl.BatchJobRequestHeaderData
         * @instance
         */
        BatchJobRequestHeaderData.prototype.id = "";

        /**
         * * Progress value. Optional
         * @member {number} progress
         * @memberof ptsl.BatchJobRequestHeaderData
         * @instance
         */
        BatchJobRequestHeaderData.prototype.progress = 0;

        /**
         * Creates a new BatchJobRequestHeaderData instance using the specified properties.
         * @function create
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {ptsl.IBatchJobRequestHeaderData=} [properties] Properties to set
         * @returns {ptsl.BatchJobRequestHeaderData} BatchJobRequestHeaderData instance
         */
        BatchJobRequestHeaderData.create = function create(properties) {
            return new BatchJobRequestHeaderData(properties);
        };

        /**
         * Encodes the specified BatchJobRequestHeaderData message. Does not implicitly {@link ptsl.BatchJobRequestHeaderData.verify|verify} messages.
         * @function encode
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {ptsl.IBatchJobRequestHeaderData} message BatchJobRequestHeaderData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchJobRequestHeaderData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.progress);
            return writer;
        };

        /**
         * Encodes the specified BatchJobRequestHeaderData message, length delimited. Does not implicitly {@link ptsl.BatchJobRequestHeaderData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {ptsl.IBatchJobRequestHeaderData} message BatchJobRequestHeaderData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchJobRequestHeaderData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BatchJobRequestHeaderData message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.BatchJobRequestHeaderData} BatchJobRequestHeaderData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchJobRequestHeaderData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.BatchJobRequestHeaderData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.progress = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BatchJobRequestHeaderData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.BatchJobRequestHeaderData} BatchJobRequestHeaderData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchJobRequestHeaderData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BatchJobRequestHeaderData message.
         * @function verify
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BatchJobRequestHeaderData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            return null;
        };

        /**
         * Creates a BatchJobRequestHeaderData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.BatchJobRequestHeaderData} BatchJobRequestHeaderData
         */
        BatchJobRequestHeaderData.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.BatchJobRequestHeaderData)
                return object;
            var message = new $root.ptsl.BatchJobRequestHeaderData();
            if (object.id != null)
                message.id = String(object.id);
            if (object.progress != null)
                message.progress = object.progress | 0;
            return message;
        };

        /**
         * Creates a plain object from a BatchJobRequestHeaderData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {ptsl.BatchJobRequestHeaderData} message BatchJobRequestHeaderData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BatchJobRequestHeaderData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.progress = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            return object;
        };

        /**
         * Converts this BatchJobRequestHeaderData to JSON.
         * @function toJSON
         * @memberof ptsl.BatchJobRequestHeaderData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BatchJobRequestHeaderData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BatchJobRequestHeaderData
         * @function getTypeUrl
         * @memberof ptsl.BatchJobRequestHeaderData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BatchJobRequestHeaderData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.BatchJobRequestHeaderData";
        };

        return BatchJobRequestHeaderData;
    })();

    ptsl.BatchJobDefinition = (function() {

        /**
         * Properties of a BatchJobDefinition.
         * @memberof ptsl
         * @interface IBatchJobDefinition
         * @property {string|null} [name] * Name of the job that may be displayed on the GUI.
         * @property {string|null} [description] * Description of the job that may be displayed on the GUI. Optional
         * @property {number|null} [timeout] * Time period in milliseconds after which the job will be
         * * automatically canceled if no requests with the corresponding
         * * job ID are received. Optional
         * @property {boolean|null} [isCancelable] * Can be canceled by the user via the GUI. Optional
         * @property {boolean|null} [cancelOnFailure] * Will cancel the job if any request with the corresponding job ID fails. Optional
         */

        /**
         * Constructs a new BatchJobDefinition.
         * @memberof ptsl
         * @classdesc Structure that describes a batch job
         * @since Pro Tools 2025.06
         * @implements IBatchJobDefinition
         * @constructor
         * @param {ptsl.IBatchJobDefinition=} [properties] Properties to set
         */
        function BatchJobDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Name of the job that may be displayed on the GUI.
         * @member {string} name
         * @memberof ptsl.BatchJobDefinition
         * @instance
         */
        BatchJobDefinition.prototype.name = "";

        /**
         * * Description of the job that may be displayed on the GUI. Optional
         * @member {string} description
         * @memberof ptsl.BatchJobDefinition
         * @instance
         */
        BatchJobDefinition.prototype.description = "";

        /**
         * * Time period in milliseconds after which the job will be
         * * automatically canceled if no requests with the corresponding
         * * job ID are received. Optional
         * @member {number} timeout
         * @memberof ptsl.BatchJobDefinition
         * @instance
         */
        BatchJobDefinition.prototype.timeout = 0;

        /**
         * * Can be canceled by the user via the GUI. Optional
         * @member {boolean} isCancelable
         * @memberof ptsl.BatchJobDefinition
         * @instance
         */
        BatchJobDefinition.prototype.isCancelable = false;

        /**
         * * Will cancel the job if any request with the corresponding job ID fails. Optional
         * @member {boolean} cancelOnFailure
         * @memberof ptsl.BatchJobDefinition
         * @instance
         */
        BatchJobDefinition.prototype.cancelOnFailure = false;

        /**
         * Creates a new BatchJobDefinition instance using the specified properties.
         * @function create
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {ptsl.IBatchJobDefinition=} [properties] Properties to set
         * @returns {ptsl.BatchJobDefinition} BatchJobDefinition instance
         */
        BatchJobDefinition.create = function create(properties) {
            return new BatchJobDefinition(properties);
        };

        /**
         * Encodes the specified BatchJobDefinition message. Does not implicitly {@link ptsl.BatchJobDefinition.verify|verify} messages.
         * @function encode
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {ptsl.IBatchJobDefinition} message BatchJobDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchJobDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
            if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.timeout);
            if (message.isCancelable != null && Object.hasOwnProperty.call(message, "isCancelable"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isCancelable);
            if (message.cancelOnFailure != null && Object.hasOwnProperty.call(message, "cancelOnFailure"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.cancelOnFailure);
            return writer;
        };

        /**
         * Encodes the specified BatchJobDefinition message, length delimited. Does not implicitly {@link ptsl.BatchJobDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {ptsl.IBatchJobDefinition} message BatchJobDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchJobDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BatchJobDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.BatchJobDefinition} BatchJobDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchJobDefinition.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.BatchJobDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.description = reader.string();
                        break;
                    }
                case 3: {
                        message.timeout = reader.int32();
                        break;
                    }
                case 4: {
                        message.isCancelable = reader.bool();
                        break;
                    }
                case 5: {
                        message.cancelOnFailure = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BatchJobDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.BatchJobDefinition} BatchJobDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchJobDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BatchJobDefinition message.
         * @function verify
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BatchJobDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout))
                    return "timeout: integer expected";
            if (message.isCancelable != null && message.hasOwnProperty("isCancelable"))
                if (typeof message.isCancelable !== "boolean")
                    return "isCancelable: boolean expected";
            if (message.cancelOnFailure != null && message.hasOwnProperty("cancelOnFailure"))
                if (typeof message.cancelOnFailure !== "boolean")
                    return "cancelOnFailure: boolean expected";
            return null;
        };

        /**
         * Creates a BatchJobDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.BatchJobDefinition} BatchJobDefinition
         */
        BatchJobDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.BatchJobDefinition)
                return object;
            var message = new $root.ptsl.BatchJobDefinition();
            if (object.name != null)
                message.name = String(object.name);
            if (object.description != null)
                message.description = String(object.description);
            if (object.timeout != null)
                message.timeout = object.timeout | 0;
            if (object.isCancelable != null)
                message.isCancelable = Boolean(object.isCancelable);
            if (object.cancelOnFailure != null)
                message.cancelOnFailure = Boolean(object.cancelOnFailure);
            return message;
        };

        /**
         * Creates a plain object from a BatchJobDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {ptsl.BatchJobDefinition} message BatchJobDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BatchJobDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.description = "";
                object.timeout = 0;
                object.isCancelable = false;
                object.cancelOnFailure = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                object.timeout = message.timeout;
            if (message.isCancelable != null && message.hasOwnProperty("isCancelable"))
                object.isCancelable = message.isCancelable;
            if (message.cancelOnFailure != null && message.hasOwnProperty("cancelOnFailure"))
                object.cancelOnFailure = message.cancelOnFailure;
            return object;
        };

        /**
         * Converts this BatchJobDefinition to JSON.
         * @function toJSON
         * @memberof ptsl.BatchJobDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BatchJobDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BatchJobDefinition
         * @function getTypeUrl
         * @memberof ptsl.BatchJobDefinition
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BatchJobDefinition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.BatchJobDefinition";
        };

        return BatchJobDefinition;
    })();

    ptsl.CreateBatchJobRequestBody = (function() {

        /**
         * Properties of a CreateBatchJobRequestBody.
         * @memberof ptsl
         * @interface ICreateBatchJobRequestBody
         * @property {ptsl.IBatchJobDefinition|null} [job] * Information about the batch job to be created
         */

        /**
         * Constructs a new CreateBatchJobRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateBatchJob request data.
         * @implements ICreateBatchJobRequestBody
         * @constructor
         * @param {ptsl.ICreateBatchJobRequestBody=} [properties] Properties to set
         */
        function CreateBatchJobRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Information about the batch job to be created
         * @member {ptsl.IBatchJobDefinition|null|undefined} job
         * @memberof ptsl.CreateBatchJobRequestBody
         * @instance
         */
        CreateBatchJobRequestBody.prototype.job = null;

        /**
         * Creates a new CreateBatchJobRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {ptsl.ICreateBatchJobRequestBody=} [properties] Properties to set
         * @returns {ptsl.CreateBatchJobRequestBody} CreateBatchJobRequestBody instance
         */
        CreateBatchJobRequestBody.create = function create(properties) {
            return new CreateBatchJobRequestBody(properties);
        };

        /**
         * Encodes the specified CreateBatchJobRequestBody message. Does not implicitly {@link ptsl.CreateBatchJobRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {ptsl.ICreateBatchJobRequestBody} message CreateBatchJobRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateBatchJobRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.job != null && Object.hasOwnProperty.call(message, "job"))
                $root.ptsl.BatchJobDefinition.encode(message.job, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateBatchJobRequestBody message, length delimited. Does not implicitly {@link ptsl.CreateBatchJobRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {ptsl.ICreateBatchJobRequestBody} message CreateBatchJobRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateBatchJobRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateBatchJobRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateBatchJobRequestBody} CreateBatchJobRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateBatchJobRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateBatchJobRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.job = $root.ptsl.BatchJobDefinition.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateBatchJobRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateBatchJobRequestBody} CreateBatchJobRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateBatchJobRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateBatchJobRequestBody message.
         * @function verify
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateBatchJobRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.job != null && message.hasOwnProperty("job")) {
                var error = $root.ptsl.BatchJobDefinition.verify(message.job);
                if (error)
                    return "job." + error;
            }
            return null;
        };

        /**
         * Creates a CreateBatchJobRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateBatchJobRequestBody} CreateBatchJobRequestBody
         */
        CreateBatchJobRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateBatchJobRequestBody)
                return object;
            var message = new $root.ptsl.CreateBatchJobRequestBody();
            if (object.job != null) {
                if (typeof object.job !== "object")
                    throw TypeError(".ptsl.CreateBatchJobRequestBody.job: object expected");
                message.job = $root.ptsl.BatchJobDefinition.fromObject(object.job);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateBatchJobRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {ptsl.CreateBatchJobRequestBody} message CreateBatchJobRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateBatchJobRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.job = null;
            if (message.job != null && message.hasOwnProperty("job"))
                object.job = $root.ptsl.BatchJobDefinition.toObject(message.job, options);
            return object;
        };

        /**
         * Converts this CreateBatchJobRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateBatchJobRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateBatchJobRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateBatchJobRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CreateBatchJobRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateBatchJobRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateBatchJobRequestBody";
        };

        return CreateBatchJobRequestBody;
    })();

    ptsl.CreateBatchJobResponseBody = (function() {

        /**
         * Properties of a CreateBatchJobResponseBody.
         * @memberof ptsl
         * @interface ICreateBatchJobResponseBody
         * @property {string|null} [id] * Unique ID of the batch job
         */

        /**
         * Constructs a new CreateBatchJobResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes CreateBatchJob response data.
         * @implements ICreateBatchJobResponseBody
         * @constructor
         * @param {ptsl.ICreateBatchJobResponseBody=} [properties] Properties to set
         */
        function CreateBatchJobResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Unique ID of the batch job
         * @member {string} id
         * @memberof ptsl.CreateBatchJobResponseBody
         * @instance
         */
        CreateBatchJobResponseBody.prototype.id = "";

        /**
         * Creates a new CreateBatchJobResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {ptsl.ICreateBatchJobResponseBody=} [properties] Properties to set
         * @returns {ptsl.CreateBatchJobResponseBody} CreateBatchJobResponseBody instance
         */
        CreateBatchJobResponseBody.create = function create(properties) {
            return new CreateBatchJobResponseBody(properties);
        };

        /**
         * Encodes the specified CreateBatchJobResponseBody message. Does not implicitly {@link ptsl.CreateBatchJobResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {ptsl.ICreateBatchJobResponseBody} message CreateBatchJobResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateBatchJobResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified CreateBatchJobResponseBody message, length delimited. Does not implicitly {@link ptsl.CreateBatchJobResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {ptsl.ICreateBatchJobResponseBody} message CreateBatchJobResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateBatchJobResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateBatchJobResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CreateBatchJobResponseBody} CreateBatchJobResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateBatchJobResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CreateBatchJobResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateBatchJobResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CreateBatchJobResponseBody} CreateBatchJobResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateBatchJobResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateBatchJobResponseBody message.
         * @function verify
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateBatchJobResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a CreateBatchJobResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CreateBatchJobResponseBody} CreateBatchJobResponseBody
         */
        CreateBatchJobResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CreateBatchJobResponseBody)
                return object;
            var message = new $root.ptsl.CreateBatchJobResponseBody();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a CreateBatchJobResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {ptsl.CreateBatchJobResponseBody} message CreateBatchJobResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateBatchJobResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this CreateBatchJobResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.CreateBatchJobResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateBatchJobResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateBatchJobResponseBody
         * @function getTypeUrl
         * @memberof ptsl.CreateBatchJobResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateBatchJobResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CreateBatchJobResponseBody";
        };

        return CreateBatchJobResponseBody;
    })();

    ptsl.GetExportMixSourceListRequestBody = (function() {

        /**
         * Properties of a GetExportMixSourceListRequestBody.
         * @memberof ptsl
         * @interface IGetExportMixSourceListRequestBody
         * @property {ptsl.EM_SourceType|null} [type] GetExportMixSourceListRequestBody type
         */

        /**
         * Constructs a new GetExportMixSourceListRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetExportMixSourceList request data.
         * 
         * @since Pro Tools 2025.06
         * @implements IGetExportMixSourceListRequestBody
         * @constructor
         * @param {ptsl.IGetExportMixSourceListRequestBody=} [properties] Properties to set
         */
        function GetExportMixSourceListRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExportMixSourceListRequestBody type.
         * @member {ptsl.EM_SourceType} type
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @instance
         */
        GetExportMixSourceListRequestBody.prototype.type = 0;

        /**
         * Creates a new GetExportMixSourceListRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {ptsl.IGetExportMixSourceListRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetExportMixSourceListRequestBody} GetExportMixSourceListRequestBody instance
         */
        GetExportMixSourceListRequestBody.create = function create(properties) {
            return new GetExportMixSourceListRequestBody(properties);
        };

        /**
         * Encodes the specified GetExportMixSourceListRequestBody message. Does not implicitly {@link ptsl.GetExportMixSourceListRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {ptsl.IGetExportMixSourceListRequestBody} message GetExportMixSourceListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExportMixSourceListRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified GetExportMixSourceListRequestBody message, length delimited. Does not implicitly {@link ptsl.GetExportMixSourceListRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {ptsl.IGetExportMixSourceListRequestBody} message GetExportMixSourceListRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExportMixSourceListRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExportMixSourceListRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetExportMixSourceListRequestBody} GetExportMixSourceListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExportMixSourceListRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetExportMixSourceListRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExportMixSourceListRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetExportMixSourceListRequestBody} GetExportMixSourceListRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExportMixSourceListRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExportMixSourceListRequestBody message.
         * @function verify
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExportMixSourceListRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetExportMixSourceListRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetExportMixSourceListRequestBody} GetExportMixSourceListRequestBody
         */
        GetExportMixSourceListRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetExportMixSourceListRequestBody)
                return object;
            var message = new $root.ptsl.GetExportMixSourceListRequestBody();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "EMSType_Unknown":
            case 0:
                message.type = 0;
                break;
            case "PhysicalOut":
            case 1:
                message.type = 1;
                break;
            case "EMSType_PhysicalOut":
            case 1:
                message.type = 1;
                break;
            case "Bus":
            case 2:
                message.type = 2;
                break;
            case "EMSType_Bus":
            case 2:
                message.type = 2;
                break;
            case "Output":
            case 3:
                message.type = 3;
                break;
            case "EMSType_Output":
            case 3:
                message.type = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExportMixSourceListRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {ptsl.GetExportMixSourceListRequestBody} message GetExportMixSourceListRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExportMixSourceListRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "EMSType_Unknown" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ptsl.EM_SourceType[message.type] === undefined ? message.type : $root.ptsl.EM_SourceType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this GetExportMixSourceListRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExportMixSourceListRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetExportMixSourceListRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetExportMixSourceListRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetExportMixSourceListRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetExportMixSourceListRequestBody";
        };

        return GetExportMixSourceListRequestBody;
    })();

    ptsl.GetExportMixSourceListResponseBody = (function() {

        /**
         * Properties of a GetExportMixSourceListResponseBody.
         * @memberof ptsl
         * @interface IGetExportMixSourceListResponseBody
         * @property {Array.<string>|null} [sourceList] GetExportMixSourceListResponseBody sourceList
         */

        /**
         * Constructs a new GetExportMixSourceListResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetExportMixSourceList response data.
         * 
         * @since Pro Tools 2025.06
         * @implements IGetExportMixSourceListResponseBody
         * @constructor
         * @param {ptsl.IGetExportMixSourceListResponseBody=} [properties] Properties to set
         */
        function GetExportMixSourceListResponseBody(properties) {
            this.sourceList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetExportMixSourceListResponseBody sourceList.
         * @member {Array.<string>} sourceList
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @instance
         */
        GetExportMixSourceListResponseBody.prototype.sourceList = $util.emptyArray;

        /**
         * Creates a new GetExportMixSourceListResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {ptsl.IGetExportMixSourceListResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetExportMixSourceListResponseBody} GetExportMixSourceListResponseBody instance
         */
        GetExportMixSourceListResponseBody.create = function create(properties) {
            return new GetExportMixSourceListResponseBody(properties);
        };

        /**
         * Encodes the specified GetExportMixSourceListResponseBody message. Does not implicitly {@link ptsl.GetExportMixSourceListResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {ptsl.IGetExportMixSourceListResponseBody} message GetExportMixSourceListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExportMixSourceListResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sourceList != null && message.sourceList.length)
                for (var i = 0; i < message.sourceList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourceList[i]);
            return writer;
        };

        /**
         * Encodes the specified GetExportMixSourceListResponseBody message, length delimited. Does not implicitly {@link ptsl.GetExportMixSourceListResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {ptsl.IGetExportMixSourceListResponseBody} message GetExportMixSourceListResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetExportMixSourceListResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetExportMixSourceListResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetExportMixSourceListResponseBody} GetExportMixSourceListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExportMixSourceListResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetExportMixSourceListResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.sourceList && message.sourceList.length))
                            message.sourceList = [];
                        message.sourceList.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetExportMixSourceListResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetExportMixSourceListResponseBody} GetExportMixSourceListResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetExportMixSourceListResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetExportMixSourceListResponseBody message.
         * @function verify
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetExportMixSourceListResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sourceList != null && message.hasOwnProperty("sourceList")) {
                if (!Array.isArray(message.sourceList))
                    return "sourceList: array expected";
                for (var i = 0; i < message.sourceList.length; ++i)
                    if (!$util.isString(message.sourceList[i]))
                        return "sourceList: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetExportMixSourceListResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetExportMixSourceListResponseBody} GetExportMixSourceListResponseBody
         */
        GetExportMixSourceListResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetExportMixSourceListResponseBody)
                return object;
            var message = new $root.ptsl.GetExportMixSourceListResponseBody();
            if (object.sourceList) {
                if (!Array.isArray(object.sourceList))
                    throw TypeError(".ptsl.GetExportMixSourceListResponseBody.sourceList: array expected");
                message.sourceList = [];
                for (var i = 0; i < object.sourceList.length; ++i)
                    message.sourceList[i] = String(object.sourceList[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetExportMixSourceListResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {ptsl.GetExportMixSourceListResponseBody} message GetExportMixSourceListResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetExportMixSourceListResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sourceList = [];
            if (message.sourceList && message.sourceList.length) {
                object.sourceList = [];
                for (var j = 0; j < message.sourceList.length; ++j)
                    object.sourceList[j] = message.sourceList[j];
            }
            return object;
        };

        /**
         * Converts this GetExportMixSourceListResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetExportMixSourceListResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetExportMixSourceListResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetExportMixSourceListResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetExportMixSourceListResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetExportMixSourceListResponseBody";
        };

        return GetExportMixSourceListResponseBody;
    })();

    ptsl.BeginScrubRequestBody = (function() {

        /**
         * Properties of a BeginScrubRequestBody.
         * @memberof ptsl
         * @interface IBeginScrubRequestBody
         * @property {number|Long|null} [startPosition] BeginScrubRequestBody startPosition
         */

        /**
         * Constructs a new BeginScrubRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes BeginScrub request data.
         * @implements IBeginScrubRequestBody
         * @constructor
         * @param {ptsl.IBeginScrubRequestBody=} [properties] Properties to set
         */
        function BeginScrubRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginScrubRequestBody startPosition.
         * @member {number|Long} startPosition
         * @memberof ptsl.BeginScrubRequestBody
         * @instance
         */
        BeginScrubRequestBody.prototype.startPosition = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BeginScrubRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {ptsl.IBeginScrubRequestBody=} [properties] Properties to set
         * @returns {ptsl.BeginScrubRequestBody} BeginScrubRequestBody instance
         */
        BeginScrubRequestBody.create = function create(properties) {
            return new BeginScrubRequestBody(properties);
        };

        /**
         * Encodes the specified BeginScrubRequestBody message. Does not implicitly {@link ptsl.BeginScrubRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {ptsl.IBeginScrubRequestBody} message BeginScrubRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginScrubRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startPosition != null && Object.hasOwnProperty.call(message, "startPosition"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startPosition);
            return writer;
        };

        /**
         * Encodes the specified BeginScrubRequestBody message, length delimited. Does not implicitly {@link ptsl.BeginScrubRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {ptsl.IBeginScrubRequestBody} message BeginScrubRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginScrubRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginScrubRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.BeginScrubRequestBody} BeginScrubRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginScrubRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.BeginScrubRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.startPosition = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginScrubRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.BeginScrubRequestBody} BeginScrubRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginScrubRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginScrubRequestBody message.
         * @function verify
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginScrubRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startPosition != null && message.hasOwnProperty("startPosition"))
                if (!$util.isInteger(message.startPosition) && !(message.startPosition && $util.isInteger(message.startPosition.low) && $util.isInteger(message.startPosition.high)))
                    return "startPosition: integer|Long expected";
            return null;
        };

        /**
         * Creates a BeginScrubRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.BeginScrubRequestBody} BeginScrubRequestBody
         */
        BeginScrubRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.BeginScrubRequestBody)
                return object;
            var message = new $root.ptsl.BeginScrubRequestBody();
            if (object.startPosition != null)
                if ($util.Long)
                    (message.startPosition = $util.Long.fromValue(object.startPosition)).unsigned = false;
                else if (typeof object.startPosition === "string")
                    message.startPosition = parseInt(object.startPosition, 10);
                else if (typeof object.startPosition === "number")
                    message.startPosition = object.startPosition;
                else if (typeof object.startPosition === "object")
                    message.startPosition = new $util.LongBits(object.startPosition.low >>> 0, object.startPosition.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BeginScrubRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {ptsl.BeginScrubRequestBody} message BeginScrubRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginScrubRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startPosition = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startPosition = options.longs === String ? "0" : 0;
            if (message.startPosition != null && message.hasOwnProperty("startPosition"))
                if (typeof message.startPosition === "number")
                    object.startPosition = options.longs === String ? String(message.startPosition) : message.startPosition;
                else
                    object.startPosition = options.longs === String ? $util.Long.prototype.toString.call(message.startPosition) : options.longs === Number ? new $util.LongBits(message.startPosition.low >>> 0, message.startPosition.high >>> 0).toNumber() : message.startPosition;
            return object;
        };

        /**
         * Converts this BeginScrubRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.BeginScrubRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginScrubRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BeginScrubRequestBody
         * @function getTypeUrl
         * @memberof ptsl.BeginScrubRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BeginScrubRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.BeginScrubRequestBody";
        };

        return BeginScrubRequestBody;
    })();

    ptsl.ContinueScrubRequestBody = (function() {

        /**
         * Properties of a ContinueScrubRequestBody.
         * @memberof ptsl
         * @interface IContinueScrubRequestBody
         * @property {number|null} [velocity] ContinueScrubRequestBody velocity
         */

        /**
         * Constructs a new ContinueScrubRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ContinueScrub request data.
         * @implements IContinueScrubRequestBody
         * @constructor
         * @param {ptsl.IContinueScrubRequestBody=} [properties] Properties to set
         */
        function ContinueScrubRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContinueScrubRequestBody velocity.
         * @member {number} velocity
         * @memberof ptsl.ContinueScrubRequestBody
         * @instance
         */
        ContinueScrubRequestBody.prototype.velocity = 0;

        /**
         * Creates a new ContinueScrubRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {ptsl.IContinueScrubRequestBody=} [properties] Properties to set
         * @returns {ptsl.ContinueScrubRequestBody} ContinueScrubRequestBody instance
         */
        ContinueScrubRequestBody.create = function create(properties) {
            return new ContinueScrubRequestBody(properties);
        };

        /**
         * Encodes the specified ContinueScrubRequestBody message. Does not implicitly {@link ptsl.ContinueScrubRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {ptsl.IContinueScrubRequestBody} message ContinueScrubRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinueScrubRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.velocity);
            return writer;
        };

        /**
         * Encodes the specified ContinueScrubRequestBody message, length delimited. Does not implicitly {@link ptsl.ContinueScrubRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {ptsl.IContinueScrubRequestBody} message ContinueScrubRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinueScrubRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContinueScrubRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ContinueScrubRequestBody} ContinueScrubRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinueScrubRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ContinueScrubRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.velocity = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContinueScrubRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ContinueScrubRequestBody} ContinueScrubRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinueScrubRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContinueScrubRequestBody message.
         * @function verify
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContinueScrubRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.velocity != null && message.hasOwnProperty("velocity"))
                if (!$util.isInteger(message.velocity))
                    return "velocity: integer expected";
            return null;
        };

        /**
         * Creates a ContinueScrubRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ContinueScrubRequestBody} ContinueScrubRequestBody
         */
        ContinueScrubRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ContinueScrubRequestBody)
                return object;
            var message = new $root.ptsl.ContinueScrubRequestBody();
            if (object.velocity != null)
                message.velocity = object.velocity | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContinueScrubRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {ptsl.ContinueScrubRequestBody} message ContinueScrubRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContinueScrubRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.velocity = 0;
            if (message.velocity != null && message.hasOwnProperty("velocity"))
                object.velocity = message.velocity;
            return object;
        };

        /**
         * Converts this ContinueScrubRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ContinueScrubRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContinueScrubRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContinueScrubRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ContinueScrubRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContinueScrubRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ContinueScrubRequestBody";
        };

        return ContinueScrubRequestBody;
    })();

    ptsl.ContinueScrubResponseBody = (function() {

        /**
         * Properties of a ContinueScrubResponseBody.
         * @memberof ptsl
         * @interface IContinueScrubResponseBody
         * @property {ptsl.ITimelineLocation|null} [timelinePosition] ContinueScrubResponseBody timelinePosition
         */

        /**
         * Constructs a new ContinueScrubResponseBody.
         * @memberof ptsl
         * @classdesc Represents a ContinueScrubResponseBody.
         * @implements IContinueScrubResponseBody
         * @constructor
         * @param {ptsl.IContinueScrubResponseBody=} [properties] Properties to set
         */
        function ContinueScrubResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContinueScrubResponseBody timelinePosition.
         * @member {ptsl.ITimelineLocation|null|undefined} timelinePosition
         * @memberof ptsl.ContinueScrubResponseBody
         * @instance
         */
        ContinueScrubResponseBody.prototype.timelinePosition = null;

        /**
         * Creates a new ContinueScrubResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {ptsl.IContinueScrubResponseBody=} [properties] Properties to set
         * @returns {ptsl.ContinueScrubResponseBody} ContinueScrubResponseBody instance
         */
        ContinueScrubResponseBody.create = function create(properties) {
            return new ContinueScrubResponseBody(properties);
        };

        /**
         * Encodes the specified ContinueScrubResponseBody message. Does not implicitly {@link ptsl.ContinueScrubResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {ptsl.IContinueScrubResponseBody} message ContinueScrubResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinueScrubResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timelinePosition != null && Object.hasOwnProperty.call(message, "timelinePosition"))
                $root.ptsl.TimelineLocation.encode(message.timelinePosition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContinueScrubResponseBody message, length delimited. Does not implicitly {@link ptsl.ContinueScrubResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {ptsl.IContinueScrubResponseBody} message ContinueScrubResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinueScrubResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContinueScrubResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ContinueScrubResponseBody} ContinueScrubResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinueScrubResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ContinueScrubResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.timelinePosition = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContinueScrubResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ContinueScrubResponseBody} ContinueScrubResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinueScrubResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContinueScrubResponseBody message.
         * @function verify
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContinueScrubResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timelinePosition != null && message.hasOwnProperty("timelinePosition")) {
                var error = $root.ptsl.TimelineLocation.verify(message.timelinePosition);
                if (error)
                    return "timelinePosition." + error;
            }
            return null;
        };

        /**
         * Creates a ContinueScrubResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ContinueScrubResponseBody} ContinueScrubResponseBody
         */
        ContinueScrubResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ContinueScrubResponseBody)
                return object;
            var message = new $root.ptsl.ContinueScrubResponseBody();
            if (object.timelinePosition != null) {
                if (typeof object.timelinePosition !== "object")
                    throw TypeError(".ptsl.ContinueScrubResponseBody.timelinePosition: object expected");
                message.timelinePosition = $root.ptsl.TimelineLocation.fromObject(object.timelinePosition);
            }
            return message;
        };

        /**
         * Creates a plain object from a ContinueScrubResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {ptsl.ContinueScrubResponseBody} message ContinueScrubResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContinueScrubResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.timelinePosition = null;
            if (message.timelinePosition != null && message.hasOwnProperty("timelinePosition"))
                object.timelinePosition = $root.ptsl.TimelineLocation.toObject(message.timelinePosition, options);
            return object;
        };

        /**
         * Converts this ContinueScrubResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ContinueScrubResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContinueScrubResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContinueScrubResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ContinueScrubResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContinueScrubResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ContinueScrubResponseBody";
        };

        return ContinueScrubResponseBody;
    })();

    ptsl.EnableCueProVideoPlugInRequestBody = (function() {

        /**
         * Properties of an EnableCueProVideoPlugInRequestBody.
         * @memberof ptsl
         * @interface IEnableCueProVideoPlugInRequestBody
         * @property {boolean|null} [enable] EnableCueProVideoPlugInRequestBody enable
         */

        /**
         * Constructs a new EnableCueProVideoPlugInRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes EnableCueProVideoPlugIn request data.
         * @implements IEnableCueProVideoPlugInRequestBody
         * @constructor
         * @param {ptsl.IEnableCueProVideoPlugInRequestBody=} [properties] Properties to set
         */
        function EnableCueProVideoPlugInRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnableCueProVideoPlugInRequestBody enable.
         * @member {boolean} enable
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @instance
         */
        EnableCueProVideoPlugInRequestBody.prototype.enable = false;

        /**
         * Creates a new EnableCueProVideoPlugInRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {ptsl.IEnableCueProVideoPlugInRequestBody=} [properties] Properties to set
         * @returns {ptsl.EnableCueProVideoPlugInRequestBody} EnableCueProVideoPlugInRequestBody instance
         */
        EnableCueProVideoPlugInRequestBody.create = function create(properties) {
            return new EnableCueProVideoPlugInRequestBody(properties);
        };

        /**
         * Encodes the specified EnableCueProVideoPlugInRequestBody message. Does not implicitly {@link ptsl.EnableCueProVideoPlugInRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {ptsl.IEnableCueProVideoPlugInRequestBody} message EnableCueProVideoPlugInRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnableCueProVideoPlugInRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enable);
            return writer;
        };

        /**
         * Encodes the specified EnableCueProVideoPlugInRequestBody message, length delimited. Does not implicitly {@link ptsl.EnableCueProVideoPlugInRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {ptsl.IEnableCueProVideoPlugInRequestBody} message EnableCueProVideoPlugInRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnableCueProVideoPlugInRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnableCueProVideoPlugInRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EnableCueProVideoPlugInRequestBody} EnableCueProVideoPlugInRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnableCueProVideoPlugInRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EnableCueProVideoPlugInRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.enable = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnableCueProVideoPlugInRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EnableCueProVideoPlugInRequestBody} EnableCueProVideoPlugInRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnableCueProVideoPlugInRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnableCueProVideoPlugInRequestBody message.
         * @function verify
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnableCueProVideoPlugInRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enable != null && message.hasOwnProperty("enable"))
                if (typeof message.enable !== "boolean")
                    return "enable: boolean expected";
            return null;
        };

        /**
         * Creates an EnableCueProVideoPlugInRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EnableCueProVideoPlugInRequestBody} EnableCueProVideoPlugInRequestBody
         */
        EnableCueProVideoPlugInRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EnableCueProVideoPlugInRequestBody)
                return object;
            var message = new $root.ptsl.EnableCueProVideoPlugInRequestBody();
            if (object.enable != null)
                message.enable = Boolean(object.enable);
            return message;
        };

        /**
         * Creates a plain object from an EnableCueProVideoPlugInRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {ptsl.EnableCueProVideoPlugInRequestBody} message EnableCueProVideoPlugInRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnableCueProVideoPlugInRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enable = false;
            if (message.enable != null && message.hasOwnProperty("enable"))
                object.enable = message.enable;
            return object;
        };

        /**
         * Converts this EnableCueProVideoPlugInRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnableCueProVideoPlugInRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EnableCueProVideoPlugInRequestBody
         * @function getTypeUrl
         * @memberof ptsl.EnableCueProVideoPlugInRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EnableCueProVideoPlugInRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EnableCueProVideoPlugInRequestBody";
        };

        return EnableCueProVideoPlugInRequestBody;
    })();

    ptsl.UpdateVideoRequestBody = (function() {

        /**
         * Properties of an UpdateVideoRequestBody.
         * @memberof ptsl
         * @interface IUpdateVideoRequestBody
         * @property {number|Long|null} [framePosition] UpdateVideoRequestBody framePosition
         */

        /**
         * Constructs a new UpdateVideoRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes UpdateVideo request data.
         * @implements IUpdateVideoRequestBody
         * @constructor
         * @param {ptsl.IUpdateVideoRequestBody=} [properties] Properties to set
         */
        function UpdateVideoRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateVideoRequestBody framePosition.
         * @member {number|Long} framePosition
         * @memberof ptsl.UpdateVideoRequestBody
         * @instance
         */
        UpdateVideoRequestBody.prototype.framePosition = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateVideoRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {ptsl.IUpdateVideoRequestBody=} [properties] Properties to set
         * @returns {ptsl.UpdateVideoRequestBody} UpdateVideoRequestBody instance
         */
        UpdateVideoRequestBody.create = function create(properties) {
            return new UpdateVideoRequestBody(properties);
        };

        /**
         * Encodes the specified UpdateVideoRequestBody message. Does not implicitly {@link ptsl.UpdateVideoRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {ptsl.IUpdateVideoRequestBody} message UpdateVideoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateVideoRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.framePosition != null && Object.hasOwnProperty.call(message, "framePosition"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.framePosition);
            return writer;
        };

        /**
         * Encodes the specified UpdateVideoRequestBody message, length delimited. Does not implicitly {@link ptsl.UpdateVideoRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {ptsl.IUpdateVideoRequestBody} message UpdateVideoRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateVideoRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateVideoRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.UpdateVideoRequestBody} UpdateVideoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateVideoRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.UpdateVideoRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.framePosition = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateVideoRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.UpdateVideoRequestBody} UpdateVideoRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateVideoRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateVideoRequestBody message.
         * @function verify
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateVideoRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.framePosition != null && message.hasOwnProperty("framePosition"))
                if (!$util.isInteger(message.framePosition) && !(message.framePosition && $util.isInteger(message.framePosition.low) && $util.isInteger(message.framePosition.high)))
                    return "framePosition: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateVideoRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.UpdateVideoRequestBody} UpdateVideoRequestBody
         */
        UpdateVideoRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.UpdateVideoRequestBody)
                return object;
            var message = new $root.ptsl.UpdateVideoRequestBody();
            if (object.framePosition != null)
                if ($util.Long)
                    (message.framePosition = $util.Long.fromValue(object.framePosition)).unsigned = false;
                else if (typeof object.framePosition === "string")
                    message.framePosition = parseInt(object.framePosition, 10);
                else if (typeof object.framePosition === "number")
                    message.framePosition = object.framePosition;
                else if (typeof object.framePosition === "object")
                    message.framePosition = new $util.LongBits(object.framePosition.low >>> 0, object.framePosition.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateVideoRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {ptsl.UpdateVideoRequestBody} message UpdateVideoRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateVideoRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.framePosition = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.framePosition = options.longs === String ? "0" : 0;
            if (message.framePosition != null && message.hasOwnProperty("framePosition"))
                if (typeof message.framePosition === "number")
                    object.framePosition = options.longs === String ? String(message.framePosition) : message.framePosition;
                else
                    object.framePosition = options.longs === String ? $util.Long.prototype.toString.call(message.framePosition) : options.longs === Number ? new $util.LongBits(message.framePosition.low >>> 0, message.framePosition.high >>> 0).toNumber() : message.framePosition;
            return object;
        };

        /**
         * Converts this UpdateVideoRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.UpdateVideoRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateVideoRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UpdateVideoRequestBody
         * @function getTypeUrl
         * @memberof ptsl.UpdateVideoRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpdateVideoRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.UpdateVideoRequestBody";
        };

        return UpdateVideoRequestBody;
    })();

    ptsl.GetMonitorOutputPathResponseBody = (function() {

        /**
         * Properties of a GetMonitorOutputPathResponseBody.
         * @memberof ptsl
         * @interface IGetMonitorOutputPathResponseBody
         * @property {string|null} [monitorPath] * Currently assigned monitor path.
         */

        /**
         * Constructs a new GetMonitorOutputPathResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetMonitorOutputPath response data.
         * @implements IGetMonitorOutputPathResponseBody
         * @constructor
         * @param {ptsl.IGetMonitorOutputPathResponseBody=} [properties] Properties to set
         */
        function GetMonitorOutputPathResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Currently assigned monitor path.
         * @member {string} monitorPath
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @instance
         */
        GetMonitorOutputPathResponseBody.prototype.monitorPath = "";

        /**
         * Creates a new GetMonitorOutputPathResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {ptsl.IGetMonitorOutputPathResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetMonitorOutputPathResponseBody} GetMonitorOutputPathResponseBody instance
         */
        GetMonitorOutputPathResponseBody.create = function create(properties) {
            return new GetMonitorOutputPathResponseBody(properties);
        };

        /**
         * Encodes the specified GetMonitorOutputPathResponseBody message. Does not implicitly {@link ptsl.GetMonitorOutputPathResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {ptsl.IGetMonitorOutputPathResponseBody} message GetMonitorOutputPathResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMonitorOutputPathResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.monitorPath != null && Object.hasOwnProperty.call(message, "monitorPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.monitorPath);
            return writer;
        };

        /**
         * Encodes the specified GetMonitorOutputPathResponseBody message, length delimited. Does not implicitly {@link ptsl.GetMonitorOutputPathResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {ptsl.IGetMonitorOutputPathResponseBody} message GetMonitorOutputPathResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMonitorOutputPathResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMonitorOutputPathResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetMonitorOutputPathResponseBody} GetMonitorOutputPathResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMonitorOutputPathResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetMonitorOutputPathResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.monitorPath = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMonitorOutputPathResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetMonitorOutputPathResponseBody} GetMonitorOutputPathResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMonitorOutputPathResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMonitorOutputPathResponseBody message.
         * @function verify
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMonitorOutputPathResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.monitorPath != null && message.hasOwnProperty("monitorPath"))
                if (!$util.isString(message.monitorPath))
                    return "monitorPath: string expected";
            return null;
        };

        /**
         * Creates a GetMonitorOutputPathResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetMonitorOutputPathResponseBody} GetMonitorOutputPathResponseBody
         */
        GetMonitorOutputPathResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetMonitorOutputPathResponseBody)
                return object;
            var message = new $root.ptsl.GetMonitorOutputPathResponseBody();
            if (object.monitorPath != null)
                message.monitorPath = String(object.monitorPath);
            return message;
        };

        /**
         * Creates a plain object from a GetMonitorOutputPathResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {ptsl.GetMonitorOutputPathResponseBody} message GetMonitorOutputPathResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMonitorOutputPathResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.monitorPath = "";
            if (message.monitorPath != null && message.hasOwnProperty("monitorPath"))
                object.monitorPath = message.monitorPath;
            return object;
        };

        /**
         * Converts this GetMonitorOutputPathResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMonitorOutputPathResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetMonitorOutputPathResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetMonitorOutputPathResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMonitorOutputPathResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetMonitorOutputPathResponseBody";
        };

        return GetMonitorOutputPathResponseBody;
    })();

    ptsl.GetEditSelectionRequestBody = (function() {

        /**
         * Properties of a GetEditSelectionRequestBody.
         * @memberof ptsl
         * @interface IGetEditSelectionRequestBody
         * @property {ptsl.TimelineLocationType|null} [locationType] * Desired timeline location type
         */

        /**
         * Constructs a new GetEditSelectionRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetEditSelection request data.
         * @implements IGetEditSelectionRequestBody
         * @constructor
         * @param {ptsl.IGetEditSelectionRequestBody=} [properties] Properties to set
         */
        function GetEditSelectionRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Desired timeline location type
         * @member {ptsl.TimelineLocationType} locationType
         * @memberof ptsl.GetEditSelectionRequestBody
         * @instance
         */
        GetEditSelectionRequestBody.prototype.locationType = 0;

        /**
         * Creates a new GetEditSelectionRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {ptsl.IGetEditSelectionRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetEditSelectionRequestBody} GetEditSelectionRequestBody instance
         */
        GetEditSelectionRequestBody.create = function create(properties) {
            return new GetEditSelectionRequestBody(properties);
        };

        /**
         * Encodes the specified GetEditSelectionRequestBody message. Does not implicitly {@link ptsl.GetEditSelectionRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {ptsl.IGetEditSelectionRequestBody} message GetEditSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditSelectionRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.locationType != null && Object.hasOwnProperty.call(message, "locationType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.locationType);
            return writer;
        };

        /**
         * Encodes the specified GetEditSelectionRequestBody message, length delimited. Does not implicitly {@link ptsl.GetEditSelectionRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {ptsl.IGetEditSelectionRequestBody} message GetEditSelectionRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditSelectionRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEditSelectionRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetEditSelectionRequestBody} GetEditSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditSelectionRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetEditSelectionRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.locationType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEditSelectionRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetEditSelectionRequestBody} GetEditSelectionRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditSelectionRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEditSelectionRequestBody message.
         * @function verify
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEditSelectionRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                switch (message.locationType) {
                default:
                    return "locationType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetEditSelectionRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetEditSelectionRequestBody} GetEditSelectionRequestBody
         */
        GetEditSelectionRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetEditSelectionRequestBody)
                return object;
            var message = new $root.ptsl.GetEditSelectionRequestBody();
            switch (object.locationType) {
            default:
                if (typeof object.locationType === "number") {
                    message.locationType = object.locationType;
                    break;
                }
                break;
            case "TLType_Unknown":
            case 0:
                message.locationType = 0;
                break;
            case "TLType_Samples":
            case 1:
                message.locationType = 1;
                break;
            case "TLType_Ticks":
            case 2:
                message.locationType = 2;
                break;
            case "TLType_Frames":
            case 3:
                message.locationType = 3;
                break;
            case "TLType_MinSecs":
            case 4:
                message.locationType = 4;
                break;
            case "TLType_TimeCode":
            case 5:
                message.locationType = 5;
                break;
            case "TLType_BarsBeats":
            case 6:
                message.locationType = 6;
                break;
            case "TLType_FeetFrames":
            case 7:
                message.locationType = 7;
                break;
            case "TLType_Seconds":
            case 8:
                message.locationType = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetEditSelectionRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {ptsl.GetEditSelectionRequestBody} message GetEditSelectionRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEditSelectionRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.locationType = options.enums === String ? "TLType_Unknown" : 0;
            if (message.locationType != null && message.hasOwnProperty("locationType"))
                object.locationType = options.enums === String ? $root.ptsl.TimelineLocationType[message.locationType] === undefined ? message.locationType : $root.ptsl.TimelineLocationType[message.locationType] : message.locationType;
            return object;
        };

        /**
         * Converts this GetEditSelectionRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetEditSelectionRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEditSelectionRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetEditSelectionRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetEditSelectionRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetEditSelectionRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetEditSelectionRequestBody";
        };

        return GetEditSelectionRequestBody;
    })();

    ptsl.GetEditSelectionResponseBody = (function() {

        /**
         * Properties of a GetEditSelectionResponseBody.
         * @memberof ptsl
         * @interface IGetEditSelectionResponseBody
         * @property {string|null} [inTime] * Edit selection start
         * @property {string|null} [outTime] * Edit selection end
         */

        /**
         * Constructs a new GetEditSelectionResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetEditSelection response data.
         * @implements IGetEditSelectionResponseBody
         * @constructor
         * @param {ptsl.IGetEditSelectionResponseBody=} [properties] Properties to set
         */
        function GetEditSelectionResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Edit selection start
         * @member {string} inTime
         * @memberof ptsl.GetEditSelectionResponseBody
         * @instance
         */
        GetEditSelectionResponseBody.prototype.inTime = "";

        /**
         * * Edit selection end
         * @member {string} outTime
         * @memberof ptsl.GetEditSelectionResponseBody
         * @instance
         */
        GetEditSelectionResponseBody.prototype.outTime = "";

        /**
         * Creates a new GetEditSelectionResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {ptsl.IGetEditSelectionResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetEditSelectionResponseBody} GetEditSelectionResponseBody instance
         */
        GetEditSelectionResponseBody.create = function create(properties) {
            return new GetEditSelectionResponseBody(properties);
        };

        /**
         * Encodes the specified GetEditSelectionResponseBody message. Does not implicitly {@link ptsl.GetEditSelectionResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {ptsl.IGetEditSelectionResponseBody} message GetEditSelectionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditSelectionResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inTime != null && Object.hasOwnProperty.call(message, "inTime"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.inTime);
            if (message.outTime != null && Object.hasOwnProperty.call(message, "outTime"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.outTime);
            return writer;
        };

        /**
         * Encodes the specified GetEditSelectionResponseBody message, length delimited. Does not implicitly {@link ptsl.GetEditSelectionResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {ptsl.IGetEditSelectionResponseBody} message GetEditSelectionResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetEditSelectionResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetEditSelectionResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetEditSelectionResponseBody} GetEditSelectionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditSelectionResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetEditSelectionResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.inTime = reader.string();
                        break;
                    }
                case 2: {
                        message.outTime = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetEditSelectionResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetEditSelectionResponseBody} GetEditSelectionResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetEditSelectionResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetEditSelectionResponseBody message.
         * @function verify
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetEditSelectionResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.inTime != null && message.hasOwnProperty("inTime"))
                if (!$util.isString(message.inTime))
                    return "inTime: string expected";
            if (message.outTime != null && message.hasOwnProperty("outTime"))
                if (!$util.isString(message.outTime))
                    return "outTime: string expected";
            return null;
        };

        /**
         * Creates a GetEditSelectionResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetEditSelectionResponseBody} GetEditSelectionResponseBody
         */
        GetEditSelectionResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetEditSelectionResponseBody)
                return object;
            var message = new $root.ptsl.GetEditSelectionResponseBody();
            if (object.inTime != null)
                message.inTime = String(object.inTime);
            if (object.outTime != null)
                message.outTime = String(object.outTime);
            return message;
        };

        /**
         * Creates a plain object from a GetEditSelectionResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {ptsl.GetEditSelectionResponseBody} message GetEditSelectionResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetEditSelectionResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.inTime = "";
                object.outTime = "";
            }
            if (message.inTime != null && message.hasOwnProperty("inTime"))
                object.inTime = message.inTime;
            if (message.outTime != null && message.hasOwnProperty("outTime"))
                object.outTime = message.outTime;
            return object;
        };

        /**
         * Converts this GetEditSelectionResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetEditSelectionResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetEditSelectionResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetEditSelectionResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetEditSelectionResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetEditSelectionResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetEditSelectionResponseBody";
        };

        return GetEditSelectionResponseBody;
    })();

    ptsl.SubscribeToEventsRequestBody = (function() {

        /**
         * Properties of a SubscribeToEventsRequestBody.
         * @memberof ptsl
         * @interface ISubscribeToEventsRequestBody
         * @property {Array.<ptsl.IEventRequestData>|null} [events] * List of events to subscribe to.
         */

        /**
         * Constructs a new SubscribeToEventsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes SubscribeToEvents request data.
         * @implements ISubscribeToEventsRequestBody
         * @constructor
         * @param {ptsl.ISubscribeToEventsRequestBody=} [properties] Properties to set
         */
        function SubscribeToEventsRequestBody(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of events to subscribe to.
         * @member {Array.<ptsl.IEventRequestData>} events
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @instance
         */
        SubscribeToEventsRequestBody.prototype.events = $util.emptyArray;

        /**
         * Creates a new SubscribeToEventsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {ptsl.ISubscribeToEventsRequestBody=} [properties] Properties to set
         * @returns {ptsl.SubscribeToEventsRequestBody} SubscribeToEventsRequestBody instance
         */
        SubscribeToEventsRequestBody.create = function create(properties) {
            return new SubscribeToEventsRequestBody(properties);
        };

        /**
         * Encodes the specified SubscribeToEventsRequestBody message. Does not implicitly {@link ptsl.SubscribeToEventsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {ptsl.ISubscribeToEventsRequestBody} message SubscribeToEventsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeToEventsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.ptsl.EventRequestData.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribeToEventsRequestBody message, length delimited. Does not implicitly {@link ptsl.SubscribeToEventsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {ptsl.ISubscribeToEventsRequestBody} message SubscribeToEventsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeToEventsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeToEventsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.SubscribeToEventsRequestBody} SubscribeToEventsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeToEventsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.SubscribeToEventsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push($root.ptsl.EventRequestData.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeToEventsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.SubscribeToEventsRequestBody} SubscribeToEventsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeToEventsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeToEventsRequestBody message.
         * @function verify
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeToEventsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.ptsl.EventRequestData.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubscribeToEventsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.SubscribeToEventsRequestBody} SubscribeToEventsRequestBody
         */
        SubscribeToEventsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.SubscribeToEventsRequestBody)
                return object;
            var message = new $root.ptsl.SubscribeToEventsRequestBody();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".ptsl.SubscribeToEventsRequestBody.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".ptsl.SubscribeToEventsRequestBody.events: object expected");
                    message.events[i] = $root.ptsl.EventRequestData.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeToEventsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {ptsl.SubscribeToEventsRequestBody} message SubscribeToEventsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeToEventsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.ptsl.EventRequestData.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this SubscribeToEventsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeToEventsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeToEventsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.SubscribeToEventsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeToEventsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.SubscribeToEventsRequestBody";
        };

        return SubscribeToEventsRequestBody;
    })();

    /**
     * Enum that defines the possible statuses for a batch job.
     * @since Pro Tools 2025.06
     * @name ptsl.BatchJobStatus
     * @enum {number}
     * @property {number} BatchJobStatus_Unknown=0 * Tech-only value. Don't use it in requests.
     * @property {number} BatchJobStatus_Pending=1 * Pending status is set upon a job creation.
     * @property {number} BatchJobStatus_Running=2 * Running status is set when job is running.
     * @property {number} BatchJobStatus_Completed=3 * Completed status is set when job is finished successfully.
     * @property {number} BatchJobStatus_TimedOut=4 * TimedOut status is set when job is timed out.
     * @property {number} BatchJobStatus_Failed=5 * Failed status is set when some command in this job is failed.
     * @property {number} BatchJobStatus_Canceled=6 * Canceled status is set when timeout occurred or host closed connection or canceled job manually.
     */
    ptsl.BatchJobStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BatchJobStatus_Unknown"] = 0;
        values[valuesById[1] = "BatchJobStatus_Pending"] = 1;
        values[valuesById[2] = "BatchJobStatus_Running"] = 2;
        values[valuesById[3] = "BatchJobStatus_Completed"] = 3;
        values[valuesById[4] = "BatchJobStatus_TimedOut"] = 4;
        values[valuesById[5] = "BatchJobStatus_Failed"] = 5;
        values[valuesById[6] = "BatchJobStatus_Canceled"] = 6;
        return values;
    })();

    ptsl.BatchJobStatusInfo = (function() {

        /**
         * Properties of a BatchJobStatusInfo.
         * @memberof ptsl
         * @interface IBatchJobStatusInfo
         * @property {ptsl.IBatchJobDefinition|null} [jobData] * Information about the batch job.
         * @property {string|null} [id] * Unique ID of the batch job.
         * @property {number|null} [progress] * Progress of the job as a percentage.
         * @property {ptsl.BatchJobStatus|null} [status] * Status of the job.
         */

        /**
         * Constructs a new BatchJobStatusInfo.
         * @memberof ptsl
         * @classdesc Structure that is used to communicate the status of a batch job.
         * @since Pro Tools 2025.06
         * @implements IBatchJobStatusInfo
         * @constructor
         * @param {ptsl.IBatchJobStatusInfo=} [properties] Properties to set
         */
        function BatchJobStatusInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Information about the batch job.
         * @member {ptsl.IBatchJobDefinition|null|undefined} jobData
         * @memberof ptsl.BatchJobStatusInfo
         * @instance
         */
        BatchJobStatusInfo.prototype.jobData = null;

        /**
         * * Unique ID of the batch job.
         * @member {string} id
         * @memberof ptsl.BatchJobStatusInfo
         * @instance
         */
        BatchJobStatusInfo.prototype.id = "";

        /**
         * * Progress of the job as a percentage.
         * @member {number} progress
         * @memberof ptsl.BatchJobStatusInfo
         * @instance
         */
        BatchJobStatusInfo.prototype.progress = 0;

        /**
         * * Status of the job.
         * @member {ptsl.BatchJobStatus} status
         * @memberof ptsl.BatchJobStatusInfo
         * @instance
         */
        BatchJobStatusInfo.prototype.status = 0;

        /**
         * Creates a new BatchJobStatusInfo instance using the specified properties.
         * @function create
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {ptsl.IBatchJobStatusInfo=} [properties] Properties to set
         * @returns {ptsl.BatchJobStatusInfo} BatchJobStatusInfo instance
         */
        BatchJobStatusInfo.create = function create(properties) {
            return new BatchJobStatusInfo(properties);
        };

        /**
         * Encodes the specified BatchJobStatusInfo message. Does not implicitly {@link ptsl.BatchJobStatusInfo.verify|verify} messages.
         * @function encode
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {ptsl.IBatchJobStatusInfo} message BatchJobStatusInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchJobStatusInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jobData != null && Object.hasOwnProperty.call(message, "jobData"))
                $root.ptsl.BatchJobDefinition.encode(message.jobData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.progress);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified BatchJobStatusInfo message, length delimited. Does not implicitly {@link ptsl.BatchJobStatusInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {ptsl.IBatchJobStatusInfo} message BatchJobStatusInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchJobStatusInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BatchJobStatusInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.BatchJobStatusInfo} BatchJobStatusInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchJobStatusInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.BatchJobStatusInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.jobData = $root.ptsl.BatchJobDefinition.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.id = reader.string();
                        break;
                    }
                case 3: {
                        message.progress = reader.int32();
                        break;
                    }
                case 4: {
                        message.status = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BatchJobStatusInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.BatchJobStatusInfo} BatchJobStatusInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchJobStatusInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BatchJobStatusInfo message.
         * @function verify
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BatchJobStatusInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jobData != null && message.hasOwnProperty("jobData")) {
                var error = $root.ptsl.BatchJobDefinition.verify(message.jobData);
                if (error)
                    return "jobData." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates a BatchJobStatusInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.BatchJobStatusInfo} BatchJobStatusInfo
         */
        BatchJobStatusInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.BatchJobStatusInfo)
                return object;
            var message = new $root.ptsl.BatchJobStatusInfo();
            if (object.jobData != null) {
                if (typeof object.jobData !== "object")
                    throw TypeError(".ptsl.BatchJobStatusInfo.jobData: object expected");
                message.jobData = $root.ptsl.BatchJobDefinition.fromObject(object.jobData);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.progress != null)
                message.progress = object.progress | 0;
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "BatchJobStatus_Unknown":
            case 0:
                message.status = 0;
                break;
            case "BatchJobStatus_Pending":
            case 1:
                message.status = 1;
                break;
            case "BatchJobStatus_Running":
            case 2:
                message.status = 2;
                break;
            case "BatchJobStatus_Completed":
            case 3:
                message.status = 3;
                break;
            case "BatchJobStatus_TimedOut":
            case 4:
                message.status = 4;
                break;
            case "BatchJobStatus_Failed":
            case 5:
                message.status = 5;
                break;
            case "BatchJobStatus_Canceled":
            case 6:
                message.status = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BatchJobStatusInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {ptsl.BatchJobStatusInfo} message BatchJobStatusInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BatchJobStatusInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.jobData = null;
                object.id = "";
                object.progress = 0;
                object.status = options.enums === String ? "BatchJobStatus_Unknown" : 0;
            }
            if (message.jobData != null && message.hasOwnProperty("jobData"))
                object.jobData = $root.ptsl.BatchJobDefinition.toObject(message.jobData, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.ptsl.BatchJobStatus[message.status] === undefined ? message.status : $root.ptsl.BatchJobStatus[message.status] : message.status;
            return object;
        };

        /**
         * Converts this BatchJobStatusInfo to JSON.
         * @function toJSON
         * @memberof ptsl.BatchJobStatusInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BatchJobStatusInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BatchJobStatusInfo
         * @function getTypeUrl
         * @memberof ptsl.BatchJobStatusInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BatchJobStatusInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.BatchJobStatusInfo";
        };

        return BatchJobStatusInfo;
    })();

    ptsl.GetBatchJobStatusRequestBody = (function() {

        /**
         * Properties of a GetBatchJobStatusRequestBody.
         * @memberof ptsl
         * @interface IGetBatchJobStatusRequestBody
         * @property {string|null} [id] * Unique ID of the batch job.
         */

        /**
         * Constructs a new GetBatchJobStatusRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetBatchJob request data.
         * @since Pro Tools 2025.06
         * @implements IGetBatchJobStatusRequestBody
         * @constructor
         * @param {ptsl.IGetBatchJobStatusRequestBody=} [properties] Properties to set
         */
        function GetBatchJobStatusRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Unique ID of the batch job.
         * @member {string} id
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @instance
         */
        GetBatchJobStatusRequestBody.prototype.id = "";

        /**
         * Creates a new GetBatchJobStatusRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {ptsl.IGetBatchJobStatusRequestBody=} [properties] Properties to set
         * @returns {ptsl.GetBatchJobStatusRequestBody} GetBatchJobStatusRequestBody instance
         */
        GetBatchJobStatusRequestBody.create = function create(properties) {
            return new GetBatchJobStatusRequestBody(properties);
        };

        /**
         * Encodes the specified GetBatchJobStatusRequestBody message. Does not implicitly {@link ptsl.GetBatchJobStatusRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {ptsl.IGetBatchJobStatusRequestBody} message GetBatchJobStatusRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBatchJobStatusRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified GetBatchJobStatusRequestBody message, length delimited. Does not implicitly {@link ptsl.GetBatchJobStatusRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {ptsl.IGetBatchJobStatusRequestBody} message GetBatchJobStatusRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBatchJobStatusRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBatchJobStatusRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetBatchJobStatusRequestBody} GetBatchJobStatusRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBatchJobStatusRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetBatchJobStatusRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBatchJobStatusRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetBatchJobStatusRequestBody} GetBatchJobStatusRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBatchJobStatusRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBatchJobStatusRequestBody message.
         * @function verify
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBatchJobStatusRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a GetBatchJobStatusRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetBatchJobStatusRequestBody} GetBatchJobStatusRequestBody
         */
        GetBatchJobStatusRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetBatchJobStatusRequestBody)
                return object;
            var message = new $root.ptsl.GetBatchJobStatusRequestBody();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a GetBatchJobStatusRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {ptsl.GetBatchJobStatusRequestBody} message GetBatchJobStatusRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBatchJobStatusRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this GetBatchJobStatusRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBatchJobStatusRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetBatchJobStatusRequestBody
         * @function getTypeUrl
         * @memberof ptsl.GetBatchJobStatusRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBatchJobStatusRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetBatchJobStatusRequestBody";
        };

        return GetBatchJobStatusRequestBody;
    })();

    ptsl.GetBatchJobStatusResponseBody = (function() {

        /**
         * Properties of a GetBatchJobStatusResponseBody.
         * @memberof ptsl
         * @interface IGetBatchJobStatusResponseBody
         * @property {ptsl.IBatchJobStatusInfo|null} [jobInfo] * Information about the batch job.
         */

        /**
         * Constructs a new GetBatchJobStatusResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes GetBatchJob response data.
         * @since Pro Tools 2025.06
         * @implements IGetBatchJobStatusResponseBody
         * @constructor
         * @param {ptsl.IGetBatchJobStatusResponseBody=} [properties] Properties to set
         */
        function GetBatchJobStatusResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Information about the batch job.
         * @member {ptsl.IBatchJobStatusInfo|null|undefined} jobInfo
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @instance
         */
        GetBatchJobStatusResponseBody.prototype.jobInfo = null;

        /**
         * Creates a new GetBatchJobStatusResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {ptsl.IGetBatchJobStatusResponseBody=} [properties] Properties to set
         * @returns {ptsl.GetBatchJobStatusResponseBody} GetBatchJobStatusResponseBody instance
         */
        GetBatchJobStatusResponseBody.create = function create(properties) {
            return new GetBatchJobStatusResponseBody(properties);
        };

        /**
         * Encodes the specified GetBatchJobStatusResponseBody message. Does not implicitly {@link ptsl.GetBatchJobStatusResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {ptsl.IGetBatchJobStatusResponseBody} message GetBatchJobStatusResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBatchJobStatusResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.jobInfo != null && Object.hasOwnProperty.call(message, "jobInfo"))
                $root.ptsl.BatchJobStatusInfo.encode(message.jobInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetBatchJobStatusResponseBody message, length delimited. Does not implicitly {@link ptsl.GetBatchJobStatusResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {ptsl.IGetBatchJobStatusResponseBody} message GetBatchJobStatusResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBatchJobStatusResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBatchJobStatusResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.GetBatchJobStatusResponseBody} GetBatchJobStatusResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBatchJobStatusResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.GetBatchJobStatusResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.jobInfo = $root.ptsl.BatchJobStatusInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBatchJobStatusResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.GetBatchJobStatusResponseBody} GetBatchJobStatusResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBatchJobStatusResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBatchJobStatusResponseBody message.
         * @function verify
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBatchJobStatusResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.jobInfo != null && message.hasOwnProperty("jobInfo")) {
                var error = $root.ptsl.BatchJobStatusInfo.verify(message.jobInfo);
                if (error)
                    return "jobInfo." + error;
            }
            return null;
        };

        /**
         * Creates a GetBatchJobStatusResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.GetBatchJobStatusResponseBody} GetBatchJobStatusResponseBody
         */
        GetBatchJobStatusResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.GetBatchJobStatusResponseBody)
                return object;
            var message = new $root.ptsl.GetBatchJobStatusResponseBody();
            if (object.jobInfo != null) {
                if (typeof object.jobInfo !== "object")
                    throw TypeError(".ptsl.GetBatchJobStatusResponseBody.jobInfo: object expected");
                message.jobInfo = $root.ptsl.BatchJobStatusInfo.fromObject(object.jobInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetBatchJobStatusResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {ptsl.GetBatchJobStatusResponseBody} message GetBatchJobStatusResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBatchJobStatusResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.jobInfo = null;
            if (message.jobInfo != null && message.hasOwnProperty("jobInfo"))
                object.jobInfo = $root.ptsl.BatchJobStatusInfo.toObject(message.jobInfo, options);
            return object;
        };

        /**
         * Converts this GetBatchJobStatusResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBatchJobStatusResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetBatchJobStatusResponseBody
         * @function getTypeUrl
         * @memberof ptsl.GetBatchJobStatusResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBatchJobStatusResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.GetBatchJobStatusResponseBody";
        };

        return GetBatchJobStatusResponseBody;
    })();

    ptsl.RenderAutomationOptions = (function() {

        /**
         * Properties of a RenderAutomationOptions.
         * @memberof ptsl
         * @interface IRenderAutomationOptions
         * @property {boolean|null} [renderVolumeAutomation] * Apply volume automation to the render
         * @property {boolean|null} [renderPanAutomation] * Apply pan automation to the render
         */

        /**
         * Constructs a new RenderAutomationOptions.
         * @memberof ptsl
         * @classdesc Structrure that describes track bounce automation options.
         * @since Pro Tools 2025.06
         * @implements IRenderAutomationOptions
         * @constructor
         * @param {ptsl.IRenderAutomationOptions=} [properties] Properties to set
         */
        function RenderAutomationOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Apply volume automation to the render
         * @member {boolean} renderVolumeAutomation
         * @memberof ptsl.RenderAutomationOptions
         * @instance
         */
        RenderAutomationOptions.prototype.renderVolumeAutomation = false;

        /**
         * * Apply pan automation to the render
         * @member {boolean} renderPanAutomation
         * @memberof ptsl.RenderAutomationOptions
         * @instance
         */
        RenderAutomationOptions.prototype.renderPanAutomation = false;

        /**
         * Creates a new RenderAutomationOptions instance using the specified properties.
         * @function create
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {ptsl.IRenderAutomationOptions=} [properties] Properties to set
         * @returns {ptsl.RenderAutomationOptions} RenderAutomationOptions instance
         */
        RenderAutomationOptions.create = function create(properties) {
            return new RenderAutomationOptions(properties);
        };

        /**
         * Encodes the specified RenderAutomationOptions message. Does not implicitly {@link ptsl.RenderAutomationOptions.verify|verify} messages.
         * @function encode
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {ptsl.IRenderAutomationOptions} message RenderAutomationOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenderAutomationOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.renderVolumeAutomation != null && Object.hasOwnProperty.call(message, "renderVolumeAutomation"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.renderVolumeAutomation);
            if (message.renderPanAutomation != null && Object.hasOwnProperty.call(message, "renderPanAutomation"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.renderPanAutomation);
            return writer;
        };

        /**
         * Encodes the specified RenderAutomationOptions message, length delimited. Does not implicitly {@link ptsl.RenderAutomationOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {ptsl.IRenderAutomationOptions} message RenderAutomationOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenderAutomationOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenderAutomationOptions message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.RenderAutomationOptions} RenderAutomationOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenderAutomationOptions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.RenderAutomationOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.renderVolumeAutomation = reader.bool();
                        break;
                    }
                case 2: {
                        message.renderPanAutomation = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RenderAutomationOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.RenderAutomationOptions} RenderAutomationOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenderAutomationOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenderAutomationOptions message.
         * @function verify
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenderAutomationOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.renderVolumeAutomation != null && message.hasOwnProperty("renderVolumeAutomation"))
                if (typeof message.renderVolumeAutomation !== "boolean")
                    return "renderVolumeAutomation: boolean expected";
            if (message.renderPanAutomation != null && message.hasOwnProperty("renderPanAutomation"))
                if (typeof message.renderPanAutomation !== "boolean")
                    return "renderPanAutomation: boolean expected";
            return null;
        };

        /**
         * Creates a RenderAutomationOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.RenderAutomationOptions} RenderAutomationOptions
         */
        RenderAutomationOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.RenderAutomationOptions)
                return object;
            var message = new $root.ptsl.RenderAutomationOptions();
            if (object.renderVolumeAutomation != null)
                message.renderVolumeAutomation = Boolean(object.renderVolumeAutomation);
            if (object.renderPanAutomation != null)
                message.renderPanAutomation = Boolean(object.renderPanAutomation);
            return message;
        };

        /**
         * Creates a plain object from a RenderAutomationOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {ptsl.RenderAutomationOptions} message RenderAutomationOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenderAutomationOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.renderVolumeAutomation = false;
                object.renderPanAutomation = false;
            }
            if (message.renderVolumeAutomation != null && message.hasOwnProperty("renderVolumeAutomation"))
                object.renderVolumeAutomation = message.renderVolumeAutomation;
            if (message.renderPanAutomation != null && message.hasOwnProperty("renderPanAutomation"))
                object.renderPanAutomation = message.renderPanAutomation;
            return object;
        };

        /**
         * Converts this RenderAutomationOptions to JSON.
         * @function toJSON
         * @memberof ptsl.RenderAutomationOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenderAutomationOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RenderAutomationOptions
         * @function getTypeUrl
         * @memberof ptsl.RenderAutomationOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RenderAutomationOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.RenderAutomationOptions";
        };

        return RenderAutomationOptions;
    })();

    ptsl.BounceTrackRequestBody = (function() {

        /**
         * Properties of a BounceTrackRequestBody.
         * @memberof ptsl
         * @interface IBounceTrackRequestBody
         * @property {string|null} [presetPath] * File path for to TrackBounce preset to use
         * @property {string|null} [fileNamePrefix] * File name of bounced track
         * @property {ptsl.EM_FileType|null} [fileType] * File type of bounced track
         * @property {ptsl.IEM_AudioInfo|null} [audioInfo] * Information for audio section in the Track Bounce window.
         * @property {ptsl.IEM_LocationInfo|null} [locationInfo] * Information for location section in the Track Bounce window.
         * @property {ptsl.TripleBool|null} [offlineBounce] * Option for offline bounce or real-time bounce
         * @property {ptsl.IAudioEncodingOptions|null} [audioEncodingOptions] * Encoding options information
         * @property {string|null} [srcTrackId] * Track ID to bounce
         * @property {ptsl.ITimelineLocation|null} [inLocation] * Start location of the bounce
         * @property {ptsl.ITimelineLocation|null} [outLocation] * End location of the bounce
         * @property {ptsl.IRenderAutomationOptions|null} [automationOptions] * Track bounce automation options
         */

        /**
         * Constructs a new BounceTrackRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes BounceTrack request data.
         * @since Pro Tools 2025.06
         * @implements IBounceTrackRequestBody
         * @constructor
         * @param {ptsl.IBounceTrackRequestBody=} [properties] Properties to set
         */
        function BounceTrackRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * File path for to TrackBounce preset to use
         * @member {string} presetPath
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.presetPath = "";

        /**
         * * File name of bounced track
         * @member {string} fileNamePrefix
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.fileNamePrefix = "";

        /**
         * * File type of bounced track
         * @member {ptsl.EM_FileType} fileType
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.fileType = 0;

        /**
         * * Information for audio section in the Track Bounce window.
         * @member {ptsl.IEM_AudioInfo|null|undefined} audioInfo
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.audioInfo = null;

        /**
         * * Information for location section in the Track Bounce window.
         * @member {ptsl.IEM_LocationInfo|null|undefined} locationInfo
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.locationInfo = null;

        /**
         * * Option for offline bounce or real-time bounce
         * @member {ptsl.TripleBool} offlineBounce
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.offlineBounce = 0;

        /**
         * * Encoding options information
         * @member {ptsl.IAudioEncodingOptions|null|undefined} audioEncodingOptions
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.audioEncodingOptions = null;

        /**
         * * Track ID to bounce
         * @member {string} srcTrackId
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.srcTrackId = "";

        /**
         * * Start location of the bounce
         * @member {ptsl.ITimelineLocation|null|undefined} inLocation
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.inLocation = null;

        /**
         * * End location of the bounce
         * @member {ptsl.ITimelineLocation|null|undefined} outLocation
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.outLocation = null;

        /**
         * * Track bounce automation options
         * @member {ptsl.IRenderAutomationOptions|null|undefined} automationOptions
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         */
        BounceTrackRequestBody.prototype.automationOptions = null;

        /**
         * Creates a new BounceTrackRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {ptsl.IBounceTrackRequestBody=} [properties] Properties to set
         * @returns {ptsl.BounceTrackRequestBody} BounceTrackRequestBody instance
         */
        BounceTrackRequestBody.create = function create(properties) {
            return new BounceTrackRequestBody(properties);
        };

        /**
         * Encodes the specified BounceTrackRequestBody message. Does not implicitly {@link ptsl.BounceTrackRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {ptsl.IBounceTrackRequestBody} message BounceTrackRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BounceTrackRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.presetPath != null && Object.hasOwnProperty.call(message, "presetPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetPath);
            if (message.fileNamePrefix != null && Object.hasOwnProperty.call(message, "fileNamePrefix"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileNamePrefix);
            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fileType);
            if (message.audioInfo != null && Object.hasOwnProperty.call(message, "audioInfo"))
                $root.ptsl.EM_AudioInfo.encode(message.audioInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.locationInfo != null && Object.hasOwnProperty.call(message, "locationInfo"))
                $root.ptsl.EM_LocationInfo.encode(message.locationInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.offlineBounce != null && Object.hasOwnProperty.call(message, "offlineBounce"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.offlineBounce);
            if (message.audioEncodingOptions != null && Object.hasOwnProperty.call(message, "audioEncodingOptions"))
                $root.ptsl.AudioEncodingOptions.encode(message.audioEncodingOptions, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.srcTrackId != null && Object.hasOwnProperty.call(message, "srcTrackId"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.srcTrackId);
            if (message.inLocation != null && Object.hasOwnProperty.call(message, "inLocation"))
                $root.ptsl.TimelineLocation.encode(message.inLocation, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.outLocation != null && Object.hasOwnProperty.call(message, "outLocation"))
                $root.ptsl.TimelineLocation.encode(message.outLocation, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.automationOptions != null && Object.hasOwnProperty.call(message, "automationOptions"))
                $root.ptsl.RenderAutomationOptions.encode(message.automationOptions, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BounceTrackRequestBody message, length delimited. Does not implicitly {@link ptsl.BounceTrackRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {ptsl.IBounceTrackRequestBody} message BounceTrackRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BounceTrackRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BounceTrackRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.BounceTrackRequestBody} BounceTrackRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BounceTrackRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.BounceTrackRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.presetPath = reader.string();
                        break;
                    }
                case 2: {
                        message.fileNamePrefix = reader.string();
                        break;
                    }
                case 3: {
                        message.fileType = reader.int32();
                        break;
                    }
                case 4: {
                        message.audioInfo = $root.ptsl.EM_AudioInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.locationInfo = $root.ptsl.EM_LocationInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.offlineBounce = reader.int32();
                        break;
                    }
                case 7: {
                        message.audioEncodingOptions = $root.ptsl.AudioEncodingOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.srcTrackId = reader.string();
                        break;
                    }
                case 9: {
                        message.inLocation = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.outLocation = $root.ptsl.TimelineLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.automationOptions = $root.ptsl.RenderAutomationOptions.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BounceTrackRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.BounceTrackRequestBody} BounceTrackRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BounceTrackRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BounceTrackRequestBody message.
         * @function verify
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BounceTrackRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.presetPath != null && message.hasOwnProperty("presetPath"))
                if (!$util.isString(message.presetPath))
                    return "presetPath: string expected";
            if (message.fileNamePrefix != null && message.hasOwnProperty("fileNamePrefix"))
                if (!$util.isString(message.fileNamePrefix))
                    return "fileNamePrefix: string expected";
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                switch (message.fileType) {
                default:
                    return "fileType: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                case 4:
                case 4:
                case 5:
                case 5:
                case 6:
                case 6:
                case 7:
                case 7:
                case 8:
                    break;
                }
            if (message.audioInfo != null && message.hasOwnProperty("audioInfo")) {
                var error = $root.ptsl.EM_AudioInfo.verify(message.audioInfo);
                if (error)
                    return "audioInfo." + error;
            }
            if (message.locationInfo != null && message.hasOwnProperty("locationInfo")) {
                var error = $root.ptsl.EM_LocationInfo.verify(message.locationInfo);
                if (error)
                    return "locationInfo." + error;
            }
            if (message.offlineBounce != null && message.hasOwnProperty("offlineBounce"))
                switch (message.offlineBounce) {
                default:
                    return "offlineBounce: enum value expected";
                case 0:
                case 1:
                case 1:
                case 2:
                case 2:
                case 3:
                case 3:
                    break;
                }
            if (message.audioEncodingOptions != null && message.hasOwnProperty("audioEncodingOptions")) {
                var error = $root.ptsl.AudioEncodingOptions.verify(message.audioEncodingOptions);
                if (error)
                    return "audioEncodingOptions." + error;
            }
            if (message.srcTrackId != null && message.hasOwnProperty("srcTrackId"))
                if (!$util.isString(message.srcTrackId))
                    return "srcTrackId: string expected";
            if (message.inLocation != null && message.hasOwnProperty("inLocation")) {
                var error = $root.ptsl.TimelineLocation.verify(message.inLocation);
                if (error)
                    return "inLocation." + error;
            }
            if (message.outLocation != null && message.hasOwnProperty("outLocation")) {
                var error = $root.ptsl.TimelineLocation.verify(message.outLocation);
                if (error)
                    return "outLocation." + error;
            }
            if (message.automationOptions != null && message.hasOwnProperty("automationOptions")) {
                var error = $root.ptsl.RenderAutomationOptions.verify(message.automationOptions);
                if (error)
                    return "automationOptions." + error;
            }
            return null;
        };

        /**
         * Creates a BounceTrackRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.BounceTrackRequestBody} BounceTrackRequestBody
         */
        BounceTrackRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.BounceTrackRequestBody)
                return object;
            var message = new $root.ptsl.BounceTrackRequestBody();
            if (object.presetPath != null)
                message.presetPath = String(object.presetPath);
            if (object.fileNamePrefix != null)
                message.fileNamePrefix = String(object.fileNamePrefix);
            switch (object.fileType) {
            default:
                if (typeof object.fileType === "number") {
                    message.fileType = object.fileType;
                    break;
                }
                break;
            case "EMFType_Unknown":
            case 0:
                message.fileType = 0;
                break;
            case "EM_None":
            case 1:
                message.fileType = 1;
                break;
            case "EMFType_None":
            case 1:
                message.fileType = 1;
                break;
            case "EM_MOV":
            case 2:
                message.fileType = 2;
                break;
            case "EMFType_MOV":
            case 2:
                message.fileType = 2;
                break;
            case "EM_WAV":
            case 3:
                message.fileType = 3;
                break;
            case "EMFType_WAV":
            case 3:
                message.fileType = 3;
                break;
            case "EM_AIFF":
            case 4:
                message.fileType = 4;
                break;
            case "EMFType_AIFF":
            case 4:
                message.fileType = 4;
                break;
            case "EM_MP3":
            case 5:
                message.fileType = 5;
                break;
            case "EMFType_MP3":
            case 5:
                message.fileType = 5;
                break;
            case "EM_MXFOPAtom":
            case 6:
                message.fileType = 6;
                break;
            case "EMFType_MXFOPAtom":
            case 6:
                message.fileType = 6;
                break;
            case "EM_WAVADM":
            case 7:
                message.fileType = 7;
                break;
            case "EMFType_WAVADM":
            case 7:
                message.fileType = 7;
                break;
            case "EMFType_M4A":
            case 8:
                message.fileType = 8;
                break;
            }
            if (object.audioInfo != null) {
                if (typeof object.audioInfo !== "object")
                    throw TypeError(".ptsl.BounceTrackRequestBody.audioInfo: object expected");
                message.audioInfo = $root.ptsl.EM_AudioInfo.fromObject(object.audioInfo);
            }
            if (object.locationInfo != null) {
                if (typeof object.locationInfo !== "object")
                    throw TypeError(".ptsl.BounceTrackRequestBody.locationInfo: object expected");
                message.locationInfo = $root.ptsl.EM_LocationInfo.fromObject(object.locationInfo);
            }
            switch (object.offlineBounce) {
            default:
                if (typeof object.offlineBounce === "number") {
                    message.offlineBounce = object.offlineBounce;
                    break;
                }
                break;
            case "TBool_Unknown":
            case 0:
                message.offlineBounce = 0;
                break;
            case "TB_None":
            case 1:
                message.offlineBounce = 1;
                break;
            case "TBool_None":
            case 1:
                message.offlineBounce = 1;
                break;
            case "TB_False":
            case 2:
                message.offlineBounce = 2;
                break;
            case "TBool_False":
            case 2:
                message.offlineBounce = 2;
                break;
            case "TB_True":
            case 3:
                message.offlineBounce = 3;
                break;
            case "TBool_True":
            case 3:
                message.offlineBounce = 3;
                break;
            }
            if (object.audioEncodingOptions != null) {
                if (typeof object.audioEncodingOptions !== "object")
                    throw TypeError(".ptsl.BounceTrackRequestBody.audioEncodingOptions: object expected");
                message.audioEncodingOptions = $root.ptsl.AudioEncodingOptions.fromObject(object.audioEncodingOptions);
            }
            if (object.srcTrackId != null)
                message.srcTrackId = String(object.srcTrackId);
            if (object.inLocation != null) {
                if (typeof object.inLocation !== "object")
                    throw TypeError(".ptsl.BounceTrackRequestBody.inLocation: object expected");
                message.inLocation = $root.ptsl.TimelineLocation.fromObject(object.inLocation);
            }
            if (object.outLocation != null) {
                if (typeof object.outLocation !== "object")
                    throw TypeError(".ptsl.BounceTrackRequestBody.outLocation: object expected");
                message.outLocation = $root.ptsl.TimelineLocation.fromObject(object.outLocation);
            }
            if (object.automationOptions != null) {
                if (typeof object.automationOptions !== "object")
                    throw TypeError(".ptsl.BounceTrackRequestBody.automationOptions: object expected");
                message.automationOptions = $root.ptsl.RenderAutomationOptions.fromObject(object.automationOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a BounceTrackRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {ptsl.BounceTrackRequestBody} message BounceTrackRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BounceTrackRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.presetPath = "";
                object.fileNamePrefix = "";
                object.fileType = options.enums === String ? "EMFType_Unknown" : 0;
                object.audioInfo = null;
                object.locationInfo = null;
                object.offlineBounce = options.enums === String ? "TBool_Unknown" : 0;
                object.audioEncodingOptions = null;
                object.srcTrackId = "";
                object.inLocation = null;
                object.outLocation = null;
                object.automationOptions = null;
            }
            if (message.presetPath != null && message.hasOwnProperty("presetPath"))
                object.presetPath = message.presetPath;
            if (message.fileNamePrefix != null && message.hasOwnProperty("fileNamePrefix"))
                object.fileNamePrefix = message.fileNamePrefix;
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.ptsl.EM_FileType[message.fileType] === undefined ? message.fileType : $root.ptsl.EM_FileType[message.fileType] : message.fileType;
            if (message.audioInfo != null && message.hasOwnProperty("audioInfo"))
                object.audioInfo = $root.ptsl.EM_AudioInfo.toObject(message.audioInfo, options);
            if (message.locationInfo != null && message.hasOwnProperty("locationInfo"))
                object.locationInfo = $root.ptsl.EM_LocationInfo.toObject(message.locationInfo, options);
            if (message.offlineBounce != null && message.hasOwnProperty("offlineBounce"))
                object.offlineBounce = options.enums === String ? $root.ptsl.TripleBool[message.offlineBounce] === undefined ? message.offlineBounce : $root.ptsl.TripleBool[message.offlineBounce] : message.offlineBounce;
            if (message.audioEncodingOptions != null && message.hasOwnProperty("audioEncodingOptions"))
                object.audioEncodingOptions = $root.ptsl.AudioEncodingOptions.toObject(message.audioEncodingOptions, options);
            if (message.srcTrackId != null && message.hasOwnProperty("srcTrackId"))
                object.srcTrackId = message.srcTrackId;
            if (message.inLocation != null && message.hasOwnProperty("inLocation"))
                object.inLocation = $root.ptsl.TimelineLocation.toObject(message.inLocation, options);
            if (message.outLocation != null && message.hasOwnProperty("outLocation"))
                object.outLocation = $root.ptsl.TimelineLocation.toObject(message.outLocation, options);
            if (message.automationOptions != null && message.hasOwnProperty("automationOptions"))
                object.automationOptions = $root.ptsl.RenderAutomationOptions.toObject(message.automationOptions, options);
            return object;
        };

        /**
         * Converts this BounceTrackRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.BounceTrackRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BounceTrackRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BounceTrackRequestBody
         * @function getTypeUrl
         * @memberof ptsl.BounceTrackRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BounceTrackRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.BounceTrackRequestBody";
        };

        return BounceTrackRequestBody;
    })();

    ptsl.BounceTrackResponseBody = (function() {

        /**
         * Properties of a BounceTrackResponseBody.
         * @memberof ptsl
         * @interface IBounceTrackResponseBody
         * @property {Array.<string>|null} [filePaths] * Absolute path of each generated file
         */

        /**
         * Constructs a new BounceTrackResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes BounceTrack response data.
         * @since Pro Tools 2025.06
         * @implements IBounceTrackResponseBody
         * @constructor
         * @param {ptsl.IBounceTrackResponseBody=} [properties] Properties to set
         */
        function BounceTrackResponseBody(properties) {
            this.filePaths = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Absolute path of each generated file
         * @member {Array.<string>} filePaths
         * @memberof ptsl.BounceTrackResponseBody
         * @instance
         */
        BounceTrackResponseBody.prototype.filePaths = $util.emptyArray;

        /**
         * Creates a new BounceTrackResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {ptsl.IBounceTrackResponseBody=} [properties] Properties to set
         * @returns {ptsl.BounceTrackResponseBody} BounceTrackResponseBody instance
         */
        BounceTrackResponseBody.create = function create(properties) {
            return new BounceTrackResponseBody(properties);
        };

        /**
         * Encodes the specified BounceTrackResponseBody message. Does not implicitly {@link ptsl.BounceTrackResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {ptsl.IBounceTrackResponseBody} message BounceTrackResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BounceTrackResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filePaths != null && message.filePaths.length)
                for (var i = 0; i < message.filePaths.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filePaths[i]);
            return writer;
        };

        /**
         * Encodes the specified BounceTrackResponseBody message, length delimited. Does not implicitly {@link ptsl.BounceTrackResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {ptsl.IBounceTrackResponseBody} message BounceTrackResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BounceTrackResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BounceTrackResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.BounceTrackResponseBody} BounceTrackResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BounceTrackResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.BounceTrackResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.filePaths && message.filePaths.length))
                            message.filePaths = [];
                        message.filePaths.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BounceTrackResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.BounceTrackResponseBody} BounceTrackResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BounceTrackResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BounceTrackResponseBody message.
         * @function verify
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BounceTrackResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filePaths != null && message.hasOwnProperty("filePaths")) {
                if (!Array.isArray(message.filePaths))
                    return "filePaths: array expected";
                for (var i = 0; i < message.filePaths.length; ++i)
                    if (!$util.isString(message.filePaths[i]))
                        return "filePaths: string[] expected";
            }
            return null;
        };

        /**
         * Creates a BounceTrackResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.BounceTrackResponseBody} BounceTrackResponseBody
         */
        BounceTrackResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.BounceTrackResponseBody)
                return object;
            var message = new $root.ptsl.BounceTrackResponseBody();
            if (object.filePaths) {
                if (!Array.isArray(object.filePaths))
                    throw TypeError(".ptsl.BounceTrackResponseBody.filePaths: array expected");
                message.filePaths = [];
                for (var i = 0; i < object.filePaths.length; ++i)
                    message.filePaths[i] = String(object.filePaths[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a BounceTrackResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {ptsl.BounceTrackResponseBody} message BounceTrackResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BounceTrackResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filePaths = [];
            if (message.filePaths && message.filePaths.length) {
                object.filePaths = [];
                for (var j = 0; j < message.filePaths.length; ++j)
                    object.filePaths[j] = message.filePaths[j];
            }
            return object;
        };

        /**
         * Converts this BounceTrackResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.BounceTrackResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BounceTrackResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BounceTrackResponseBody
         * @function getTypeUrl
         * @memberof ptsl.BounceTrackResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BounceTrackResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.BounceTrackResponseBody";
        };

        return BounceTrackResponseBody;
    })();

    ptsl.PollEventsResponseBody = (function() {

        /**
         * Properties of a PollEventsResponseBody.
         * @memberof ptsl
         * @interface IPollEventsResponseBody
         * @property {ptsl.IEventResponseData|null} [event] * An event that occurred.
         */

        /**
         * Constructs a new PollEventsResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes PollEvents response data.
         * @implements IPollEventsResponseBody
         * @constructor
         * @param {ptsl.IPollEventsResponseBody=} [properties] Properties to set
         */
        function PollEventsResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * An event that occurred.
         * @member {ptsl.IEventResponseData|null|undefined} event
         * @memberof ptsl.PollEventsResponseBody
         * @instance
         */
        PollEventsResponseBody.prototype.event = null;

        /**
         * Creates a new PollEventsResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {ptsl.IPollEventsResponseBody=} [properties] Properties to set
         * @returns {ptsl.PollEventsResponseBody} PollEventsResponseBody instance
         */
        PollEventsResponseBody.create = function create(properties) {
            return new PollEventsResponseBody(properties);
        };

        /**
         * Encodes the specified PollEventsResponseBody message. Does not implicitly {@link ptsl.PollEventsResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {ptsl.IPollEventsResponseBody} message PollEventsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollEventsResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                $root.ptsl.EventResponseData.encode(message.event, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PollEventsResponseBody message, length delimited. Does not implicitly {@link ptsl.PollEventsResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {ptsl.IPollEventsResponseBody} message PollEventsResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PollEventsResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PollEventsResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.PollEventsResponseBody} PollEventsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollEventsResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.PollEventsResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.event = $root.ptsl.EventResponseData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PollEventsResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.PollEventsResponseBody} PollEventsResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PollEventsResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PollEventsResponseBody message.
         * @function verify
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PollEventsResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event != null && message.hasOwnProperty("event")) {
                var error = $root.ptsl.EventResponseData.verify(message.event);
                if (error)
                    return "event." + error;
            }
            return null;
        };

        /**
         * Creates a PollEventsResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.PollEventsResponseBody} PollEventsResponseBody
         */
        PollEventsResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.PollEventsResponseBody)
                return object;
            var message = new $root.ptsl.PollEventsResponseBody();
            if (object.event != null) {
                if (typeof object.event !== "object")
                    throw TypeError(".ptsl.PollEventsResponseBody.event: object expected");
                message.event = $root.ptsl.EventResponseData.fromObject(object.event);
            }
            return message;
        };

        /**
         * Creates a plain object from a PollEventsResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {ptsl.PollEventsResponseBody} message PollEventsResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PollEventsResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.event = null;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = $root.ptsl.EventResponseData.toObject(message.event, options);
            return object;
        };

        /**
         * Converts this PollEventsResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.PollEventsResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PollEventsResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PollEventsResponseBody
         * @function getTypeUrl
         * @memberof ptsl.PollEventsResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PollEventsResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.PollEventsResponseBody";
        };

        return PollEventsResponseBody;
    })();

    ptsl.UnsubscribeFromEventsRequestBody = (function() {

        /**
         * Properties of an UnsubscribeFromEventsRequestBody.
         * @memberof ptsl
         * @interface IUnsubscribeFromEventsRequestBody
         * @property {Array.<ptsl.IEventRequestData>|null} [events] * List of events to subscribe to.
         */

        /**
         * Constructs a new UnsubscribeFromEventsRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes UnsubscribeFromEvents request data.
         * @implements IUnsubscribeFromEventsRequestBody
         * @constructor
         * @param {ptsl.IUnsubscribeFromEventsRequestBody=} [properties] Properties to set
         */
        function UnsubscribeFromEventsRequestBody(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * List of events to subscribe to.
         * @member {Array.<ptsl.IEventRequestData>} events
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @instance
         */
        UnsubscribeFromEventsRequestBody.prototype.events = $util.emptyArray;

        /**
         * Creates a new UnsubscribeFromEventsRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {ptsl.IUnsubscribeFromEventsRequestBody=} [properties] Properties to set
         * @returns {ptsl.UnsubscribeFromEventsRequestBody} UnsubscribeFromEventsRequestBody instance
         */
        UnsubscribeFromEventsRequestBody.create = function create(properties) {
            return new UnsubscribeFromEventsRequestBody(properties);
        };

        /**
         * Encodes the specified UnsubscribeFromEventsRequestBody message. Does not implicitly {@link ptsl.UnsubscribeFromEventsRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {ptsl.IUnsubscribeFromEventsRequestBody} message UnsubscribeFromEventsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnsubscribeFromEventsRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.ptsl.EventRequestData.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnsubscribeFromEventsRequestBody message, length delimited. Does not implicitly {@link ptsl.UnsubscribeFromEventsRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {ptsl.IUnsubscribeFromEventsRequestBody} message UnsubscribeFromEventsRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnsubscribeFromEventsRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnsubscribeFromEventsRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.UnsubscribeFromEventsRequestBody} UnsubscribeFromEventsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnsubscribeFromEventsRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.UnsubscribeFromEventsRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push($root.ptsl.EventRequestData.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnsubscribeFromEventsRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.UnsubscribeFromEventsRequestBody} UnsubscribeFromEventsRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnsubscribeFromEventsRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnsubscribeFromEventsRequestBody message.
         * @function verify
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnsubscribeFromEventsRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.ptsl.EventRequestData.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UnsubscribeFromEventsRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.UnsubscribeFromEventsRequestBody} UnsubscribeFromEventsRequestBody
         */
        UnsubscribeFromEventsRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.UnsubscribeFromEventsRequestBody)
                return object;
            var message = new $root.ptsl.UnsubscribeFromEventsRequestBody();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".ptsl.UnsubscribeFromEventsRequestBody.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".ptsl.UnsubscribeFromEventsRequestBody.events: object expected");
                    message.events[i] = $root.ptsl.EventRequestData.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UnsubscribeFromEventsRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {ptsl.UnsubscribeFromEventsRequestBody} message UnsubscribeFromEventsRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnsubscribeFromEventsRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.ptsl.EventRequestData.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this UnsubscribeFromEventsRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnsubscribeFromEventsRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UnsubscribeFromEventsRequestBody
         * @function getTypeUrl
         * @memberof ptsl.UnsubscribeFromEventsRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UnsubscribeFromEventsRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.UnsubscribeFromEventsRequestBody";
        };

        return UnsubscribeFromEventsRequestBody;
    })();

    ptsl.CompleteBatchJobRequestBody = (function() {

        /**
         * Properties of a CompleteBatchJobRequestBody.
         * @memberof ptsl
         * @interface ICompleteBatchJobRequestBody
         * @property {string|null} [id] * Unique ID of the batch job.
         */

        /**
         * Constructs a new CompleteBatchJobRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CompleteBatchJob request data.
         * @since Pro Tools 2025.06
         * @implements ICompleteBatchJobRequestBody
         * @constructor
         * @param {ptsl.ICompleteBatchJobRequestBody=} [properties] Properties to set
         */
        function CompleteBatchJobRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Unique ID of the batch job.
         * @member {string} id
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @instance
         */
        CompleteBatchJobRequestBody.prototype.id = "";

        /**
         * Creates a new CompleteBatchJobRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {ptsl.ICompleteBatchJobRequestBody=} [properties] Properties to set
         * @returns {ptsl.CompleteBatchJobRequestBody} CompleteBatchJobRequestBody instance
         */
        CompleteBatchJobRequestBody.create = function create(properties) {
            return new CompleteBatchJobRequestBody(properties);
        };

        /**
         * Encodes the specified CompleteBatchJobRequestBody message. Does not implicitly {@link ptsl.CompleteBatchJobRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {ptsl.ICompleteBatchJobRequestBody} message CompleteBatchJobRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompleteBatchJobRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified CompleteBatchJobRequestBody message, length delimited. Does not implicitly {@link ptsl.CompleteBatchJobRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {ptsl.ICompleteBatchJobRequestBody} message CompleteBatchJobRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompleteBatchJobRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompleteBatchJobRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CompleteBatchJobRequestBody} CompleteBatchJobRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompleteBatchJobRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CompleteBatchJobRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompleteBatchJobRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CompleteBatchJobRequestBody} CompleteBatchJobRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompleteBatchJobRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompleteBatchJobRequestBody message.
         * @function verify
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompleteBatchJobRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a CompleteBatchJobRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CompleteBatchJobRequestBody} CompleteBatchJobRequestBody
         */
        CompleteBatchJobRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CompleteBatchJobRequestBody)
                return object;
            var message = new $root.ptsl.CompleteBatchJobRequestBody();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a CompleteBatchJobRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {ptsl.CompleteBatchJobRequestBody} message CompleteBatchJobRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompleteBatchJobRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this CompleteBatchJobRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompleteBatchJobRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompleteBatchJobRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CompleteBatchJobRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompleteBatchJobRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CompleteBatchJobRequestBody";
        };

        return CompleteBatchJobRequestBody;
    })();

    ptsl.CancelBatchJobRequestBody = (function() {

        /**
         * Properties of a CancelBatchJobRequestBody.
         * @memberof ptsl
         * @interface ICancelBatchJobRequestBody
         * @property {string|null} [id] * Unique ID of the batch job.
         */

        /**
         * Constructs a new CancelBatchJobRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes CancelBatchJob request data.
         * @since Pro Tools 2025.06
         * @implements ICancelBatchJobRequestBody
         * @constructor
         * @param {ptsl.ICancelBatchJobRequestBody=} [properties] Properties to set
         */
        function CancelBatchJobRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * * Unique ID of the batch job.
         * @member {string} id
         * @memberof ptsl.CancelBatchJobRequestBody
         * @instance
         */
        CancelBatchJobRequestBody.prototype.id = "";

        /**
         * Creates a new CancelBatchJobRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {ptsl.ICancelBatchJobRequestBody=} [properties] Properties to set
         * @returns {ptsl.CancelBatchJobRequestBody} CancelBatchJobRequestBody instance
         */
        CancelBatchJobRequestBody.create = function create(properties) {
            return new CancelBatchJobRequestBody(properties);
        };

        /**
         * Encodes the specified CancelBatchJobRequestBody message. Does not implicitly {@link ptsl.CancelBatchJobRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {ptsl.ICancelBatchJobRequestBody} message CancelBatchJobRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelBatchJobRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified CancelBatchJobRequestBody message, length delimited. Does not implicitly {@link ptsl.CancelBatchJobRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {ptsl.ICancelBatchJobRequestBody} message CancelBatchJobRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelBatchJobRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelBatchJobRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.CancelBatchJobRequestBody} CancelBatchJobRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelBatchJobRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.CancelBatchJobRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelBatchJobRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.CancelBatchJobRequestBody} CancelBatchJobRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelBatchJobRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelBatchJobRequestBody message.
         * @function verify
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelBatchJobRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a CancelBatchJobRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.CancelBatchJobRequestBody} CancelBatchJobRequestBody
         */
        CancelBatchJobRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.CancelBatchJobRequestBody)
                return object;
            var message = new $root.ptsl.CancelBatchJobRequestBody();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a CancelBatchJobRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {ptsl.CancelBatchJobRequestBody} message CancelBatchJobRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelBatchJobRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this CancelBatchJobRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.CancelBatchJobRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelBatchJobRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CancelBatchJobRequestBody
         * @function getTypeUrl
         * @memberof ptsl.CancelBatchJobRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CancelBatchJobRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.CancelBatchJobRequestBody";
        };

        return CancelBatchJobRequestBody;
    })();

    ptsl.EnableAPIRequestBody = (function() {

        /**
         * Properties of an EnableAPIRequestBody.
         * @memberof ptsl
         * @interface IEnableAPIRequestBody
         * @property {string|null} [clientKeyString] EnableAPIRequestBody clientKeyString
         */

        /**
         * Constructs a new EnableAPIRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes EnableAPI request data.
         * @implements IEnableAPIRequestBody
         * @constructor
         * @param {ptsl.IEnableAPIRequestBody=} [properties] Properties to set
         */
        function EnableAPIRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnableAPIRequestBody clientKeyString.
         * @member {string} clientKeyString
         * @memberof ptsl.EnableAPIRequestBody
         * @instance
         */
        EnableAPIRequestBody.prototype.clientKeyString = "";

        /**
         * Creates a new EnableAPIRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {ptsl.IEnableAPIRequestBody=} [properties] Properties to set
         * @returns {ptsl.EnableAPIRequestBody} EnableAPIRequestBody instance
         */
        EnableAPIRequestBody.create = function create(properties) {
            return new EnableAPIRequestBody(properties);
        };

        /**
         * Encodes the specified EnableAPIRequestBody message. Does not implicitly {@link ptsl.EnableAPIRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {ptsl.IEnableAPIRequestBody} message EnableAPIRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnableAPIRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientKeyString != null && Object.hasOwnProperty.call(message, "clientKeyString"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientKeyString);
            return writer;
        };

        /**
         * Encodes the specified EnableAPIRequestBody message, length delimited. Does not implicitly {@link ptsl.EnableAPIRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {ptsl.IEnableAPIRequestBody} message EnableAPIRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnableAPIRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnableAPIRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EnableAPIRequestBody} EnableAPIRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnableAPIRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EnableAPIRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.clientKeyString = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnableAPIRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EnableAPIRequestBody} EnableAPIRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnableAPIRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnableAPIRequestBody message.
         * @function verify
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnableAPIRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientKeyString != null && message.hasOwnProperty("clientKeyString"))
                if (!$util.isString(message.clientKeyString))
                    return "clientKeyString: string expected";
            return null;
        };

        /**
         * Creates an EnableAPIRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EnableAPIRequestBody} EnableAPIRequestBody
         */
        EnableAPIRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EnableAPIRequestBody)
                return object;
            var message = new $root.ptsl.EnableAPIRequestBody();
            if (object.clientKeyString != null)
                message.clientKeyString = String(object.clientKeyString);
            return message;
        };

        /**
         * Creates a plain object from an EnableAPIRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {ptsl.EnableAPIRequestBody} message EnableAPIRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnableAPIRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.clientKeyString = "";
            if (message.clientKeyString != null && message.hasOwnProperty("clientKeyString"))
                object.clientKeyString = message.clientKeyString;
            return object;
        };

        /**
         * Converts this EnableAPIRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.EnableAPIRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnableAPIRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EnableAPIRequestBody
         * @function getTypeUrl
         * @memberof ptsl.EnableAPIRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EnableAPIRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EnableAPIRequestBody";
        };

        return EnableAPIRequestBody;
    })();

    ptsl.EnableAPIResponseBody = (function() {

        /**
         * Properties of an EnableAPIResponseBody.
         * @memberof ptsl
         * @interface IEnableAPIResponseBody
         * @property {boolean|null} [success] EnableAPIResponseBody success
         */

        /**
         * Constructs a new EnableAPIResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes EnableAPI response data.
         * @implements IEnableAPIResponseBody
         * @constructor
         * @param {ptsl.IEnableAPIResponseBody=} [properties] Properties to set
         */
        function EnableAPIResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnableAPIResponseBody success.
         * @member {boolean} success
         * @memberof ptsl.EnableAPIResponseBody
         * @instance
         */
        EnableAPIResponseBody.prototype.success = false;

        /**
         * Creates a new EnableAPIResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {ptsl.IEnableAPIResponseBody=} [properties] Properties to set
         * @returns {ptsl.EnableAPIResponseBody} EnableAPIResponseBody instance
         */
        EnableAPIResponseBody.create = function create(properties) {
            return new EnableAPIResponseBody(properties);
        };

        /**
         * Encodes the specified EnableAPIResponseBody message. Does not implicitly {@link ptsl.EnableAPIResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {ptsl.IEnableAPIResponseBody} message EnableAPIResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnableAPIResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified EnableAPIResponseBody message, length delimited. Does not implicitly {@link ptsl.EnableAPIResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {ptsl.IEnableAPIResponseBody} message EnableAPIResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnableAPIResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnableAPIResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.EnableAPIResponseBody} EnableAPIResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnableAPIResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.EnableAPIResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.success = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnableAPIResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.EnableAPIResponseBody} EnableAPIResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnableAPIResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnableAPIResponseBody message.
         * @function verify
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnableAPIResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates an EnableAPIResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.EnableAPIResponseBody} EnableAPIResponseBody
         */
        EnableAPIResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.EnableAPIResponseBody)
                return object;
            var message = new $root.ptsl.EnableAPIResponseBody();
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from an EnableAPIResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {ptsl.EnableAPIResponseBody} message EnableAPIResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnableAPIResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.success = false;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this EnableAPIResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.EnableAPIResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnableAPIResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EnableAPIResponseBody
         * @function getTypeUrl
         * @memberof ptsl.EnableAPIResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EnableAPIResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.EnableAPIResponseBody";
        };

        return EnableAPIResponseBody;
    })();

    ptsl.ExchangePublicKeysRequestBody = (function() {

        /**
         * Properties of an ExchangePublicKeysRequestBody.
         * @memberof ptsl
         * @interface IExchangePublicKeysRequestBody
         * @property {string|null} [clientKeyString] ExchangePublicKeysRequestBody clientKeyString
         */

        /**
         * Constructs a new ExchangePublicKeysRequestBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExchangePublicKeys request data.
         * @implements IExchangePublicKeysRequestBody
         * @constructor
         * @param {ptsl.IExchangePublicKeysRequestBody=} [properties] Properties to set
         */
        function ExchangePublicKeysRequestBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangePublicKeysRequestBody clientKeyString.
         * @member {string} clientKeyString
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @instance
         */
        ExchangePublicKeysRequestBody.prototype.clientKeyString = "";

        /**
         * Creates a new ExchangePublicKeysRequestBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {ptsl.IExchangePublicKeysRequestBody=} [properties] Properties to set
         * @returns {ptsl.ExchangePublicKeysRequestBody} ExchangePublicKeysRequestBody instance
         */
        ExchangePublicKeysRequestBody.create = function create(properties) {
            return new ExchangePublicKeysRequestBody(properties);
        };

        /**
         * Encodes the specified ExchangePublicKeysRequestBody message. Does not implicitly {@link ptsl.ExchangePublicKeysRequestBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {ptsl.IExchangePublicKeysRequestBody} message ExchangePublicKeysRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangePublicKeysRequestBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientKeyString != null && Object.hasOwnProperty.call(message, "clientKeyString"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientKeyString);
            return writer;
        };

        /**
         * Encodes the specified ExchangePublicKeysRequestBody message, length delimited. Does not implicitly {@link ptsl.ExchangePublicKeysRequestBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {ptsl.IExchangePublicKeysRequestBody} message ExchangePublicKeysRequestBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangePublicKeysRequestBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangePublicKeysRequestBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExchangePublicKeysRequestBody} ExchangePublicKeysRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangePublicKeysRequestBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExchangePublicKeysRequestBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.clientKeyString = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangePublicKeysRequestBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExchangePublicKeysRequestBody} ExchangePublicKeysRequestBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangePublicKeysRequestBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangePublicKeysRequestBody message.
         * @function verify
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangePublicKeysRequestBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientKeyString != null && message.hasOwnProperty("clientKeyString"))
                if (!$util.isString(message.clientKeyString))
                    return "clientKeyString: string expected";
            return null;
        };

        /**
         * Creates an ExchangePublicKeysRequestBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExchangePublicKeysRequestBody} ExchangePublicKeysRequestBody
         */
        ExchangePublicKeysRequestBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExchangePublicKeysRequestBody)
                return object;
            var message = new $root.ptsl.ExchangePublicKeysRequestBody();
            if (object.clientKeyString != null)
                message.clientKeyString = String(object.clientKeyString);
            return message;
        };

        /**
         * Creates a plain object from an ExchangePublicKeysRequestBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {ptsl.ExchangePublicKeysRequestBody} message ExchangePublicKeysRequestBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangePublicKeysRequestBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.clientKeyString = "";
            if (message.clientKeyString != null && message.hasOwnProperty("clientKeyString"))
                object.clientKeyString = message.clientKeyString;
            return object;
        };

        /**
         * Converts this ExchangePublicKeysRequestBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangePublicKeysRequestBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExchangePublicKeysRequestBody
         * @function getTypeUrl
         * @memberof ptsl.ExchangePublicKeysRequestBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExchangePublicKeysRequestBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExchangePublicKeysRequestBody";
        };

        return ExchangePublicKeysRequestBody;
    })();

    ptsl.ExchangePublicKeysResponseBody = (function() {

        /**
         * Properties of an ExchangePublicKeysResponseBody.
         * @memberof ptsl
         * @interface IExchangePublicKeysResponseBody
         * @property {string|null} [ptKeyString] ExchangePublicKeysResponseBody ptKeyString
         */

        /**
         * Constructs a new ExchangePublicKeysResponseBody.
         * @memberof ptsl
         * @classdesc Structure that describes ExchangePublicKeys response data.
         * @implements IExchangePublicKeysResponseBody
         * @constructor
         * @param {ptsl.IExchangePublicKeysResponseBody=} [properties] Properties to set
         */
        function ExchangePublicKeysResponseBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangePublicKeysResponseBody ptKeyString.
         * @member {string} ptKeyString
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @instance
         */
        ExchangePublicKeysResponseBody.prototype.ptKeyString = "";

        /**
         * Creates a new ExchangePublicKeysResponseBody instance using the specified properties.
         * @function create
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {ptsl.IExchangePublicKeysResponseBody=} [properties] Properties to set
         * @returns {ptsl.ExchangePublicKeysResponseBody} ExchangePublicKeysResponseBody instance
         */
        ExchangePublicKeysResponseBody.create = function create(properties) {
            return new ExchangePublicKeysResponseBody(properties);
        };

        /**
         * Encodes the specified ExchangePublicKeysResponseBody message. Does not implicitly {@link ptsl.ExchangePublicKeysResponseBody.verify|verify} messages.
         * @function encode
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {ptsl.IExchangePublicKeysResponseBody} message ExchangePublicKeysResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangePublicKeysResponseBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ptKeyString != null && Object.hasOwnProperty.call(message, "ptKeyString"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ptKeyString);
            return writer;
        };

        /**
         * Encodes the specified ExchangePublicKeysResponseBody message, length delimited. Does not implicitly {@link ptsl.ExchangePublicKeysResponseBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {ptsl.IExchangePublicKeysResponseBody} message ExchangePublicKeysResponseBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangePublicKeysResponseBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangePublicKeysResponseBody message from the specified reader or buffer.
         * @function decode
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ptsl.ExchangePublicKeysResponseBody} ExchangePublicKeysResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangePublicKeysResponseBody.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ptsl.ExchangePublicKeysResponseBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ptKeyString = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangePublicKeysResponseBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ptsl.ExchangePublicKeysResponseBody} ExchangePublicKeysResponseBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangePublicKeysResponseBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangePublicKeysResponseBody message.
         * @function verify
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangePublicKeysResponseBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ptKeyString != null && message.hasOwnProperty("ptKeyString"))
                if (!$util.isString(message.ptKeyString))
                    return "ptKeyString: string expected";
            return null;
        };

        /**
         * Creates an ExchangePublicKeysResponseBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ptsl.ExchangePublicKeysResponseBody} ExchangePublicKeysResponseBody
         */
        ExchangePublicKeysResponseBody.fromObject = function fromObject(object) {
            if (object instanceof $root.ptsl.ExchangePublicKeysResponseBody)
                return object;
            var message = new $root.ptsl.ExchangePublicKeysResponseBody();
            if (object.ptKeyString != null)
                message.ptKeyString = String(object.ptKeyString);
            return message;
        };

        /**
         * Creates a plain object from an ExchangePublicKeysResponseBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {ptsl.ExchangePublicKeysResponseBody} message ExchangePublicKeysResponseBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangePublicKeysResponseBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.ptKeyString = "";
            if (message.ptKeyString != null && message.hasOwnProperty("ptKeyString"))
                object.ptKeyString = message.ptKeyString;
            return object;
        };

        /**
         * Converts this ExchangePublicKeysResponseBody to JSON.
         * @function toJSON
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangePublicKeysResponseBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExchangePublicKeysResponseBody
         * @function getTypeUrl
         * @memberof ptsl.ExchangePublicKeysResponseBody
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExchangePublicKeysResponseBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ptsl.ExchangePublicKeysResponseBody";
        };

        return ExchangePublicKeysResponseBody;
    })();

    return ptsl;
})();

module.exports = $root;
